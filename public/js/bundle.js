(function(){function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s}return e})()({1:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var DEFAULT_VALUES = {
    emitDelay: 10,
    strictMode: false
};

/**
 * @typedef {object} EventEmitterListenerFunc
 * @property {boolean} once
 * @property {function} fn
 */

/**
 * @class EventEmitter
 *
 * @private
 * @property {Object.<string, EventEmitterListenerFunc[]>} _listeners
 * @property {string[]} events
 */

var EventEmitter = function () {

    /**
     * @constructor
     * @param {{}}      [opts]
     * @param {number}  [opts.emitDelay = 10] - Number in ms. Specifies whether emit will be sync or async. By default - 10ms. If 0 - fires sync
     * @param {boolean} [opts.strictMode = false] - is true, Emitter throws error on emit error with no listeners
     */

    function EventEmitter() {
        var opts = arguments.length <= 0 || arguments[0] === undefined ? DEFAULT_VALUES : arguments[0];

        _classCallCheck(this, EventEmitter);

        var emitDelay = void 0,
            strictMode = void 0;

        if (opts.hasOwnProperty('emitDelay')) {
            emitDelay = opts.emitDelay;
        } else {
            emitDelay = DEFAULT_VALUES.emitDelay;
        }
        this._emitDelay = emitDelay;

        if (opts.hasOwnProperty('strictMode')) {
            strictMode = opts.strictMode;
        } else {
            strictMode = DEFAULT_VALUES.strictMode;
        }
        this._strictMode = strictMode;

        this._listeners = {};
        this.events = [];
    }

    /**
     * @protected
     * @param {string} type
     * @param {function} listener
     * @param {boolean} [once = false]
     */


    _createClass(EventEmitter, [{
        key: '_addListenner',
        value: function _addListenner(type, listener, once) {
            if (typeof listener !== 'function') {
                throw TypeError('listener must be a function');
            }

            if (this.events.indexOf(type) === -1) {
                this._listeners[type] = [{
                    once: once,
                    fn: listener
                }];
                this.events.push(type);
            } else {
                this._listeners[type].push({
                    once: once,
                    fn: listener
                });
            }
        }

        /**
         * Subscribes on event type specified function
         * @param {string} type
         * @param {function} listener
         */

    }, {
        key: 'on',
        value: function on(type, listener) {
            this._addListenner(type, listener, false);
        }

        /**
         * Subscribes on event type specified function to fire only once
         * @param {string} type
         * @param {function} listener
         */

    }, {
        key: 'once',
        value: function once(type, listener) {
            this._addListenner(type, listener, true);
        }

        /**
         * Removes event with specified type. If specified listenerFunc - deletes only one listener of specified type
         * @param {string} eventType
         * @param {function} [listenerFunc]
         */

    }, {
        key: 'off',
        value: function off(eventType, listenerFunc) {
            var _this = this;

            var typeIndex = this.events.indexOf(eventType);
            var hasType = eventType && typeIndex !== -1;

            if (hasType) {
                if (!listenerFunc) {
                    delete this._listeners[eventType];
                    this.events.splice(typeIndex, 1);
                } else {
                    (function () {
                        var removedEvents = [];
                        var typeListeners = _this._listeners[eventType];

                        typeListeners.forEach(
                        /**
                         * @param {EventEmitterListenerFunc} fn
                         * @param {number} idx
                         */
                        function (fn, idx) {
                            if (fn.fn === listenerFunc) {
                                removedEvents.unshift(idx);
                            }
                        });

                        removedEvents.forEach(function (idx) {
                            typeListeners.splice(idx, 1);
                        });

                        if (!typeListeners.length) {
                            _this.events.splice(typeIndex, 1);
                            delete _this._listeners[eventType];
                        }
                    })();
                }
            }
        }

        /**
         * Applies arguments to specified event type
         * @param {string} eventType
         * @param {*[]} eventArguments
         * @protected
         */

    }, {
        key: '_applyEvents',
        value: function _applyEvents(eventType, eventArguments) {
            var typeListeners = this._listeners[eventType];

            if (!typeListeners || !typeListeners.length) {
                if (this._strictMode) {
                    throw 'No listeners specified for event: ' + eventType;
                } else {
                    return;
                }
            }

            var removableListeners = [];
            typeListeners.forEach(function (eeListener, idx) {
                eeListener.fn.apply(null, eventArguments);
                if (eeListener.once) {
                    removableListeners.unshift(idx);
                }
            });

            removableListeners.forEach(function (idx) {
                typeListeners.splice(idx, 1);
            });
        }

        /**
         * Emits event with specified type and params.
         * @param {string} type
         * @param eventArgs
         */

    }, {
        key: 'emit',
        value: function emit(type) {
            var _this2 = this;

            for (var _len = arguments.length, eventArgs = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                eventArgs[_key - 1] = arguments[_key];
            }

            if (this._emitDelay) {
                setTimeout(function () {
                    _this2._applyEvents.call(_this2, type, eventArgs);
                }, this._emitDelay);
            } else {
                this._applyEvents(type, eventArgs);
            }
        }

        /**
         * Emits event with specified type and params synchronously.
         * @param {string} type
         * @param eventArgs
         */

    }, {
        key: 'emitSync',
        value: function emitSync(type) {
            for (var _len2 = arguments.length, eventArgs = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                eventArgs[_key2 - 1] = arguments[_key2];
            }

            this._applyEvents(type, eventArgs);
        }

        /**
         * Destroys EventEmitter
         */

    }, {
        key: 'destroy',
        value: function destroy() {
            this._listeners = {};
            this.events = [];
        }
    }]);

    return EventEmitter;
}();

module.exports = EventEmitter;

},{}],2:[function(require,module,exports){
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (factory((global.THREE = global.THREE || {})));
}(this, (function (exports) { 'use strict';

    // Polyfills

    if ( Number.EPSILON === undefined ) {

    	Number.EPSILON = Math.pow( 2, - 52 );

    }

    //

    if ( Math.sign === undefined ) {

    	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign

    	Math.sign = function ( x ) {

    		return ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;

    	};

    }

    if ( Function.prototype.name === undefined ) {

    	// Missing in IE9-11.
    	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name

    	Object.defineProperty( Function.prototype, 'name', {

    		get: function () {

    			return this.toString().match( /^\s*function\s*(\S*)\s*\(/ )[ 1 ];

    		}

    	} );

    }

    if ( Object.assign === undefined ) {

    	// Missing in IE.
    	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign

    	( function () {

    		Object.assign = function ( target ) {

    			'use strict';

    			if ( target === undefined || target === null ) {

    				throw new TypeError( 'Cannot convert undefined or null to object' );

    			}

    			var output = Object( target );

    			for ( var index = 1; index < arguments.length; index ++ ) {

    				var source = arguments[ index ];

    				if ( source !== undefined && source !== null ) {

    					for ( var nextKey in source ) {

    						if ( Object.prototype.hasOwnProperty.call( source, nextKey ) ) {

    							output[ nextKey ] = source[ nextKey ];

    						}

    					}

    				}

    			}

    			return output;

    		};

    	} )();

    }

    /**
     * https://github.com/mrdoob/eventdispatcher.js/
     */

    function EventDispatcher() {}

    Object.assign( EventDispatcher.prototype, {

    	addEventListener: function ( type, listener ) {

    		if ( this._listeners === undefined ) this._listeners = {};

    		var listeners = this._listeners;

    		if ( listeners[ type ] === undefined ) {

    			listeners[ type ] = [];

    		}

    		if ( listeners[ type ].indexOf( listener ) === - 1 ) {

    			listeners[ type ].push( listener );

    		}

    	},

    	hasEventListener: function ( type, listener ) {

    		if ( this._listeners === undefined ) return false;

    		var listeners = this._listeners;

    		if ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {

    			return true;

    		}

    		return false;

    	},

    	removeEventListener: function ( type, listener ) {

    		if ( this._listeners === undefined ) return;

    		var listeners = this._listeners;
    		var listenerArray = listeners[ type ];

    		if ( listenerArray !== undefined ) {

    			var index = listenerArray.indexOf( listener );

    			if ( index !== - 1 ) {

    				listenerArray.splice( index, 1 );

    			}

    		}

    	},

    	dispatchEvent: function ( event ) {

    		if ( this._listeners === undefined ) return;

    		var listeners = this._listeners;
    		var listenerArray = listeners[ event.type ];

    		if ( listenerArray !== undefined ) {

    			event.target = this;

    			var array = [], i = 0;
    			var length = listenerArray.length;

    			for ( i = 0; i < length; i ++ ) {

    				array[ i ] = listenerArray[ i ];

    			}

    			for ( i = 0; i < length; i ++ ) {

    				array[ i ].call( this, event );

    			}

    		}

    	}

    } );

    var REVISION = '81';
    var MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };
    var CullFaceNone = 0;
    var CullFaceBack = 1;
    var CullFaceFront = 2;
    var CullFaceFrontBack = 3;
    var FrontFaceDirectionCW = 0;
    var FrontFaceDirectionCCW = 1;
    var BasicShadowMap = 0;
    var PCFShadowMap = 1;
    var PCFSoftShadowMap = 2;
    var FrontSide = 0;
    var BackSide = 1;
    var DoubleSide = 2;
    var FlatShading = 1;
    var SmoothShading = 2;
    var NoColors = 0;
    var FaceColors = 1;
    var VertexColors = 2;
    var NoBlending = 0;
    var NormalBlending = 1;
    var AdditiveBlending = 2;
    var SubtractiveBlending = 3;
    var MultiplyBlending = 4;
    var CustomBlending = 5;
    var BlendingMode = {
        NoBlending: NoBlending,
        NormalBlending: NormalBlending,
        AdditiveBlending: AdditiveBlending,
        SubtractiveBlending: SubtractiveBlending,
        MultiplyBlending: MultiplyBlending,
        CustomBlending: CustomBlending
    };
    var AddEquation = 100;
    var SubtractEquation = 101;
    var ReverseSubtractEquation = 102;
    var MinEquation = 103;
    var MaxEquation = 104;
    var ZeroFactor = 200;
    var OneFactor = 201;
    var SrcColorFactor = 202;
    var OneMinusSrcColorFactor = 203;
    var SrcAlphaFactor = 204;
    var OneMinusSrcAlphaFactor = 205;
    var DstAlphaFactor = 206;
    var OneMinusDstAlphaFactor = 207;
    var DstColorFactor = 208;
    var OneMinusDstColorFactor = 209;
    var SrcAlphaSaturateFactor = 210;
    var NeverDepth = 0;
    var AlwaysDepth = 1;
    var LessDepth = 2;
    var LessEqualDepth = 3;
    var EqualDepth = 4;
    var GreaterEqualDepth = 5;
    var GreaterDepth = 6;
    var NotEqualDepth = 7;
    var MultiplyOperation = 0;
    var MixOperation = 1;
    var AddOperation = 2;
    var NoToneMapping = 0;
    var LinearToneMapping = 1;
    var ReinhardToneMapping = 2;
    var Uncharted2ToneMapping = 3;
    var CineonToneMapping = 4;
    var UVMapping = 300;
    var CubeReflectionMapping = 301;
    var CubeRefractionMapping = 302;
    var EquirectangularReflectionMapping = 303;
    var EquirectangularRefractionMapping = 304;
    var SphericalReflectionMapping = 305;
    var CubeUVReflectionMapping = 306;
    var CubeUVRefractionMapping = 307;
    var TextureMapping = {
        UVMapping: UVMapping,
        CubeReflectionMapping: CubeReflectionMapping,
        CubeRefractionMapping: CubeRefractionMapping,
        EquirectangularReflectionMapping: EquirectangularReflectionMapping,
        EquirectangularRefractionMapping: EquirectangularRefractionMapping,
        SphericalReflectionMapping: SphericalReflectionMapping,
        CubeUVReflectionMapping: CubeUVReflectionMapping,
        CubeUVRefractionMapping: CubeUVRefractionMapping
    };
    var RepeatWrapping = 1000;
    var ClampToEdgeWrapping = 1001;
    var MirroredRepeatWrapping = 1002;
    var TextureWrapping = {
        RepeatWrapping: RepeatWrapping,
        ClampToEdgeWrapping: ClampToEdgeWrapping,
        MirroredRepeatWrapping: MirroredRepeatWrapping
    };
    var NearestFilter = 1003;
    var NearestMipMapNearestFilter = 1004;
    var NearestMipMapLinearFilter = 1005;
    var LinearFilter = 1006;
    var LinearMipMapNearestFilter = 1007;
    var LinearMipMapLinearFilter = 1008;
    var TextureFilter = {
        NearestFilter: NearestFilter,
        NearestMipMapNearestFilter: NearestMipMapNearestFilter,
        NearestMipMapLinearFilter: NearestMipMapLinearFilter,
        LinearFilter: LinearFilter,
        LinearMipMapNearestFilter: LinearMipMapNearestFilter,
        LinearMipMapLinearFilter: LinearMipMapLinearFilter
    };
    var UnsignedByteType = 1009;
    var ByteType = 1010;
    var ShortType = 1011;
    var UnsignedShortType = 1012;
    var IntType = 1013;
    var UnsignedIntType = 1014;
    var FloatType = 1015;
    var HalfFloatType = 1016;
    var UnsignedShort4444Type = 1017;
    var UnsignedShort5551Type = 1018;
    var UnsignedShort565Type = 1019;
    var UnsignedInt248Type = 1020;
    var AlphaFormat = 1021;
    var RGBFormat = 1022;
    var RGBAFormat = 1023;
    var LuminanceFormat = 1024;
    var LuminanceAlphaFormat = 1025;
    var RGBEFormat = RGBAFormat;
    var DepthFormat = 1026;
    var DepthStencilFormat = 1027;
    var RGB_S3TC_DXT1_Format = 2001;
    var RGBA_S3TC_DXT1_Format = 2002;
    var RGBA_S3TC_DXT3_Format = 2003;
    var RGBA_S3TC_DXT5_Format = 2004;
    var RGB_PVRTC_4BPPV1_Format = 2100;
    var RGB_PVRTC_2BPPV1_Format = 2101;
    var RGBA_PVRTC_4BPPV1_Format = 2102;
    var RGBA_PVRTC_2BPPV1_Format = 2103;
    var RGB_ETC1_Format = 2151;
    var LoopOnce = 2200;
    var LoopRepeat = 2201;
    var LoopPingPong = 2202;
    var InterpolateDiscrete = 2300;
    var InterpolateLinear = 2301;
    var InterpolateSmooth = 2302;
    var ZeroCurvatureEnding = 2400;
    var ZeroSlopeEnding = 2401;
    var WrapAroundEnding = 2402;
    var TrianglesDrawMode = 0;
    var TriangleStripDrawMode = 1;
    var TriangleFanDrawMode = 2;
    var LinearEncoding = 3000;
    var sRGBEncoding = 3001;
    var GammaEncoding = 3007;
    var RGBEEncoding = 3002;
    var LogLuvEncoding = 3003;
    var RGBM7Encoding = 3004;
    var RGBM16Encoding = 3005;
    var RGBDEncoding = 3006;
    var BasicDepthPacking = 3200;
    var RGBADepthPacking = 3201;

    /**
     * @author alteredq / http://alteredqualia.com/
     * @author mrdoob / http://mrdoob.com/
     */

    exports.Math = {

    	DEG2RAD: Math.PI / 180,
    	RAD2DEG: 180 / Math.PI,

    	generateUUID: function () {

    		// http://www.broofa.com/Tools/Math.uuid.htm

    		var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );
    		var uuid = new Array( 36 );
    		var rnd = 0, r;

    		return function generateUUID() {

    			for ( var i = 0; i < 36; i ++ ) {

    				if ( i === 8 || i === 13 || i === 18 || i === 23 ) {

    					uuid[ i ] = '-';

    				} else if ( i === 14 ) {

    					uuid[ i ] = '4';

    				} else {

    					if ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;
    					r = rnd & 0xf;
    					rnd = rnd >> 4;
    					uuid[ i ] = chars[ ( i === 19 ) ? ( r & 0x3 ) | 0x8 : r ];

    				}

    			}

    			return uuid.join( '' );

    		};

    	}(),

    	clamp: function ( value, min, max ) {

    		return Math.max( min, Math.min( max, value ) );

    	},

    	// compute euclidian modulo of m % n
    	// https://en.wikipedia.org/wiki/Modulo_operation

    	euclideanModulo: function ( n, m ) {

    		return ( ( n % m ) + m ) % m;

    	},

    	// Linear mapping from range <a1, a2> to range <b1, b2>

    	mapLinear: function ( x, a1, a2, b1, b2 ) {

    		return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

    	},

    	// http://en.wikipedia.org/wiki/Smoothstep

    	smoothstep: function ( x, min, max ) {

    		if ( x <= min ) return 0;
    		if ( x >= max ) return 1;

    		x = ( x - min ) / ( max - min );

    		return x * x * ( 3 - 2 * x );

    	},

    	smootherstep: function ( x, min, max ) {

    		if ( x <= min ) return 0;
    		if ( x >= max ) return 1;

    		x = ( x - min ) / ( max - min );

    		return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

    	},

    	random16: function () {

    		console.warn( 'THREE.Math.random16() has been deprecated. Use Math.random() instead.' );
    		return Math.random();

    	},

    	// Random integer from <low, high> interval

    	randInt: function ( low, high ) {

    		return low + Math.floor( Math.random() * ( high - low + 1 ) );

    	},

    	// Random float from <low, high> interval

    	randFloat: function ( low, high ) {

    		return low + Math.random() * ( high - low );

    	},

    	// Random float from <-range/2, range/2> interval

    	randFloatSpread: function ( range ) {

    		return range * ( 0.5 - Math.random() );

    	},

    	degToRad: function ( degrees ) {

    		return degrees * exports.Math.DEG2RAD;

    	},

    	radToDeg: function ( radians ) {

    		return radians * exports.Math.RAD2DEG;

    	},

    	isPowerOfTwo: function ( value ) {

    		return ( value & ( value - 1 ) ) === 0 && value !== 0;

    	},

    	nearestPowerOfTwo: function ( value ) {

    		return Math.pow( 2, Math.round( Math.log( value ) / Math.LN2 ) );

    	},

    	nextPowerOfTwo: function ( value ) {

    		value --;
    		value |= value >> 1;
    		value |= value >> 2;
    		value |= value >> 4;
    		value |= value >> 8;
    		value |= value >> 16;
    		value ++;

    		return value;

    	}

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author philogb / http://blog.thejit.org/
     * @author egraether / http://egraether.com/
     * @author zz85 / http://www.lab4games.net/zz85/blog
     */

    function Vector2( x, y ) {

    	this.x = x || 0;
    	this.y = y || 0;

    }

    Vector2.prototype = {

    	constructor: Vector2,

    	isVector2: true,

    	get width() {

    		return this.x;

    	},

    	set width( value ) {

    		this.x = value;

    	},

    	get height() {

    		return this.y;

    	},

    	set height( value ) {

    		this.y = value;

    	},

    	//

    	set: function ( x, y ) {

    		this.x = x;
    		this.y = y;

    		return this;

    	},

    	setScalar: function ( scalar ) {

    		this.x = scalar;
    		this.y = scalar;

    		return this;

    	},

    	setX: function ( x ) {

    		this.x = x;

    		return this;

    	},

    	setY: function ( y ) {

    		this.y = y;

    		return this;

    	},

    	setComponent: function ( index, value ) {

    		switch ( index ) {

    			case 0: this.x = value; break;
    			case 1: this.y = value; break;
    			default: throw new Error( 'index is out of range: ' + index );

    		}

    	},

    	getComponent: function ( index ) {

    		switch ( index ) {

    			case 0: return this.x;
    			case 1: return this.y;
    			default: throw new Error( 'index is out of range: ' + index );

    		}

    	},

    	clone: function () {

    		return new this.constructor( this.x, this.y );

    	},

    	copy: function ( v ) {

    		this.x = v.x;
    		this.y = v.y;

    		return this;

    	},

    	add: function ( v, w ) {

    		if ( w !== undefined ) {

    			console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
    			return this.addVectors( v, w );

    		}

    		this.x += v.x;
    		this.y += v.y;

    		return this;

    	},

    	addScalar: function ( s ) {

    		this.x += s;
    		this.y += s;

    		return this;

    	},

    	addVectors: function ( a, b ) {

    		this.x = a.x + b.x;
    		this.y = a.y + b.y;

    		return this;

    	},

    	addScaledVector: function ( v, s ) {

    		this.x += v.x * s;
    		this.y += v.y * s;

    		return this;

    	},

    	sub: function ( v, w ) {

    		if ( w !== undefined ) {

    			console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
    			return this.subVectors( v, w );

    		}

    		this.x -= v.x;
    		this.y -= v.y;

    		return this;

    	},

    	subScalar: function ( s ) {

    		this.x -= s;
    		this.y -= s;

    		return this;

    	},

    	subVectors: function ( a, b ) {

    		this.x = a.x - b.x;
    		this.y = a.y - b.y;

    		return this;

    	},

    	multiply: function ( v ) {

    		this.x *= v.x;
    		this.y *= v.y;

    		return this;

    	},

    	multiplyScalar: function ( scalar ) {

    		if ( isFinite( scalar ) ) {

    			this.x *= scalar;
    			this.y *= scalar;

    		} else {

    			this.x = 0;
    			this.y = 0;

    		}

    		return this;

    	},

    	divide: function ( v ) {

    		this.x /= v.x;
    		this.y /= v.y;

    		return this;

    	},

    	divideScalar: function ( scalar ) {

    		return this.multiplyScalar( 1 / scalar );

    	},

    	min: function ( v ) {

    		this.x = Math.min( this.x, v.x );
    		this.y = Math.min( this.y, v.y );

    		return this;

    	},

    	max: function ( v ) {

    		this.x = Math.max( this.x, v.x );
    		this.y = Math.max( this.y, v.y );

    		return this;

    	},

    	clamp: function ( min, max ) {

    		// This function assumes min < max, if this assumption isn't true it will not operate correctly

    		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
    		this.y = Math.max( min.y, Math.min( max.y, this.y ) );

    		return this;

    	},

    	clampScalar: function () {

    		var min, max;

    		return function clampScalar( minVal, maxVal ) {

    			if ( min === undefined ) {

    				min = new Vector2();
    				max = new Vector2();

    			}

    			min.set( minVal, minVal );
    			max.set( maxVal, maxVal );

    			return this.clamp( min, max );

    		};

    	}(),

    	clampLength: function ( min, max ) {

    		var length = this.length();

    		return this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );

    	},

    	floor: function () {

    		this.x = Math.floor( this.x );
    		this.y = Math.floor( this.y );

    		return this;

    	},

    	ceil: function () {

    		this.x = Math.ceil( this.x );
    		this.y = Math.ceil( this.y );

    		return this;

    	},

    	round: function () {

    		this.x = Math.round( this.x );
    		this.y = Math.round( this.y );

    		return this;

    	},

    	roundToZero: function () {

    		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
    		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

    		return this;

    	},

    	negate: function () {

    		this.x = - this.x;
    		this.y = - this.y;

    		return this;

    	},

    	dot: function ( v ) {

    		return this.x * v.x + this.y * v.y;

    	},

    	lengthSq: function () {

    		return this.x * this.x + this.y * this.y;

    	},

    	length: function () {

    		return Math.sqrt( this.x * this.x + this.y * this.y );

    	},

    	lengthManhattan: function() {

    		return Math.abs( this.x ) + Math.abs( this.y );

    	},

    	normalize: function () {

    		return this.divideScalar( this.length() );

    	},

    	angle: function () {

    		// computes the angle in radians with respect to the positive x-axis

    		var angle = Math.atan2( this.y, this.x );

    		if ( angle < 0 ) angle += 2 * Math.PI;

    		return angle;

    	},

    	distanceTo: function ( v ) {

    		return Math.sqrt( this.distanceToSquared( v ) );

    	},

    	distanceToSquared: function ( v ) {

    		var dx = this.x - v.x, dy = this.y - v.y;
    		return dx * dx + dy * dy;

    	},

    	distanceToManhattan: function ( v ) {

    		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );

    	},

    	setLength: function ( length ) {

    		return this.multiplyScalar( length / this.length() );

    	},

    	lerp: function ( v, alpha ) {

    		this.x += ( v.x - this.x ) * alpha;
    		this.y += ( v.y - this.y ) * alpha;

    		return this;

    	},

    	lerpVectors: function ( v1, v2, alpha ) {

    		return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

    	},

    	equals: function ( v ) {

    		return ( ( v.x === this.x ) && ( v.y === this.y ) );

    	},

    	fromArray: function ( array, offset ) {

    		if ( offset === undefined ) offset = 0;

    		this.x = array[ offset ];
    		this.y = array[ offset + 1 ];

    		return this;

    	},

    	toArray: function ( array, offset ) {

    		if ( array === undefined ) array = [];
    		if ( offset === undefined ) offset = 0;

    		array[ offset ] = this.x;
    		array[ offset + 1 ] = this.y;

    		return array;

    	},

    	fromAttribute: function ( attribute, index, offset ) {

    		if ( offset === undefined ) offset = 0;

    		index = index * attribute.itemSize + offset;

    		this.x = attribute.array[ index ];
    		this.y = attribute.array[ index + 1 ];

    		return this;

    	},

    	rotateAround: function ( center, angle ) {

    		var c = Math.cos( angle ), s = Math.sin( angle );

    		var x = this.x - center.x;
    		var y = this.y - center.y;

    		this.x = x * c - y * s + center.x;
    		this.y = x * s + y * c + center.y;

    		return this;

    	}

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     * @author szimek / https://github.com/szimek/
     */

    function Texture( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {

    	Object.defineProperty( this, 'id', { value: TextureIdCount() } );

    	this.uuid = exports.Math.generateUUID();

    	this.name = '';
    	this.sourceFile = '';

    	this.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;
    	this.mipmaps = [];

    	this.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;

    	this.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;
    	this.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;

    	this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
    	this.minFilter = minFilter !== undefined ? minFilter : LinearMipMapLinearFilter;

    	this.anisotropy = anisotropy !== undefined ? anisotropy : 1;

    	this.format = format !== undefined ? format : RGBAFormat;
    	this.type = type !== undefined ? type : UnsignedByteType;

    	this.offset = new Vector2( 0, 0 );
    	this.repeat = new Vector2( 1, 1 );

    	this.generateMipmaps = true;
    	this.premultiplyAlpha = false;
    	this.flipY = true;
    	this.unpackAlignment = 4;	// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)


    	// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
    	//
    	// Also changing the encoding after already used by a Material will not automatically make the Material
    	// update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.
    	this.encoding = encoding !== undefined ? encoding :  LinearEncoding;

    	this.version = 0;
    	this.onUpdate = null;

    }

    Texture.DEFAULT_IMAGE = undefined;
    Texture.DEFAULT_MAPPING = UVMapping;

    Texture.prototype = {

    	constructor: Texture,

    	isTexture: true,

    	set needsUpdate( value ) {

    		if ( value === true ) this.version ++;

    	},

    	clone: function () {

    		return new this.constructor().copy( this );

    	},

    	copy: function ( source ) {

    		this.image = source.image;
    		this.mipmaps = source.mipmaps.slice( 0 );

    		this.mapping = source.mapping;

    		this.wrapS = source.wrapS;
    		this.wrapT = source.wrapT;

    		this.magFilter = source.magFilter;
    		this.minFilter = source.minFilter;

    		this.anisotropy = source.anisotropy;

    		this.format = source.format;
    		this.type = source.type;

    		this.offset.copy( source.offset );
    		this.repeat.copy( source.repeat );

    		this.generateMipmaps = source.generateMipmaps;
    		this.premultiplyAlpha = source.premultiplyAlpha;
    		this.flipY = source.flipY;
    		this.unpackAlignment = source.unpackAlignment;
    		this.encoding = source.encoding;

    		return this;

    	},

    	toJSON: function ( meta ) {

    		if ( meta.textures[ this.uuid ] !== undefined ) {

    			return meta.textures[ this.uuid ];

    		}

    		function getDataURL( image ) {

    			var canvas;

    			if ( image.toDataURL !== undefined ) {

    				canvas = image;

    			} else {

    				canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
    				canvas.width = image.width;
    				canvas.height = image.height;

    				canvas.getContext( '2d' ).drawImage( image, 0, 0, image.width, image.height );

    			}

    			if ( canvas.width > 2048 || canvas.height > 2048 ) {

    				return canvas.toDataURL( 'image/jpeg', 0.6 );

    			} else {

    				return canvas.toDataURL( 'image/png' );

    			}

    		}

    		var output = {
    			metadata: {
    				version: 4.4,
    				type: 'Texture',
    				generator: 'Texture.toJSON'
    			},

    			uuid: this.uuid,
    			name: this.name,

    			mapping: this.mapping,

    			repeat: [ this.repeat.x, this.repeat.y ],
    			offset: [ this.offset.x, this.offset.y ],
    			wrap: [ this.wrapS, this.wrapT ],

    			minFilter: this.minFilter,
    			magFilter: this.magFilter,
    			anisotropy: this.anisotropy,

    			flipY: this.flipY
    		};

    		if ( this.image !== undefined ) {

    			// TODO: Move to THREE.Image

    			var image = this.image;

    			if ( image.uuid === undefined ) {

    				image.uuid = exports.Math.generateUUID(); // UGH

    			}

    			if ( meta.images[ image.uuid ] === undefined ) {

    				meta.images[ image.uuid ] = {
    					uuid: image.uuid,
    					url: getDataURL( image )
    				};

    			}

    			output.image = image.uuid;

    		}

    		meta.textures[ this.uuid ] = output;

    		return output;

    	},

    	dispose: function () {

    		this.dispatchEvent( { type: 'dispose' } );

    	},

    	transformUv: function ( uv ) {

    		if ( this.mapping !== UVMapping )  return;

    		uv.multiply( this.repeat );
    		uv.add( this.offset );

    		if ( uv.x < 0 || uv.x > 1 ) {

    			switch ( this.wrapS ) {

    				case RepeatWrapping:

    					uv.x = uv.x - Math.floor( uv.x );
    					break;

    				case ClampToEdgeWrapping:

    					uv.x = uv.x < 0 ? 0 : 1;
    					break;

    				case MirroredRepeatWrapping:

    					if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {

    						uv.x = Math.ceil( uv.x ) - uv.x;

    					} else {

    						uv.x = uv.x - Math.floor( uv.x );

    					}
    					break;

    			}

    		}

    		if ( uv.y < 0 || uv.y > 1 ) {

    			switch ( this.wrapT ) {

    				case RepeatWrapping:

    					uv.y = uv.y - Math.floor( uv.y );
    					break;

    				case ClampToEdgeWrapping:

    					uv.y = uv.y < 0 ? 0 : 1;
    					break;

    				case MirroredRepeatWrapping:

    					if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {

    						uv.y = Math.ceil( uv.y ) - uv.y;

    					} else {

    						uv.y = uv.y - Math.floor( uv.y );

    					}
    					break;

    			}

    		}

    		if ( this.flipY ) {

    			uv.y = 1 - uv.y;

    		}

    	}

    };

    Object.assign( Texture.prototype, EventDispatcher.prototype );

    var count = 0;
    function TextureIdCount() { return count++; };

    /**
     * @author supereggbert / http://www.paulbrunt.co.uk/
     * @author philogb / http://blog.thejit.org/
     * @author mikael emtinger / http://gomo.se/
     * @author egraether / http://egraether.com/
     * @author WestLangley / http://github.com/WestLangley
     */

    function Vector4( x, y, z, w ) {

    	this.x = x || 0;
    	this.y = y || 0;
    	this.z = z || 0;
    	this.w = ( w !== undefined ) ? w : 1;

    }

    Vector4.prototype = {

    	constructor: Vector4,

    	isVector4: true,

    	set: function ( x, y, z, w ) {

    		this.x = x;
    		this.y = y;
    		this.z = z;
    		this.w = w;

    		return this;

    	},

    	setScalar: function ( scalar ) {

    		this.x = scalar;
    		this.y = scalar;
    		this.z = scalar;
    		this.w = scalar;

    		return this;

    	},

    	setX: function ( x ) {

    		this.x = x;

    		return this;

    	},

    	setY: function ( y ) {

    		this.y = y;

    		return this;

    	},

    	setZ: function ( z ) {

    		this.z = z;

    		return this;

    	},

    	setW: function ( w ) {

    		this.w = w;

    		return this;

    	},

    	setComponent: function ( index, value ) {

    		switch ( index ) {

    			case 0: this.x = value; break;
    			case 1: this.y = value; break;
    			case 2: this.z = value; break;
    			case 3: this.w = value; break;
    			default: throw new Error( 'index is out of range: ' + index );

    		}

    	},

    	getComponent: function ( index ) {

    		switch ( index ) {

    			case 0: return this.x;
    			case 1: return this.y;
    			case 2: return this.z;
    			case 3: return this.w;
    			default: throw new Error( 'index is out of range: ' + index );

    		}

    	},

    	clone: function () {

    		return new this.constructor( this.x, this.y, this.z, this.w );

    	},

    	copy: function ( v ) {

    		this.x = v.x;
    		this.y = v.y;
    		this.z = v.z;
    		this.w = ( v.w !== undefined ) ? v.w : 1;

    		return this;

    	},

    	add: function ( v, w ) {

    		if ( w !== undefined ) {

    			console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
    			return this.addVectors( v, w );

    		}

    		this.x += v.x;
    		this.y += v.y;
    		this.z += v.z;
    		this.w += v.w;

    		return this;

    	},

    	addScalar: function ( s ) {

    		this.x += s;
    		this.y += s;
    		this.z += s;
    		this.w += s;

    		return this;

    	},

    	addVectors: function ( a, b ) {

    		this.x = a.x + b.x;
    		this.y = a.y + b.y;
    		this.z = a.z + b.z;
    		this.w = a.w + b.w;

    		return this;

    	},

    	addScaledVector: function ( v, s ) {

    		this.x += v.x * s;
    		this.y += v.y * s;
    		this.z += v.z * s;
    		this.w += v.w * s;

    		return this;

    	},

    	sub: function ( v, w ) {

    		if ( w !== undefined ) {

    			console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
    			return this.subVectors( v, w );

    		}

    		this.x -= v.x;
    		this.y -= v.y;
    		this.z -= v.z;
    		this.w -= v.w;

    		return this;

    	},

    	subScalar: function ( s ) {

    		this.x -= s;
    		this.y -= s;
    		this.z -= s;
    		this.w -= s;

    		return this;

    	},

    	subVectors: function ( a, b ) {

    		this.x = a.x - b.x;
    		this.y = a.y - b.y;
    		this.z = a.z - b.z;
    		this.w = a.w - b.w;

    		return this;

    	},

    	multiplyScalar: function ( scalar ) {

    		if ( isFinite( scalar ) ) {

    			this.x *= scalar;
    			this.y *= scalar;
    			this.z *= scalar;
    			this.w *= scalar;

    		} else {

    			this.x = 0;
    			this.y = 0;
    			this.z = 0;
    			this.w = 0;

    		}

    		return this;

    	},

    	applyMatrix4: function ( m ) {

    		var x = this.x, y = this.y, z = this.z, w = this.w;
    		var e = m.elements;

    		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
    		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
    		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
    		this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

    		return this;

    	},

    	divideScalar: function ( scalar ) {

    		return this.multiplyScalar( 1 / scalar );

    	},

    	setAxisAngleFromQuaternion: function ( q ) {

    		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

    		// q is assumed to be normalized

    		this.w = 2 * Math.acos( q.w );

    		var s = Math.sqrt( 1 - q.w * q.w );

    		if ( s < 0.0001 ) {

    			 this.x = 1;
    			 this.y = 0;
    			 this.z = 0;

    		} else {

    			 this.x = q.x / s;
    			 this.y = q.y / s;
    			 this.z = q.z / s;

    		}

    		return this;

    	},

    	setAxisAngleFromRotationMatrix: function ( m ) {

    		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

    		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

    		var angle, x, y, z,		// variables for result
    			epsilon = 0.01,		// margin to allow for rounding errors
    			epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

    			te = m.elements,

    			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
    			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
    			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

    		if ( ( Math.abs( m12 - m21 ) < epsilon ) &&
    		     ( Math.abs( m13 - m31 ) < epsilon ) &&
    		     ( Math.abs( m23 - m32 ) < epsilon ) ) {

    			// singularity found
    			// first check for identity matrix which must have +1 for all terms
    			// in leading diagonal and zero in other terms

    			if ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&
    			     ( Math.abs( m13 + m31 ) < epsilon2 ) &&
    			     ( Math.abs( m23 + m32 ) < epsilon2 ) &&
    			     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

    				// this singularity is identity matrix so angle = 0

    				this.set( 1, 0, 0, 0 );

    				return this; // zero angle, arbitrary axis

    			}

    			// otherwise this singularity is angle = 180

    			angle = Math.PI;

    			var xx = ( m11 + 1 ) / 2;
    			var yy = ( m22 + 1 ) / 2;
    			var zz = ( m33 + 1 ) / 2;
    			var xy = ( m12 + m21 ) / 4;
    			var xz = ( m13 + m31 ) / 4;
    			var yz = ( m23 + m32 ) / 4;

    			if ( ( xx > yy ) && ( xx > zz ) ) {

    				// m11 is the largest diagonal term

    				if ( xx < epsilon ) {

    					x = 0;
    					y = 0.707106781;
    					z = 0.707106781;

    				} else {

    					x = Math.sqrt( xx );
    					y = xy / x;
    					z = xz / x;

    				}

    			} else if ( yy > zz ) {

    				// m22 is the largest diagonal term

    				if ( yy < epsilon ) {

    					x = 0.707106781;
    					y = 0;
    					z = 0.707106781;

    				} else {

    					y = Math.sqrt( yy );
    					x = xy / y;
    					z = yz / y;

    				}

    			} else {

    				// m33 is the largest diagonal term so base result on this

    				if ( zz < epsilon ) {

    					x = 0.707106781;
    					y = 0.707106781;
    					z = 0;

    				} else {

    					z = Math.sqrt( zz );
    					x = xz / z;
    					y = yz / z;

    				}

    			}

    			this.set( x, y, z, angle );

    			return this; // return 180 deg rotation

    		}

    		// as we have reached here there are no singularities so we can handle normally

    		var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +
    		                   ( m13 - m31 ) * ( m13 - m31 ) +
    		                   ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

    		if ( Math.abs( s ) < 0.001 ) s = 1;

    		// prevent divide by zero, should not happen if matrix is orthogonal and should be
    		// caught by singularity test above, but I've left it in just in case

    		this.x = ( m32 - m23 ) / s;
    		this.y = ( m13 - m31 ) / s;
    		this.z = ( m21 - m12 ) / s;
    		this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

    		return this;

    	},

    	min: function ( v ) {

    		this.x = Math.min( this.x, v.x );
    		this.y = Math.min( this.y, v.y );
    		this.z = Math.min( this.z, v.z );
    		this.w = Math.min( this.w, v.w );

    		return this;

    	},

    	max: function ( v ) {

    		this.x = Math.max( this.x, v.x );
    		this.y = Math.max( this.y, v.y );
    		this.z = Math.max( this.z, v.z );
    		this.w = Math.max( this.w, v.w );

    		return this;

    	},

    	clamp: function ( min, max ) {

    		// This function assumes min < max, if this assumption isn't true it will not operate correctly

    		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
    		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
    		this.z = Math.max( min.z, Math.min( max.z, this.z ) );
    		this.w = Math.max( min.w, Math.min( max.w, this.w ) );

    		return this;

    	},

    	clampScalar: function () {

    		var min, max;

    		return function clampScalar( minVal, maxVal ) {

    			if ( min === undefined ) {

    				min = new Vector4();
    				max = new Vector4();

    			}

    			min.set( minVal, minVal, minVal, minVal );
    			max.set( maxVal, maxVal, maxVal, maxVal );

    			return this.clamp( min, max );

    		};

    	}(),

    	floor: function () {

    		this.x = Math.floor( this.x );
    		this.y = Math.floor( this.y );
    		this.z = Math.floor( this.z );
    		this.w = Math.floor( this.w );

    		return this;

    	},

    	ceil: function () {

    		this.x = Math.ceil( this.x );
    		this.y = Math.ceil( this.y );
    		this.z = Math.ceil( this.z );
    		this.w = Math.ceil( this.w );

    		return this;

    	},

    	round: function () {

    		this.x = Math.round( this.x );
    		this.y = Math.round( this.y );
    		this.z = Math.round( this.z );
    		this.w = Math.round( this.w );

    		return this;

    	},

    	roundToZero: function () {

    		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
    		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
    		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
    		this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

    		return this;

    	},

    	negate: function () {

    		this.x = - this.x;
    		this.y = - this.y;
    		this.z = - this.z;
    		this.w = - this.w;

    		return this;

    	},

    	dot: function ( v ) {

    		return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

    	},

    	lengthSq: function () {

    		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

    	},

    	length: function () {

    		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

    	},

    	lengthManhattan: function () {

    		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

    	},

    	normalize: function () {

    		return this.divideScalar( this.length() );

    	},

    	setLength: function ( length ) {

    		return this.multiplyScalar( length / this.length() );

    	},

    	lerp: function ( v, alpha ) {

    		this.x += ( v.x - this.x ) * alpha;
    		this.y += ( v.y - this.y ) * alpha;
    		this.z += ( v.z - this.z ) * alpha;
    		this.w += ( v.w - this.w ) * alpha;

    		return this;

    	},

    	lerpVectors: function ( v1, v2, alpha ) {

    		return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

    	},

    	equals: function ( v ) {

    		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

    	},

    	fromArray: function ( array, offset ) {

    		if ( offset === undefined ) offset = 0;

    		this.x = array[ offset ];
    		this.y = array[ offset + 1 ];
    		this.z = array[ offset + 2 ];
    		this.w = array[ offset + 3 ];

    		return this;

    	},

    	toArray: function ( array, offset ) {

    		if ( array === undefined ) array = [];
    		if ( offset === undefined ) offset = 0;

    		array[ offset ] = this.x;
    		array[ offset + 1 ] = this.y;
    		array[ offset + 2 ] = this.z;
    		array[ offset + 3 ] = this.w;

    		return array;

    	},

    	fromAttribute: function ( attribute, index, offset ) {

    		if ( offset === undefined ) offset = 0;

    		index = index * attribute.itemSize + offset;

    		this.x = attribute.array[ index ];
    		this.y = attribute.array[ index + 1 ];
    		this.z = attribute.array[ index + 2 ];
    		this.w = attribute.array[ index + 3 ];

    		return this;

    	}

    };

    /**
     * @author szimek / https://github.com/szimek/
     * @author alteredq / http://alteredqualia.com/
     * @author Marius Kintel / https://github.com/kintel
     */

    /*
     In options, we can specify:
     * Texture parameters for an auto-generated target texture
     * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
    */
    function WebGLRenderTarget( width, height, options ) {

    	this.uuid = exports.Math.generateUUID();

    	this.width = width;
    	this.height = height;

    	this.scissor = new Vector4( 0, 0, width, height );
    	this.scissorTest = false;

    	this.viewport = new Vector4( 0, 0, width, height );

    	options = options || {};

    	if ( options.minFilter === undefined ) options.minFilter = LinearFilter;

    	this.texture = new Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );

    	this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
    	this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
    	this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;

    }

    Object.assign( WebGLRenderTarget.prototype, EventDispatcher.prototype, {

    	isWebGLRenderTarget: true,

    	setSize: function ( width, height ) {

    		if ( this.width !== width || this.height !== height ) {

    			this.width = width;
    			this.height = height;

    			this.dispose();

    		}

    		this.viewport.set( 0, 0, width, height );
    		this.scissor.set( 0, 0, width, height );

    	},

    	clone: function () {

    		return new this.constructor().copy( this );

    	},

    	copy: function ( source ) {

    		this.width = source.width;
    		this.height = source.height;

    		this.viewport.copy( source.viewport );

    		this.texture = source.texture.clone();

    		this.depthBuffer = source.depthBuffer;
    		this.stencilBuffer = source.stencilBuffer;
    		this.depthTexture = source.depthTexture;

    		return this;

    	},

    	dispose: function () {

    		this.dispatchEvent( { type: 'dispose' } );

    	}

    } );

    /**
     * @author alteredq / http://alteredqualia.com
     */

    function WebGLRenderTargetCube( width, height, options ) {

    	WebGLRenderTarget.call( this, width, height, options );

    	this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5
    	this.activeMipMapLevel = 0;

    }

    WebGLRenderTargetCube.prototype = Object.create( WebGLRenderTarget.prototype );
    WebGLRenderTargetCube.prototype.constructor = WebGLRenderTargetCube;

    WebGLRenderTargetCube.prototype.isWebGLRenderTargetCube = true;

    /**
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     * @author WestLangley / http://github.com/WestLangley
     * @author bhouston / http://clara.io
     */

    function Quaternion( x, y, z, w ) {

    	this._x = x || 0;
    	this._y = y || 0;
    	this._z = z || 0;
    	this._w = ( w !== undefined ) ? w : 1;

    }

    Quaternion.prototype = {

    	constructor: Quaternion,

    	get x () {

    		return this._x;

    	},

    	set x ( value ) {

    		this._x = value;
    		this.onChangeCallback();

    	},

    	get y () {

    		return this._y;

    	},

    	set y ( value ) {

    		this._y = value;
    		this.onChangeCallback();

    	},

    	get z () {

    		return this._z;

    	},

    	set z ( value ) {

    		this._z = value;
    		this.onChangeCallback();

    	},

    	get w () {

    		return this._w;

    	},

    	set w ( value ) {

    		this._w = value;
    		this.onChangeCallback();

    	},

    	set: function ( x, y, z, w ) {

    		this._x = x;
    		this._y = y;
    		this._z = z;
    		this._w = w;

    		this.onChangeCallback();

    		return this;

    	},

    	clone: function () {

    		return new this.constructor( this._x, this._y, this._z, this._w );

    	},

    	copy: function ( quaternion ) {

    		this._x = quaternion.x;
    		this._y = quaternion.y;
    		this._z = quaternion.z;
    		this._w = quaternion.w;

    		this.onChangeCallback();

    		return this;

    	},

    	setFromEuler: function ( euler, update ) {

    		if ( (euler && euler.isEuler) === false ) {

    			throw new Error( 'THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

    		}

    		// http://www.mathworks.com/matlabcentral/fileexchange/
    		// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
    		//	content/SpinCalc.m

    		var c1 = Math.cos( euler._x / 2 );
    		var c2 = Math.cos( euler._y / 2 );
    		var c3 = Math.cos( euler._z / 2 );
    		var s1 = Math.sin( euler._x / 2 );
    		var s2 = Math.sin( euler._y / 2 );
    		var s3 = Math.sin( euler._z / 2 );

    		var order = euler.order;

    		if ( order === 'XYZ' ) {

    			this._x = s1 * c2 * c3 + c1 * s2 * s3;
    			this._y = c1 * s2 * c3 - s1 * c2 * s3;
    			this._z = c1 * c2 * s3 + s1 * s2 * c3;
    			this._w = c1 * c2 * c3 - s1 * s2 * s3;

    		} else if ( order === 'YXZ' ) {

    			this._x = s1 * c2 * c3 + c1 * s2 * s3;
    			this._y = c1 * s2 * c3 - s1 * c2 * s3;
    			this._z = c1 * c2 * s3 - s1 * s2 * c3;
    			this._w = c1 * c2 * c3 + s1 * s2 * s3;

    		} else if ( order === 'ZXY' ) {

    			this._x = s1 * c2 * c3 - c1 * s2 * s3;
    			this._y = c1 * s2 * c3 + s1 * c2 * s3;
    			this._z = c1 * c2 * s3 + s1 * s2 * c3;
    			this._w = c1 * c2 * c3 - s1 * s2 * s3;

    		} else if ( order === 'ZYX' ) {

    			this._x = s1 * c2 * c3 - c1 * s2 * s3;
    			this._y = c1 * s2 * c3 + s1 * c2 * s3;
    			this._z = c1 * c2 * s3 - s1 * s2 * c3;
    			this._w = c1 * c2 * c3 + s1 * s2 * s3;

    		} else if ( order === 'YZX' ) {

    			this._x = s1 * c2 * c3 + c1 * s2 * s3;
    			this._y = c1 * s2 * c3 + s1 * c2 * s3;
    			this._z = c1 * c2 * s3 - s1 * s2 * c3;
    			this._w = c1 * c2 * c3 - s1 * s2 * s3;

    		} else if ( order === 'XZY' ) {

    			this._x = s1 * c2 * c3 - c1 * s2 * s3;
    			this._y = c1 * s2 * c3 - s1 * c2 * s3;
    			this._z = c1 * c2 * s3 + s1 * s2 * c3;
    			this._w = c1 * c2 * c3 + s1 * s2 * s3;

    		}

    		if ( update !== false ) this.onChangeCallback();

    		return this;

    	},

    	setFromAxisAngle: function ( axis, angle ) {

    		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

    		// assumes axis is normalized

    		var halfAngle = angle / 2, s = Math.sin( halfAngle );

    		this._x = axis.x * s;
    		this._y = axis.y * s;
    		this._z = axis.z * s;
    		this._w = Math.cos( halfAngle );

    		this.onChangeCallback();

    		return this;

    	},

    	setFromRotationMatrix: function ( m ) {

    		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

    		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

    		var te = m.elements,

    			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
    			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
    			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

    			trace = m11 + m22 + m33,
    			s;

    		if ( trace > 0 ) {

    			s = 0.5 / Math.sqrt( trace + 1.0 );

    			this._w = 0.25 / s;
    			this._x = ( m32 - m23 ) * s;
    			this._y = ( m13 - m31 ) * s;
    			this._z = ( m21 - m12 ) * s;

    		} else if ( m11 > m22 && m11 > m33 ) {

    			s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

    			this._w = ( m32 - m23 ) / s;
    			this._x = 0.25 * s;
    			this._y = ( m12 + m21 ) / s;
    			this._z = ( m13 + m31 ) / s;

    		} else if ( m22 > m33 ) {

    			s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

    			this._w = ( m13 - m31 ) / s;
    			this._x = ( m12 + m21 ) / s;
    			this._y = 0.25 * s;
    			this._z = ( m23 + m32 ) / s;

    		} else {

    			s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

    			this._w = ( m21 - m12 ) / s;
    			this._x = ( m13 + m31 ) / s;
    			this._y = ( m23 + m32 ) / s;
    			this._z = 0.25 * s;

    		}

    		this.onChangeCallback();

    		return this;

    	},

    	setFromUnitVectors: function () {

    		// http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final

    		// assumes direction vectors vFrom and vTo are normalized

    		var v1, r;

    		var EPS = 0.000001;

    		return function setFromUnitVectors( vFrom, vTo ) {

    			if ( v1 === undefined ) v1 = new Vector3();

    			r = vFrom.dot( vTo ) + 1;

    			if ( r < EPS ) {

    				r = 0;

    				if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

    					v1.set( - vFrom.y, vFrom.x, 0 );

    				} else {

    					v1.set( 0, - vFrom.z, vFrom.y );

    				}

    			} else {

    				v1.crossVectors( vFrom, vTo );

    			}

    			this._x = v1.x;
    			this._y = v1.y;
    			this._z = v1.z;
    			this._w = r;

    			return this.normalize();

    		};

    	}(),

    	inverse: function () {

    		return this.conjugate().normalize();

    	},

    	conjugate: function () {

    		this._x *= - 1;
    		this._y *= - 1;
    		this._z *= - 1;

    		this.onChangeCallback();

    		return this;

    	},

    	dot: function ( v ) {

    		return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

    	},

    	lengthSq: function () {

    		return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

    	},

    	length: function () {

    		return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

    	},

    	normalize: function () {

    		var l = this.length();

    		if ( l === 0 ) {

    			this._x = 0;
    			this._y = 0;
    			this._z = 0;
    			this._w = 1;

    		} else {

    			l = 1 / l;

    			this._x = this._x * l;
    			this._y = this._y * l;
    			this._z = this._z * l;
    			this._w = this._w * l;

    		}

    		this.onChangeCallback();

    		return this;

    	},

    	multiply: function ( q, p ) {

    		if ( p !== undefined ) {

    			console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
    			return this.multiplyQuaternions( q, p );

    		}

    		return this.multiplyQuaternions( this, q );

    	},

    	premultiply: function ( q ) {

    		return this.multiplyQuaternions( q, this );

    	},

    	multiplyQuaternions: function ( a, b ) {

    		// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

    		var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
    		var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

    		this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
    		this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
    		this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
    		this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

    		this.onChangeCallback();

    		return this;

    	},

    	slerp: function ( qb, t ) {

    		if ( t === 0 ) return this;
    		if ( t === 1 ) return this.copy( qb );

    		var x = this._x, y = this._y, z = this._z, w = this._w;

    		// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

    		var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

    		if ( cosHalfTheta < 0 ) {

    			this._w = - qb._w;
    			this._x = - qb._x;
    			this._y = - qb._y;
    			this._z = - qb._z;

    			cosHalfTheta = - cosHalfTheta;

    		} else {

    			this.copy( qb );

    		}

    		if ( cosHalfTheta >= 1.0 ) {

    			this._w = w;
    			this._x = x;
    			this._y = y;
    			this._z = z;

    			return this;

    		}

    		var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );

    		if ( Math.abs( sinHalfTheta ) < 0.001 ) {

    			this._w = 0.5 * ( w + this._w );
    			this._x = 0.5 * ( x + this._x );
    			this._y = 0.5 * ( y + this._y );
    			this._z = 0.5 * ( z + this._z );

    			return this;

    		}

    		var halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
    		var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
    		ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

    		this._w = ( w * ratioA + this._w * ratioB );
    		this._x = ( x * ratioA + this._x * ratioB );
    		this._y = ( y * ratioA + this._y * ratioB );
    		this._z = ( z * ratioA + this._z * ratioB );

    		this.onChangeCallback();

    		return this;

    	},

    	equals: function ( quaternion ) {

    		return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

    	},

    	fromArray: function ( array, offset ) {

    		if ( offset === undefined ) offset = 0;

    		this._x = array[ offset ];
    		this._y = array[ offset + 1 ];
    		this._z = array[ offset + 2 ];
    		this._w = array[ offset + 3 ];

    		this.onChangeCallback();

    		return this;

    	},

    	toArray: function ( array, offset ) {

    		if ( array === undefined ) array = [];
    		if ( offset === undefined ) offset = 0;

    		array[ offset ] = this._x;
    		array[ offset + 1 ] = this._y;
    		array[ offset + 2 ] = this._z;
    		array[ offset + 3 ] = this._w;

    		return array;

    	},

    	onChange: function ( callback ) {

    		this.onChangeCallback = callback;

    		return this;

    	},

    	onChangeCallback: function () {}

    };

    Object.assign( Quaternion, {

    	slerp: function( qa, qb, qm, t ) {

    		return qm.copy( qa ).slerp( qb, t );

    	},

    	slerpFlat: function(
    			dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {

    		// fuzz-free, array-based Quaternion SLERP operation

    		var x0 = src0[ srcOffset0 + 0 ],
    			y0 = src0[ srcOffset0 + 1 ],
    			z0 = src0[ srcOffset0 + 2 ],
    			w0 = src0[ srcOffset0 + 3 ],

    			x1 = src1[ srcOffset1 + 0 ],
    			y1 = src1[ srcOffset1 + 1 ],
    			z1 = src1[ srcOffset1 + 2 ],
    			w1 = src1[ srcOffset1 + 3 ];

    		if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {

    			var s = 1 - t,

    				cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,

    				dir = ( cos >= 0 ? 1 : - 1 ),
    				sqrSin = 1 - cos * cos;

    			// Skip the Slerp for tiny steps to avoid numeric problems:
    			if ( sqrSin > Number.EPSILON ) {

    				var sin = Math.sqrt( sqrSin ),
    					len = Math.atan2( sin, cos * dir );

    				s = Math.sin( s * len ) / sin;
    				t = Math.sin( t * len ) / sin;

    			}

    			var tDir = t * dir;

    			x0 = x0 * s + x1 * tDir;
    			y0 = y0 * s + y1 * tDir;
    			z0 = z0 * s + z1 * tDir;
    			w0 = w0 * s + w1 * tDir;

    			// Normalize in case we just did a lerp:
    			if ( s === 1 - t ) {

    				var f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );

    				x0 *= f;
    				y0 *= f;
    				z0 *= f;
    				w0 *= f;

    			}

    		}

    		dst[ dstOffset ] = x0;
    		dst[ dstOffset + 1 ] = y0;
    		dst[ dstOffset + 2 ] = z0;
    		dst[ dstOffset + 3 ] = w0;

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author *kile / http://kile.stravaganza.org/
     * @author philogb / http://blog.thejit.org/
     * @author mikael emtinger / http://gomo.se/
     * @author egraether / http://egraether.com/
     * @author WestLangley / http://github.com/WestLangley
     */

    function Vector3( x, y, z ) {

    	this.x = x || 0;
    	this.y = y || 0;
    	this.z = z || 0;

    }

    Vector3.prototype = {

    	constructor: Vector3,

    	isVector3: true,

    	set: function ( x, y, z ) {

    		this.x = x;
    		this.y = y;
    		this.z = z;

    		return this;

    	},

    	setScalar: function ( scalar ) {

    		this.x = scalar;
    		this.y = scalar;
    		this.z = scalar;

    		return this;

    	},

    	setX: function ( x ) {

    		this.x = x;

    		return this;

    	},

    	setY: function ( y ) {

    		this.y = y;

    		return this;

    	},

    	setZ: function ( z ) {

    		this.z = z;

    		return this;

    	},

    	setComponent: function ( index, value ) {

    		switch ( index ) {

    			case 0: this.x = value; break;
    			case 1: this.y = value; break;
    			case 2: this.z = value; break;
    			default: throw new Error( 'index is out of range: ' + index );

    		}

    	},

    	getComponent: function ( index ) {

    		switch ( index ) {

    			case 0: return this.x;
    			case 1: return this.y;
    			case 2: return this.z;
    			default: throw new Error( 'index is out of range: ' + index );

    		}

    	},

    	clone: function () {

    		return new this.constructor( this.x, this.y, this.z );

    	},

    	copy: function ( v ) {

    		this.x = v.x;
    		this.y = v.y;
    		this.z = v.z;

    		return this;

    	},

    	add: function ( v, w ) {

    		if ( w !== undefined ) {

    			console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
    			return this.addVectors( v, w );

    		}

    		this.x += v.x;
    		this.y += v.y;
    		this.z += v.z;

    		return this;

    	},

    	addScalar: function ( s ) {

    		this.x += s;
    		this.y += s;
    		this.z += s;

    		return this;

    	},

    	addVectors: function ( a, b ) {

    		this.x = a.x + b.x;
    		this.y = a.y + b.y;
    		this.z = a.z + b.z;

    		return this;

    	},

    	addScaledVector: function ( v, s ) {

    		this.x += v.x * s;
    		this.y += v.y * s;
    		this.z += v.z * s;

    		return this;

    	},

    	sub: function ( v, w ) {

    		if ( w !== undefined ) {

    			console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
    			return this.subVectors( v, w );

    		}

    		this.x -= v.x;
    		this.y -= v.y;
    		this.z -= v.z;

    		return this;

    	},

    	subScalar: function ( s ) {

    		this.x -= s;
    		this.y -= s;
    		this.z -= s;

    		return this;

    	},

    	subVectors: function ( a, b ) {

    		this.x = a.x - b.x;
    		this.y = a.y - b.y;
    		this.z = a.z - b.z;

    		return this;

    	},

    	multiply: function ( v, w ) {

    		if ( w !== undefined ) {

    			console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
    			return this.multiplyVectors( v, w );

    		}

    		this.x *= v.x;
    		this.y *= v.y;
    		this.z *= v.z;

    		return this;

    	},

    	multiplyScalar: function ( scalar ) {

    		if ( isFinite( scalar ) ) {

    			this.x *= scalar;
    			this.y *= scalar;
    			this.z *= scalar;

    		} else {

    			this.x = 0;
    			this.y = 0;
    			this.z = 0;

    		}

    		return this;

    	},

    	multiplyVectors: function ( a, b ) {

    		this.x = a.x * b.x;
    		this.y = a.y * b.y;
    		this.z = a.z * b.z;

    		return this;

    	},

    	applyEuler: function () {

    		var quaternion;

    		return function applyEuler( euler ) {

    			if ( (euler && euler.isEuler) === false ) {

    				console.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );

    			}

    			if ( quaternion === undefined ) quaternion = new Quaternion();

    			return this.applyQuaternion( quaternion.setFromEuler( euler ) );

    		};

    	}(),

    	applyAxisAngle: function () {

    		var quaternion;

    		return function applyAxisAngle( axis, angle ) {

    			if ( quaternion === undefined ) quaternion = new Quaternion();

    			return this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );

    		};

    	}(),

    	applyMatrix3: function ( m ) {

    		var x = this.x, y = this.y, z = this.z;
    		var e = m.elements;

    		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
    		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
    		this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

    		return this;

    	},

    	applyMatrix4: function ( m ) {

    		// input: THREE.Matrix4 affine matrix

    		var x = this.x, y = this.y, z = this.z;
    		var e = m.elements;

    		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ];
    		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ];
    		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];

    		return this;

    	},

    	applyProjection: function ( m ) {

    		// input: THREE.Matrix4 projection matrix

    		var x = this.x, y = this.y, z = this.z;
    		var e = m.elements;
    		var d = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] ); // perspective divide

    		this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ] ) * d;
    		this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ] ) * d;
    		this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * d;

    		return this;

    	},

    	applyQuaternion: function ( q ) {

    		var x = this.x, y = this.y, z = this.z;
    		var qx = q.x, qy = q.y, qz = q.z, qw = q.w;

    		// calculate quat * vector

    		var ix =  qw * x + qy * z - qz * y;
    		var iy =  qw * y + qz * x - qx * z;
    		var iz =  qw * z + qx * y - qy * x;
    		var iw = - qx * x - qy * y - qz * z;

    		// calculate result * inverse quat

    		this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
    		this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
    		this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

    		return this;

    	},

    	project: function () {

    		var matrix;

    		return function project( camera ) {

    			if ( matrix === undefined ) matrix = new Matrix4();

    			matrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );
    			return this.applyProjection( matrix );

    		};

    	}(),

    	unproject: function () {

    		var matrix;

    		return function unproject( camera ) {

    			if ( matrix === undefined ) matrix = new Matrix4();

    			matrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );
    			return this.applyProjection( matrix );

    		};

    	}(),

    	transformDirection: function ( m ) {

    		// input: THREE.Matrix4 affine matrix
    		// vector interpreted as a direction

    		var x = this.x, y = this.y, z = this.z;
    		var e = m.elements;

    		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;
    		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;
    		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

    		return this.normalize();

    	},

    	divide: function ( v ) {

    		this.x /= v.x;
    		this.y /= v.y;
    		this.z /= v.z;

    		return this;

    	},

    	divideScalar: function ( scalar ) {

    		return this.multiplyScalar( 1 / scalar );

    	},

    	min: function ( v ) {

    		this.x = Math.min( this.x, v.x );
    		this.y = Math.min( this.y, v.y );
    		this.z = Math.min( this.z, v.z );

    		return this;

    	},

    	max: function ( v ) {

    		this.x = Math.max( this.x, v.x );
    		this.y = Math.max( this.y, v.y );
    		this.z = Math.max( this.z, v.z );

    		return this;

    	},

    	clamp: function ( min, max ) {

    		// This function assumes min < max, if this assumption isn't true it will not operate correctly

    		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
    		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
    		this.z = Math.max( min.z, Math.min( max.z, this.z ) );

    		return this;

    	},

    	clampScalar: function () {

    		var min, max;

    		return function clampScalar( minVal, maxVal ) {

    			if ( min === undefined ) {

    				min = new Vector3();
    				max = new Vector3();

    			}

    			min.set( minVal, minVal, minVal );
    			max.set( maxVal, maxVal, maxVal );

    			return this.clamp( min, max );

    		};

    	}(),

    	clampLength: function ( min, max ) {

    		var length = this.length();

    		return this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );

    	},

    	floor: function () {

    		this.x = Math.floor( this.x );
    		this.y = Math.floor( this.y );
    		this.z = Math.floor( this.z );

    		return this;

    	},

    	ceil: function () {

    		this.x = Math.ceil( this.x );
    		this.y = Math.ceil( this.y );
    		this.z = Math.ceil( this.z );

    		return this;

    	},

    	round: function () {

    		this.x = Math.round( this.x );
    		this.y = Math.round( this.y );
    		this.z = Math.round( this.z );

    		return this;

    	},

    	roundToZero: function () {

    		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
    		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
    		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

    		return this;

    	},

    	negate: function () {

    		this.x = - this.x;
    		this.y = - this.y;
    		this.z = - this.z;

    		return this;

    	},

    	dot: function ( v ) {

    		return this.x * v.x + this.y * v.y + this.z * v.z;

    	},

    	lengthSq: function () {

    		return this.x * this.x + this.y * this.y + this.z * this.z;

    	},

    	length: function () {

    		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

    	},

    	lengthManhattan: function () {

    		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

    	},

    	normalize: function () {

    		return this.divideScalar( this.length() );

    	},

    	setLength: function ( length ) {

    		return this.multiplyScalar( length / this.length() );

    	},

    	lerp: function ( v, alpha ) {

    		this.x += ( v.x - this.x ) * alpha;
    		this.y += ( v.y - this.y ) * alpha;
    		this.z += ( v.z - this.z ) * alpha;

    		return this;

    	},

    	lerpVectors: function ( v1, v2, alpha ) {

    		return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

    	},

    	cross: function ( v, w ) {

    		if ( w !== undefined ) {

    			console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
    			return this.crossVectors( v, w );

    		}

    		var x = this.x, y = this.y, z = this.z;

    		this.x = y * v.z - z * v.y;
    		this.y = z * v.x - x * v.z;
    		this.z = x * v.y - y * v.x;

    		return this;

    	},

    	crossVectors: function ( a, b ) {

    		var ax = a.x, ay = a.y, az = a.z;
    		var bx = b.x, by = b.y, bz = b.z;

    		this.x = ay * bz - az * by;
    		this.y = az * bx - ax * bz;
    		this.z = ax * by - ay * bx;

    		return this;

    	},

    	projectOnVector: function ( vector ) {

    		var scalar = vector.dot( this ) / vector.lengthSq();

    		return this.copy( vector ).multiplyScalar( scalar );

    	},

    	projectOnPlane: function () {

    		var v1;

    		return function projectOnPlane( planeNormal ) {

    			if ( v1 === undefined ) v1 = new Vector3();

    			v1.copy( this ).projectOnVector( planeNormal );

    			return this.sub( v1 );

    		};

    	}(),

    	reflect: function () {

    		// reflect incident vector off plane orthogonal to normal
    		// normal is assumed to have unit length

    		var v1;

    		return function reflect( normal ) {

    			if ( v1 === undefined ) v1 = new Vector3();

    			return this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

    		};

    	}(),

    	angleTo: function ( v ) {

    		var theta = this.dot( v ) / ( Math.sqrt( this.lengthSq() * v.lengthSq() ) );

    		// clamp, to handle numerical problems

    		return Math.acos( exports.Math.clamp( theta, - 1, 1 ) );

    	},

    	distanceTo: function ( v ) {

    		return Math.sqrt( this.distanceToSquared( v ) );

    	},

    	distanceToSquared: function ( v ) {

    		var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;

    		return dx * dx + dy * dy + dz * dz;

    	},

    	distanceToManhattan: function ( v ) {

    		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );

    	},

    	setFromSpherical: function( s ) {

    		var sinPhiRadius = Math.sin( s.phi ) * s.radius;

    		this.x = sinPhiRadius * Math.sin( s.theta );
    		this.y = Math.cos( s.phi ) * s.radius;
    		this.z = sinPhiRadius * Math.cos( s.theta );

    		return this;

    	},

    	setFromMatrixPosition: function ( m ) {

    		return this.setFromMatrixColumn( m, 3 );

    	},

    	setFromMatrixScale: function ( m ) {

    		var sx = this.setFromMatrixColumn( m, 0 ).length();
    		var sy = this.setFromMatrixColumn( m, 1 ).length();
    		var sz = this.setFromMatrixColumn( m, 2 ).length();

    		this.x = sx;
    		this.y = sy;
    		this.z = sz;

    		return this;

    	},

    	setFromMatrixColumn: function ( m, index ) {

    		if ( typeof m === 'number' ) {

    			console.warn( 'THREE.Vector3: setFromMatrixColumn now expects ( matrix, index ).' );
    			var temp = m
    			m = index;
    			index = temp;

    		}

    		return this.fromArray( m.elements, index * 4 );

    	},

    	equals: function ( v ) {

    		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

    	},

    	fromArray: function ( array, offset ) {

    		if ( offset === undefined ) offset = 0;

    		this.x = array[ offset ];
    		this.y = array[ offset + 1 ];
    		this.z = array[ offset + 2 ];

    		return this;

    	},

    	toArray: function ( array, offset ) {

    		if ( array === undefined ) array = [];
    		if ( offset === undefined ) offset = 0;

    		array[ offset ] = this.x;
    		array[ offset + 1 ] = this.y;
    		array[ offset + 2 ] = this.z;

    		return array;

    	},

    	fromAttribute: function ( attribute, index, offset ) {

    		if ( offset === undefined ) offset = 0;

    		index = index * attribute.itemSize + offset;

    		this.x = attribute.array[ index ];
    		this.y = attribute.array[ index + 1 ];
    		this.z = attribute.array[ index + 2 ];

    		return this;

    	}

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author supereggbert / http://www.paulbrunt.co.uk/
     * @author philogb / http://blog.thejit.org/
     * @author jordi_ros / http://plattsoft.com
     * @author D1plo1d / http://github.com/D1plo1d
     * @author alteredq / http://alteredqualia.com/
     * @author mikael emtinger / http://gomo.se/
     * @author timknip / http://www.floorplanner.com/
     * @author bhouston / http://clara.io
     * @author WestLangley / http://github.com/WestLangley
     */

    function Matrix4() {

    	this.elements = new Float32Array( [

    		1, 0, 0, 0,
    		0, 1, 0, 0,
    		0, 0, 1, 0,
    		0, 0, 0, 1

    	] );

    	if ( arguments.length > 0 ) {

    		console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );

    	}

    }

    Matrix4.prototype = {

    	constructor: Matrix4,

    	isMatrix4: true,

    	set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

    		var te = this.elements;

    		te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
    		te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
    		te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
    		te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

    		return this;

    	},

    	identity: function () {

    		this.set(

    			1, 0, 0, 0,
    			0, 1, 0, 0,
    			0, 0, 1, 0,
    			0, 0, 0, 1

    		);

    		return this;

    	},

    	clone: function () {

    		return new Matrix4().fromArray( this.elements );

    	},

    	copy: function ( m ) {

    		this.elements.set( m.elements );

    		return this;

    	},

    	copyPosition: function ( m ) {

    		var te = this.elements;
    		var me = m.elements;

    		te[ 12 ] = me[ 12 ];
    		te[ 13 ] = me[ 13 ];
    		te[ 14 ] = me[ 14 ];

    		return this;

    	},

    	extractBasis: function ( xAxis, yAxis, zAxis ) {

    		xAxis.setFromMatrixColumn( this, 0 );
    		yAxis.setFromMatrixColumn( this, 1 );
    		zAxis.setFromMatrixColumn( this, 2 );

    		return this;

    	},

    	makeBasis: function ( xAxis, yAxis, zAxis ) {

    		this.set(
    			xAxis.x, yAxis.x, zAxis.x, 0,
    			xAxis.y, yAxis.y, zAxis.y, 0,
    			xAxis.z, yAxis.z, zAxis.z, 0,
    			0,       0,       0,       1
    		);

    		return this;

    	},

    	extractRotation: function () {

    		var v1;

    		return function extractRotation( m ) {

    			if ( v1 === undefined ) v1 = new Vector3();

    			var te = this.elements;
    			var me = m.elements;

    			var scaleX = 1 / v1.setFromMatrixColumn( m, 0 ).length();
    			var scaleY = 1 / v1.setFromMatrixColumn( m, 1 ).length();
    			var scaleZ = 1 / v1.setFromMatrixColumn( m, 2 ).length();

    			te[ 0 ] = me[ 0 ] * scaleX;
    			te[ 1 ] = me[ 1 ] * scaleX;
    			te[ 2 ] = me[ 2 ] * scaleX;

    			te[ 4 ] = me[ 4 ] * scaleY;
    			te[ 5 ] = me[ 5 ] * scaleY;
    			te[ 6 ] = me[ 6 ] * scaleY;

    			te[ 8 ] = me[ 8 ] * scaleZ;
    			te[ 9 ] = me[ 9 ] * scaleZ;
    			te[ 10 ] = me[ 10 ] * scaleZ;

    			return this;

    		};

    	}(),

    	makeRotationFromEuler: function ( euler ) {

    		if ( (euler && euler.isEuler) === false ) {

    			console.error( 'THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

    		}

    		var te = this.elements;

    		var x = euler.x, y = euler.y, z = euler.z;
    		var a = Math.cos( x ), b = Math.sin( x );
    		var c = Math.cos( y ), d = Math.sin( y );
    		var e = Math.cos( z ), f = Math.sin( z );

    		if ( euler.order === 'XYZ' ) {

    			var ae = a * e, af = a * f, be = b * e, bf = b * f;

    			te[ 0 ] = c * e;
    			te[ 4 ] = - c * f;
    			te[ 8 ] = d;

    			te[ 1 ] = af + be * d;
    			te[ 5 ] = ae - bf * d;
    			te[ 9 ] = - b * c;

    			te[ 2 ] = bf - ae * d;
    			te[ 6 ] = be + af * d;
    			te[ 10 ] = a * c;

    		} else if ( euler.order === 'YXZ' ) {

    			var ce = c * e, cf = c * f, de = d * e, df = d * f;

    			te[ 0 ] = ce + df * b;
    			te[ 4 ] = de * b - cf;
    			te[ 8 ] = a * d;

    			te[ 1 ] = a * f;
    			te[ 5 ] = a * e;
    			te[ 9 ] = - b;

    			te[ 2 ] = cf * b - de;
    			te[ 6 ] = df + ce * b;
    			te[ 10 ] = a * c;

    		} else if ( euler.order === 'ZXY' ) {

    			var ce = c * e, cf = c * f, de = d * e, df = d * f;

    			te[ 0 ] = ce - df * b;
    			te[ 4 ] = - a * f;
    			te[ 8 ] = de + cf * b;

    			te[ 1 ] = cf + de * b;
    			te[ 5 ] = a * e;
    			te[ 9 ] = df - ce * b;

    			te[ 2 ] = - a * d;
    			te[ 6 ] = b;
    			te[ 10 ] = a * c;

    		} else if ( euler.order === 'ZYX' ) {

    			var ae = a * e, af = a * f, be = b * e, bf = b * f;

    			te[ 0 ] = c * e;
    			te[ 4 ] = be * d - af;
    			te[ 8 ] = ae * d + bf;

    			te[ 1 ] = c * f;
    			te[ 5 ] = bf * d + ae;
    			te[ 9 ] = af * d - be;

    			te[ 2 ] = - d;
    			te[ 6 ] = b * c;
    			te[ 10 ] = a * c;

    		} else if ( euler.order === 'YZX' ) {

    			var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

    			te[ 0 ] = c * e;
    			te[ 4 ] = bd - ac * f;
    			te[ 8 ] = bc * f + ad;

    			te[ 1 ] = f;
    			te[ 5 ] = a * e;
    			te[ 9 ] = - b * e;

    			te[ 2 ] = - d * e;
    			te[ 6 ] = ad * f + bc;
    			te[ 10 ] = ac - bd * f;

    		} else if ( euler.order === 'XZY' ) {

    			var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

    			te[ 0 ] = c * e;
    			te[ 4 ] = - f;
    			te[ 8 ] = d * e;

    			te[ 1 ] = ac * f + bd;
    			te[ 5 ] = a * e;
    			te[ 9 ] = ad * f - bc;

    			te[ 2 ] = bc * f - ad;
    			te[ 6 ] = b * e;
    			te[ 10 ] = bd * f + ac;

    		}

    		// last column
    		te[ 3 ] = 0;
    		te[ 7 ] = 0;
    		te[ 11 ] = 0;

    		// bottom row
    		te[ 12 ] = 0;
    		te[ 13 ] = 0;
    		te[ 14 ] = 0;
    		te[ 15 ] = 1;

    		return this;

    	},

    	makeRotationFromQuaternion: function ( q ) {

    		var te = this.elements;

    		var x = q.x, y = q.y, z = q.z, w = q.w;
    		var x2 = x + x, y2 = y + y, z2 = z + z;
    		var xx = x * x2, xy = x * y2, xz = x * z2;
    		var yy = y * y2, yz = y * z2, zz = z * z2;
    		var wx = w * x2, wy = w * y2, wz = w * z2;

    		te[ 0 ] = 1 - ( yy + zz );
    		te[ 4 ] = xy - wz;
    		te[ 8 ] = xz + wy;

    		te[ 1 ] = xy + wz;
    		te[ 5 ] = 1 - ( xx + zz );
    		te[ 9 ] = yz - wx;

    		te[ 2 ] = xz - wy;
    		te[ 6 ] = yz + wx;
    		te[ 10 ] = 1 - ( xx + yy );

    		// last column
    		te[ 3 ] = 0;
    		te[ 7 ] = 0;
    		te[ 11 ] = 0;

    		// bottom row
    		te[ 12 ] = 0;
    		te[ 13 ] = 0;
    		te[ 14 ] = 0;
    		te[ 15 ] = 1;

    		return this;

    	},

    	lookAt: function () {

    		var x, y, z;

    		return function lookAt( eye, target, up ) {

    			if ( x === undefined ) {

    				x = new Vector3();
    				y = new Vector3();
    				z = new Vector3();

    			}

    			var te = this.elements;

    			z.subVectors( eye, target ).normalize();

    			if ( z.lengthSq() === 0 ) {

    				z.z = 1;

    			}

    			x.crossVectors( up, z ).normalize();

    			if ( x.lengthSq() === 0 ) {

    				z.z += 0.0001;
    				x.crossVectors( up, z ).normalize();

    			}

    			y.crossVectors( z, x );


    			te[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;
    			te[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;
    			te[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;

    			return this;

    		};

    	}(),

    	multiply: function ( m, n ) {

    		if ( n !== undefined ) {

    			console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
    			return this.multiplyMatrices( m, n );

    		}

    		return this.multiplyMatrices( this, m );

    	},

    	premultiply: function ( m ) {

    		return this.multiplyMatrices( m, this );

    	},

    	multiplyMatrices: function ( a, b ) {

    		var ae = a.elements;
    		var be = b.elements;
    		var te = this.elements;

    		var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
    		var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
    		var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
    		var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

    		var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
    		var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
    		var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
    		var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

    		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
    		te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
    		te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
    		te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

    		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
    		te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
    		te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
    		te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

    		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
    		te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
    		te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
    		te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

    		te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
    		te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
    		te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
    		te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

    		return this;

    	},

    	multiplyToArray: function ( a, b, r ) {

    		var te = this.elements;

    		this.multiplyMatrices( a, b );

    		r[ 0 ] = te[ 0 ]; r[ 1 ] = te[ 1 ]; r[ 2 ] = te[ 2 ]; r[ 3 ] = te[ 3 ];
    		r[ 4 ] = te[ 4 ]; r[ 5 ] = te[ 5 ]; r[ 6 ] = te[ 6 ]; r[ 7 ] = te[ 7 ];
    		r[ 8 ]  = te[ 8 ]; r[ 9 ]  = te[ 9 ]; r[ 10 ] = te[ 10 ]; r[ 11 ] = te[ 11 ];
    		r[ 12 ] = te[ 12 ]; r[ 13 ] = te[ 13 ]; r[ 14 ] = te[ 14 ]; r[ 15 ] = te[ 15 ];

    		return this;

    	},

    	multiplyScalar: function ( s ) {

    		var te = this.elements;

    		te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
    		te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
    		te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
    		te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

    		return this;

    	},

    	applyToVector3Array: function () {

    		var v1;

    		return function applyToVector3Array( array, offset, length ) {

    			if ( v1 === undefined ) v1 = new Vector3();
    			if ( offset === undefined ) offset = 0;
    			if ( length === undefined ) length = array.length;

    			for ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {

    				v1.fromArray( array, j );
    				v1.applyMatrix4( this );
    				v1.toArray( array, j );

    			}

    			return array;

    		};

    	}(),

    	applyToBuffer: function () {

    		var v1;

    		return function applyToBuffer( buffer, offset, length ) {

    			if ( v1 === undefined ) v1 = new Vector3();
    			if ( offset === undefined ) offset = 0;
    			if ( length === undefined ) length = buffer.length / buffer.itemSize;

    			for ( var i = 0, j = offset; i < length; i ++, j ++ ) {

    				v1.x = buffer.getX( j );
    				v1.y = buffer.getY( j );
    				v1.z = buffer.getZ( j );

    				v1.applyMatrix4( this );

    				buffer.setXYZ( v1.x, v1.y, v1.z );

    			}

    			return buffer;

    		};

    	}(),

    	determinant: function () {

    		var te = this.elements;

    		var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
    		var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
    		var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
    		var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

    		//TODO: make this more efficient
    		//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

    		return (
    			n41 * (
    				+ n14 * n23 * n32
    				 - n13 * n24 * n32
    				 - n14 * n22 * n33
    				 + n12 * n24 * n33
    				 + n13 * n22 * n34
    				 - n12 * n23 * n34
    			) +
    			n42 * (
    				+ n11 * n23 * n34
    				 - n11 * n24 * n33
    				 + n14 * n21 * n33
    				 - n13 * n21 * n34
    				 + n13 * n24 * n31
    				 - n14 * n23 * n31
    			) +
    			n43 * (
    				+ n11 * n24 * n32
    				 - n11 * n22 * n34
    				 - n14 * n21 * n32
    				 + n12 * n21 * n34
    				 + n14 * n22 * n31
    				 - n12 * n24 * n31
    			) +
    			n44 * (
    				- n13 * n22 * n31
    				 - n11 * n23 * n32
    				 + n11 * n22 * n33
    				 + n13 * n21 * n32
    				 - n12 * n21 * n33
    				 + n12 * n23 * n31
    			)

    		);

    	},

    	transpose: function () {

    		var te = this.elements;
    		var tmp;

    		tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
    		tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
    		tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

    		tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
    		tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
    		tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

    		return this;

    	},

    	flattenToArrayOffset: function ( array, offset ) {

    		console.warn( "THREE.Matrix3: .flattenToArrayOffset is deprecated " +
    				"- just use .toArray instead." );

    		return this.toArray( array, offset );

    	},

    	getPosition: function () {

    		var v1;

    		return function getPosition() {

    			if ( v1 === undefined ) v1 = new Vector3();
    			console.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );

    			return v1.setFromMatrixColumn( this, 3 );

    		};

    	}(),

    	setPosition: function ( v ) {

    		var te = this.elements;

    		te[ 12 ] = v.x;
    		te[ 13 ] = v.y;
    		te[ 14 ] = v.z;

    		return this;

    	},

    	getInverse: function ( m, throwOnDegenerate ) {

    		// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
    		var te = this.elements,
    			me = m.elements,

    			n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],
    			n12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],
    			n13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],
    			n14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],

    			t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
    			t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
    			t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
    			t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

    		var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

    		if ( det === 0 ) {

    			var msg = "THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0";

    			if ( throwOnDegenerate === true ) {

    				throw new Error( msg );

    			} else {

    				console.warn( msg );

    			}

    			return this.identity();

    		}

    		var detInv = 1 / det;

    		te[ 0 ] = t11 * detInv;
    		te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
    		te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
    		te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;

    		te[ 4 ] = t12 * detInv;
    		te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
    		te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
    		te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;

    		te[ 8 ] = t13 * detInv;
    		te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
    		te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
    		te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;

    		te[ 12 ] = t14 * detInv;
    		te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
    		te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
    		te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;

    		return this;

    	},

    	scale: function ( v ) {

    		var te = this.elements;
    		var x = v.x, y = v.y, z = v.z;

    		te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
    		te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
    		te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
    		te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

    		return this;

    	},

    	getMaxScaleOnAxis: function () {

    		var te = this.elements;

    		var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
    		var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
    		var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

    		return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

    	},

    	makeTranslation: function ( x, y, z ) {

    		this.set(

    			1, 0, 0, x,
    			0, 1, 0, y,
    			0, 0, 1, z,
    			0, 0, 0, 1

    		);

    		return this;

    	},

    	makeRotationX: function ( theta ) {

    		var c = Math.cos( theta ), s = Math.sin( theta );

    		this.set(

    			1, 0,  0, 0,
    			0, c, - s, 0,
    			0, s,  c, 0,
    			0, 0,  0, 1

    		);

    		return this;

    	},

    	makeRotationY: function ( theta ) {

    		var c = Math.cos( theta ), s = Math.sin( theta );

    		this.set(

    			 c, 0, s, 0,
    			 0, 1, 0, 0,
    			- s, 0, c, 0,
    			 0, 0, 0, 1

    		);

    		return this;

    	},

    	makeRotationZ: function ( theta ) {

    		var c = Math.cos( theta ), s = Math.sin( theta );

    		this.set(

    			c, - s, 0, 0,
    			s,  c, 0, 0,
    			0,  0, 1, 0,
    			0,  0, 0, 1

    		);

    		return this;

    	},

    	makeRotationAxis: function ( axis, angle ) {

    		// Based on http://www.gamedev.net/reference/articles/article1199.asp

    		var c = Math.cos( angle );
    		var s = Math.sin( angle );
    		var t = 1 - c;
    		var x = axis.x, y = axis.y, z = axis.z;
    		var tx = t * x, ty = t * y;

    		this.set(

    			tx * x + c, tx * y - s * z, tx * z + s * y, 0,
    			tx * y + s * z, ty * y + c, ty * z - s * x, 0,
    			tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
    			0, 0, 0, 1

    		);

    		 return this;

    	},

    	makeScale: function ( x, y, z ) {

    		this.set(

    			x, 0, 0, 0,
    			0, y, 0, 0,
    			0, 0, z, 0,
    			0, 0, 0, 1

    		);

    		return this;

    	},

    	compose: function ( position, quaternion, scale ) {

    		this.makeRotationFromQuaternion( quaternion );
    		this.scale( scale );
    		this.setPosition( position );

    		return this;

    	},

    	decompose: function () {

    		var vector, matrix;

    		return function decompose( position, quaternion, scale ) {

    			if ( vector === undefined ) {

    				vector = new Vector3();
    				matrix = new Matrix4();

    			}

    			var te = this.elements;

    			var sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
    			var sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
    			var sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

    			// if determine is negative, we need to invert one scale
    			var det = this.determinant();
    			if ( det < 0 ) {

    				sx = - sx;

    			}

    			position.x = te[ 12 ];
    			position.y = te[ 13 ];
    			position.z = te[ 14 ];

    			// scale the rotation part

    			matrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()

    			var invSX = 1 / sx;
    			var invSY = 1 / sy;
    			var invSZ = 1 / sz;

    			matrix.elements[ 0 ] *= invSX;
    			matrix.elements[ 1 ] *= invSX;
    			matrix.elements[ 2 ] *= invSX;

    			matrix.elements[ 4 ] *= invSY;
    			matrix.elements[ 5 ] *= invSY;
    			matrix.elements[ 6 ] *= invSY;

    			matrix.elements[ 8 ] *= invSZ;
    			matrix.elements[ 9 ] *= invSZ;
    			matrix.elements[ 10 ] *= invSZ;

    			quaternion.setFromRotationMatrix( matrix );

    			scale.x = sx;
    			scale.y = sy;
    			scale.z = sz;

    			return this;

    		};

    	}(),

    	makeFrustum: function ( left, right, bottom, top, near, far ) {

    		var te = this.elements;
    		var x = 2 * near / ( right - left );
    		var y = 2 * near / ( top - bottom );

    		var a = ( right + left ) / ( right - left );
    		var b = ( top + bottom ) / ( top - bottom );
    		var c = - ( far + near ) / ( far - near );
    		var d = - 2 * far * near / ( far - near );

    		te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
    		te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
    		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
    		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

    		return this;

    	},

    	makePerspective: function ( fov, aspect, near, far ) {

    		var ymax = near * Math.tan( exports.Math.DEG2RAD * fov * 0.5 );
    		var ymin = - ymax;
    		var xmin = ymin * aspect;
    		var xmax = ymax * aspect;

    		return this.makeFrustum( xmin, xmax, ymin, ymax, near, far );

    	},

    	makeOrthographic: function ( left, right, top, bottom, near, far ) {

    		var te = this.elements;
    		var w = 1.0 / ( right - left );
    		var h = 1.0 / ( top - bottom );
    		var p = 1.0 / ( far - near );

    		var x = ( right + left ) * w;
    		var y = ( top + bottom ) * h;
    		var z = ( far + near ) * p;

    		te[ 0 ] = 2 * w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
    		te[ 1 ] = 0;	te[ 5 ] = 2 * h;	te[ 9 ] = 0;	te[ 13 ] = - y;
    		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 * p;	te[ 14 ] = - z;
    		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;

    		return this;

    	},

    	equals: function ( matrix ) {

    		var te = this.elements;
    		var me = matrix.elements;

    		for ( var i = 0; i < 16; i ++ ) {

    			if ( te[ i ] !== me[ i ] ) return false;

    		}

    		return true;

    	},

    	fromArray: function ( array, offset ) {

    		if ( offset === undefined ) offset = 0;

    		for( var i = 0; i < 16; i ++ ) {

    			this.elements[ i ] = array[ i + offset ];

    		}

    		return this;

    	},

    	toArray: function ( array, offset ) {

    		if ( array === undefined ) array = [];
    		if ( offset === undefined ) offset = 0;

    		var te = this.elements;

    		array[ offset ] = te[ 0 ];
    		array[ offset + 1 ] = te[ 1 ];
    		array[ offset + 2 ] = te[ 2 ];
    		array[ offset + 3 ] = te[ 3 ];

    		array[ offset + 4 ] = te[ 4 ];
    		array[ offset + 5 ] = te[ 5 ];
    		array[ offset + 6 ] = te[ 6 ];
    		array[ offset + 7 ] = te[ 7 ];

    		array[ offset + 8 ]  = te[ 8 ];
    		array[ offset + 9 ]  = te[ 9 ];
    		array[ offset + 10 ] = te[ 10 ];
    		array[ offset + 11 ] = te[ 11 ];

    		array[ offset + 12 ] = te[ 12 ];
    		array[ offset + 13 ] = te[ 13 ];
    		array[ offset + 14 ] = te[ 14 ];
    		array[ offset + 15 ] = te[ 15 ];

    		return array;

    	}

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function CubeTexture( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {

    	images = images !== undefined ? images : [];
    	mapping = mapping !== undefined ? mapping : CubeReflectionMapping;

    	Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

    	this.flipY = false;

    }

    CubeTexture.prototype = Object.create( Texture.prototype );
    CubeTexture.prototype.constructor = CubeTexture;

    CubeTexture.prototype.isCubeTexture = true;

    Object.defineProperty( CubeTexture.prototype, 'images', {

    	get: function () {

    		return this.image;

    	},

    	set: function ( value ) {

    		this.image = value;

    	}

    } );

    var emptyTexture = new Texture();
    var emptyCubeTexture = new CubeTexture();

    // --- Base for inner nodes (including the root) ---

    function UniformContainer() {

    	this.seq = [];
    	this.map = {};

    }

    // --- Utilities ---

    // Array Caches (provide typed arrays for temporary by size)

    var arrayCacheF32 = [];
    var arrayCacheI32 = [];

    // Flattening for arrays of vectors and matrices

    function flatten( array, nBlocks, blockSize ) {

    	var firstElem = array[ 0 ];

    	if ( firstElem <= 0 || firstElem > 0 ) return array;
    	// unoptimized: ! isNaN( firstElem )
    	// see http://jacksondunstan.com/articles/983

    	var n = nBlocks * blockSize,
    		r = arrayCacheF32[ n ];

    	if ( r === undefined ) {

    		r = new Float32Array( n );
    		arrayCacheF32[ n ] = r;

    	}

    	if ( nBlocks !== 0 ) {

    		firstElem.toArray( r, 0 );

    		for ( var i = 1, offset = 0; i !== nBlocks; ++ i ) {

    			offset += blockSize;
    			array[ i ].toArray( r, offset );

    		}

    	}

    	return r;

    }

    // Texture unit allocation

    function allocTexUnits( renderer, n ) {

    	var r = arrayCacheI32[ n ];

    	if ( r === undefined ) {

    		r = new Int32Array( n );
    		arrayCacheI32[ n ] = r;

    	}

    	for ( var i = 0; i !== n; ++ i )
    		r[ i ] = renderer.allocTextureUnit();

    	return r;

    }

    // --- Setters ---

    // Note: Defining these methods externally, because they come in a bunch
    // and this way their names minify.

    // Single scalar

    function setValue1f( gl, v ) { gl.uniform1f( this.addr, v ); }
    function setValue1i( gl, v ) { gl.uniform1i( this.addr, v ); }

    // Single float vector (from flat array or THREE.VectorN)

    function setValue2fv( gl, v ) {

    	if ( v.x === undefined ) gl.uniform2fv( this.addr, v );
    	else gl.uniform2f( this.addr, v.x, v.y );

    }

    function setValue3fv( gl, v ) {

    	if ( v.x !== undefined )
    		gl.uniform3f( this.addr, v.x, v.y, v.z );
    	else if ( v.r !== undefined )
    		gl.uniform3f( this.addr, v.r, v.g, v.b );
    	else
    		gl.uniform3fv( this.addr, v );

    }

    function setValue4fv( gl, v ) {

    	if ( v.x === undefined ) gl.uniform4fv( this.addr, v );
    	else gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );

    }

    // Single matrix (from flat array or MatrixN)

    function setValue2fm( gl, v ) {

    	gl.uniformMatrix2fv( this.addr, false, v.elements || v );

    }

    function setValue3fm( gl, v ) {

    	gl.uniformMatrix3fv( this.addr, false, v.elements || v );

    }

    function setValue4fm( gl, v ) {

    	gl.uniformMatrix4fv( this.addr, false, v.elements || v );

    }

    // Single texture (2D / Cube)

    function setValueT1( gl, v, renderer ) {

    	var unit = renderer.allocTextureUnit();
    	gl.uniform1i( this.addr, unit );
    	renderer.setTexture2D( v || emptyTexture, unit );

    }

    function setValueT6( gl, v, renderer ) {

    	var unit = renderer.allocTextureUnit();
    	gl.uniform1i( this.addr, unit );
    	renderer.setTextureCube( v || emptyCubeTexture, unit );

    }

    // Integer / Boolean vectors or arrays thereof (always flat arrays)

    function setValue2iv( gl, v ) { gl.uniform2iv( this.addr, v ); }
    function setValue3iv( gl, v ) { gl.uniform3iv( this.addr, v ); }
    function setValue4iv( gl, v ) { gl.uniform4iv( this.addr, v ); }

    // Helper to pick the right setter for the singular case

    function getSingularSetter( type ) {

    	switch ( type ) {

    		case 0x1406: return setValue1f; // FLOAT
    		case 0x8b50: return setValue2fv; // _VEC2
    		case 0x8b51: return setValue3fv; // _VEC3
    		case 0x8b52: return setValue4fv; // _VEC4

    		case 0x8b5a: return setValue2fm; // _MAT2
    		case 0x8b5b: return setValue3fm; // _MAT3
    		case 0x8b5c: return setValue4fm; // _MAT4

    		case 0x8b5e: return setValueT1; // SAMPLER_2D
    		case 0x8b60: return setValueT6; // SAMPLER_CUBE

    		case 0x1404: case 0x8b56: return setValue1i; // INT, BOOL
    		case 0x8b53: case 0x8b57: return setValue2iv; // _VEC2
    		case 0x8b54: case 0x8b58: return setValue3iv; // _VEC3
    		case 0x8b55: case 0x8b59: return setValue4iv; // _VEC4

    	}

    }

    // Array of scalars

    function setValue1fv( gl, v ) { gl.uniform1fv( this.addr, v ); }
    function setValue1iv( gl, v ) { gl.uniform1iv( this.addr, v ); }

    // Array of vectors (flat or from THREE classes)

    function setValueV2a( gl, v ) {

    	gl.uniform2fv( this.addr, flatten( v, this.size, 2 ) );

    }

    function setValueV3a( gl, v ) {

    	gl.uniform3fv( this.addr, flatten( v, this.size, 3 ) );

    }

    function setValueV4a( gl, v ) {

    	gl.uniform4fv( this.addr, flatten( v, this.size, 4 ) );

    }

    // Array of matrices (flat or from THREE clases)

    function setValueM2a( gl, v ) {

    	gl.uniformMatrix2fv( this.addr, false, flatten( v, this.size, 4 ) );

    }

    function setValueM3a( gl, v ) {

    	gl.uniformMatrix3fv( this.addr, false, flatten( v, this.size, 9 ) );

    }

    function setValueM4a( gl, v ) {

    	gl.uniformMatrix4fv( this.addr, false, flatten( v, this.size, 16 ) );

    }

    // Array of textures (2D / Cube)

    function setValueT1a( gl, v, renderer ) {

    	var n = v.length,
    		units = allocTexUnits( renderer, n );

    	gl.uniform1iv( this.addr, units );

    	for ( var i = 0; i !== n; ++ i ) {

    		renderer.setTexture2D( v[ i ] || emptyTexture, units[ i ] );

    	}

    }

    function setValueT6a( gl, v, renderer ) {

    	var n = v.length,
    		units = allocTexUnits( renderer, n );

    	gl.uniform1iv( this.addr, units );

    	for ( var i = 0; i !== n; ++ i ) {

    		renderer.setTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );

    	}

    }

    // Helper to pick the right setter for a pure (bottom-level) array

    function getPureArraySetter( type ) {

    	switch ( type ) {

    		case 0x1406: return setValue1fv; // FLOAT
    		case 0x8b50: return setValueV2a; // _VEC2
    		case 0x8b51: return setValueV3a; // _VEC3
    		case 0x8b52: return setValueV4a; // _VEC4

    		case 0x8b5a: return setValueM2a; // _MAT2
    		case 0x8b5b: return setValueM3a; // _MAT3
    		case 0x8b5c: return setValueM4a; // _MAT4

    		case 0x8b5e: return setValueT1a; // SAMPLER_2D
    		case 0x8b60: return setValueT6a; // SAMPLER_CUBE

    		case 0x1404: case 0x8b56: return setValue1iv; // INT, BOOL
    		case 0x8b53: case 0x8b57: return setValue2iv; // _VEC2
    		case 0x8b54: case 0x8b58: return setValue3iv; // _VEC3
    		case 0x8b55: case 0x8b59: return setValue4iv; // _VEC4

    	}

    }

    // --- Uniform Classes ---

    function SingleUniform( id, activeInfo, addr ) {

    	this.id = id;
    	this.addr = addr;
    	this.setValue = getSingularSetter( activeInfo.type );

    	// this.path = activeInfo.name; // DEBUG

    }

    function PureArrayUniform( id, activeInfo, addr ) {

    	this.id = id;
    	this.addr = addr;
    	this.size = activeInfo.size;
    	this.setValue = getPureArraySetter( activeInfo.type );

    	// this.path = activeInfo.name; // DEBUG

    }

    function StructuredUniform( id ) {

    	this.id = id;

    	UniformContainer.call( this ); // mix-in

    }

    StructuredUniform.prototype.setValue = function( gl, value ) {

    	// Note: Don't need an extra 'renderer' parameter, since samplers
    	// are not allowed in structured uniforms.

    	var seq = this.seq;

    	for ( var i = 0, n = seq.length; i !== n; ++ i ) {

    		var u = seq[ i ];
    		u.setValue( gl, value[ u.id ] );

    	}

    };

    // --- Top-level ---

    // Parser - builds up the property tree from the path strings

    var RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g;

    // extracts
    // 	- the identifier (member name or array index)
    //  - followed by an optional right bracket (found when array index)
    //  - followed by an optional left bracket or dot (type of subscript)
    //
    // Note: These portions can be read in a non-overlapping fashion and
    // allow straightforward parsing of the hierarchy that WebGL encodes
    // in the uniform names.

    function addUniform( container, uniformObject ) {

    	container.seq.push( uniformObject );
    	container.map[ uniformObject.id ] = uniformObject;

    }

    function parseUniform( activeInfo, addr, container ) {

    	var path = activeInfo.name,
    		pathLength = path.length;

    	// reset RegExp object, because of the early exit of a previous run
    	RePathPart.lastIndex = 0;

    	for (; ;) {

    		var match = RePathPart.exec( path ),
    			matchEnd = RePathPart.lastIndex,

    			id = match[ 1 ],
    			idIsIndex = match[ 2 ] === ']',
    			subscript = match[ 3 ];

    		if ( idIsIndex ) id = id | 0; // convert to integer

    		if ( subscript === undefined ||
    				subscript === '[' && matchEnd + 2 === pathLength ) {
    			// bare name or "pure" bottom-level array "[0]" suffix

    			addUniform( container, subscript === undefined ?
    					new SingleUniform( id, activeInfo, addr ) :
    					new PureArrayUniform( id, activeInfo, addr ) );

    			break;

    		} else {
    			// step into inner node / create it in case it doesn't exist

    			var map = container.map,
    				next = map[ id ];

    			if ( next === undefined ) {

    				next = new StructuredUniform( id );
    				addUniform( container, next );

    			}

    			container = next;

    		}

    	}

    }

    // Root Container

    function WebGLUniforms( gl, program, renderer ) {

    	UniformContainer.call( this );

    	this.renderer = renderer;

    	var n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );

    	for ( var i = 0; i !== n; ++ i ) {

    		var info = gl.getActiveUniform( program, i ),
    			path = info.name,
    			addr = gl.getUniformLocation( program, path );

    		parseUniform( info, addr, this );

    	}

    }

    WebGLUniforms.prototype.setValue = function( gl, name, value ) {

    	var u = this.map[ name ];

    	if ( u !== undefined ) u.setValue( gl, value, this.renderer );

    };

    WebGLUniforms.prototype.set = function( gl, object, name ) {

    	var u = this.map[ name ];

    	if ( u !== undefined ) u.setValue( gl, object[ name ], this.renderer );

    };

    WebGLUniforms.prototype.setOptional = function( gl, object, name ) {

    	var v = object[ name ];

    	if ( v !== undefined ) this.setValue( gl, name, v );

    };


    // Static interface

    WebGLUniforms.upload = function( gl, seq, values, renderer ) {

    	for ( var i = 0, n = seq.length; i !== n; ++ i ) {

    		var u = seq[ i ],
    			v = values[ u.id ];

    		if ( v.needsUpdate !== false ) {
    			// note: always updating when .needsUpdate is undefined

    			u.setValue( gl, v.value, renderer );

    		}

    	}

    };

    WebGLUniforms.seqWithValue = function( seq, values ) {

    	var r = [];

    	for ( var i = 0, n = seq.length; i !== n; ++ i ) {

    		var u = seq[ i ];
    		if ( u.id in values ) r.push( u );

    	}

    	return r;

    };

    WebGLUniforms.splitDynamic = function( seq, values ) {

    	var r = null,
    		n = seq.length,
    		w = 0;

    	for ( var i = 0; i !== n; ++ i ) {

    		var u = seq[ i ],
    			v = values[ u.id ];

    		if ( v && v.dynamic === true ) {

    			if ( r === null ) r = [];
    			r.push( u );

    		} else {

    			// in-place compact 'seq', removing the matches
    			if ( w < i ) seq[ w ] = u;
    			++ w;

    		}

    	}

    	if ( w < n ) seq.length = w;

    	return r;

    };

    WebGLUniforms.evalDynamic = function( seq, values, object, material, camera ) {

    	for ( var i = 0, n = seq.length; i !== n; ++ i ) {

    		var v = values[ seq[ i ].id ],
    			f = v.onUpdateCallback;

    		if ( f !== undefined ) f.call( v, object, material, camera );

    	}

    };

    /**
     * Uniform Utilities
     */

    exports.UniformsUtils = {

    	merge: function ( uniforms ) {

    		var merged = {};

    		for ( var u = 0; u < uniforms.length; u ++ ) {

    			var tmp = this.clone( uniforms[ u ] );

    			for ( var p in tmp ) {

    				merged[ p ] = tmp[ p ];

    			}

    		}

    		return merged;

    	},

    	clone: function ( uniforms_src ) {

    		var uniforms_dst = {};

    		for ( var u in uniforms_src ) {

    			uniforms_dst[ u ] = {};

    			for ( var p in uniforms_src[ u ] ) {

    				var parameter_src = uniforms_src[ u ][ p ];

    				if ( (parameter_src && parameter_src.isColor) ||
    					 (parameter_src && parameter_src.isVector2) ||
    					 (parameter_src && parameter_src.isVector3) ||
    					 (parameter_src && parameter_src.isVector4) ||
    					 (parameter_src && parameter_src.isMatrix3) ||
    					 (parameter_src && parameter_src.isMatrix4) ||
    					 (parameter_src && parameter_src.isTexture) ) {

    					uniforms_dst[ u ][ p ] = parameter_src.clone();

    				} else if ( Array.isArray( parameter_src ) ) {

    					uniforms_dst[ u ][ p ] = parameter_src.slice();

    				} else {

    					uniforms_dst[ u ][ p ] = parameter_src;

    				}

    			}

    		}

    		return uniforms_dst;

    	}

    };

    var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n";

    var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n";

    var alphatest_fragment = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n";

    var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n";

    var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";

    var begin_vertex = "\nvec3 transformed = vec3( position );\n";

    var beginnormal_vertex = "\nvec3 objectNormal = vec3( normal );\n";

    var bsdfs = "bool testLightInRange( const in float lightDistance, const in float cutoffDistance ) {\n\treturn any( bvec2( cutoffDistance == 0.0, lightDistance < cutoffDistance ) );\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t\t}\n\t\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n";

    var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos );\n\t\tvec3 vSigmaY = dFdy( surf_pos );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n";

    var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tfor ( int i = 0; i < NUM_CLIPPING_PLANES; ++ i ) {\n\t\tvec4 plane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n#endif\n";

    var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n";

    var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n";

    var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n";

    var color_fragment = "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif";

    var color_pars_fragment = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n";

    var color_pars_vertex = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";

    var color_vertex = "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif";

    var common = "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\n";

    var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n";

    var defaultnormal_vertex = "#ifdef FLIP_SIDED\n\tobjectNormal = -objectNormal;\n#endif\nvec3 transformedNormal = normalMatrix * objectNormal;\n";

    var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n";

    var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n";

    var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n";

    var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n";

    var encodings_fragment = "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n";

    var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n  return value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n  return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n  return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n  float maxComponent = max( max( value.r, value.g ), value.b );\n  float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n  return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n  return vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n  float maxRGB = max( value.x, max( value.g, value.b ) );\n  float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n  M            = ceil( M * 255.0 ) / 255.0;\n  return vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n    return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n    float maxRGB = max( value.x, max( value.g, value.b ) );\n    float D      = max( maxRange / maxRGB, 1.0 );\n    D            = min( floor( D ) / 255.0, 1.0 );\n    return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n  vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n  Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n  vec4 vResult;\n  vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n  float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n  vResult.w = fract(Le);\n  vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n  return vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n  float Le = value.z * 255.0 + value.w;\n  vec3 Xp_Y_XYZp;\n  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n  Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n  Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n  vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n  return vec4( max(vRGB, 0.0), 1.0 );\n}\n";

    var envmap_fragment = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n";

    var envmap_pars_fragment = "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntenstiy;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n";

    var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n";

    var envmap_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n";

    var fog_fragment = "#ifdef USE_FOG\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\n\t#else\n\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n\t#endif\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, depth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n";

    var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";

    var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n";

    var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";

    var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n";

    var lights_pars = "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tif ( testLightInRange( lightDistance, pointLight.distance ) ) {\n\t\t\tdirectLight.color = pointLight.color;\n\t\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( all( bvec2( angleCos > spotLight.coneCos, testLightInRange( lightDistance, spotLight.distance ) ) ) ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\t#include <normal_flip>\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\t#include <normal_flip>\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n\t\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n";

    var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n";

    var lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n";

    var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n";

    var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n";

    var lights_template = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t \tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\n\t#endif\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n\t#ifndef STANDARD\n\t\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\n\t#else\n\t\tvec3 clearCoatRadiance = vec3( 0.0 );\n\t#endif\n\t\t\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n";

    var logdepthbuf_fragment = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n#endif";

    var logdepthbuf_pars_fragment = "#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n";

    var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif";

    var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\t#endif\n#endif\n";

    var map_fragment = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n";

    var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n";

    var map_particle_fragment = "#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n";

    var map_particle_pars_fragment = "#ifdef USE_MAP\n\tuniform vec4 offsetRepeat;\n\tuniform sampler2D map;\n#endif\n";

    var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.r;\n#endif\n";

    var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";

    var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n";

    var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif";

    var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n";

    var normal_flip = "#ifdef DOUBLE_SIDED\n\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n#else\n\tfloat flipNormal = 1.0;\n#endif\n";

    var normal_fragment = "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal ) * flipNormal;\n#endif\n#ifdef USE_NORMALMAP\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n";

    var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif\n";

    var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n  return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n  return 1.0 - 2.0 * rgb.xyz;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n  return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n  return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n  return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n  return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n";

    var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n";

    var project_vertex = "#ifdef USE_SKINNING\n\tvec4 mvPosition = modelViewMatrix * skinned;\n#else\n\tvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n#endif\ngl_Position = projectionMatrix * mvPosition;\n";

    var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.r;\n#endif\n";

    var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";

    var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn 1.0;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\tfloat dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n";

    var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n";

    var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n";

    var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n";

    var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";

    var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureWidth;\n\t\tuniform int boneTextureHeight;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureWidth ) );\n\t\t\tfloat y = floor( j / float( boneTextureWidth ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureWidth );\n\t\t\tfloat dy = 1.0 / float( boneTextureHeight );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n";

    var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\tskinned  = bindMatrixInverse * skinned;\n#endif\n";

    var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n";

    var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";

    var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";

    var tonemapping_fragment = "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n";

    var tonemapping_pars_fragment = "#define saturate(a) clamp( a, 0.0, 1.0 )\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n  return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  return saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  color = max( vec3( 0.0 ), color - 0.004 );\n  return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n";

    var uv_pars_fragment = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif";

    var uv_pars_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform vec4 offsetRepeat;\n#endif\n";

    var uv_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n#endif";

    var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";

    var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif";

    var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif";

    var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\t#ifdef USE_SKINNING\n\t\tvec4 worldPosition = modelMatrix * skinned;\n\t#else\n\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\t#endif\n#endif\n";

    var cube_frag = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n";

    var cube_vert = "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n";

    var depth_frag = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n";

    var depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n";

    var distanceRGBA_frag = "uniform vec3 lightPos;\nvarying vec4 vWorldPosition;\n#include <common>\n#include <packing>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tgl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );\n}\n";

    var distanceRGBA_vert = "varying vec4 vWorldPosition;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition;\n}\n";

    var equirect_frag = "uniform sampler2D tEquirect;\nuniform float tFlip;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n";

    var equirect_vert = "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n";

    var linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";

    var linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n";

    var meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight;\n\treflectedLight.directDiffuse = vec3( 0.0 );\n\treflectedLight.directSpecular = vec3( 0.0 );\n\treflectedLight.indirectDiffuse = diffuseColor.rgb;\n\treflectedLight.indirectSpecular = vec3( 0.0 );\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";

    var meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n}\n";

    var meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";

    var meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n}\n";

    var meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";

    var meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n}\n";

    var meshphysical_frag = "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nuniform float envMapIntensity;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";

    var meshphysical_vert = "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n";

    var normal_frag = "uniform float opacity;\nvarying vec3 vNormal;\n#include <common>\n#include <packing>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tgl_FragColor = vec4( packNormalToRGB( vNormal ), opacity );\n\t#include <logdepthbuf_fragment>\n}\n";

    var normal_vert = "varying vec3 vNormal;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvNormal = normalize( normalMatrix * normal );\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n";

    var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";

    var points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n";

    var shadow_frag = "uniform float opacity;\n#include <common>\n#include <packing>\n#include <bsdfs>\n#include <lights_pars>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( 0.0, 0.0, 0.0, opacity * ( 1.0  - getShadowMask() ) );\n}\n";

    var shadow_vert = "#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n";

    var ShaderChunk = {
    	alphamap_fragment: alphamap_fragment,
    	alphamap_pars_fragment: alphamap_pars_fragment,
    	alphatest_fragment: alphatest_fragment,
    	aomap_fragment: aomap_fragment,
    	aomap_pars_fragment: aomap_pars_fragment,
    	begin_vertex: begin_vertex,
    	beginnormal_vertex: beginnormal_vertex,
    	bsdfs: bsdfs,
    	bumpmap_pars_fragment: bumpmap_pars_fragment,
    	clipping_planes_fragment: clipping_planes_fragment,
    	clipping_planes_pars_fragment: clipping_planes_pars_fragment,
    	clipping_planes_pars_vertex: clipping_planes_pars_vertex,
    	clipping_planes_vertex: clipping_planes_vertex,
    	color_fragment: color_fragment,
    	color_pars_fragment: color_pars_fragment,
    	color_pars_vertex: color_pars_vertex,
    	color_vertex: color_vertex,
    	common: common,
    	cube_uv_reflection_fragment: cube_uv_reflection_fragment,
    	defaultnormal_vertex: defaultnormal_vertex,
    	displacementmap_pars_vertex: displacementmap_pars_vertex,
    	displacementmap_vertex: displacementmap_vertex,
    	emissivemap_fragment: emissivemap_fragment,
    	emissivemap_pars_fragment: emissivemap_pars_fragment,
    	encodings_fragment: encodings_fragment,
    	encodings_pars_fragment: encodings_pars_fragment,
    	envmap_fragment: envmap_fragment,
    	envmap_pars_fragment: envmap_pars_fragment,
    	envmap_pars_vertex: envmap_pars_vertex,
    	envmap_vertex: envmap_vertex,
    	fog_fragment: fog_fragment,
    	fog_pars_fragment: fog_pars_fragment,
    	lightmap_fragment: lightmap_fragment,
    	lightmap_pars_fragment: lightmap_pars_fragment,
    	lights_lambert_vertex: lights_lambert_vertex,
    	lights_pars: lights_pars,
    	lights_phong_fragment: lights_phong_fragment,
    	lights_phong_pars_fragment: lights_phong_pars_fragment,
    	lights_physical_fragment: lights_physical_fragment,
    	lights_physical_pars_fragment: lights_physical_pars_fragment,
    	lights_template: lights_template,
    	logdepthbuf_fragment: logdepthbuf_fragment,
    	logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
    	logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
    	logdepthbuf_vertex: logdepthbuf_vertex,
    	map_fragment: map_fragment,
    	map_pars_fragment: map_pars_fragment,
    	map_particle_fragment: map_particle_fragment,
    	map_particle_pars_fragment: map_particle_pars_fragment,
    	metalnessmap_fragment: metalnessmap_fragment,
    	metalnessmap_pars_fragment: metalnessmap_pars_fragment,
    	morphnormal_vertex: morphnormal_vertex,
    	morphtarget_pars_vertex: morphtarget_pars_vertex,
    	morphtarget_vertex: morphtarget_vertex,
    	normal_flip: normal_flip,
    	normal_fragment: normal_fragment,
    	normalmap_pars_fragment: normalmap_pars_fragment,
    	packing: packing,
    	premultiplied_alpha_fragment: premultiplied_alpha_fragment,
    	project_vertex: project_vertex,
    	roughnessmap_fragment: roughnessmap_fragment,
    	roughnessmap_pars_fragment: roughnessmap_pars_fragment,
    	shadowmap_pars_fragment: shadowmap_pars_fragment,
    	shadowmap_pars_vertex: shadowmap_pars_vertex,
    	shadowmap_vertex: shadowmap_vertex,
    	shadowmask_pars_fragment: shadowmask_pars_fragment,
    	skinbase_vertex: skinbase_vertex,
    	skinning_pars_vertex: skinning_pars_vertex,
    	skinning_vertex: skinning_vertex,
    	skinnormal_vertex: skinnormal_vertex,
    	specularmap_fragment: specularmap_fragment,
    	specularmap_pars_fragment: specularmap_pars_fragment,
    	tonemapping_fragment: tonemapping_fragment,
    	tonemapping_pars_fragment: tonemapping_pars_fragment,
    	uv_pars_fragment: uv_pars_fragment,
    	uv_pars_vertex: uv_pars_vertex,
    	uv_vertex: uv_vertex,
    	uv2_pars_fragment: uv2_pars_fragment,
    	uv2_pars_vertex: uv2_pars_vertex,
    	uv2_vertex: uv2_vertex,
    	worldpos_vertex: worldpos_vertex,

    	cube_frag: cube_frag,
    	cube_vert: cube_vert,
    	depth_frag: depth_frag,
    	depth_vert: depth_vert,
    	distanceRGBA_frag: distanceRGBA_frag,
    	distanceRGBA_vert: distanceRGBA_vert,
    	equirect_frag: equirect_frag,
    	equirect_vert: equirect_vert,
    	linedashed_frag: linedashed_frag,
    	linedashed_vert: linedashed_vert,
    	meshbasic_frag: meshbasic_frag,
    	meshbasic_vert: meshbasic_vert,
    	meshlambert_frag: meshlambert_frag,
    	meshlambert_vert: meshlambert_vert,
    	meshphong_frag: meshphong_frag,
    	meshphong_vert: meshphong_vert,
    	meshphysical_frag: meshphysical_frag,
    	meshphysical_vert: meshphysical_vert,
    	normal_frag: normal_frag,
    	normal_vert: normal_vert,
    	points_frag: points_frag,
    	points_vert: points_vert,
    	shadow_frag: shadow_frag,
    	shadow_vert: shadow_vert
    };

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function Color( r, g, b ) {

    	if ( g === undefined && b === undefined ) {

    		// r is THREE.Color, hex or string
    		return this.set( r );

    	}

    	return this.setRGB( r, g, b );

    }

    Color.prototype = {

    	constructor: Color,

    	isColor: true,

    	r: 1, g: 1, b: 1,

    	set: function ( value ) {

    		if ( (value && value.isColor) ) {

    			this.copy( value );

    		} else if ( typeof value === 'number' ) {

    			this.setHex( value );

    		} else if ( typeof value === 'string' ) {

    			this.setStyle( value );

    		}

    		return this;

    	},

    	setScalar: function ( scalar ) {

    		this.r = scalar;
    		this.g = scalar;
    		this.b = scalar;

    	},

    	setHex: function ( hex ) {

    		hex = Math.floor( hex );

    		this.r = ( hex >> 16 & 255 ) / 255;
    		this.g = ( hex >> 8 & 255 ) / 255;
    		this.b = ( hex & 255 ) / 255;

    		return this;

    	},

    	setRGB: function ( r, g, b ) {

    		this.r = r;
    		this.g = g;
    		this.b = b;

    		return this;

    	},

    	setHSL: function () {

    		function hue2rgb( p, q, t ) {

    			if ( t < 0 ) t += 1;
    			if ( t > 1 ) t -= 1;
    			if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
    			if ( t < 1 / 2 ) return q;
    			if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
    			return p;

    		}

    		return function setHSL( h, s, l ) {

    			// h,s,l ranges are in 0.0 - 1.0
    			h = exports.Math.euclideanModulo( h, 1 );
    			s = exports.Math.clamp( s, 0, 1 );
    			l = exports.Math.clamp( l, 0, 1 );

    			if ( s === 0 ) {

    				this.r = this.g = this.b = l;

    			} else {

    				var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
    				var q = ( 2 * l ) - p;

    				this.r = hue2rgb( q, p, h + 1 / 3 );
    				this.g = hue2rgb( q, p, h );
    				this.b = hue2rgb( q, p, h - 1 / 3 );

    			}

    			return this;

    		};

    	}(),

    	setStyle: function ( style ) {

    		function handleAlpha( string ) {

    			if ( string === undefined ) return;

    			if ( parseFloat( string ) < 1 ) {

    				console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );

    			}

    		}


    		var m;

    		if ( m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec( style ) ) {

    			// rgb / hsl

    			var color;
    			var name = m[ 1 ];
    			var components = m[ 2 ];

    			switch ( name ) {

    				case 'rgb':
    				case 'rgba':

    					if ( color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

    						// rgb(255,0,0) rgba(255,0,0,0.5)
    						this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
    						this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
    						this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

    						handleAlpha( color[ 5 ] );

    						return this;

    					}

    					if ( color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

    						// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
    						this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
    						this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
    						this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

    						handleAlpha( color[ 5 ] );

    						return this;

    					}

    					break;

    				case 'hsl':
    				case 'hsla':

    					if ( color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

    						// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
    						var h = parseFloat( color[ 1 ] ) / 360;
    						var s = parseInt( color[ 2 ], 10 ) / 100;
    						var l = parseInt( color[ 3 ], 10 ) / 100;

    						handleAlpha( color[ 5 ] );

    						return this.setHSL( h, s, l );

    					}

    					break;

    			}

    		} else if ( m = /^\#([A-Fa-f0-9]+)$/.exec( style ) ) {

    			// hex color

    			var hex = m[ 1 ];
    			var size = hex.length;

    			if ( size === 3 ) {

    				// #ff0
    				this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;
    				this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;
    				this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;

    				return this;

    			} else if ( size === 6 ) {

    				// #ff0000
    				this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;
    				this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;
    				this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;

    				return this;

    			}

    		}

    		if ( style && style.length > 0 ) {

    			// color keywords
    			var hex = exports.ColorKeywords[ style ];

    			if ( hex !== undefined ) {

    				// red
    				this.setHex( hex );

    			} else {

    				// unknown color
    				console.warn( 'THREE.Color: Unknown color ' + style );

    			}

    		}

    		return this;

    	},

    	clone: function () {

    		return new this.constructor( this.r, this.g, this.b );

    	},

    	copy: function ( color ) {

    		this.r = color.r;
    		this.g = color.g;
    		this.b = color.b;

    		return this;

    	},

    	copyGammaToLinear: function ( color, gammaFactor ) {

    		if ( gammaFactor === undefined ) gammaFactor = 2.0;

    		this.r = Math.pow( color.r, gammaFactor );
    		this.g = Math.pow( color.g, gammaFactor );
    		this.b = Math.pow( color.b, gammaFactor );

    		return this;

    	},

    	copyLinearToGamma: function ( color, gammaFactor ) {

    		if ( gammaFactor === undefined ) gammaFactor = 2.0;

    		var safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;

    		this.r = Math.pow( color.r, safeInverse );
    		this.g = Math.pow( color.g, safeInverse );
    		this.b = Math.pow( color.b, safeInverse );

    		return this;

    	},

    	convertGammaToLinear: function () {

    		var r = this.r, g = this.g, b = this.b;

    		this.r = r * r;
    		this.g = g * g;
    		this.b = b * b;

    		return this;

    	},

    	convertLinearToGamma: function () {

    		this.r = Math.sqrt( this.r );
    		this.g = Math.sqrt( this.g );
    		this.b = Math.sqrt( this.b );

    		return this;

    	},

    	getHex: function () {

    		return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;

    	},

    	getHexString: function () {

    		return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );

    	},

    	getHSL: function ( optionalTarget ) {

    		// h,s,l ranges are in 0.0 - 1.0

    		var hsl = optionalTarget || { h: 0, s: 0, l: 0 };

    		var r = this.r, g = this.g, b = this.b;

    		var max = Math.max( r, g, b );
    		var min = Math.min( r, g, b );

    		var hue, saturation;
    		var lightness = ( min + max ) / 2.0;

    		if ( min === max ) {

    			hue = 0;
    			saturation = 0;

    		} else {

    			var delta = max - min;

    			saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

    			switch ( max ) {

    				case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
    				case g: hue = ( b - r ) / delta + 2; break;
    				case b: hue = ( r - g ) / delta + 4; break;

    			}

    			hue /= 6;

    		}

    		hsl.h = hue;
    		hsl.s = saturation;
    		hsl.l = lightness;

    		return hsl;

    	},

    	getStyle: function () {

    		return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';

    	},

    	offsetHSL: function ( h, s, l ) {

    		var hsl = this.getHSL();

    		hsl.h += h; hsl.s += s; hsl.l += l;

    		this.setHSL( hsl.h, hsl.s, hsl.l );

    		return this;

    	},

    	add: function ( color ) {

    		this.r += color.r;
    		this.g += color.g;
    		this.b += color.b;

    		return this;

    	},

    	addColors: function ( color1, color2 ) {

    		this.r = color1.r + color2.r;
    		this.g = color1.g + color2.g;
    		this.b = color1.b + color2.b;

    		return this;

    	},

    	addScalar: function ( s ) {

    		this.r += s;
    		this.g += s;
    		this.b += s;

    		return this;

    	},

    	sub: function( color ) {

    		this.r = Math.max( 0, this.r - color.r );
    		this.g = Math.max( 0, this.g - color.g );
    		this.b = Math.max( 0, this.b - color.b );

    		return this;

    	},

    	multiply: function ( color ) {

    		this.r *= color.r;
    		this.g *= color.g;
    		this.b *= color.b;

    		return this;

    	},

    	multiplyScalar: function ( s ) {

    		this.r *= s;
    		this.g *= s;
    		this.b *= s;

    		return this;

    	},

    	lerp: function ( color, alpha ) {

    		this.r += ( color.r - this.r ) * alpha;
    		this.g += ( color.g - this.g ) * alpha;
    		this.b += ( color.b - this.b ) * alpha;

    		return this;

    	},

    	equals: function ( c ) {

    		return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

    	},

    	fromArray: function ( array, offset ) {

    		if ( offset === undefined ) offset = 0;

    		this.r = array[ offset ];
    		this.g = array[ offset + 1 ];
    		this.b = array[ offset + 2 ];

    		return this;

    	},

    	toArray: function ( array, offset ) {

    		if ( array === undefined ) array = [];
    		if ( offset === undefined ) offset = 0;

    		array[ offset ] = this.r;
    		array[ offset + 1 ] = this.g;
    		array[ offset + 2 ] = this.b;

    		return array;

    	},

    	toJSON: function () {

    		return this.getHex();

    	}

    };

    exports.ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
    'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
    'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
    'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
    'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
    'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
    'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
    'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
    'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
    'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
    'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
    'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
    'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
    'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
    'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
    'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
    'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
    'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
    'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
    'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
    'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
    'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
    'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
    'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

    /**
     * Uniforms library for shared webgl shaders
     */

    var UniformsLib = {

    	common: {

    		diffuse: { value: new Color( 0xeeeeee ) },
    		opacity: { value: 1.0 },

    		map: { value: null },
    		offsetRepeat: { value: new Vector4( 0, 0, 1, 1 ) },

    		specularMap: { value: null },
    		alphaMap: { value: null },

    		envMap: { value: null },
    		flipEnvMap: { value: - 1 },
    		reflectivity: { value: 1.0 },
    		refractionRatio: { value: 0.98 }

    	},

    	aomap: {

    		aoMap: { value: null },
    		aoMapIntensity: { value: 1 }

    	},

    	lightmap: {

    		lightMap: { value: null },
    		lightMapIntensity: { value: 1 }

    	},

    	emissivemap: {

    		emissiveMap: { value: null }

    	},

    	bumpmap: {

    		bumpMap: { value: null },
    		bumpScale: { value: 1 }

    	},

    	normalmap: {

    		normalMap: { value: null },
    		normalScale: { value: new Vector2( 1, 1 ) }

    	},

    	displacementmap: {

    		displacementMap: { value: null },
    		displacementScale: { value: 1 },
    		displacementBias: { value: 0 }

    	},

    	roughnessmap: {

    		roughnessMap: { value: null }

    	},

    	metalnessmap: {

    		metalnessMap: { value: null }

    	},

    	fog: {

    		fogDensity: { value: 0.00025 },
    		fogNear: { value: 1 },
    		fogFar: { value: 2000 },
    		fogColor: { value: new Color( 0xffffff ) }

    	},

    	lights: {

    		ambientLightColor: { value: [] },

    		directionalLights: { value: [], properties: {
    			direction: {},
    			color: {},

    			shadow: {},
    			shadowBias: {},
    			shadowRadius: {},
    			shadowMapSize: {}
    		} },

    		directionalShadowMap: { value: [] },
    		directionalShadowMatrix: { value: [] },

    		spotLights: { value: [], properties: {
    			color: {},
    			position: {},
    			direction: {},
    			distance: {},
    			coneCos: {},
    			penumbraCos: {},
    			decay: {},

    			shadow: {},
    			shadowBias: {},
    			shadowRadius: {},
    			shadowMapSize: {}
    		} },

    		spotShadowMap: { value: [] },
    		spotShadowMatrix: { value: [] },

    		pointLights: { value: [], properties: {
    			color: {},
    			position: {},
    			decay: {},
    			distance: {},

    			shadow: {},
    			shadowBias: {},
    			shadowRadius: {},
    			shadowMapSize: {}
    		} },

    		pointShadowMap: { value: [] },
    		pointShadowMatrix: { value: [] },

    		hemisphereLights: { value: [], properties: {
    			direction: {},
    			skyColor: {},
    			groundColor: {}
    		} }

    	},

    	points: {

    		diffuse: { value: new Color( 0xeeeeee ) },
    		opacity: { value: 1.0 },
    		size: { value: 1.0 },
    		scale: { value: 1.0 },
    		map: { value: null },
    		offsetRepeat: { value: new Vector4( 0, 0, 1, 1 ) }

    	}

    };

    /**
     * @author alteredq / http://alteredqualia.com/
     * @author mrdoob / http://mrdoob.com/
     * @author mikael emtinger / http://gomo.se/
     */

    var ShaderLib = {

    	basic: {

    		uniforms: exports.UniformsUtils.merge( [

    			UniformsLib.common,
    			UniformsLib.aomap,
    			UniformsLib.fog

    		] ),

    		vertexShader: ShaderChunk.meshbasic_vert,
    		fragmentShader: ShaderChunk.meshbasic_frag

    	},

    	lambert: {

    		uniforms: exports.UniformsUtils.merge( [

    			UniformsLib.common,
    			UniformsLib.aomap,
    			UniformsLib.lightmap,
    			UniformsLib.emissivemap,
    			UniformsLib.fog,
    			UniformsLib.lights,

    			{
    				emissive : { value: new Color( 0x000000 ) }
    			}

    		] ),

    		vertexShader: ShaderChunk.meshlambert_vert,
    		fragmentShader: ShaderChunk.meshlambert_frag

    	},

    	phong: {

    		uniforms: exports.UniformsUtils.merge( [

    			UniformsLib.common,
    			UniformsLib.aomap,
    			UniformsLib.lightmap,
    			UniformsLib.emissivemap,
    			UniformsLib.bumpmap,
    			UniformsLib.normalmap,
    			UniformsLib.displacementmap,
    			UniformsLib.fog,
    			UniformsLib.lights,

    			{
    				emissive : { value: new Color( 0x000000 ) },
    				specular : { value: new Color( 0x111111 ) },
    				shininess: { value: 30 }
    			}

    		] ),

    		vertexShader: ShaderChunk.meshphong_vert,
    		fragmentShader: ShaderChunk.meshphong_frag

    	},

    	standard: {

    		uniforms: exports.UniformsUtils.merge( [

    			UniformsLib.common,
    			UniformsLib.aomap,
    			UniformsLib.lightmap,
    			UniformsLib.emissivemap,
    			UniformsLib.bumpmap,
    			UniformsLib.normalmap,
    			UniformsLib.displacementmap,
    			UniformsLib.roughnessmap,
    			UniformsLib.metalnessmap,
    			UniformsLib.fog,
    			UniformsLib.lights,

    			{
    				emissive : { value: new Color( 0x000000 ) },
    				roughness: { value: 0.5 },
    				metalness: { value: 0 },
    				envMapIntensity : { value: 1 }, // temporary
    			}

    		] ),

    		vertexShader: ShaderChunk.meshphysical_vert,
    		fragmentShader: ShaderChunk.meshphysical_frag

    	},

    	points: {

    		uniforms: exports.UniformsUtils.merge( [

    			UniformsLib.points,
    			UniformsLib.fog

    		] ),

    		vertexShader: ShaderChunk.points_vert,
    		fragmentShader: ShaderChunk.points_frag

    	},

    	dashed: {

    		uniforms: exports.UniformsUtils.merge( [

    			UniformsLib.common,
    			UniformsLib.fog,

    			{
    				scale    : { value: 1 },
    				dashSize : { value: 1 },
    				totalSize: { value: 2 }
    			}

    		] ),

    		vertexShader: ShaderChunk.linedashed_vert,
    		fragmentShader: ShaderChunk.linedashed_frag

    	},

    	depth: {

    		uniforms: exports.UniformsUtils.merge( [

    			UniformsLib.common,
    			UniformsLib.displacementmap

    		] ),

    		vertexShader: ShaderChunk.depth_vert,
    		fragmentShader: ShaderChunk.depth_frag

    	},

    	normal: {

    		uniforms: {

    			opacity : { value: 1.0 }

    		},

    		vertexShader: ShaderChunk.normal_vert,
    		fragmentShader: ShaderChunk.normal_frag

    	},

    	/* -------------------------------------------------------------------------
    	//	Cube map shader
    	 ------------------------------------------------------------------------- */

    	cube: {

    		uniforms: {
    			tCube: { value: null },
    			tFlip: { value: - 1 },
    			opacity: { value: 1.0 }
    		},

    		vertexShader: ShaderChunk.cube_vert,
    		fragmentShader: ShaderChunk.cube_frag

    	},

    	/* -------------------------------------------------------------------------
    	//	Cube map shader
    	 ------------------------------------------------------------------------- */

    	equirect: {

    		uniforms: {
    			tEquirect: { value: null },
    			tFlip: { value: - 1 }
    		},

    		vertexShader: ShaderChunk.equirect_vert,
    		fragmentShader: ShaderChunk.equirect_frag

    	},

    	distanceRGBA: {

    		uniforms: {

    			lightPos: { value: new Vector3() }

    		},

    		vertexShader: ShaderChunk.distanceRGBA_vert,
    		fragmentShader: ShaderChunk.distanceRGBA_frag

    	}

    };

    ShaderLib.physical = {

    	uniforms: exports.UniformsUtils.merge( [

    		ShaderLib.standard.uniforms,

    		{
    			clearCoat: { value: 0 },
    			clearCoatRoughness: { value: 0 }
    		}

    	] ),

    	vertexShader: ShaderChunk.meshphysical_vert,
    	fragmentShader: ShaderChunk.meshphysical_frag

    };

    /**
     * @author bhouston / http://clara.io
     */

    function Box2( min, max ) {

    	this.min = ( min !== undefined ) ? min : new Vector2( + Infinity, + Infinity );
    	this.max = ( max !== undefined ) ? max : new Vector2( - Infinity, - Infinity );

    }

    Box2.prototype = {

    	constructor: Box2,

    	set: function ( min, max ) {

    		this.min.copy( min );
    		this.max.copy( max );

    		return this;

    	},

    	setFromPoints: function ( points ) {

    		this.makeEmpty();

    		for ( var i = 0, il = points.length; i < il; i ++ ) {

    			this.expandByPoint( points[ i ] );

    		}

    		return this;

    	},

    	setFromCenterAndSize: function () {

    		var v1 = new Vector2();

    		return function setFromCenterAndSize( center, size ) {

    			var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
    			this.min.copy( center ).sub( halfSize );
    			this.max.copy( center ).add( halfSize );

    			return this;

    		};

    	}(),

    	clone: function () {

    		return new this.constructor().copy( this );

    	},

    	copy: function ( box ) {

    		this.min.copy( box.min );
    		this.max.copy( box.max );

    		return this;

    	},

    	makeEmpty: function () {

    		this.min.x = this.min.y = + Infinity;
    		this.max.x = this.max.y = - Infinity;

    		return this;

    	},

    	isEmpty: function () {

    		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

    		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );

    	},

    	getCenter: function ( optionalTarget ) {

    		var result = optionalTarget || new Vector2();
    		return this.isEmpty() ? result.set( 0, 0 ) : result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

    	},

    	getSize: function ( optionalTarget ) {

    		var result = optionalTarget || new Vector2();
    		return this.isEmpty() ? result.set( 0, 0 ) : result.subVectors( this.max, this.min );

    	},

    	expandByPoint: function ( point ) {

    		this.min.min( point );
    		this.max.max( point );

    		return this;

    	},

    	expandByVector: function ( vector ) {

    		this.min.sub( vector );
    		this.max.add( vector );

    		return this;

    	},

    	expandByScalar: function ( scalar ) {

    		this.min.addScalar( - scalar );
    		this.max.addScalar( scalar );

    		return this;

    	},

    	containsPoint: function ( point ) {

    		if ( point.x < this.min.x || point.x > this.max.x ||
    		     point.y < this.min.y || point.y > this.max.y ) {

    			return false;

    		}

    		return true;

    	},

    	containsBox: function ( box ) {

    		if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
    		     ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {

    			return true;

    		}

    		return false;

    	},

    	getParameter: function ( point, optionalTarget ) {

    		// This can potentially have a divide by zero if the box
    		// has a size dimension of 0.

    		var result = optionalTarget || new Vector2();

    		return result.set(
    			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
    			( point.y - this.min.y ) / ( this.max.y - this.min.y )
    		);

    	},

    	intersectsBox: function ( box ) {

    		// using 6 splitting planes to rule out intersections.

    		if ( box.max.x < this.min.x || box.min.x > this.max.x ||
    		     box.max.y < this.min.y || box.min.y > this.max.y ) {

    			return false;

    		}

    		return true;

    	},

    	clampPoint: function ( point, optionalTarget ) {

    		var result = optionalTarget || new Vector2();
    		return result.copy( point ).clamp( this.min, this.max );

    	},

    	distanceToPoint: function () {

    		var v1 = new Vector2();

    		return function distanceToPoint( point ) {

    			var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
    			return clampedPoint.sub( point ).length();

    		};

    	}(),

    	intersect: function ( box ) {

    		this.min.max( box.min );
    		this.max.min( box.max );

    		return this;

    	},

    	union: function ( box ) {

    		this.min.min( box.min );
    		this.max.max( box.max );

    		return this;

    	},

    	translate: function ( offset ) {

    		this.min.add( offset );
    		this.max.add( offset );

    		return this;

    	},

    	equals: function ( box ) {

    		return box.min.equals( this.min ) && box.max.equals( this.max );

    	}

    };

    /**
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     */

    function LensFlarePlugin( renderer, flares ) {

    	var gl = renderer.context;
    	var state = renderer.state;

    	var vertexBuffer, elementBuffer;
    	var shader, program, attributes, uniforms;

    	var tempTexture, occlusionTexture;

    	function init() {

    		var vertices = new Float32Array( [
    			- 1, - 1,  0, 0,
    			 1, - 1,  1, 0,
    			 1,  1,  1, 1,
    			- 1,  1,  0, 1
    		] );

    		var faces = new Uint16Array( [
    			0, 1, 2,
    			0, 2, 3
    		] );

    		// buffers

    		vertexBuffer     = gl.createBuffer();
    		elementBuffer    = gl.createBuffer();

    		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
    		gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

    		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
    		gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

    		// textures

    		tempTexture      = gl.createTexture();
    		occlusionTexture = gl.createTexture();

    		state.bindTexture( gl.TEXTURE_2D, tempTexture );
    		gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );
    		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
    		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
    		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
    		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

    		state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
    		gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );
    		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
    		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
    		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
    		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

    		shader = {

    			vertexShader: [

    				"uniform lowp int renderType;",

    				"uniform vec3 screenPosition;",
    				"uniform vec2 scale;",
    				"uniform float rotation;",

    				"uniform sampler2D occlusionMap;",

    				"attribute vec2 position;",
    				"attribute vec2 uv;",

    				"varying vec2 vUV;",
    				"varying float vVisibility;",

    				"void main() {",

    					"vUV = uv;",

    					"vec2 pos = position;",

    					"if ( renderType == 2 ) {",

    						"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );",
    						"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );",
    						"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );",
    						"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );",
    						"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );",
    						"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );",
    						"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );",
    						"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );",
    						"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );",

    						"vVisibility =        visibility.r / 9.0;",
    						"vVisibility *= 1.0 - visibility.g / 9.0;",
    						"vVisibility *=       visibility.b / 9.0;",
    						"vVisibility *= 1.0 - visibility.a / 9.0;",

    						"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
    						"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",

    					"}",

    					"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",

    				"}"

    			].join( "\n" ),

    			fragmentShader: [

    				"uniform lowp int renderType;",

    				"uniform sampler2D map;",
    				"uniform float opacity;",
    				"uniform vec3 color;",

    				"varying vec2 vUV;",
    				"varying float vVisibility;",

    				"void main() {",

    					// pink square

    					"if ( renderType == 0 ) {",

    						"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );",

    					// restore

    					"} else if ( renderType == 1 ) {",

    						"gl_FragColor = texture2D( map, vUV );",

    					// flare

    					"} else {",

    						"vec4 texture = texture2D( map, vUV );",
    						"texture.a *= opacity * vVisibility;",
    						"gl_FragColor = texture;",
    						"gl_FragColor.rgb *= color;",

    					"}",

    				"}"

    			].join( "\n" )

    		};

    		program = createProgram( shader );

    		attributes = {
    			vertex: gl.getAttribLocation ( program, "position" ),
    			uv:     gl.getAttribLocation ( program, "uv" )
    		};

    		uniforms = {
    			renderType:     gl.getUniformLocation( program, "renderType" ),
    			map:            gl.getUniformLocation( program, "map" ),
    			occlusionMap:   gl.getUniformLocation( program, "occlusionMap" ),
    			opacity:        gl.getUniformLocation( program, "opacity" ),
    			color:          gl.getUniformLocation( program, "color" ),
    			scale:          gl.getUniformLocation( program, "scale" ),
    			rotation:       gl.getUniformLocation( program, "rotation" ),
    			screenPosition: gl.getUniformLocation( program, "screenPosition" )
    		};

    	}

    	/*
    	 * Render lens flares
    	 * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,
    	 *         reads these back and calculates occlusion.
    	 */

    	this.render = function ( scene, camera, viewport ) {

    		if ( flares.length === 0 ) return;

    		var tempPosition = new Vector3();

    		var invAspect = viewport.w / viewport.z,
    			halfViewportWidth = viewport.z * 0.5,
    			halfViewportHeight = viewport.w * 0.5;

    		var size = 16 / viewport.w,
    			scale = new Vector2( size * invAspect, size );

    		var screenPosition = new Vector3( 1, 1, 0 ),
    			screenPositionPixels = new Vector2( 1, 1 );

    		var validArea = new Box2();

    		validArea.min.set( 0, 0 );
    		validArea.max.set( viewport.z - 16, viewport.w - 16 );

    		if ( program === undefined ) {

    			init();

    		}

    		gl.useProgram( program );

    		state.initAttributes();
    		state.enableAttribute( attributes.vertex );
    		state.enableAttribute( attributes.uv );
    		state.disableUnusedAttributes();

    		// loop through all lens flares to update their occlusion and positions
    		// setup gl and common used attribs/uniforms

    		gl.uniform1i( uniforms.occlusionMap, 0 );
    		gl.uniform1i( uniforms.map, 1 );

    		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
    		gl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );
    		gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

    		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

    		state.disable( gl.CULL_FACE );
    		state.setDepthWrite( false );

    		for ( var i = 0, l = flares.length; i < l; i ++ ) {

    			size = 16 / viewport.w;
    			scale.set( size * invAspect, size );

    			// calc object screen position

    			var flare = flares[ i ];

    			tempPosition.set( flare.matrixWorld.elements[ 12 ], flare.matrixWorld.elements[ 13 ], flare.matrixWorld.elements[ 14 ] );

    			tempPosition.applyMatrix4( camera.matrixWorldInverse );
    			tempPosition.applyProjection( camera.projectionMatrix );

    			// setup arrays for gl programs

    			screenPosition.copy( tempPosition );

    			// horizontal and vertical coordinate of the lower left corner of the pixels to copy

    			screenPositionPixels.x = viewport.x + ( screenPosition.x * halfViewportWidth ) + halfViewportWidth - 8;
    			screenPositionPixels.y = viewport.y + ( screenPosition.y * halfViewportHeight ) + halfViewportHeight - 8;

    			// screen cull

    			if ( validArea.containsPoint( screenPositionPixels ) === true ) {

    				// save current RGB to temp texture

    				state.activeTexture( gl.TEXTURE0 );
    				state.bindTexture( gl.TEXTURE_2D, null );
    				state.activeTexture( gl.TEXTURE1 );
    				state.bindTexture( gl.TEXTURE_2D, tempTexture );
    				gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );


    				// render pink quad

    				gl.uniform1i( uniforms.renderType, 0 );
    				gl.uniform2f( uniforms.scale, scale.x, scale.y );
    				gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );

    				state.disable( gl.BLEND );
    				state.enable( gl.DEPTH_TEST );

    				gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


    				// copy result to occlusionMap

    				state.activeTexture( gl.TEXTURE0 );
    				state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
    				gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );


    				// restore graphics

    				gl.uniform1i( uniforms.renderType, 1 );
    				state.disable( gl.DEPTH_TEST );

    				state.activeTexture( gl.TEXTURE1 );
    				state.bindTexture( gl.TEXTURE_2D, tempTexture );
    				gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


    				// update object positions

    				flare.positionScreen.copy( screenPosition );

    				if ( flare.customUpdateCallback ) {

    					flare.customUpdateCallback( flare );

    				} else {

    					flare.updateLensFlares();

    				}

    				// render flares

    				gl.uniform1i( uniforms.renderType, 2 );
    				state.enable( gl.BLEND );

    				for ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {

    					var sprite = flare.lensFlares[ j ];

    					if ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {

    						screenPosition.x = sprite.x;
    						screenPosition.y = sprite.y;
    						screenPosition.z = sprite.z;

    						size = sprite.size * sprite.scale / viewport.w;

    						scale.x = size * invAspect;
    						scale.y = size;

    						gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );
    						gl.uniform2f( uniforms.scale, scale.x, scale.y );
    						gl.uniform1f( uniforms.rotation, sprite.rotation );

    						gl.uniform1f( uniforms.opacity, sprite.opacity );
    						gl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );

    						state.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );
    						renderer.setTexture2D( sprite.texture, 1 );

    						gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

    					}

    				}

    			}

    		}

    		// restore gl

    		state.enable( gl.CULL_FACE );
    		state.enable( gl.DEPTH_TEST );
    		state.setDepthWrite( true );

    		renderer.resetGLState();

    	};

    	function createProgram( shader ) {

    		var program = gl.createProgram();

    		var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );
    		var vertexShader = gl.createShader( gl.VERTEX_SHADER );

    		var prefix = "precision " + renderer.getPrecision() + " float;\n";

    		gl.shaderSource( fragmentShader, prefix + shader.fragmentShader );
    		gl.shaderSource( vertexShader, prefix + shader.vertexShader );

    		gl.compileShader( fragmentShader );
    		gl.compileShader( vertexShader );

    		gl.attachShader( program, fragmentShader );
    		gl.attachShader( program, vertexShader );

    		gl.linkProgram( program );

    		return program;

    	}

    }

    /**
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     */

    function SpritePlugin( renderer, sprites ) {

    	var gl = renderer.context;
    	var state = renderer.state;

    	var vertexBuffer, elementBuffer;
    	var program, attributes, uniforms;

    	var texture;

    	// decompose matrixWorld

    	var spritePosition = new Vector3();
    	var spriteRotation = new Quaternion();
    	var spriteScale = new Vector3();

    	function init() {

    		var vertices = new Float32Array( [
    			- 0.5, - 0.5,  0, 0,
    			  0.5, - 0.5,  1, 0,
    			  0.5,   0.5,  1, 1,
    			- 0.5,   0.5,  0, 1
    		] );

    		var faces = new Uint16Array( [
    			0, 1, 2,
    			0, 2, 3
    		] );

    		vertexBuffer  = gl.createBuffer();
    		elementBuffer = gl.createBuffer();

    		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
    		gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

    		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
    		gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

    		program = createProgram();

    		attributes = {
    			position:			gl.getAttribLocation ( program, 'position' ),
    			uv:					gl.getAttribLocation ( program, 'uv' )
    		};

    		uniforms = {
    			uvOffset:			gl.getUniformLocation( program, 'uvOffset' ),
    			uvScale:			gl.getUniformLocation( program, 'uvScale' ),

    			rotation:			gl.getUniformLocation( program, 'rotation' ),
    			scale:				gl.getUniformLocation( program, 'scale' ),

    			color:				gl.getUniformLocation( program, 'color' ),
    			map:				gl.getUniformLocation( program, 'map' ),
    			opacity:			gl.getUniformLocation( program, 'opacity' ),

    			modelViewMatrix: 	gl.getUniformLocation( program, 'modelViewMatrix' ),
    			projectionMatrix:	gl.getUniformLocation( program, 'projectionMatrix' ),

    			fogType:			gl.getUniformLocation( program, 'fogType' ),
    			fogDensity:			gl.getUniformLocation( program, 'fogDensity' ),
    			fogNear:			gl.getUniformLocation( program, 'fogNear' ),
    			fogFar:				gl.getUniformLocation( program, 'fogFar' ),
    			fogColor:			gl.getUniformLocation( program, 'fogColor' ),

    			alphaTest:			gl.getUniformLocation( program, 'alphaTest' )
    		};

    		var canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
    		canvas.width = 8;
    		canvas.height = 8;

    		var context = canvas.getContext( '2d' );
    		context.fillStyle = 'white';
    		context.fillRect( 0, 0, 8, 8 );

    		texture = new Texture( canvas );
    		texture.needsUpdate = true;

    	}

    	this.render = function ( scene, camera ) {

    		if ( sprites.length === 0 ) return;

    		// setup gl

    		if ( program === undefined ) {

    			init();

    		}

    		gl.useProgram( program );

    		state.initAttributes();
    		state.enableAttribute( attributes.position );
    		state.enableAttribute( attributes.uv );
    		state.disableUnusedAttributes();

    		state.disable( gl.CULL_FACE );
    		state.enable( gl.BLEND );

    		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
    		gl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );
    		gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

    		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

    		gl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

    		state.activeTexture( gl.TEXTURE0 );
    		gl.uniform1i( uniforms.map, 0 );

    		var oldFogType = 0;
    		var sceneFogType = 0;
    		var fog = scene.fog;

    		if ( fog ) {

    			gl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );

    			if ( (fog && fog.isFog) ) {

    				gl.uniform1f( uniforms.fogNear, fog.near );
    				gl.uniform1f( uniforms.fogFar, fog.far );

    				gl.uniform1i( uniforms.fogType, 1 );
    				oldFogType = 1;
    				sceneFogType = 1;

    			} else if ( (fog && fog.isFogExp2) ) {

    				gl.uniform1f( uniforms.fogDensity, fog.density );

    				gl.uniform1i( uniforms.fogType, 2 );
    				oldFogType = 2;
    				sceneFogType = 2;

    			}

    		} else {

    			gl.uniform1i( uniforms.fogType, 0 );
    			oldFogType = 0;
    			sceneFogType = 0;

    		}


    		// update positions and sort

    		for ( var i = 0, l = sprites.length; i < l; i ++ ) {

    			var sprite = sprites[ i ];

    			sprite.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );
    			sprite.z = - sprite.modelViewMatrix.elements[ 14 ];

    		}

    		sprites.sort( painterSortStable );

    		// render all sprites

    		var scale = [];

    		for ( var i = 0, l = sprites.length; i < l; i ++ ) {

    			var sprite = sprites[ i ];
    			var material = sprite.material;

    			if ( material.visible === false ) continue;

    			gl.uniform1f( uniforms.alphaTest, material.alphaTest );
    			gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements );

    			sprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );

    			scale[ 0 ] = spriteScale.x;
    			scale[ 1 ] = spriteScale.y;

    			var fogType = 0;

    			if ( scene.fog && material.fog ) {

    				fogType = sceneFogType;

    			}

    			if ( oldFogType !== fogType ) {

    				gl.uniform1i( uniforms.fogType, fogType );
    				oldFogType = fogType;

    			}

    			if ( material.map !== null ) {

    				gl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );
    				gl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );

    			} else {

    				gl.uniform2f( uniforms.uvOffset, 0, 0 );
    				gl.uniform2f( uniforms.uvScale, 1, 1 );

    			}

    			gl.uniform1f( uniforms.opacity, material.opacity );
    			gl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );

    			gl.uniform1f( uniforms.rotation, material.rotation );
    			gl.uniform2fv( uniforms.scale, scale );

    			state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );
    			state.setDepthTest( material.depthTest );
    			state.setDepthWrite( material.depthWrite );

    			if ( material.map ) {

    				renderer.setTexture2D( material.map, 0 );

    			} else {

    				renderer.setTexture2D( texture, 0 );

    			}

    			gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

    		}

    		// restore gl

    		state.enable( gl.CULL_FACE );

    		renderer.resetGLState();

    	};

    	function createProgram() {

    		var program = gl.createProgram();

    		var vertexShader = gl.createShader( gl.VERTEX_SHADER );
    		var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );

    		gl.shaderSource( vertexShader, [

    			'precision ' + renderer.getPrecision() + ' float;',

    			'uniform mat4 modelViewMatrix;',
    			'uniform mat4 projectionMatrix;',
    			'uniform float rotation;',
    			'uniform vec2 scale;',
    			'uniform vec2 uvOffset;',
    			'uniform vec2 uvScale;',

    			'attribute vec2 position;',
    			'attribute vec2 uv;',

    			'varying vec2 vUV;',

    			'void main() {',

    				'vUV = uvOffset + uv * uvScale;',

    				'vec2 alignedPosition = position * scale;',

    				'vec2 rotatedPosition;',
    				'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',
    				'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',

    				'vec4 finalPosition;',

    				'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',
    				'finalPosition.xy += rotatedPosition;',
    				'finalPosition = projectionMatrix * finalPosition;',

    				'gl_Position = finalPosition;',

    			'}'

    		].join( '\n' ) );

    		gl.shaderSource( fragmentShader, [

    			'precision ' + renderer.getPrecision() + ' float;',

    			'uniform vec3 color;',
    			'uniform sampler2D map;',
    			'uniform float opacity;',

    			'uniform int fogType;',
    			'uniform vec3 fogColor;',
    			'uniform float fogDensity;',
    			'uniform float fogNear;',
    			'uniform float fogFar;',
    			'uniform float alphaTest;',

    			'varying vec2 vUV;',

    			'void main() {',

    				'vec4 texture = texture2D( map, vUV );',

    				'if ( texture.a < alphaTest ) discard;',

    				'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',

    				'if ( fogType > 0 ) {',

    					'float depth = gl_FragCoord.z / gl_FragCoord.w;',
    					'float fogFactor = 0.0;',

    					'if ( fogType == 1 ) {',

    						'fogFactor = smoothstep( fogNear, fogFar, depth );',

    					'} else {',

    						'const float LOG2 = 1.442695;',
    						'fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',
    						'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',

    					'}',

    					'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',

    				'}',

    			'}'

    		].join( '\n' ) );

    		gl.compileShader( vertexShader );
    		gl.compileShader( fragmentShader );

    		gl.attachShader( program, vertexShader );
    		gl.attachShader( program, fragmentShader );

    		gl.linkProgram( program );

    		return program;

    	}

    	function painterSortStable( a, b ) {

    		if ( a.renderOrder !== b.renderOrder ) {

    			return a.renderOrder - b.renderOrder;

    		} else if ( a.z !== b.z ) {

    			return b.z - a.z;

    		} else {

    			return b.id - a.id;

    		}

    	}

    }

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     */

    function Material() {

    	Object.defineProperty( this, 'id', { value: MaterialIdCount() } );

    	this.uuid = exports.Math.generateUUID();

    	this.name = '';
    	this.type = 'Material';

    	this.fog = true;
    	this.lights = true;

    	this.blending = NormalBlending;
    	this.side = FrontSide;
    	this.shading = SmoothShading; // THREE.FlatShading, THREE.SmoothShading
    	this.vertexColors = NoColors; // THREE.NoColors, THREE.VertexColors, THREE.FaceColors

    	this.opacity = 1;
    	this.transparent = false;

    	this.blendSrc = SrcAlphaFactor;
    	this.blendDst = OneMinusSrcAlphaFactor;
    	this.blendEquation = AddEquation;
    	this.blendSrcAlpha = null;
    	this.blendDstAlpha = null;
    	this.blendEquationAlpha = null;

    	this.depthFunc = LessEqualDepth;
    	this.depthTest = true;
    	this.depthWrite = true;

    	this.clippingPlanes = null;
    	this.clipShadows = false;

    	this.colorWrite = true;

    	this.precision = null; // override the renderer's default precision for this material

    	this.polygonOffset = false;
    	this.polygonOffsetFactor = 0;
    	this.polygonOffsetUnits = 0;

    	this.alphaTest = 0;
    	this.premultipliedAlpha = false;

    	this.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer

    	this.visible = true;

    	this._needsUpdate = true;

    }

    Material.prototype = {

    	constructor: Material,

    	isMaterial: true,

    	get needsUpdate() {

    		return this._needsUpdate;

    	},

    	set needsUpdate( value ) {

    		if ( value === true ) this.update();
    		this._needsUpdate = value;

    	},

    	setValues: function ( values ) {

    		if ( values === undefined ) return;

    		for ( var key in values ) {

    			var newValue = values[ key ];

    			if ( newValue === undefined ) {

    				console.warn( "THREE.Material: '" + key + "' parameter is undefined." );
    				continue;

    			}

    			var currentValue = this[ key ];

    			if ( currentValue === undefined ) {

    				console.warn( "THREE." + this.type + ": '" + key + "' is not a property of this material." );
    				continue;

    			}

    			if ( (currentValue && currentValue.isColor) ) {

    				currentValue.set( newValue );

    			} else if ( (currentValue && currentValue.isVector3) && (newValue && newValue.isVector3) ) {

    				currentValue.copy( newValue );

    			} else if ( key === 'overdraw' ) {

    				// ensure overdraw is backwards-compatible with legacy boolean type
    				this[ key ] = Number( newValue );

    			} else {

    				this[ key ] = newValue;

    			}

    		}

    	},

    	toJSON: function ( meta ) {

    		var isRoot = meta === undefined;

    		if ( isRoot ) {

    			meta = {
    				textures: {},
    				images: {}
    			};

    		}

    		var data = {
    			metadata: {
    				version: 4.4,
    				type: 'Material',
    				generator: 'Material.toJSON'
    			}
    		};

    		// standard Material serialization
    		data.uuid = this.uuid;
    		data.type = this.type;

    		if ( this.name !== '' ) data.name = this.name;

    		if ( (this.color && this.color.isColor) ) data.color = this.color.getHex();

    		if ( this.roughness !== undefined ) data.roughness = this.roughness;
    		if ( this.metalness !== undefined ) data.metalness = this.metalness;

    		if ( (this.emissive && this.emissive.isColor) ) data.emissive = this.emissive.getHex();
    		if ( (this.specular && this.specular.isColor) ) data.specular = this.specular.getHex();
    		if ( this.shininess !== undefined ) data.shininess = this.shininess;

    		if ( (this.map && this.map.isTexture) ) data.map = this.map.toJSON( meta ).uuid;
    		if ( (this.alphaMap && this.alphaMap.isTexture) ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;
    		if ( (this.lightMap && this.lightMap.isTexture) ) data.lightMap = this.lightMap.toJSON( meta ).uuid;
    		if ( (this.bumpMap && this.bumpMap.isTexture) ) {

    			data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
    			data.bumpScale = this.bumpScale;

    		}
    		if ( (this.normalMap && this.normalMap.isTexture) ) {

    			data.normalMap = this.normalMap.toJSON( meta ).uuid;
    			data.normalScale = this.normalScale.toArray();

    		}
    		if ( (this.displacementMap && this.displacementMap.isTexture) ) {

    			data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
    			data.displacementScale = this.displacementScale;
    			data.displacementBias = this.displacementBias;

    		}
    		if ( (this.roughnessMap && this.roughnessMap.isTexture) ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;
    		if ( (this.metalnessMap && this.metalnessMap.isTexture) ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;

    		if ( (this.emissiveMap && this.emissiveMap.isTexture) ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;
    		if ( (this.specularMap && this.specularMap.isTexture) ) data.specularMap = this.specularMap.toJSON( meta ).uuid;

    		if ( (this.envMap && this.envMap.isTexture) ) {

    			data.envMap = this.envMap.toJSON( meta ).uuid;
    			data.reflectivity = this.reflectivity; // Scale behind envMap

    		}

    		if ( this.size !== undefined ) data.size = this.size;
    		if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;

    		if ( this.blending !== NormalBlending ) data.blending = this.blending;
    		if ( this.shading !== SmoothShading ) data.shading = this.shading;
    		if ( this.side !== FrontSide ) data.side = this.side;
    		if ( this.vertexColors !== NoColors ) data.vertexColors = this.vertexColors;

    		if ( this.opacity < 1 ) data.opacity = this.opacity;
    		if ( this.transparent === true ) data.transparent = this.transparent;

    		data.depthFunc = this.depthFunc;
    		data.depthTest = this.depthTest;
    		data.depthWrite = this.depthWrite;

    		if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
    		if ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;
    		if ( this.wireframe === true ) data.wireframe = this.wireframe;
    		if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;
    		if ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;
    		if ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;

    		data.skinning = this.skinning;
    		data.morphTargets = this.morphTargets;

    		// TODO: Copied from Object3D.toJSON

    		function extractFromCache( cache ) {

    			var values = [];

    			for ( var key in cache ) {

    				var data = cache[ key ];
    				delete data.metadata;
    				values.push( data );

    			}

    			return values;

    		}

    		if ( isRoot ) {

    			var textures = extractFromCache( meta.textures );
    			var images = extractFromCache( meta.images );

    			if ( textures.length > 0 ) data.textures = textures;
    			if ( images.length > 0 ) data.images = images;

    		}

    		return data;

    	},

    	clone: function () {

    		return new this.constructor().copy( this );

    	},

    	copy: function ( source ) {

    		this.name = source.name;

    		this.fog = source.fog;
    		this.lights = source.lights;

    		this.blending = source.blending;
    		this.side = source.side;
    		this.shading = source.shading;
    		this.vertexColors = source.vertexColors;

    		this.opacity = source.opacity;
    		this.transparent = source.transparent;

    		this.blendSrc = source.blendSrc;
    		this.blendDst = source.blendDst;
    		this.blendEquation = source.blendEquation;
    		this.blendSrcAlpha = source.blendSrcAlpha;
    		this.blendDstAlpha = source.blendDstAlpha;
    		this.blendEquationAlpha = source.blendEquationAlpha;

    		this.depthFunc = source.depthFunc;
    		this.depthTest = source.depthTest;
    		this.depthWrite = source.depthWrite;

    		this.colorWrite = source.colorWrite;

    		this.precision = source.precision;

    		this.polygonOffset = source.polygonOffset;
    		this.polygonOffsetFactor = source.polygonOffsetFactor;
    		this.polygonOffsetUnits = source.polygonOffsetUnits;

    		this.alphaTest = source.alphaTest;

    		this.premultipliedAlpha = source.premultipliedAlpha;

    		this.overdraw = source.overdraw;

    		this.visible = source.visible;
    		this.clipShadows = source.clipShadows;

    		var srcPlanes = source.clippingPlanes,
    			dstPlanes = null;

    		if ( srcPlanes !== null ) {

    			var n = srcPlanes.length;
    			dstPlanes = new Array( n );

    			for ( var i = 0; i !== n; ++ i )
    				dstPlanes[ i ] = srcPlanes[ i ].clone();

    		}

    		this.clippingPlanes = dstPlanes;

    		return this;

    	},

    	update: function () {

    		this.dispatchEvent( { type: 'update' } );

    	},

    	dispose: function () {

    		this.dispatchEvent( { type: 'dispose' } );

    	}

    };

    Object.assign( Material.prototype, EventDispatcher.prototype );

    var count$1 = 0;
    function MaterialIdCount() { return count$1++; };

    /**
     * @author alteredq / http://alteredqualia.com/
     *
     * parameters = {
     *  defines: { "label" : "value" },
     *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
     *
     *  fragmentShader: <string>,
     *  vertexShader: <string>,
     *
     *  wireframe: <boolean>,
     *  wireframeLinewidth: <float>,
     *
     *  lights: <bool>,
     *
     *  skinning: <bool>,
     *  morphTargets: <bool>,
     *  morphNormals: <bool>
     * }
     */

    function ShaderMaterial( parameters ) {

    	Material.call( this );

    	this.type = 'ShaderMaterial';

    	this.defines = {};
    	this.uniforms = {};

    	this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';
    	this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';

    	this.linewidth = 1;

    	this.wireframe = false;
    	this.wireframeLinewidth = 1;

    	this.fog = false; // set to use scene fog
    	this.lights = false; // set to use scene lights
    	this.clipping = false; // set to use user-defined clipping planes

    	this.skinning = false; // set to use skinning attribute streams
    	this.morphTargets = false; // set to use morph targets
    	this.morphNormals = false; // set to use morph normals

    	this.extensions = {
    		derivatives: false, // set to use derivatives
    		fragDepth: false, // set to use fragment depth values
    		drawBuffers: false, // set to use draw buffers
    		shaderTextureLOD: false // set to use shader texture LOD
    	};

    	// When rendered geometry doesn't include these attributes but the material does,
    	// use these default values in WebGL. This avoids errors when buffer data is missing.
    	this.defaultAttributeValues = {
    		'color': [ 1, 1, 1 ],
    		'uv': [ 0, 0 ],
    		'uv2': [ 0, 0 ]
    	};

    	this.index0AttributeName = undefined;

    	if ( parameters !== undefined ) {

    		if ( parameters.attributes !== undefined ) {

    			console.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );

    		}

    		this.setValues( parameters );

    	}

    }

    ShaderMaterial.prototype = Object.create( Material.prototype );
    ShaderMaterial.prototype.constructor = ShaderMaterial;

    ShaderMaterial.prototype.isShaderMaterial = true;

    ShaderMaterial.prototype.copy = function ( source ) {

    	Material.prototype.copy.call( this, source );

    	this.fragmentShader = source.fragmentShader;
    	this.vertexShader = source.vertexShader;

    	this.uniforms = exports.UniformsUtils.clone( source.uniforms );

    	this.defines = source.defines;

    	this.wireframe = source.wireframe;
    	this.wireframeLinewidth = source.wireframeLinewidth;

    	this.lights = source.lights;
    	this.clipping = source.clipping;

    	this.skinning = source.skinning;

    	this.morphTargets = source.morphTargets;
    	this.morphNormals = source.morphNormals;

    	this.extensions = source.extensions;

    	return this;

    };

    ShaderMaterial.prototype.toJSON = function ( meta ) {

    	var data = Material.prototype.toJSON.call( this, meta );

    	data.uniforms = this.uniforms;
    	data.vertexShader = this.vertexShader;
    	data.fragmentShader = this.fragmentShader;

    	return data;

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     * @author bhouston / https://clara.io
     * @author WestLangley / http://github.com/WestLangley
     *
     * parameters = {
     *
     *  opacity: <float>,
     *
     *  map: new THREE.Texture( <Image> ),
     *
     *  alphaMap: new THREE.Texture( <Image> ),
     *
     *  displacementMap: new THREE.Texture( <Image> ),
     *  displacementScale: <float>,
     *  displacementBias: <float>,
     *
     *  wireframe: <boolean>,
     *  wireframeLinewidth: <float>
     * }
     */

    function MeshDepthMaterial( parameters ) {

    	Material.call( this );

    	this.type = 'MeshDepthMaterial';

    	this.depthPacking = BasicDepthPacking;

    	this.skinning = false;
    	this.morphTargets = false;

    	this.map = null;

    	this.alphaMap = null;

    	this.displacementMap = null;
    	this.displacementScale = 1;
    	this.displacementBias = 0;

    	this.wireframe = false;
    	this.wireframeLinewidth = 1;

    	this.fog = false;
    	this.lights = false;

    	this.setValues( parameters );

    }

    MeshDepthMaterial.prototype = Object.create( Material.prototype );
    MeshDepthMaterial.prototype.constructor = MeshDepthMaterial;

    MeshDepthMaterial.prototype.isMeshDepthMaterial = true;

    MeshDepthMaterial.prototype.copy = function ( source ) {

    	Material.prototype.copy.call( this, source );

    	this.depthPacking = source.depthPacking;

    	this.skinning = source.skinning;
    	this.morphTargets = source.morphTargets;

    	this.map = source.map;

    	this.alphaMap = source.alphaMap;

    	this.displacementMap = source.displacementMap;
    	this.displacementScale = source.displacementScale;
    	this.displacementBias = source.displacementBias;

    	this.wireframe = source.wireframe;
    	this.wireframeLinewidth = source.wireframeLinewidth;

    	return this;

    };

    /**
     * @author bhouston / http://clara.io
     * @author WestLangley / http://github.com/WestLangley
     */

    function Box3( min, max ) {

    	this.min = ( min !== undefined ) ? min : new Vector3( + Infinity, + Infinity, + Infinity );
    	this.max = ( max !== undefined ) ? max : new Vector3( - Infinity, - Infinity, - Infinity );

    }

    Box3.prototype = {

    	constructor: Box3,

    	isBox3: true,

    	set: function ( min, max ) {

    		this.min.copy( min );
    		this.max.copy( max );

    		return this;

    	},

    	setFromArray: function ( array ) {

    		var minX = + Infinity;
    		var minY = + Infinity;
    		var minZ = + Infinity;

    		var maxX = - Infinity;
    		var maxY = - Infinity;
    		var maxZ = - Infinity;

    		for ( var i = 0, l = array.length; i < l; i += 3 ) {

    			var x = array[ i ];
    			var y = array[ i + 1 ];
    			var z = array[ i + 2 ];

    			if ( x < minX ) minX = x;
    			if ( y < minY ) minY = y;
    			if ( z < minZ ) minZ = z;

    			if ( x > maxX ) maxX = x;
    			if ( y > maxY ) maxY = y;
    			if ( z > maxZ ) maxZ = z;

    		}

    		this.min.set( minX, minY, minZ );
    		this.max.set( maxX, maxY, maxZ );

    	},

    	setFromPoints: function ( points ) {

    		this.makeEmpty();

    		for ( var i = 0, il = points.length; i < il; i ++ ) {

    			this.expandByPoint( points[ i ] );

    		}

    		return this;

    	},

    	setFromCenterAndSize: function () {

    		var v1 = new Vector3();

    		return function setFromCenterAndSize( center, size ) {

    			var halfSize = v1.copy( size ).multiplyScalar( 0.5 );

    			this.min.copy( center ).sub( halfSize );
    			this.max.copy( center ).add( halfSize );

    			return this;

    		};

    	}(),

    	setFromObject: function () {

    		// Computes the world-axis-aligned bounding box of an object (including its children),
    		// accounting for both the object's, and children's, world transforms

    		var v1 = new Vector3();

    		return function setFromObject( object ) {

    			var scope = this;

    			object.updateMatrixWorld( true );

    			this.makeEmpty();

    			object.traverse( function ( node ) {

    				var geometry = node.geometry;

    				if ( geometry !== undefined ) {

    					if ( (geometry && geometry.isGeometry) ) {

    						var vertices = geometry.vertices;

    						for ( var i = 0, il = vertices.length; i < il; i ++ ) {

    							v1.copy( vertices[ i ] );
    							v1.applyMatrix4( node.matrixWorld );

    							scope.expandByPoint( v1 );

    						}

    					} else if ( (geometry && geometry.isBufferGeometry) ) {

    						var attribute = geometry.attributes.position;

    						if ( attribute !== undefined ) {

    							var array, offset, stride;

    							if ( (attribute && attribute.isInterleavedBufferAttribute) ) {

    								array = attribute.data.array;
    								offset = attribute.offset;
    								stride = attribute.data.stride;

    							} else {

    								array = attribute.array;
    								offset = 0;
    								stride = 3;

    							}

    							for ( var i = offset, il = array.length; i < il; i += stride ) {

    								v1.fromArray( array, i );
    								v1.applyMatrix4( node.matrixWorld );

    								scope.expandByPoint( v1 );

    							}

    						}

    					}

    				}

    			} );

    			return this;

    		};

    	}(),

    	clone: function () {

    		return new this.constructor().copy( this );

    	},

    	copy: function ( box ) {

    		this.min.copy( box.min );
    		this.max.copy( box.max );

    		return this;

    	},

    	makeEmpty: function () {

    		this.min.x = this.min.y = this.min.z = + Infinity;
    		this.max.x = this.max.y = this.max.z = - Infinity;

    		return this;

    	},

    	isEmpty: function () {

    		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

    		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

    	},

    	getCenter: function ( optionalTarget ) {

    		var result = optionalTarget || new Vector3();
    		return this.isEmpty() ? result.set( 0, 0, 0 ) : result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

    	},

    	getSize: function ( optionalTarget ) {

    		var result = optionalTarget || new Vector3();
    		return this.isEmpty() ? result.set( 0, 0, 0 ) : result.subVectors( this.max, this.min );

    	},

    	expandByPoint: function ( point ) {

    		this.min.min( point );
    		this.max.max( point );

    		return this;

    	},

    	expandByVector: function ( vector ) {

    		this.min.sub( vector );
    		this.max.add( vector );

    		return this;

    	},

    	expandByScalar: function ( scalar ) {

    		this.min.addScalar( - scalar );
    		this.max.addScalar( scalar );

    		return this;

    	},

    	containsPoint: function ( point ) {

    		if ( point.x < this.min.x || point.x > this.max.x ||
    				 point.y < this.min.y || point.y > this.max.y ||
    				 point.z < this.min.z || point.z > this.max.z ) {

    			return false;

    		}

    		return true;

    	},

    	containsBox: function ( box ) {

    		if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
    			 ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&
    			 ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {

    			return true;

    		}

    		return false;

    	},

    	getParameter: function ( point, optionalTarget ) {

    		// This can potentially have a divide by zero if the box
    		// has a size dimension of 0.

    		var result = optionalTarget || new Vector3();

    		return result.set(
    			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
    			( point.y - this.min.y ) / ( this.max.y - this.min.y ),
    			( point.z - this.min.z ) / ( this.max.z - this.min.z )
    		);

    	},

    	intersectsBox: function ( box ) {

    		// using 6 splitting planes to rule out intersections.

    		if ( box.max.x < this.min.x || box.min.x > this.max.x ||
    				 box.max.y < this.min.y || box.min.y > this.max.y ||
    				 box.max.z < this.min.z || box.min.z > this.max.z ) {

    			return false;

    		}

    		return true;

    	},

    	intersectsSphere: ( function () {

    		var closestPoint;

    		return function intersectsSphere( sphere ) {

    			if ( closestPoint === undefined ) closestPoint = new Vector3();

    			// Find the point on the AABB closest to the sphere center.
    			this.clampPoint( sphere.center, closestPoint );

    			// If that point is inside the sphere, the AABB and sphere intersect.
    			return closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );

    		};

    	} )(),

    	intersectsPlane: function ( plane ) {

    		// We compute the minimum and maximum dot product values. If those values
    		// are on the same side (back or front) of the plane, then there is no intersection.

    		var min, max;

    		if ( plane.normal.x > 0 ) {

    			min = plane.normal.x * this.min.x;
    			max = plane.normal.x * this.max.x;

    		} else {

    			min = plane.normal.x * this.max.x;
    			max = plane.normal.x * this.min.x;

    		}

    		if ( plane.normal.y > 0 ) {

    			min += plane.normal.y * this.min.y;
    			max += plane.normal.y * this.max.y;

    		} else {

    			min += plane.normal.y * this.max.y;
    			max += plane.normal.y * this.min.y;

    		}

    		if ( plane.normal.z > 0 ) {

    			min += plane.normal.z * this.min.z;
    			max += plane.normal.z * this.max.z;

    		} else {

    			min += plane.normal.z * this.max.z;
    			max += plane.normal.z * this.min.z;

    		}

    		return ( min <= plane.constant && max >= plane.constant );

    	},

    	clampPoint: function ( point, optionalTarget ) {

    		var result = optionalTarget || new Vector3();
    		return result.copy( point ).clamp( this.min, this.max );

    	},

    	distanceToPoint: function () {

    		var v1 = new Vector3();

    		return function distanceToPoint( point ) {

    			var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
    			return clampedPoint.sub( point ).length();

    		};

    	}(),

    	getBoundingSphere: function () {

    		var v1 = new Vector3();

    		return function getBoundingSphere( optionalTarget ) {

    			var result = optionalTarget || new Sphere();

    			this.getCenter( result.center );

    			result.radius = this.size( v1 ).length() * 0.5;

    			return result;

    		};

    	}(),

    	intersect: function ( box ) {

    		this.min.max( box.min );
    		this.max.min( box.max );

    		// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
    		if( this.isEmpty() ) this.makeEmpty();

    		return this;

    	},

    	union: function ( box ) {

    		this.min.min( box.min );
    		this.max.max( box.max );

    		return this;

    	},

    	applyMatrix4: function () {

    		var points = [
    			new Vector3(),
    			new Vector3(),
    			new Vector3(),
    			new Vector3(),
    			new Vector3(),
    			new Vector3(),
    			new Vector3(),
    			new Vector3()
    		];

    		return function applyMatrix4( matrix ) {

    			// transform of empty box is an empty box.
    			if( this.isEmpty() ) return this;

    			// NOTE: I am using a binary pattern to specify all 2^3 combinations below
    			points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
    			points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
    			points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
    			points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
    			points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
    			points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
    			points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
    			points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );	// 111

    			this.setFromPoints( points );

    			return this;

    		};

    	}(),

    	translate: function ( offset ) {

    		this.min.add( offset );
    		this.max.add( offset );

    		return this;

    	},

    	equals: function ( box ) {

    		return box.min.equals( this.min ) && box.max.equals( this.max );

    	}

    };

    /**
     * @author bhouston / http://clara.io
     * @author mrdoob / http://mrdoob.com/
     */

    function Sphere( center, radius ) {

    	this.center = ( center !== undefined ) ? center : new Vector3();
    	this.radius = ( radius !== undefined ) ? radius : 0;

    }

    Sphere.prototype = {

    	constructor: Sphere,

    	set: function ( center, radius ) {

    		this.center.copy( center );
    		this.radius = radius;

    		return this;

    	},

    	setFromPoints: function () {

    		var box = new Box3();

    		return function setFromPoints( points, optionalCenter ) {

    			var center = this.center;

    			if ( optionalCenter !== undefined ) {

    				center.copy( optionalCenter );

    			} else {

    				box.setFromPoints( points ).getCenter( center );

    			}

    			var maxRadiusSq = 0;

    			for ( var i = 0, il = points.length; i < il; i ++ ) {

    				maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

    			}

    			this.radius = Math.sqrt( maxRadiusSq );

    			return this;

    		};

    	}(),

    	clone: function () {

    		return new this.constructor().copy( this );

    	},

    	copy: function ( sphere ) {

    		this.center.copy( sphere.center );
    		this.radius = sphere.radius;

    		return this;

    	},

    	empty: function () {

    		return ( this.radius <= 0 );

    	},

    	containsPoint: function ( point ) {

    		return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

    	},

    	distanceToPoint: function ( point ) {

    		return ( point.distanceTo( this.center ) - this.radius );

    	},

    	intersectsSphere: function ( sphere ) {

    		var radiusSum = this.radius + sphere.radius;

    		return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

    	},

    	intersectsBox: function ( box ) {

    		return box.intersectsSphere( this );

    	},

    	intersectsPlane: function ( plane ) {

    		// We use the following equation to compute the signed distance from
    		// the center of the sphere to the plane.
    		//
    		// distance = q * n - d
    		//
    		// If this distance is greater than the radius of the sphere,
    		// then there is no intersection.

    		return Math.abs( this.center.dot( plane.normal ) - plane.constant ) <= this.radius;

    	},

    	clampPoint: function ( point, optionalTarget ) {

    		var deltaLengthSq = this.center.distanceToSquared( point );

    		var result = optionalTarget || new Vector3();

    		result.copy( point );

    		if ( deltaLengthSq > ( this.radius * this.radius ) ) {

    			result.sub( this.center ).normalize();
    			result.multiplyScalar( this.radius ).add( this.center );

    		}

    		return result;

    	},

    	getBoundingBox: function ( optionalTarget ) {

    		var box = optionalTarget || new Box3();

    		box.set( this.center, this.center );
    		box.expandByScalar( this.radius );

    		return box;

    	},

    	applyMatrix4: function ( matrix ) {

    		this.center.applyMatrix4( matrix );
    		this.radius = this.radius * matrix.getMaxScaleOnAxis();

    		return this;

    	},

    	translate: function ( offset ) {

    		this.center.add( offset );

    		return this;

    	},

    	equals: function ( sphere ) {

    		return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

    	}

    };

    /**
     * @author alteredq / http://alteredqualia.com/
     * @author WestLangley / http://github.com/WestLangley
     * @author bhouston / http://clara.io
     * @author tschw
     */

    function Matrix3() {

    	this.elements = new Float32Array( [

    		1, 0, 0,
    		0, 1, 0,
    		0, 0, 1

    	] );

    	if ( arguments.length > 0 ) {

    		console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );

    	}

    }

    Matrix3.prototype = {

    	constructor: Matrix3,

    	isMatrix3: true,

    	set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

    		var te = this.elements;

    		te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
    		te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
    		te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;

    		return this;

    	},

    	identity: function () {

    		this.set(

    			1, 0, 0,
    			0, 1, 0,
    			0, 0, 1

    		);

    		return this;

    	},

    	clone: function () {

    		return new this.constructor().fromArray( this.elements );

    	},

    	copy: function ( m ) {

    		var me = m.elements;

    		this.set(

    			me[ 0 ], me[ 3 ], me[ 6 ],
    			me[ 1 ], me[ 4 ], me[ 7 ],
    			me[ 2 ], me[ 5 ], me[ 8 ]

    		);

    		return this;

    	},

    	setFromMatrix4: function( m ) {

    		var me = m.elements;

    		this.set(

    			me[ 0 ], me[ 4 ], me[  8 ],
    			me[ 1 ], me[ 5 ], me[  9 ],
    			me[ 2 ], me[ 6 ], me[ 10 ]

    		);

    		return this;

    	},

    	applyToVector3Array: function () {

    		var v1;

    		return function applyToVector3Array( array, offset, length ) {

    			if ( v1 === undefined ) v1 = new Vector3();
    			if ( offset === undefined ) offset = 0;
    			if ( length === undefined ) length = array.length;

    			for ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {

    				v1.fromArray( array, j );
    				v1.applyMatrix3( this );
    				v1.toArray( array, j );

    			}

    			return array;

    		};

    	}(),

    	applyToBuffer: function () {

    		var v1;

    		return function applyToBuffer( buffer, offset, length ) {

    			if ( v1 === undefined ) v1 = new Vector3();
    			if ( offset === undefined ) offset = 0;
    			if ( length === undefined ) length = buffer.length / buffer.itemSize;

    			for ( var i = 0, j = offset; i < length; i ++, j ++ ) {

    				v1.x = buffer.getX( j );
    				v1.y = buffer.getY( j );
    				v1.z = buffer.getZ( j );

    				v1.applyMatrix3( this );

    				buffer.setXYZ( v1.x, v1.y, v1.z );

    			}

    			return buffer;

    		};

    	}(),

    	multiplyScalar: function ( s ) {

    		var te = this.elements;

    		te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
    		te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
    		te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

    		return this;

    	},

    	determinant: function () {

    		var te = this.elements;

    		var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
    			d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
    			g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

    		return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

    	},

    	getInverse: function ( matrix, throwOnDegenerate ) {

    		if ( (matrix && matrix.isMatrix4) ) {

    			console.error( "THREE.Matrix3.getInverse no longer takes a Matrix4 argument." );

    		}

    		var me = matrix.elements,
    			te = this.elements,

    			n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],
    			n12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],
    			n13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],

    			t11 = n33 * n22 - n32 * n23,
    			t12 = n32 * n13 - n33 * n12,
    			t13 = n23 * n12 - n22 * n13,

    			det = n11 * t11 + n21 * t12 + n31 * t13;

    		if ( det === 0 ) {

    			var msg = "THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0";

    			if ( throwOnDegenerate === true ) {

    				throw new Error( msg );

    			} else {

    				console.warn( msg );

    			}

    			return this.identity();
    		}

    		var detInv = 1 / det;

    		te[ 0 ] = t11 * detInv;
    		te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
    		te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;

    		te[ 3 ] = t12 * detInv;
    		te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
    		te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;

    		te[ 6 ] = t13 * detInv;
    		te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
    		te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;

    		return this;

    	},

    	transpose: function () {

    		var tmp, m = this.elements;

    		tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
    		tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
    		tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

    		return this;

    	},

    	flattenToArrayOffset: function ( array, offset ) {

    		console.warn( "THREE.Matrix3: .flattenToArrayOffset is deprecated " +
    				"- just use .toArray instead." );

    		return this.toArray( array, offset );

    	},

    	getNormalMatrix: function ( matrix4 ) {

    		return this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();

    	},

    	transposeIntoArray: function ( r ) {

    		var m = this.elements;

    		r[ 0 ] = m[ 0 ];
    		r[ 1 ] = m[ 3 ];
    		r[ 2 ] = m[ 6 ];
    		r[ 3 ] = m[ 1 ];
    		r[ 4 ] = m[ 4 ];
    		r[ 5 ] = m[ 7 ];
    		r[ 6 ] = m[ 2 ];
    		r[ 7 ] = m[ 5 ];
    		r[ 8 ] = m[ 8 ];

    		return this;

    	},

    	fromArray: function ( array, offset ) {

    		if ( offset === undefined ) offset = 0;

    		for( var i = 0; i < 9; i ++ ) {

    			this.elements[ i ] = array[ i + offset ];

    		}

    		return this;

    	},

    	toArray: function ( array, offset ) {

    		if ( array === undefined ) array = [];
    		if ( offset === undefined ) offset = 0;

    		var te = this.elements;

    		array[ offset ] = te[ 0 ];
    		array[ offset + 1 ] = te[ 1 ];
    		array[ offset + 2 ] = te[ 2 ];

    		array[ offset + 3 ] = te[ 3 ];
    		array[ offset + 4 ] = te[ 4 ];
    		array[ offset + 5 ] = te[ 5 ];

    		array[ offset + 6 ] = te[ 6 ];
    		array[ offset + 7 ] = te[ 7 ];
    		array[ offset + 8 ]  = te[ 8 ];

    		return array;

    	}

    };

    /**
     * @author bhouston / http://clara.io
     */

    function Plane( normal, constant ) {

    	this.normal = ( normal !== undefined ) ? normal : new Vector3( 1, 0, 0 );
    	this.constant = ( constant !== undefined ) ? constant : 0;

    }

    Plane.prototype = {

    	constructor: Plane,

    	set: function ( normal, constant ) {

    		this.normal.copy( normal );
    		this.constant = constant;

    		return this;

    	},

    	setComponents: function ( x, y, z, w ) {

    		this.normal.set( x, y, z );
    		this.constant = w;

    		return this;

    	},

    	setFromNormalAndCoplanarPoint: function ( normal, point ) {

    		this.normal.copy( normal );
    		this.constant = - point.dot( this.normal );	// must be this.normal, not normal, as this.normal is normalized

    		return this;

    	},

    	setFromCoplanarPoints: function () {

    		var v1 = new Vector3();
    		var v2 = new Vector3();

    		return function setFromCoplanarPoints( a, b, c ) {

    			var normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();

    			// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

    			this.setFromNormalAndCoplanarPoint( normal, a );

    			return this;

    		};

    	}(),

    	clone: function () {

    		return new this.constructor().copy( this );

    	},

    	copy: function ( plane ) {

    		this.normal.copy( plane.normal );
    		this.constant = plane.constant;

    		return this;

    	},

    	normalize: function () {

    		// Note: will lead to a divide by zero if the plane is invalid.

    		var inverseNormalLength = 1.0 / this.normal.length();
    		this.normal.multiplyScalar( inverseNormalLength );
    		this.constant *= inverseNormalLength;

    		return this;

    	},

    	negate: function () {

    		this.constant *= - 1;
    		this.normal.negate();

    		return this;

    	},

    	distanceToPoint: function ( point ) {

    		return this.normal.dot( point ) + this.constant;

    	},

    	distanceToSphere: function ( sphere ) {

    		return this.distanceToPoint( sphere.center ) - sphere.radius;

    	},

    	projectPoint: function ( point, optionalTarget ) {

    		return this.orthoPoint( point, optionalTarget ).sub( point ).negate();

    	},

    	orthoPoint: function ( point, optionalTarget ) {

    		var perpendicularMagnitude = this.distanceToPoint( point );

    		var result = optionalTarget || new Vector3();
    		return result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );

    	},

    	intersectLine: function () {

    		var v1 = new Vector3();

    		return function intersectLine( line, optionalTarget ) {

    			var result = optionalTarget || new Vector3();

    			var direction = line.delta( v1 );

    			var denominator = this.normal.dot( direction );

    			if ( denominator === 0 ) {

    				// line is coplanar, return origin
    				if ( this.distanceToPoint( line.start ) === 0 ) {

    					return result.copy( line.start );

    				}

    				// Unsure if this is the correct method to handle this case.
    				return undefined;

    			}

    			var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

    			if ( t < 0 || t > 1 ) {

    				return undefined;

    			}

    			return result.copy( direction ).multiplyScalar( t ).add( line.start );

    		};

    	}(),

    	intersectsLine: function ( line ) {

    		// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

    		var startSign = this.distanceToPoint( line.start );
    		var endSign = this.distanceToPoint( line.end );

    		return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

    	},

    	intersectsBox: function ( box ) {

    		return box.intersectsPlane( this );

    	},

    	intersectsSphere: function ( sphere ) {

    		return sphere.intersectsPlane( this );

    	},

    	coplanarPoint: function ( optionalTarget ) {

    		var result = optionalTarget || new Vector3();
    		return result.copy( this.normal ).multiplyScalar( - this.constant );

    	},

    	applyMatrix4: function () {

    		var v1 = new Vector3();
    		var m1 = new Matrix3();

    		return function applyMatrix4( matrix, optionalNormalMatrix ) {

    			var referencePoint = this.coplanarPoint( v1 ).applyMatrix4( matrix );

    			// transform normal based on theory here:
    			// http://www.songho.ca/opengl/gl_normaltransform.html
    			var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );
    			var normal = this.normal.applyMatrix3( normalMatrix ).normalize();

    			// recalculate constant (like in setFromNormalAndCoplanarPoint)
    			this.constant = - referencePoint.dot( normal );

    			return this;

    		};

    	}(),

    	translate: function ( offset ) {

    		this.constant = this.constant - offset.dot( this.normal );

    		return this;

    	},

    	equals: function ( plane ) {

    		return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

    	}

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     * @author bhouston / http://clara.io
     */

    function Frustum( p0, p1, p2, p3, p4, p5 ) {

    	this.planes = [

    		( p0 !== undefined ) ? p0 : new Plane(),
    		( p1 !== undefined ) ? p1 : new Plane(),
    		( p2 !== undefined ) ? p2 : new Plane(),
    		( p3 !== undefined ) ? p3 : new Plane(),
    		( p4 !== undefined ) ? p4 : new Plane(),
    		( p5 !== undefined ) ? p5 : new Plane()

    	];

    }

    Frustum.prototype = {

    	constructor: Frustum,

    	set: function ( p0, p1, p2, p3, p4, p5 ) {

    		var planes = this.planes;

    		planes[ 0 ].copy( p0 );
    		planes[ 1 ].copy( p1 );
    		planes[ 2 ].copy( p2 );
    		planes[ 3 ].copy( p3 );
    		planes[ 4 ].copy( p4 );
    		planes[ 5 ].copy( p5 );

    		return this;

    	},

    	clone: function () {

    		return new this.constructor().copy( this );

    	},

    	copy: function ( frustum ) {

    		var planes = this.planes;

    		for ( var i = 0; i < 6; i ++ ) {

    			planes[ i ].copy( frustum.planes[ i ] );

    		}

    		return this;

    	},

    	setFromMatrix: function ( m ) {

    		var planes = this.planes;
    		var me = m.elements;
    		var me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
    		var me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
    		var me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
    		var me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

    		planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
    		planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
    		planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
    		planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
    		planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
    		planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

    		return this;

    	},

    	intersectsObject: function () {

    		var sphere = new Sphere();

    		return function intersectsObject( object ) {

    			var geometry = object.geometry;

    			if ( geometry.boundingSphere === null )
    				geometry.computeBoundingSphere();

    			sphere.copy( geometry.boundingSphere )
    				.applyMatrix4( object.matrixWorld );

    			return this.intersectsSphere( sphere );

    		};

    	}(),

    	intersectsSprite: function () {

    		var sphere = new Sphere();

    		return function intersectsSprite( sprite ) {

    			sphere.center.set( 0, 0, 0 );
    			sphere.radius = 0.7071067811865476;
    			sphere.applyMatrix4( sprite.matrixWorld );

    			return this.intersectsSphere( sphere );

    		};

    	}(),

    	intersectsSphere: function ( sphere ) {

    		var planes = this.planes;
    		var center = sphere.center;
    		var negRadius = - sphere.radius;

    		for ( var i = 0; i < 6; i ++ ) {

    			var distance = planes[ i ].distanceToPoint( center );

    			if ( distance < negRadius ) {

    				return false;

    			}

    		}

    		return true;

    	},

    	intersectsBox: function () {

    		var p1 = new Vector3(),
    			p2 = new Vector3();

    		return function intersectsBox( box ) {

    			var planes = this.planes;

    			for ( var i = 0; i < 6 ; i ++ ) {

    				var plane = planes[ i ];

    				p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
    				p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
    				p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
    				p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
    				p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
    				p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;

    				var d1 = plane.distanceToPoint( p1 );
    				var d2 = plane.distanceToPoint( p2 );

    				// if both outside plane, no intersection

    				if ( d1 < 0 && d2 < 0 ) {

    					return false;

    				}

    			}

    			return true;

    		};

    	}(),


    	containsPoint: function ( point ) {

    		var planes = this.planes;

    		for ( var i = 0; i < 6; i ++ ) {

    			if ( planes[ i ].distanceToPoint( point ) < 0 ) {

    				return false;

    			}

    		}

    		return true;

    	}

    };

    function WebGLShadowMap( _renderer, _lights, _objects, capabilities ) {

    	var _gl = _renderer.context,
    	_state = _renderer.state,
    	_frustum = new Frustum(),
    	_projScreenMatrix = new Matrix4(),

    	_lightShadows = _lights.shadows,

    	_shadowMapSize = new Vector2(),
    	_maxShadowMapSize = new Vector2( capabilities.maxTextureSize, capabilities.maxTextureSize ),

    	_lookTarget = new Vector3(),
    	_lightPositionWorld = new Vector3(),

    	_renderList = [],

    	_MorphingFlag = 1,
    	_SkinningFlag = 2,

    	_NumberOfMaterialVariants = ( _MorphingFlag | _SkinningFlag ) + 1,

    	_depthMaterials = new Array( _NumberOfMaterialVariants ),
    	_distanceMaterials = new Array( _NumberOfMaterialVariants ),

    	_materialCache = {};

    	var cubeDirections = [
    		new Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),
    		new Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )
    	];

    	var cubeUps = [
    		new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),
    		new Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),	new Vector3( 0, 0, - 1 )
    	];

    	var cube2DViewPorts = [
    		new Vector4(), new Vector4(), new Vector4(),
    		new Vector4(), new Vector4(), new Vector4()
    	];

    	// init

    	var depthMaterialTemplate = new MeshDepthMaterial();
    	depthMaterialTemplate.depthPacking = RGBADepthPacking;
    	depthMaterialTemplate.clipping = true;

    	var distanceShader = ShaderLib[ "distanceRGBA" ];
    	var distanceUniforms = exports.UniformsUtils.clone( distanceShader.uniforms );

    	for ( var i = 0; i !== _NumberOfMaterialVariants; ++ i ) {

    		var useMorphing = ( i & _MorphingFlag ) !== 0;
    		var useSkinning = ( i & _SkinningFlag ) !== 0;

    		var depthMaterial = depthMaterialTemplate.clone();
    		depthMaterial.morphTargets = useMorphing;
    		depthMaterial.skinning = useSkinning;

    		_depthMaterials[ i ] = depthMaterial;

    		var distanceMaterial = new ShaderMaterial( {
    			defines: {
    				'USE_SHADOWMAP': ''
    			},
    			uniforms: distanceUniforms,
    			vertexShader: distanceShader.vertexShader,
    			fragmentShader: distanceShader.fragmentShader,
    			morphTargets: useMorphing,
    			skinning: useSkinning,
    			clipping: true
    		} );

    		_distanceMaterials[ i ] = distanceMaterial;

    	}

    	//

    	var scope = this;

    	this.enabled = false;

    	this.autoUpdate = true;
    	this.needsUpdate = false;

    	this.type = PCFShadowMap;

    	this.renderReverseSided = true;
    	this.renderSingleSided = true;

    	this.render = function ( scene, camera ) {

    		if ( scope.enabled === false ) return;
    		if ( scope.autoUpdate === false && scope.needsUpdate === false ) return;

    		if ( _lightShadows.length === 0 ) return;

    		// Set GL state for depth map.
    		_state.clearColor( 1, 1, 1, 1 );
    		_state.disable( _gl.BLEND );
    		_state.setDepthTest( true );
    		_state.setScissorTest( false );

    		// render depth map

    		var faceCount, isPointLight;

    		for ( var i = 0, il = _lightShadows.length; i < il; i ++ ) {

    			var light = _lightShadows[ i ];
    			var shadow = light.shadow;

    			if ( shadow === undefined ) {

    				console.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );
    				continue;

    			}

    			var shadowCamera = shadow.camera;

    			_shadowMapSize.copy( shadow.mapSize );
    			_shadowMapSize.min( _maxShadowMapSize );

    			if ( (light && light.isPointLight) ) {

    				faceCount = 6;
    				isPointLight = true;

    				var vpWidth = _shadowMapSize.x;
    				var vpHeight = _shadowMapSize.y;

    				// These viewports map a cube-map onto a 2D texture with the
    				// following orientation:
    				//
    				//  xzXZ
    				//   y Y
    				//
    				// X - Positive x direction
    				// x - Negative x direction
    				// Y - Positive y direction
    				// y - Negative y direction
    				// Z - Positive z direction
    				// z - Negative z direction

    				// positive X
    				cube2DViewPorts[ 0 ].set( vpWidth * 2, vpHeight, vpWidth, vpHeight );
    				// negative X
    				cube2DViewPorts[ 1 ].set( 0, vpHeight, vpWidth, vpHeight );
    				// positive Z
    				cube2DViewPorts[ 2 ].set( vpWidth * 3, vpHeight, vpWidth, vpHeight );
    				// negative Z
    				cube2DViewPorts[ 3 ].set( vpWidth, vpHeight, vpWidth, vpHeight );
    				// positive Y
    				cube2DViewPorts[ 4 ].set( vpWidth * 3, 0, vpWidth, vpHeight );
    				// negative Y
    				cube2DViewPorts[ 5 ].set( vpWidth, 0, vpWidth, vpHeight );

    				_shadowMapSize.x *= 4.0;
    				_shadowMapSize.y *= 2.0;

    			} else {

    				faceCount = 1;
    				isPointLight = false;

    			}

    			if ( shadow.map === null ) {

    				var pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };

    				shadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );

    				shadowCamera.updateProjectionMatrix();

    			}

    			if ( (shadow && shadow.isSpotLightShadow) ) {

    				shadow.update( light );

    			}

    			var shadowMap = shadow.map;
    			var shadowMatrix = shadow.matrix;

    			_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
    			shadowCamera.position.copy( _lightPositionWorld );

    			_renderer.setRenderTarget( shadowMap );
    			_renderer.clear();

    			// render shadow map for each cube face (if omni-directional) or
    			// run a single pass if not

    			for ( var face = 0; face < faceCount; face ++ ) {

    				if ( isPointLight ) {

    					_lookTarget.copy( shadowCamera.position );
    					_lookTarget.add( cubeDirections[ face ] );
    					shadowCamera.up.copy( cubeUps[ face ] );
    					shadowCamera.lookAt( _lookTarget );

    					var vpDimensions = cube2DViewPorts[ face ];
    					_state.viewport( vpDimensions );

    				} else {

    					_lookTarget.setFromMatrixPosition( light.target.matrixWorld );
    					shadowCamera.lookAt( _lookTarget );

    				}

    				shadowCamera.updateMatrixWorld();
    				shadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );

    				// compute shadow matrix

    				shadowMatrix.set(
    					0.5, 0.0, 0.0, 0.5,
    					0.0, 0.5, 0.0, 0.5,
    					0.0, 0.0, 0.5, 0.5,
    					0.0, 0.0, 0.0, 1.0
    				);

    				shadowMatrix.multiply( shadowCamera.projectionMatrix );
    				shadowMatrix.multiply( shadowCamera.matrixWorldInverse );

    				// update camera matrices and frustum

    				_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
    				_frustum.setFromMatrix( _projScreenMatrix );

    				// set object matrices & frustum culling

    				_renderList.length = 0;

    				projectObject( scene, camera, shadowCamera );

    				// render shadow map
    				// render regular objects

    				for ( var j = 0, jl = _renderList.length; j < jl; j ++ ) {

    					var object = _renderList[ j ];
    					var geometry = _objects.update( object );
    					var material = object.material;

    					if ( (material && material.isMultiMaterial) ) {

    						var groups = geometry.groups;
    						var materials = material.materials;

    						for ( var k = 0, kl = groups.length; k < kl; k ++ ) {

    							var group = groups[ k ];
    							var groupMaterial = materials[ group.materialIndex ];

    							if ( groupMaterial.visible === true ) {

    								var depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld );
    								_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );

    							}

    						}

    					} else {

    						var depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld );
    						_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );

    					}

    				}

    			}

    		}

    		// Restore GL state.
    		var clearColor = _renderer.getClearColor(),
    		clearAlpha = _renderer.getClearAlpha();
    		_renderer.setClearColor( clearColor, clearAlpha );

    		scope.needsUpdate = false;

    	};

    	function getDepthMaterial( object, material, isPointLight, lightPositionWorld ) {

    		var geometry = object.geometry;

    		var result = null;

    		var materialVariants = _depthMaterials;
    		var customMaterial = object.customDepthMaterial;

    		if ( isPointLight ) {

    			materialVariants = _distanceMaterials;
    			customMaterial = object.customDistanceMaterial;

    		}

    		if ( ! customMaterial ) {

    			var useMorphing = false;

    			if ( material.morphTargets ) {

    				if ( (geometry && geometry.isBufferGeometry) ) {

    					useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;

    				} else if ( (geometry && geometry.isGeometry) ) {

    					useMorphing = geometry.morphTargets && geometry.morphTargets.length > 0;

    				}

    			}

    			var useSkinning = object.isSkinnedMesh && material.skinning;

    			var variantIndex = 0;

    			if ( useMorphing ) variantIndex |= _MorphingFlag;
    			if ( useSkinning ) variantIndex |= _SkinningFlag;

    			result = materialVariants[ variantIndex ];

    		} else {

    			result = customMaterial;

    		}

    		if ( _renderer.localClippingEnabled &&
    			 material.clipShadows === true &&
    				material.clippingPlanes.length !== 0 ) {

    			// in this case we need a unique material instance reflecting the
    			// appropriate state

    			var keyA = result.uuid, keyB = material.uuid;

    			var materialsForVariant = _materialCache[ keyA ];

    			if ( materialsForVariant === undefined ) {

    				materialsForVariant = {};
    				_materialCache[ keyA ] = materialsForVariant;

    			}

    			var cachedMaterial = materialsForVariant[ keyB ];

    			if ( cachedMaterial === undefined ) {

    				cachedMaterial = result.clone();
    				materialsForVariant[ keyB ] = cachedMaterial;

    			}

    			result = cachedMaterial;

    		}

    		result.visible = material.visible;
    		result.wireframe = material.wireframe;

    		var side = material.side;

    		if ( scope.renderSingleSided && side == DoubleSide ) {

    			side = FrontSide;

    		}

    		if ( scope.renderReverseSided ) {

    			if ( side === FrontSide ) side = BackSide;
    			else if ( side === BackSide ) side = FrontSide;

    		}

    		result.side = side;

    		result.clipShadows = material.clipShadows;
    		result.clippingPlanes = material.clippingPlanes;

    		result.wireframeLinewidth = material.wireframeLinewidth;
    		result.linewidth = material.linewidth;

    		if ( isPointLight && result.uniforms.lightPos !== undefined ) {

    			result.uniforms.lightPos.value.copy( lightPositionWorld );

    		}

    		return result;

    	}

    	function projectObject( object, camera, shadowCamera ) {

    		if ( object.visible === false ) return;

    		var visible = ( object.layers.mask & camera.layers.mask ) !== 0;

    		if ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {

    			if ( object.castShadow && ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) ) {

    				var material = object.material;

    				if ( material.visible === true ) {

    					object.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );
    					_renderList.push( object );

    				}

    			}

    		}

    		var children = object.children;

    		for ( var i = 0, l = children.length; i < l; i ++ ) {

    			projectObject( children[ i ], camera, shadowCamera );

    		}

    	}

    }

    /**
     * @author bhouston / http://clara.io
     */

    function Ray( origin, direction ) {

    	this.origin = ( origin !== undefined ) ? origin : new Vector3();
    	this.direction = ( direction !== undefined ) ? direction : new Vector3();

    }

    Ray.prototype = {

    	constructor: Ray,

    	set: function ( origin, direction ) {

    		this.origin.copy( origin );
    		this.direction.copy( direction );

    		return this;

    	},

    	clone: function () {

    		return new this.constructor().copy( this );

    	},

    	copy: function ( ray ) {

    		this.origin.copy( ray.origin );
    		this.direction.copy( ray.direction );

    		return this;

    	},

    	at: function ( t, optionalTarget ) {

    		var result = optionalTarget || new Vector3();

    		return result.copy( this.direction ).multiplyScalar( t ).add( this.origin );

    	},

    	lookAt: function ( v ) {

    		this.direction.copy( v ).sub( this.origin ).normalize();

    		return this;

    	},

    	recast: function () {

    		var v1 = new Vector3();

    		return function recast( t ) {

    			this.origin.copy( this.at( t, v1 ) );

    			return this;

    		};

    	}(),

    	closestPointToPoint: function ( point, optionalTarget ) {

    		var result = optionalTarget || new Vector3();
    		result.subVectors( point, this.origin );
    		var directionDistance = result.dot( this.direction );

    		if ( directionDistance < 0 ) {

    			return result.copy( this.origin );

    		}

    		return result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

    	},

    	distanceToPoint: function ( point ) {

    		return Math.sqrt( this.distanceSqToPoint( point ) );

    	},

    	distanceSqToPoint: function () {

    		var v1 = new Vector3();

    		return function distanceSqToPoint( point ) {

    			var directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );

    			// point behind the ray

    			if ( directionDistance < 0 ) {

    				return this.origin.distanceToSquared( point );

    			}

    			v1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

    			return v1.distanceToSquared( point );

    		};

    	}(),

    	distanceSqToSegment: function () {

    		var segCenter = new Vector3();
    		var segDir = new Vector3();
    		var diff = new Vector3();

    		return function distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

    			// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
    			// It returns the min distance between the ray and the segment
    			// defined by v0 and v1
    			// It can also set two optional targets :
    			// - The closest point on the ray
    			// - The closest point on the segment

    			segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
    			segDir.copy( v1 ).sub( v0 ).normalize();
    			diff.copy( this.origin ).sub( segCenter );

    			var segExtent = v0.distanceTo( v1 ) * 0.5;
    			var a01 = - this.direction.dot( segDir );
    			var b0 = diff.dot( this.direction );
    			var b1 = - diff.dot( segDir );
    			var c = diff.lengthSq();
    			var det = Math.abs( 1 - a01 * a01 );
    			var s0, s1, sqrDist, extDet;

    			if ( det > 0 ) {

    				// The ray and segment are not parallel.

    				s0 = a01 * b1 - b0;
    				s1 = a01 * b0 - b1;
    				extDet = segExtent * det;

    				if ( s0 >= 0 ) {

    					if ( s1 >= - extDet ) {

    						if ( s1 <= extDet ) {

    							// region 0
    							// Minimum at interior points of ray and segment.

    							var invDet = 1 / det;
    							s0 *= invDet;
    							s1 *= invDet;
    							sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

    						} else {

    							// region 1

    							s1 = segExtent;
    							s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
    							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

    						}

    					} else {

    						// region 5

    						s1 = - segExtent;
    						s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
    						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

    					}

    				} else {

    					if ( s1 <= - extDet ) {

    						// region 4

    						s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
    						s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
    						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

    					} else if ( s1 <= extDet ) {

    						// region 3

    						s0 = 0;
    						s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
    						sqrDist = s1 * ( s1 + 2 * b1 ) + c;

    					} else {

    						// region 2

    						s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
    						s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
    						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

    					}

    				}

    			} else {

    				// Ray and segment are parallel.

    				s1 = ( a01 > 0 ) ? - segExtent : segExtent;
    				s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
    				sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

    			}

    			if ( optionalPointOnRay ) {

    				optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );

    			}

    			if ( optionalPointOnSegment ) {

    				optionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );

    			}

    			return sqrDist;

    		};

    	}(),

    	intersectSphere: function () {

    		var v1 = new Vector3();

    		return function intersectSphere( sphere, optionalTarget ) {

    			v1.subVectors( sphere.center, this.origin );
    			var tca = v1.dot( this.direction );
    			var d2 = v1.dot( v1 ) - tca * tca;
    			var radius2 = sphere.radius * sphere.radius;

    			if ( d2 > radius2 ) return null;

    			var thc = Math.sqrt( radius2 - d2 );

    			// t0 = first intersect point - entrance on front of sphere
    			var t0 = tca - thc;

    			// t1 = second intersect point - exit point on back of sphere
    			var t1 = tca + thc;

    			// test to see if both t0 and t1 are behind the ray - if so, return null
    			if ( t0 < 0 && t1 < 0 ) return null;

    			// test to see if t0 is behind the ray:
    			// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
    			// in order to always return an intersect point that is in front of the ray.
    			if ( t0 < 0 ) return this.at( t1, optionalTarget );

    			// else t0 is in front of the ray, so return the first collision point scaled by t0
    			return this.at( t0, optionalTarget );

    		};

    	}(),

    	intersectsSphere: function ( sphere ) {

    		return this.distanceToPoint( sphere.center ) <= sphere.radius;

    	},

    	distanceToPlane: function ( plane ) {

    		var denominator = plane.normal.dot( this.direction );

    		if ( denominator === 0 ) {

    			// line is coplanar, return origin
    			if ( plane.distanceToPoint( this.origin ) === 0 ) {

    				return 0;

    			}

    			// Null is preferable to undefined since undefined means.... it is undefined

    			return null;

    		}

    		var t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

    		// Return if the ray never intersects the plane

    		return t >= 0 ? t :  null;

    	},

    	intersectPlane: function ( plane, optionalTarget ) {

    		var t = this.distanceToPlane( plane );

    		if ( t === null ) {

    			return null;

    		}

    		return this.at( t, optionalTarget );

    	},



    	intersectsPlane: function ( plane ) {

    		// check if the ray lies on the plane first

    		var distToPoint = plane.distanceToPoint( this.origin );

    		if ( distToPoint === 0 ) {

    			return true;

    		}

    		var denominator = plane.normal.dot( this.direction );

    		if ( denominator * distToPoint < 0 ) {

    			return true;

    		}

    		// ray origin is behind the plane (and is pointing behind it)

    		return false;

    	},

    	intersectBox: function ( box, optionalTarget ) {

    		var tmin, tmax, tymin, tymax, tzmin, tzmax;

    		var invdirx = 1 / this.direction.x,
    			invdiry = 1 / this.direction.y,
    			invdirz = 1 / this.direction.z;

    		var origin = this.origin;

    		if ( invdirx >= 0 ) {

    			tmin = ( box.min.x - origin.x ) * invdirx;
    			tmax = ( box.max.x - origin.x ) * invdirx;

    		} else {

    			tmin = ( box.max.x - origin.x ) * invdirx;
    			tmax = ( box.min.x - origin.x ) * invdirx;

    		}

    		if ( invdiry >= 0 ) {

    			tymin = ( box.min.y - origin.y ) * invdiry;
    			tymax = ( box.max.y - origin.y ) * invdiry;

    		} else {

    			tymin = ( box.max.y - origin.y ) * invdiry;
    			tymax = ( box.min.y - origin.y ) * invdiry;

    		}

    		if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

    		// These lines also handle the case where tmin or tmax is NaN
    		// (result of 0 * Infinity). x !== x returns true if x is NaN

    		if ( tymin > tmin || tmin !== tmin ) tmin = tymin;

    		if ( tymax < tmax || tmax !== tmax ) tmax = tymax;

    		if ( invdirz >= 0 ) {

    			tzmin = ( box.min.z - origin.z ) * invdirz;
    			tzmax = ( box.max.z - origin.z ) * invdirz;

    		} else {

    			tzmin = ( box.max.z - origin.z ) * invdirz;
    			tzmax = ( box.min.z - origin.z ) * invdirz;

    		}

    		if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

    		if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

    		if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

    		//return point closest to the ray (positive side)

    		if ( tmax < 0 ) return null;

    		return this.at( tmin >= 0 ? tmin : tmax, optionalTarget );

    	},

    	intersectsBox: ( function () {

    		var v = new Vector3();

    		return function intersectsBox( box ) {

    			return this.intersectBox( box, v ) !== null;

    		};

    	} )(),

    	intersectTriangle: function () {

    		// Compute the offset origin, edges, and normal.
    		var diff = new Vector3();
    		var edge1 = new Vector3();
    		var edge2 = new Vector3();
    		var normal = new Vector3();

    		return function intersectTriangle( a, b, c, backfaceCulling, optionalTarget ) {

    			// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

    			edge1.subVectors( b, a );
    			edge2.subVectors( c, a );
    			normal.crossVectors( edge1, edge2 );

    			// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
    			// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
    			//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
    			//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
    			//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
    			var DdN = this.direction.dot( normal );
    			var sign;

    			if ( DdN > 0 ) {

    				if ( backfaceCulling ) return null;
    				sign = 1;

    			} else if ( DdN < 0 ) {

    				sign = - 1;
    				DdN = - DdN;

    			} else {

    				return null;

    			}

    			diff.subVectors( this.origin, a );
    			var DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );

    			// b1 < 0, no intersection
    			if ( DdQxE2 < 0 ) {

    				return null;

    			}

    			var DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );

    			// b2 < 0, no intersection
    			if ( DdE1xQ < 0 ) {

    				return null;

    			}

    			// b1+b2 > 1, no intersection
    			if ( DdQxE2 + DdE1xQ > DdN ) {

    				return null;

    			}

    			// Line intersects triangle, check if ray does.
    			var QdN = - sign * diff.dot( normal );

    			// t < 0, no intersection
    			if ( QdN < 0 ) {

    				return null;

    			}

    			// Ray intersects triangle.
    			return this.at( QdN / DdN, optionalTarget );

    		};

    	}(),

    	applyMatrix4: function ( matrix4 ) {

    		this.direction.add( this.origin ).applyMatrix4( matrix4 );
    		this.origin.applyMatrix4( matrix4 );
    		this.direction.sub( this.origin );
    		this.direction.normalize();

    		return this;

    	},

    	equals: function ( ray ) {

    		return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

    	}

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author WestLangley / http://github.com/WestLangley
     * @author bhouston / http://clara.io
     */

    function Euler( x, y, z, order ) {

    	this._x = x || 0;
    	this._y = y || 0;
    	this._z = z || 0;
    	this._order = order || Euler.DefaultOrder;

    }

    Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

    Euler.DefaultOrder = 'XYZ';

    Euler.prototype = {

    	constructor: Euler,

    	isEuler: true,

    	get x () {

    		return this._x;

    	},

    	set x ( value ) {

    		this._x = value;
    		this.onChangeCallback();

    	},

    	get y () {

    		return this._y;

    	},

    	set y ( value ) {

    		this._y = value;
    		this.onChangeCallback();

    	},

    	get z () {

    		return this._z;

    	},

    	set z ( value ) {

    		this._z = value;
    		this.onChangeCallback();

    	},

    	get order () {

    		return this._order;

    	},

    	set order ( value ) {

    		this._order = value;
    		this.onChangeCallback();

    	},

    	set: function ( x, y, z, order ) {

    		this._x = x;
    		this._y = y;
    		this._z = z;
    		this._order = order || this._order;

    		this.onChangeCallback();

    		return this;

    	},

    	clone: function () {

    		return new this.constructor( this._x, this._y, this._z, this._order );

    	},

    	copy: function ( euler ) {

    		this._x = euler._x;
    		this._y = euler._y;
    		this._z = euler._z;
    		this._order = euler._order;

    		this.onChangeCallback();

    		return this;

    	},

    	setFromRotationMatrix: function ( m, order, update ) {

    		var clamp = exports.Math.clamp;

    		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

    		var te = m.elements;
    		var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
    		var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
    		var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

    		order = order || this._order;

    		if ( order === 'XYZ' ) {

    			this._y = Math.asin( clamp( m13, - 1, 1 ) );

    			if ( Math.abs( m13 ) < 0.99999 ) {

    				this._x = Math.atan2( - m23, m33 );
    				this._z = Math.atan2( - m12, m11 );

    			} else {

    				this._x = Math.atan2( m32, m22 );
    				this._z = 0;

    			}

    		} else if ( order === 'YXZ' ) {

    			this._x = Math.asin( - clamp( m23, - 1, 1 ) );

    			if ( Math.abs( m23 ) < 0.99999 ) {

    				this._y = Math.atan2( m13, m33 );
    				this._z = Math.atan2( m21, m22 );

    			} else {

    				this._y = Math.atan2( - m31, m11 );
    				this._z = 0;

    			}

    		} else if ( order === 'ZXY' ) {

    			this._x = Math.asin( clamp( m32, - 1, 1 ) );

    			if ( Math.abs( m32 ) < 0.99999 ) {

    				this._y = Math.atan2( - m31, m33 );
    				this._z = Math.atan2( - m12, m22 );

    			} else {

    				this._y = 0;
    				this._z = Math.atan2( m21, m11 );

    			}

    		} else if ( order === 'ZYX' ) {

    			this._y = Math.asin( - clamp( m31, - 1, 1 ) );

    			if ( Math.abs( m31 ) < 0.99999 ) {

    				this._x = Math.atan2( m32, m33 );
    				this._z = Math.atan2( m21, m11 );

    			} else {

    				this._x = 0;
    				this._z = Math.atan2( - m12, m22 );

    			}

    		} else if ( order === 'YZX' ) {

    			this._z = Math.asin( clamp( m21, - 1, 1 ) );

    			if ( Math.abs( m21 ) < 0.99999 ) {

    				this._x = Math.atan2( - m23, m22 );
    				this._y = Math.atan2( - m31, m11 );

    			} else {

    				this._x = 0;
    				this._y = Math.atan2( m13, m33 );

    			}

    		} else if ( order === 'XZY' ) {

    			this._z = Math.asin( - clamp( m12, - 1, 1 ) );

    			if ( Math.abs( m12 ) < 0.99999 ) {

    				this._x = Math.atan2( m32, m22 );
    				this._y = Math.atan2( m13, m11 );

    			} else {

    				this._x = Math.atan2( - m23, m33 );
    				this._y = 0;

    			}

    		} else {

    			console.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order );

    		}

    		this._order = order;

    		if ( update !== false ) this.onChangeCallback();

    		return this;

    	},

    	setFromQuaternion: function () {

    		var matrix;

    		return function setFromQuaternion( q, order, update ) {

    			if ( matrix === undefined ) matrix = new Matrix4();

    			matrix.makeRotationFromQuaternion( q );

    			return this.setFromRotationMatrix( matrix, order, update );

    		};

    	}(),

    	setFromVector3: function ( v, order ) {

    		return this.set( v.x, v.y, v.z, order || this._order );

    	},

    	reorder: function () {

    		// WARNING: this discards revolution information -bhouston

    		var q = new Quaternion();

    		return function reorder( newOrder ) {

    			q.setFromEuler( this );

    			return this.setFromQuaternion( q, newOrder );

    		};

    	}(),

    	equals: function ( euler ) {

    		return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

    	},

    	fromArray: function ( array ) {

    		this._x = array[ 0 ];
    		this._y = array[ 1 ];
    		this._z = array[ 2 ];
    		if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

    		this.onChangeCallback();

    		return this;

    	},

    	toArray: function ( array, offset ) {

    		if ( array === undefined ) array = [];
    		if ( offset === undefined ) offset = 0;

    		array[ offset ] = this._x;
    		array[ offset + 1 ] = this._y;
    		array[ offset + 2 ] = this._z;
    		array[ offset + 3 ] = this._order;

    		return array;

    	},

    	toVector3: function ( optionalResult ) {

    		if ( optionalResult ) {

    			return optionalResult.set( this._x, this._y, this._z );

    		} else {

    			return new Vector3( this._x, this._y, this._z );

    		}

    	},

    	onChange: function ( callback ) {

    		this.onChangeCallback = callback;

    		return this;

    	},

    	onChangeCallback: function () {}

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function Layers() {

    	this.mask = 1;

    }

    Layers.prototype = {

    	constructor: Layers,

    	set: function ( channel ) {

    		this.mask = 1 << channel;

    	},

    	enable: function ( channel ) {

    		this.mask |= 1 << channel;

    	},

    	toggle: function ( channel ) {

    		this.mask ^= 1 << channel;

    	},

    	disable: function ( channel ) {

    		this.mask &= ~ ( 1 << channel );

    	},

    	test: function ( layers ) {

    		return ( this.mask & layers.mask ) !== 0;

    	}

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     * @author WestLangley / http://github.com/WestLangley
     * @author elephantatwork / www.elephantatwork.ch
     */

    function Object3D() {

    	Object.defineProperty( this, 'id', { value: Object3DIdCount() } );

    	this.uuid = exports.Math.generateUUID();

    	this.name = '';
    	this.type = 'Object3D';

    	this.parent = null;
    	this.children = [];

    	this.up = Object3D.DefaultUp.clone();

    	var position = new Vector3();
    	var rotation = new Euler();
    	var quaternion = new Quaternion();
    	var scale = new Vector3( 1, 1, 1 );

    	function onRotationChange() {

    		quaternion.setFromEuler( rotation, false );

    	}

    	function onQuaternionChange() {

    		rotation.setFromQuaternion( quaternion, undefined, false );

    	}

    	rotation.onChange( onRotationChange );
    	quaternion.onChange( onQuaternionChange );

    	Object.defineProperties( this, {
    		position: {
    			enumerable: true,
    			value: position
    		},
    		rotation: {
    			enumerable: true,
    			value: rotation
    		},
    		quaternion: {
    			enumerable: true,
    			value: quaternion
    		},
    		scale: {
    			enumerable: true,
    			value: scale
    		},
    		modelViewMatrix: {
    			value: new Matrix4()
    		},
    		normalMatrix: {
    			value: new Matrix3()
    		}
    	} );

    	this.matrix = new Matrix4();
    	this.matrixWorld = new Matrix4();

    	this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
    	this.matrixWorldNeedsUpdate = false;

    	this.layers = new Layers();
    	this.visible = true;

    	this.castShadow = false;
    	this.receiveShadow = false;

    	this.frustumCulled = true;
    	this.renderOrder = 0;

    	this.userData = {};

    	this.onBeforeRender = null;

    }

    Object3D.DefaultUp = new Vector3( 0, 1, 0 );
    Object3D.DefaultMatrixAutoUpdate = true;

    Object.assign( Object3D.prototype, EventDispatcher.prototype, {

    	isObject3D: true,

    	applyMatrix: function ( matrix ) {

    		this.matrix.multiplyMatrices( matrix, this.matrix );

    		this.matrix.decompose( this.position, this.quaternion, this.scale );

    	},

    	setRotationFromAxisAngle: function ( axis, angle ) {

    		// assumes axis is normalized

    		this.quaternion.setFromAxisAngle( axis, angle );

    	},

    	setRotationFromEuler: function ( euler ) {

    		this.quaternion.setFromEuler( euler, true );

    	},

    	setRotationFromMatrix: function ( m ) {

    		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

    		this.quaternion.setFromRotationMatrix( m );

    	},

    	setRotationFromQuaternion: function ( q ) {

    		// assumes q is normalized

    		this.quaternion.copy( q );

    	},

    	rotateOnAxis: function () {

    		// rotate object on axis in object space
    		// axis is assumed to be normalized

    		var q1 = new Quaternion();

    		return function rotateOnAxis( axis, angle ) {

    			q1.setFromAxisAngle( axis, angle );

    			this.quaternion.multiply( q1 );

    			return this;

    		};

    	}(),

    	rotateX: function () {

    		var v1 = new Vector3( 1, 0, 0 );

    		return function rotateX( angle ) {

    			return this.rotateOnAxis( v1, angle );

    		};

    	}(),

    	rotateY: function () {

    		var v1 = new Vector3( 0, 1, 0 );

    		return function rotateY( angle ) {

    			return this.rotateOnAxis( v1, angle );

    		};

    	}(),

    	rotateZ: function () {

    		var v1 = new Vector3( 0, 0, 1 );

    		return function rotateZ( angle ) {

    			return this.rotateOnAxis( v1, angle );

    		};

    	}(),

    	translateOnAxis: function () {

    		// translate object by distance along axis in object space
    		// axis is assumed to be normalized

    		var v1 = new Vector3();

    		return function translateOnAxis( axis, distance ) {

    			v1.copy( axis ).applyQuaternion( this.quaternion );

    			this.position.add( v1.multiplyScalar( distance ) );

    			return this;

    		};

    	}(),

    	translateX: function () {

    		var v1 = new Vector3( 1, 0, 0 );

    		return function translateX( distance ) {

    			return this.translateOnAxis( v1, distance );

    		};

    	}(),

    	translateY: function () {

    		var v1 = new Vector3( 0, 1, 0 );

    		return function translateY( distance ) {

    			return this.translateOnAxis( v1, distance );

    		};

    	}(),

    	translateZ: function () {

    		var v1 = new Vector3( 0, 0, 1 );

    		return function translateZ( distance ) {

    			return this.translateOnAxis( v1, distance );

    		};

    	}(),

    	localToWorld: function ( vector ) {

    		return vector.applyMatrix4( this.matrixWorld );

    	},

    	worldToLocal: function () {

    		var m1 = new Matrix4();

    		return function worldToLocal( vector ) {

    			return vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );

    		};

    	}(),

    	lookAt: function () {

    		// This routine does not support objects with rotated and/or translated parent(s)

    		var m1 = new Matrix4();

    		return function lookAt( vector ) {

    			m1.lookAt( vector, this.position, this.up );

    			this.quaternion.setFromRotationMatrix( m1 );

    		};

    	}(),

    	add: function ( object ) {

    		if ( arguments.length > 1 ) {

    			for ( var i = 0; i < arguments.length; i ++ ) {

    				this.add( arguments[ i ] );

    			}

    			return this;

    		}

    		if ( object === this ) {

    			console.error( "THREE.Object3D.add: object can't be added as a child of itself.", object );
    			return this;

    		}

    		if ( (object && object.isObject3D) ) {

    			if ( object.parent !== null ) {

    				object.parent.remove( object );

    			}

    			object.parent = this;
    			object.dispatchEvent( { type: 'added' } );

    			this.children.push( object );

    		} else {

    			console.error( "THREE.Object3D.add: object not an instance of THREE.Object3D.", object );

    		}

    		return this;

    	},

    	remove: function ( object ) {

    		if ( arguments.length > 1 ) {

    			for ( var i = 0; i < arguments.length; i ++ ) {

    				this.remove( arguments[ i ] );

    			}

    		}

    		var index = this.children.indexOf( object );

    		if ( index !== - 1 ) {

    			object.parent = null;

    			object.dispatchEvent( { type: 'removed' } );

    			this.children.splice( index, 1 );

    		}

    	},

    	getObjectById: function ( id ) {

    		return this.getObjectByProperty( 'id', id );

    	},

    	getObjectByName: function ( name ) {

    		return this.getObjectByProperty( 'name', name );

    	},

    	getObjectByProperty: function ( name, value ) {

    		if ( this[ name ] === value ) return this;

    		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

    			var child = this.children[ i ];
    			var object = child.getObjectByProperty( name, value );

    			if ( object !== undefined ) {

    				return object;

    			}

    		}

    		return undefined;

    	},

    	getWorldPosition: function ( optionalTarget ) {

    		var result = optionalTarget || new Vector3();

    		this.updateMatrixWorld( true );

    		return result.setFromMatrixPosition( this.matrixWorld );

    	},

    	getWorldQuaternion: function () {

    		var position = new Vector3();
    		var scale = new Vector3();

    		return function getWorldQuaternion( optionalTarget ) {

    			var result = optionalTarget || new Quaternion();

    			this.updateMatrixWorld( true );

    			this.matrixWorld.decompose( position, result, scale );

    			return result;

    		};

    	}(),

    	getWorldRotation: function () {

    		var quaternion = new Quaternion();

    		return function getWorldRotation( optionalTarget ) {

    			var result = optionalTarget || new Euler();

    			this.getWorldQuaternion( quaternion );

    			return result.setFromQuaternion( quaternion, this.rotation.order, false );

    		};

    	}(),

    	getWorldScale: function () {

    		var position = new Vector3();
    		var quaternion = new Quaternion();

    		return function getWorldScale( optionalTarget ) {

    			var result = optionalTarget || new Vector3();

    			this.updateMatrixWorld( true );

    			this.matrixWorld.decompose( position, quaternion, result );

    			return result;

    		};

    	}(),

    	getWorldDirection: function () {

    		var quaternion = new Quaternion();

    		return function getWorldDirection( optionalTarget ) {

    			var result = optionalTarget || new Vector3();

    			this.getWorldQuaternion( quaternion );

    			return result.set( 0, 0, 1 ).applyQuaternion( quaternion );

    		};

    	}(),

    	raycast: function () {},

    	traverse: function ( callback ) {

    		callback( this );

    		var children = this.children;

    		for ( var i = 0, l = children.length; i < l; i ++ ) {

    			children[ i ].traverse( callback );

    		}

    	},

    	traverseVisible: function ( callback ) {

    		if ( this.visible === false ) return;

    		callback( this );

    		var children = this.children;

    		for ( var i = 0, l = children.length; i < l; i ++ ) {

    			children[ i ].traverseVisible( callback );

    		}

    	},

    	traverseAncestors: function ( callback ) {

    		var parent = this.parent;

    		if ( parent !== null ) {

    			callback( parent );

    			parent.traverseAncestors( callback );

    		}

    	},

    	updateMatrix: function () {

    		this.matrix.compose( this.position, this.quaternion, this.scale );

    		this.matrixWorldNeedsUpdate = true;

    	},

    	updateMatrixWorld: function ( force ) {

    		if ( this.matrixAutoUpdate === true ) this.updateMatrix();

    		if ( this.matrixWorldNeedsUpdate === true || force === true ) {

    			if ( this.parent === null ) {

    				this.matrixWorld.copy( this.matrix );

    			} else {

    				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

    			}

    			this.matrixWorldNeedsUpdate = false;

    			force = true;

    		}

    		// update children

    		var children = this.children;

    		for ( var i = 0, l = children.length; i < l; i ++ ) {

    			children[ i ].updateMatrixWorld( force );

    		}

    	},

    	toJSON: function ( meta ) {

    		// meta is '' when called from JSON.stringify
    		var isRootObject = ( meta === undefined || meta === '' );

    		var output = {};

    		// meta is a hash used to collect geometries, materials.
    		// not providing it implies that this is the root object
    		// being serialized.
    		if ( isRootObject ) {

    			// initialize meta obj
    			meta = {
    				geometries: {},
    				materials: {},
    				textures: {},
    				images: {}
    			};

    			output.metadata = {
    				version: 4.4,
    				type: 'Object',
    				generator: 'Object3D.toJSON'
    			};

    		}

    		// standard Object3D serialization

    		var object = {};

    		object.uuid = this.uuid;
    		object.type = this.type;

    		if ( this.name !== '' ) object.name = this.name;
    		if ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;
    		if ( this.castShadow === true ) object.castShadow = true;
    		if ( this.receiveShadow === true ) object.receiveShadow = true;
    		if ( this.visible === false ) object.visible = false;

    		object.matrix = this.matrix.toArray();

    		//

    		if ( this.geometry !== undefined ) {

    			if ( meta.geometries[ this.geometry.uuid ] === undefined ) {

    				meta.geometries[ this.geometry.uuid ] = this.geometry.toJSON( meta );

    			}

    			object.geometry = this.geometry.uuid;

    		}

    		if ( this.material !== undefined ) {

    			if ( meta.materials[ this.material.uuid ] === undefined ) {

    				meta.materials[ this.material.uuid ] = this.material.toJSON( meta );

    			}

    			object.material = this.material.uuid;

    		}

    		//

    		if ( this.children.length > 0 ) {

    			object.children = [];

    			for ( var i = 0; i < this.children.length; i ++ ) {

    				object.children.push( this.children[ i ].toJSON( meta ).object );

    			}

    		}

    		if ( isRootObject ) {

    			var geometries = extractFromCache( meta.geometries );
    			var materials = extractFromCache( meta.materials );
    			var textures = extractFromCache( meta.textures );
    			var images = extractFromCache( meta.images );

    			if ( geometries.length > 0 ) output.geometries = geometries;
    			if ( materials.length > 0 ) output.materials = materials;
    			if ( textures.length > 0 ) output.textures = textures;
    			if ( images.length > 0 ) output.images = images;

    		}

    		output.object = object;

    		return output;

    		// extract data from the cache hash
    		// remove metadata on each item
    		// and return as array
    		function extractFromCache( cache ) {

    			var values = [];
    			for ( var key in cache ) {

    				var data = cache[ key ];
    				delete data.metadata;
    				values.push( data );

    			}
    			return values;

    		}

    	},

    	clone: function ( recursive ) {

    		return new this.constructor().copy( this, recursive );

    	},

    	copy: function ( source, recursive ) {

    		if ( recursive === undefined ) recursive = true;

    		this.name = source.name;

    		this.up.copy( source.up );

    		this.position.copy( source.position );
    		this.quaternion.copy( source.quaternion );
    		this.scale.copy( source.scale );

    		this.matrix.copy( source.matrix );
    		this.matrixWorld.copy( source.matrixWorld );

    		this.matrixAutoUpdate = source.matrixAutoUpdate;
    		this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

    		this.visible = source.visible;

    		this.castShadow = source.castShadow;
    		this.receiveShadow = source.receiveShadow;

    		this.frustumCulled = source.frustumCulled;
    		this.renderOrder = source.renderOrder;

    		this.userData = JSON.parse( JSON.stringify( source.userData ) );

    		if ( recursive === true ) {

    			for ( var i = 0; i < source.children.length; i ++ ) {

    				var child = source.children[ i ];
    				this.add( child.clone() );

    			}

    		}

    		return this;

    	}

    } );

    var count$2 = 0;
    function Object3DIdCount() { return count$2++; };

    /**
     * @author bhouston / http://clara.io
     */

    function Line3( start, end ) {

    	this.start = ( start !== undefined ) ? start : new Vector3();
    	this.end = ( end !== undefined ) ? end : new Vector3();

    }

    Line3.prototype = {

    	constructor: Line3,

    	set: function ( start, end ) {

    		this.start.copy( start );
    		this.end.copy( end );

    		return this;

    	},

    	clone: function () {

    		return new this.constructor().copy( this );

    	},

    	copy: function ( line ) {

    		this.start.copy( line.start );
    		this.end.copy( line.end );

    		return this;

    	},

    	getCenter: function ( optionalTarget ) {

    		var result = optionalTarget || new Vector3();
    		return result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );

    	},

    	delta: function ( optionalTarget ) {

    		var result = optionalTarget || new Vector3();
    		return result.subVectors( this.end, this.start );

    	},

    	distanceSq: function () {

    		return this.start.distanceToSquared( this.end );

    	},

    	distance: function () {

    		return this.start.distanceTo( this.end );

    	},

    	at: function ( t, optionalTarget ) {

    		var result = optionalTarget || new Vector3();

    		return this.delta( result ).multiplyScalar( t ).add( this.start );

    	},

    	closestPointToPointParameter: function () {

    		var startP = new Vector3();
    		var startEnd = new Vector3();

    		return function closestPointToPointParameter( point, clampToLine ) {

    			startP.subVectors( point, this.start );
    			startEnd.subVectors( this.end, this.start );

    			var startEnd2 = startEnd.dot( startEnd );
    			var startEnd_startP = startEnd.dot( startP );

    			var t = startEnd_startP / startEnd2;

    			if ( clampToLine ) {

    				t = exports.Math.clamp( t, 0, 1 );

    			}

    			return t;

    		};

    	}(),

    	closestPointToPoint: function ( point, clampToLine, optionalTarget ) {

    		var t = this.closestPointToPointParameter( point, clampToLine );

    		var result = optionalTarget || new Vector3();

    		return this.delta( result ).multiplyScalar( t ).add( this.start );

    	},

    	applyMatrix4: function ( matrix ) {

    		this.start.applyMatrix4( matrix );
    		this.end.applyMatrix4( matrix );

    		return this;

    	},

    	equals: function ( line ) {

    		return line.start.equals( this.start ) && line.end.equals( this.end );

    	}

    };

    /**
     * @author bhouston / http://clara.io
     * @author mrdoob / http://mrdoob.com/
     */

    function Triangle( a, b, c ) {

    	this.a = ( a !== undefined ) ? a : new Vector3();
    	this.b = ( b !== undefined ) ? b : new Vector3();
    	this.c = ( c !== undefined ) ? c : new Vector3();

    }

    Triangle.normal = function () {

    	var v0 = new Vector3();

    	return function normal( a, b, c, optionalTarget ) {

    		var result = optionalTarget || new Vector3();

    		result.subVectors( c, b );
    		v0.subVectors( a, b );
    		result.cross( v0 );

    		var resultLengthSq = result.lengthSq();
    		if ( resultLengthSq > 0 ) {

    			return result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );

    		}

    		return result.set( 0, 0, 0 );

    	};

    }();

    // static/instance method to calculate barycentric coordinates
    // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
    Triangle.barycoordFromPoint = function () {

    	var v0 = new Vector3();
    	var v1 = new Vector3();
    	var v2 = new Vector3();

    	return function barycoordFromPoint( point, a, b, c, optionalTarget ) {

    		v0.subVectors( c, a );
    		v1.subVectors( b, a );
    		v2.subVectors( point, a );

    		var dot00 = v0.dot( v0 );
    		var dot01 = v0.dot( v1 );
    		var dot02 = v0.dot( v2 );
    		var dot11 = v1.dot( v1 );
    		var dot12 = v1.dot( v2 );

    		var denom = ( dot00 * dot11 - dot01 * dot01 );

    		var result = optionalTarget || new Vector3();

    		// collinear or singular triangle
    		if ( denom === 0 ) {

    			// arbitrary location outside of triangle?
    			// not sure if this is the best idea, maybe should be returning undefined
    			return result.set( - 2, - 1, - 1 );

    		}

    		var invDenom = 1 / denom;
    		var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
    		var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

    		// barycentric coordinates must always sum to 1
    		return result.set( 1 - u - v, v, u );

    	};

    }();

    Triangle.containsPoint = function () {

    	var v1 = new Vector3();

    	return function containsPoint( point, a, b, c ) {

    		var result = Triangle.barycoordFromPoint( point, a, b, c, v1 );

    		return ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );

    	};

    }();

    Triangle.prototype = {

    	constructor: Triangle,

    	set: function ( a, b, c ) {

    		this.a.copy( a );
    		this.b.copy( b );
    		this.c.copy( c );

    		return this;

    	},

    	setFromPointsAndIndices: function ( points, i0, i1, i2 ) {

    		this.a.copy( points[ i0 ] );
    		this.b.copy( points[ i1 ] );
    		this.c.copy( points[ i2 ] );

    		return this;

    	},

    	clone: function () {

    		return new this.constructor().copy( this );

    	},

    	copy: function ( triangle ) {

    		this.a.copy( triangle.a );
    		this.b.copy( triangle.b );
    		this.c.copy( triangle.c );

    		return this;

    	},

    	area: function () {

    		var v0 = new Vector3();
    		var v1 = new Vector3();

    		return function area() {

    			v0.subVectors( this.c, this.b );
    			v1.subVectors( this.a, this.b );

    			return v0.cross( v1 ).length() * 0.5;

    		};

    	}(),

    	midpoint: function ( optionalTarget ) {

    		var result = optionalTarget || new Vector3();
    		return result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

    	},

    	normal: function ( optionalTarget ) {

    		return Triangle.normal( this.a, this.b, this.c, optionalTarget );

    	},

    	plane: function ( optionalTarget ) {

    		var result = optionalTarget || new Plane();

    		return result.setFromCoplanarPoints( this.a, this.b, this.c );

    	},

    	barycoordFromPoint: function ( point, optionalTarget ) {

    		return Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );

    	},

    	containsPoint: function ( point ) {

    		return Triangle.containsPoint( point, this.a, this.b, this.c );

    	},

    	closestPointToPoint: function () {

    		var plane, edgeList, projectedPoint, closestPoint;

    		return function closestPointToPoint( point, optionalTarget ) {

    			if ( plane === undefined ) {

    				plane = new Plane();
    				edgeList = [ new Line3(), new Line3(), new Line3() ];
    				projectedPoint = new Vector3();
    				closestPoint = new Vector3();

    			}

    			var result = optionalTarget || new Vector3();
    			var minDistance = Infinity;

    			// project the point onto the plane of the triangle

    			plane.setFromCoplanarPoints( this.a, this.b, this.c );
    			plane.projectPoint( point, projectedPoint );

    			// check if the projection lies within the triangle

    			if( this.containsPoint( projectedPoint ) === true ) {

    				// if so, this is the closest point

    				result.copy( projectedPoint );

    			} else {

    				// if not, the point falls outside the triangle. the result is the closest point to the triangle's edges or vertices

    				edgeList[ 0 ].set( this.a, this.b );
    				edgeList[ 1 ].set( this.b, this.c );
    				edgeList[ 2 ].set( this.c, this.a );

    				for( var i = 0; i < edgeList.length; i ++ ) {

    					edgeList[ i ].closestPointToPoint( projectedPoint, true, closestPoint );

    					var distance = projectedPoint.distanceToSquared( closestPoint );

    					if( distance < minDistance ) {

    						minDistance = distance;

    						result.copy( closestPoint );

    					}

    				}

    			}

    			return result;

    		};

    	}(),

    	equals: function ( triangle ) {

    		return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

    	}

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     */

    function Face3( a, b, c, normal, color, materialIndex ) {

    	this.a = a;
    	this.b = b;
    	this.c = c;

    	this.normal = (normal && normal.isVector3) ? normal : new Vector3();
    	this.vertexNormals = Array.isArray( normal ) ? normal : [];

    	this.color = (color && color.isColor) ? color : new Color();
    	this.vertexColors = Array.isArray( color ) ? color : [];

    	this.materialIndex = materialIndex !== undefined ? materialIndex : 0;

    }

    Face3.prototype = {

    	constructor: Face3,

    	clone: function () {

    		return new this.constructor().copy( this );

    	},

    	copy: function ( source ) {

    		this.a = source.a;
    		this.b = source.b;
    		this.c = source.c;

    		this.normal.copy( source.normal );
    		this.color.copy( source.color );

    		this.materialIndex = source.materialIndex;

    		for ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {

    			this.vertexNormals[ i ] = source.vertexNormals[ i ].clone();

    		}

    		for ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {

    			this.vertexColors[ i ] = source.vertexColors[ i ].clone();

    		}

    		return this;

    	}

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     *
     * parameters = {
     *  color: <hex>,
     *  opacity: <float>,
     *  map: new THREE.Texture( <Image> ),
     *
     *  aoMap: new THREE.Texture( <Image> ),
     *  aoMapIntensity: <float>
     *
     *  specularMap: new THREE.Texture( <Image> ),
     *
     *  alphaMap: new THREE.Texture( <Image> ),
     *
     *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
     *  combine: THREE.Multiply,
     *  reflectivity: <float>,
     *  refractionRatio: <float>,
     *
     *  shading: THREE.SmoothShading,
     *  depthTest: <bool>,
     *  depthWrite: <bool>,
     *
     *  wireframe: <boolean>,
     *  wireframeLinewidth: <float>,
     *
     *  skinning: <bool>,
     *  morphTargets: <bool>
     * }
     */

    function MeshBasicMaterial( parameters ) {

    	Material.call( this );

    	this.type = 'MeshBasicMaterial';

    	this.color = new Color( 0xffffff ); // emissive

    	this.map = null;

    	this.aoMap = null;
    	this.aoMapIntensity = 1.0;

    	this.specularMap = null;

    	this.alphaMap = null;

    	this.envMap = null;
    	this.combine = MultiplyOperation;
    	this.reflectivity = 1;
    	this.refractionRatio = 0.98;

    	this.wireframe = false;
    	this.wireframeLinewidth = 1;
    	this.wireframeLinecap = 'round';
    	this.wireframeLinejoin = 'round';

    	this.skinning = false;
    	this.morphTargets = false;

    	this.lights = false;

    	this.setValues( parameters );

    }

    MeshBasicMaterial.prototype = Object.create( Material.prototype );
    MeshBasicMaterial.prototype.constructor = MeshBasicMaterial;

    MeshBasicMaterial.prototype.isMeshBasicMaterial = true;

    MeshBasicMaterial.prototype.copy = function ( source ) {

    	Material.prototype.copy.call( this, source );

    	this.color.copy( source.color );

    	this.map = source.map;

    	this.aoMap = source.aoMap;
    	this.aoMapIntensity = source.aoMapIntensity;

    	this.specularMap = source.specularMap;

    	this.alphaMap = source.alphaMap;

    	this.envMap = source.envMap;
    	this.combine = source.combine;
    	this.reflectivity = source.reflectivity;
    	this.refractionRatio = source.refractionRatio;

    	this.wireframe = source.wireframe;
    	this.wireframeLinewidth = source.wireframeLinewidth;
    	this.wireframeLinecap = source.wireframeLinecap;
    	this.wireframeLinejoin = source.wireframeLinejoin;

    	this.skinning = source.skinning;
    	this.morphTargets = source.morphTargets;

    	return this;

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function BufferAttribute( array, itemSize, normalized ) {

    	if ( Array.isArray( array ) ) {

    		throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

    	}

    	this.uuid = exports.Math.generateUUID();

    	this.array = array;
    	this.itemSize = itemSize;
    	this.count = array !== undefined ? array.length / itemSize : 0;
    	this.normalized = normalized === true;

    	this.dynamic = false;
    	this.updateRange = { offset: 0, count: - 1 };

    	this.version = 0;

    }

    BufferAttribute.prototype = {

    	constructor: BufferAttribute,

    	isBufferAttribute: true,

    	set needsUpdate( value ) {

    		if ( value === true ) this.version ++;

    	},

    	setDynamic: function ( value ) {

    		this.dynamic = value;

    		return this;

    	},

    	copy: function ( source ) {

    		this.array = new source.array.constructor( source.array );
    		this.itemSize = source.itemSize;
    		this.count = source.count;
    		this.normalized = source.normalized;

    		this.dynamic = source.dynamic;

    		return this;

    	},

    	copyAt: function ( index1, attribute, index2 ) {

    		index1 *= this.itemSize;
    		index2 *= attribute.itemSize;

    		for ( var i = 0, l = this.itemSize; i < l; i ++ ) {

    			this.array[ index1 + i ] = attribute.array[ index2 + i ];

    		}

    		return this;

    	},

    	copyArray: function ( array ) {

    		this.array.set( array );

    		return this;

    	},

    	copyColorsArray: function ( colors ) {

    		var array = this.array, offset = 0;

    		for ( var i = 0, l = colors.length; i < l; i ++ ) {

    			var color = colors[ i ];

    			if ( color === undefined ) {

    				console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );
    				color = new Color();

    			}

    			array[ offset ++ ] = color.r;
    			array[ offset ++ ] = color.g;
    			array[ offset ++ ] = color.b;

    		}

    		return this;

    	},

    	copyIndicesArray: function ( indices ) {

    		var array = this.array, offset = 0;

    		for ( var i = 0, l = indices.length; i < l; i ++ ) {

    			var index = indices[ i ];

    			array[ offset ++ ] = index.a;
    			array[ offset ++ ] = index.b;
    			array[ offset ++ ] = index.c;

    		}

    		return this;

    	},

    	copyVector2sArray: function ( vectors ) {

    		var array = this.array, offset = 0;

    		for ( var i = 0, l = vectors.length; i < l; i ++ ) {

    			var vector = vectors[ i ];

    			if ( vector === undefined ) {

    				console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );
    				vector = new Vector2();

    			}

    			array[ offset ++ ] = vector.x;
    			array[ offset ++ ] = vector.y;

    		}

    		return this;

    	},

    	copyVector3sArray: function ( vectors ) {

    		var array = this.array, offset = 0;

    		for ( var i = 0, l = vectors.length; i < l; i ++ ) {

    			var vector = vectors[ i ];

    			if ( vector === undefined ) {

    				console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );
    				vector = new Vector3();

    			}

    			array[ offset ++ ] = vector.x;
    			array[ offset ++ ] = vector.y;
    			array[ offset ++ ] = vector.z;

    		}

    		return this;

    	},

    	copyVector4sArray: function ( vectors ) {

    		var array = this.array, offset = 0;

    		for ( var i = 0, l = vectors.length; i < l; i ++ ) {

    			var vector = vectors[ i ];

    			if ( vector === undefined ) {

    				console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );
    				vector = new Vector4();

    			}

    			array[ offset ++ ] = vector.x;
    			array[ offset ++ ] = vector.y;
    			array[ offset ++ ] = vector.z;
    			array[ offset ++ ] = vector.w;

    		}

    		return this;

    	},

    	set: function ( value, offset ) {

    		if ( offset === undefined ) offset = 0;

    		this.array.set( value, offset );

    		return this;

    	},

    	getX: function ( index ) {

    		return this.array[ index * this.itemSize ];

    	},

    	setX: function ( index, x ) {

    		this.array[ index * this.itemSize ] = x;

    		return this;

    	},

    	getY: function ( index ) {

    		return this.array[ index * this.itemSize + 1 ];

    	},

    	setY: function ( index, y ) {

    		this.array[ index * this.itemSize + 1 ] = y;

    		return this;

    	},

    	getZ: function ( index ) {

    		return this.array[ index * this.itemSize + 2 ];

    	},

    	setZ: function ( index, z ) {

    		this.array[ index * this.itemSize + 2 ] = z;

    		return this;

    	},

    	getW: function ( index ) {

    		return this.array[ index * this.itemSize + 3 ];

    	},

    	setW: function ( index, w ) {

    		this.array[ index * this.itemSize + 3 ] = w;

    		return this;

    	},

    	setXY: function ( index, x, y ) {

    		index *= this.itemSize;

    		this.array[ index + 0 ] = x;
    		this.array[ index + 1 ] = y;

    		return this;

    	},

    	setXYZ: function ( index, x, y, z ) {

    		index *= this.itemSize;

    		this.array[ index + 0 ] = x;
    		this.array[ index + 1 ] = y;
    		this.array[ index + 2 ] = z;

    		return this;

    	},

    	setXYZW: function ( index, x, y, z, w ) {

    		index *= this.itemSize;

    		this.array[ index + 0 ] = x;
    		this.array[ index + 1 ] = y;
    		this.array[ index + 2 ] = z;
    		this.array[ index + 3 ] = w;

    		return this;

    	},

    	clone: function () {

    		return new this.constructor().copy( this );

    	}

    };

    //

    function Int8Attribute( array, itemSize ) {

    	return new BufferAttribute( new Int8Array( array ), itemSize );

    }

    function Uint8Attribute( array, itemSize ) {

    	return new BufferAttribute( new Uint8Array( array ), itemSize );

    }

    function Uint8ClampedAttribute( array, itemSize ) {

    	return new BufferAttribute( new Uint8ClampedArray( array ), itemSize );

    }

    function Int16Attribute( array, itemSize ) {

    	return new BufferAttribute( new Int16Array( array ), itemSize );

    }

    function Uint16Attribute( array, itemSize ) {

    	return new BufferAttribute( new Uint16Array( array ), itemSize );

    }

    function Int32Attribute( array, itemSize ) {

    	return new BufferAttribute( new Int32Array( array ), itemSize );

    }

    function Uint32Attribute( array, itemSize ) {

    	return new BufferAttribute( new Uint32Array( array ), itemSize );

    }

    function Float32Attribute( array, itemSize ) {

    	return new BufferAttribute( new Float32Array( array ), itemSize );

    }

    function Float64Attribute( array, itemSize ) {

    	return new BufferAttribute( new Float64Array( array ), itemSize );

    }

    // Deprecated

    function DynamicBufferAttribute( array, itemSize ) {

    	console.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.' );
    	return new BufferAttribute( array, itemSize ).setDynamic( true );

    }

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author kile / http://kile.stravaganza.org/
     * @author alteredq / http://alteredqualia.com/
     * @author mikael emtinger / http://gomo.se/
     * @author zz85 / http://www.lab4games.net/zz85/blog
     * @author bhouston / http://clara.io
     */

    function Geometry() {

    	Object.defineProperty( this, 'id', { value: GeometryIdCount() } );

    	this.uuid = exports.Math.generateUUID();

    	this.name = '';
    	this.type = 'Geometry';

    	this.vertices = [];
    	this.colors = [];
    	this.faces = [];
    	this.faceVertexUvs = [ [] ];

    	this.morphTargets = [];
    	this.morphNormals = [];

    	this.skinWeights = [];
    	this.skinIndices = [];

    	this.lineDistances = [];

    	this.boundingBox = null;
    	this.boundingSphere = null;

    	// update flags

    	this.elementsNeedUpdate = false;
    	this.verticesNeedUpdate = false;
    	this.uvsNeedUpdate = false;
    	this.normalsNeedUpdate = false;
    	this.colorsNeedUpdate = false;
    	this.lineDistancesNeedUpdate = false;
    	this.groupsNeedUpdate = false;

    }

    Object.assign( Geometry.prototype, EventDispatcher.prototype, {

    	isGeometry: true,

    	applyMatrix: function ( matrix ) {

    		var normalMatrix = new Matrix3().getNormalMatrix( matrix );

    		for ( var i = 0, il = this.vertices.length; i < il; i ++ ) {

    			var vertex = this.vertices[ i ];
    			vertex.applyMatrix4( matrix );

    		}

    		for ( var i = 0, il = this.faces.length; i < il; i ++ ) {

    			var face = this.faces[ i ];
    			face.normal.applyMatrix3( normalMatrix ).normalize();

    			for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

    				face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();

    			}

    		}

    		if ( this.boundingBox !== null ) {

    			this.computeBoundingBox();

    		}

    		if ( this.boundingSphere !== null ) {

    			this.computeBoundingSphere();

    		}

    		this.verticesNeedUpdate = true;
    		this.normalsNeedUpdate = true;

    		return this;

    	},

    	rotateX: function () {

    		// rotate geometry around world x-axis

    		var m1;

    		return function rotateX( angle ) {

    			if ( m1 === undefined ) m1 = new Matrix4();

    			m1.makeRotationX( angle );

    			this.applyMatrix( m1 );

    			return this;

    		};

    	}(),

    	rotateY: function () {

    		// rotate geometry around world y-axis

    		var m1;

    		return function rotateY( angle ) {

    			if ( m1 === undefined ) m1 = new Matrix4();

    			m1.makeRotationY( angle );

    			this.applyMatrix( m1 );

    			return this;

    		};

    	}(),

    	rotateZ: function () {

    		// rotate geometry around world z-axis

    		var m1;

    		return function rotateZ( angle ) {

    			if ( m1 === undefined ) m1 = new Matrix4();

    			m1.makeRotationZ( angle );

    			this.applyMatrix( m1 );

    			return this;

    		};

    	}(),

    	translate: function () {

    		// translate geometry

    		var m1;

    		return function translate( x, y, z ) {

    			if ( m1 === undefined ) m1 = new Matrix4();

    			m1.makeTranslation( x, y, z );

    			this.applyMatrix( m1 );

    			return this;

    		};

    	}(),

    	scale: function () {

    		// scale geometry

    		var m1;

    		return function scale( x, y, z ) {

    			if ( m1 === undefined ) m1 = new Matrix4();

    			m1.makeScale( x, y, z );

    			this.applyMatrix( m1 );

    			return this;

    		};

    	}(),

    	lookAt: function () {

    		var obj;

    		return function lookAt( vector ) {

    			if ( obj === undefined ) obj = new Object3D();

    			obj.lookAt( vector );

    			obj.updateMatrix();

    			this.applyMatrix( obj.matrix );

    		};

    	}(),

    	fromBufferGeometry: function ( geometry ) {

    		var scope = this;

    		var indices = geometry.index !== null ? geometry.index.array : undefined;
    		var attributes = geometry.attributes;

    		var positions = attributes.position.array;
    		var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
    		var colors = attributes.color !== undefined ? attributes.color.array : undefined;
    		var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
    		var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;

    		if ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];

    		var tempNormals = [];
    		var tempUVs = [];
    		var tempUVs2 = [];

    		for ( var i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {

    			scope.vertices.push( new Vector3( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] ) );

    			if ( normals !== undefined ) {

    				tempNormals.push( new Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );

    			}

    			if ( colors !== undefined ) {

    				scope.colors.push( new Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );

    			}

    			if ( uvs !== undefined ) {

    				tempUVs.push( new Vector2( uvs[ j ], uvs[ j + 1 ] ) );

    			}

    			if ( uvs2 !== undefined ) {

    				tempUVs2.push( new Vector2( uvs2[ j ], uvs2[ j + 1 ] ) );

    			}

    		}

    		function addFace( a, b, c, materialIndex ) {

    			var vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];
    			var vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];

    			var face = new Face3( a, b, c, vertexNormals, vertexColors, materialIndex );

    			scope.faces.push( face );

    			if ( uvs !== undefined ) {

    				scope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );

    			}

    			if ( uvs2 !== undefined ) {

    				scope.faceVertexUvs[ 1 ].push( [ tempUVs2[ a ].clone(), tempUVs2[ b ].clone(), tempUVs2[ c ].clone() ] );

    			}

    		}

    		if ( indices !== undefined ) {

    			var groups = geometry.groups;

    			if ( groups.length > 0 ) {

    				for ( var i = 0; i < groups.length; i ++ ) {

    					var group = groups[ i ];

    					var start = group.start;
    					var count = group.count;

    					for ( var j = start, jl = start + count; j < jl; j += 3 ) {

    						addFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ], group.materialIndex  );

    					}

    				}

    			} else {

    				for ( var i = 0; i < indices.length; i += 3 ) {

    					addFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );

    				}

    			}

    		} else {

    			for ( var i = 0; i < positions.length / 3; i += 3 ) {

    				addFace( i, i + 1, i + 2 );

    			}

    		}

    		this.computeFaceNormals();

    		if ( geometry.boundingBox !== null ) {

    			this.boundingBox = geometry.boundingBox.clone();

    		}

    		if ( geometry.boundingSphere !== null ) {

    			this.boundingSphere = geometry.boundingSphere.clone();

    		}

    		return this;

    	},

    	center: function () {

    		this.computeBoundingBox();

    		var offset = this.boundingBox.getCenter().negate();

    		this.translate( offset.x, offset.y, offset.z );

    		return offset;

    	},

    	normalize: function () {

    		this.computeBoundingSphere();

    		var center = this.boundingSphere.center;
    		var radius = this.boundingSphere.radius;

    		var s = radius === 0 ? 1 : 1.0 / radius;

    		var matrix = new Matrix4();
    		matrix.set(
    			s, 0, 0, - s * center.x,
    			0, s, 0, - s * center.y,
    			0, 0, s, - s * center.z,
    			0, 0, 0, 1
    		);

    		this.applyMatrix( matrix );

    		return this;

    	},

    	computeFaceNormals: function () {

    		var cb = new Vector3(), ab = new Vector3();

    		for ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {

    			var face = this.faces[ f ];

    			var vA = this.vertices[ face.a ];
    			var vB = this.vertices[ face.b ];
    			var vC = this.vertices[ face.c ];

    			cb.subVectors( vC, vB );
    			ab.subVectors( vA, vB );
    			cb.cross( ab );

    			cb.normalize();

    			face.normal.copy( cb );

    		}

    	},

    	computeVertexNormals: function ( areaWeighted ) {

    		if ( areaWeighted === undefined ) areaWeighted = true;

    		var v, vl, f, fl, face, vertices;

    		vertices = new Array( this.vertices.length );

    		for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

    			vertices[ v ] = new Vector3();

    		}

    		if ( areaWeighted ) {

    			// vertex normals weighted by triangle areas
    			// http://www.iquilezles.org/www/articles/normals/normals.htm

    			var vA, vB, vC;
    			var cb = new Vector3(), ab = new Vector3();

    			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

    				face = this.faces[ f ];

    				vA = this.vertices[ face.a ];
    				vB = this.vertices[ face.b ];
    				vC = this.vertices[ face.c ];

    				cb.subVectors( vC, vB );
    				ab.subVectors( vA, vB );
    				cb.cross( ab );

    				vertices[ face.a ].add( cb );
    				vertices[ face.b ].add( cb );
    				vertices[ face.c ].add( cb );

    			}

    		} else {

    			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

    				face = this.faces[ f ];

    				vertices[ face.a ].add( face.normal );
    				vertices[ face.b ].add( face.normal );
    				vertices[ face.c ].add( face.normal );

    			}

    		}

    		for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

    			vertices[ v ].normalize();

    		}

    		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

    			face = this.faces[ f ];

    			var vertexNormals = face.vertexNormals;

    			if ( vertexNormals.length === 3 ) {

    				vertexNormals[ 0 ].copy( vertices[ face.a ] );
    				vertexNormals[ 1 ].copy( vertices[ face.b ] );
    				vertexNormals[ 2 ].copy( vertices[ face.c ] );

    			} else {

    				vertexNormals[ 0 ] = vertices[ face.a ].clone();
    				vertexNormals[ 1 ] = vertices[ face.b ].clone();
    				vertexNormals[ 2 ] = vertices[ face.c ].clone();

    			}

    		}

    		if ( this.faces.length > 0 ) {

    			this.normalsNeedUpdate = true;

    		}

    	},

    	computeMorphNormals: function () {

    		var i, il, f, fl, face;

    		// save original normals
    		// - create temp variables on first access
    		//   otherwise just copy (for faster repeated calls)

    		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

    			face = this.faces[ f ];

    			if ( ! face.__originalFaceNormal ) {

    				face.__originalFaceNormal = face.normal.clone();

    			} else {

    				face.__originalFaceNormal.copy( face.normal );

    			}

    			if ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];

    			for ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {

    				if ( ! face.__originalVertexNormals[ i ] ) {

    					face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();

    				} else {

    					face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );

    				}

    			}

    		}

    		// use temp geometry to compute face and vertex normals for each morph

    		var tmpGeo = new Geometry();
    		tmpGeo.faces = this.faces;

    		for ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {

    			// create on first access

    			if ( ! this.morphNormals[ i ] ) {

    				this.morphNormals[ i ] = {};
    				this.morphNormals[ i ].faceNormals = [];
    				this.morphNormals[ i ].vertexNormals = [];

    				var dstNormalsFace = this.morphNormals[ i ].faceNormals;
    				var dstNormalsVertex = this.morphNormals[ i ].vertexNormals;

    				var faceNormal, vertexNormals;

    				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

    					faceNormal = new Vector3();
    					vertexNormals = { a: new Vector3(), b: new Vector3(), c: new Vector3() };

    					dstNormalsFace.push( faceNormal );
    					dstNormalsVertex.push( vertexNormals );

    				}

    			}

    			var morphNormals = this.morphNormals[ i ];

    			// set vertices to morph target

    			tmpGeo.vertices = this.morphTargets[ i ].vertices;

    			// compute morph normals

    			tmpGeo.computeFaceNormals();
    			tmpGeo.computeVertexNormals();

    			// store morph normals

    			var faceNormal, vertexNormals;

    			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

    				face = this.faces[ f ];

    				faceNormal = morphNormals.faceNormals[ f ];
    				vertexNormals = morphNormals.vertexNormals[ f ];

    				faceNormal.copy( face.normal );

    				vertexNormals.a.copy( face.vertexNormals[ 0 ] );
    				vertexNormals.b.copy( face.vertexNormals[ 1 ] );
    				vertexNormals.c.copy( face.vertexNormals[ 2 ] );

    			}

    		}

    		// restore original normals

    		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

    			face = this.faces[ f ];

    			face.normal = face.__originalFaceNormal;
    			face.vertexNormals = face.__originalVertexNormals;

    		}

    	},

    	computeTangents: function () {

    		console.warn( 'THREE.Geometry: .computeTangents() has been removed.' );

    	},

    	computeLineDistances: function () {

    		var d = 0;
    		var vertices = this.vertices;

    		for ( var i = 0, il = vertices.length; i < il; i ++ ) {

    			if ( i > 0 ) {

    				d += vertices[ i ].distanceTo( vertices[ i - 1 ] );

    			}

    			this.lineDistances[ i ] = d;

    		}

    	},

    	computeBoundingBox: function () {

    		if ( this.boundingBox === null ) {

    			this.boundingBox = new Box3();

    		}

    		this.boundingBox.setFromPoints( this.vertices );

    	},

    	computeBoundingSphere: function () {

    		if ( this.boundingSphere === null ) {

    			this.boundingSphere = new Sphere();

    		}

    		this.boundingSphere.setFromPoints( this.vertices );

    	},

    	merge: function ( geometry, matrix, materialIndexOffset ) {

    		if ( (geometry && geometry.isGeometry) === false ) {

    			console.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );
    			return;

    		}

    		var normalMatrix,
    		vertexOffset = this.vertices.length,
    		vertices1 = this.vertices,
    		vertices2 = geometry.vertices,
    		faces1 = this.faces,
    		faces2 = geometry.faces,
    		uvs1 = this.faceVertexUvs[ 0 ],
    		uvs2 = geometry.faceVertexUvs[ 0 ],
    		colors1 = this.colors,
    		colors2 = geometry.colors;

    		if ( materialIndexOffset === undefined ) materialIndexOffset = 0;

    		if ( matrix !== undefined ) {

    			normalMatrix = new Matrix3().getNormalMatrix( matrix );

    		}

    		// vertices

    		for ( var i = 0, il = vertices2.length; i < il; i ++ ) {

    			var vertex = vertices2[ i ];

    			var vertexCopy = vertex.clone();

    			if ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );

    			vertices1.push( vertexCopy );

    		}

    		// colors

    		for ( var i = 0, il = colors2.length; i < il; i ++ ) {

    			colors1.push( colors2[ i ].clone() );

    		}

    		// faces

    		for ( i = 0, il = faces2.length; i < il; i ++ ) {

    			var face = faces2[ i ], faceCopy, normal, color,
    			faceVertexNormals = face.vertexNormals,
    			faceVertexColors = face.vertexColors;

    			faceCopy = new Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );
    			faceCopy.normal.copy( face.normal );

    			if ( normalMatrix !== undefined ) {

    				faceCopy.normal.applyMatrix3( normalMatrix ).normalize();

    			}

    			for ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {

    				normal = faceVertexNormals[ j ].clone();

    				if ( normalMatrix !== undefined ) {

    					normal.applyMatrix3( normalMatrix ).normalize();

    				}

    				faceCopy.vertexNormals.push( normal );

    			}

    			faceCopy.color.copy( face.color );

    			for ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {

    				color = faceVertexColors[ j ];
    				faceCopy.vertexColors.push( color.clone() );

    			}

    			faceCopy.materialIndex = face.materialIndex + materialIndexOffset;

    			faces1.push( faceCopy );

    		}

    		// uvs

    		for ( i = 0, il = uvs2.length; i < il; i ++ ) {

    			var uv = uvs2[ i ], uvCopy = [];

    			if ( uv === undefined ) {

    				continue;

    			}

    			for ( var j = 0, jl = uv.length; j < jl; j ++ ) {

    				uvCopy.push( uv[ j ].clone() );

    			}

    			uvs1.push( uvCopy );

    		}

    	},

    	mergeMesh: function ( mesh ) {

    		if ( (mesh && mesh.isMesh) === false ) {

    			console.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );
    			return;

    		}

    		mesh.matrixAutoUpdate && mesh.updateMatrix();

    		this.merge( mesh.geometry, mesh.matrix );

    	},

    	/*
    	 * Checks for duplicate vertices with hashmap.
    	 * Duplicated vertices are removed
    	 * and faces' vertices are updated.
    	 */

    	mergeVertices: function () {

    		var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)
    		var unique = [], changes = [];

    		var v, key;
    		var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001
    		var precision = Math.pow( 10, precisionPoints );
    		var i, il, face;
    		var indices, j, jl;

    		for ( i = 0, il = this.vertices.length; i < il; i ++ ) {

    			v = this.vertices[ i ];
    			key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );

    			if ( verticesMap[ key ] === undefined ) {

    				verticesMap[ key ] = i;
    				unique.push( this.vertices[ i ] );
    				changes[ i ] = unique.length - 1;

    			} else {

    				//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
    				changes[ i ] = changes[ verticesMap[ key ] ];

    			}

    		}


    		// if faces are completely degenerate after merging vertices, we
    		// have to remove them from the geometry.
    		var faceIndicesToRemove = [];

    		for ( i = 0, il = this.faces.length; i < il; i ++ ) {

    			face = this.faces[ i ];

    			face.a = changes[ face.a ];
    			face.b = changes[ face.b ];
    			face.c = changes[ face.c ];

    			indices = [ face.a, face.b, face.c ];

    			var dupIndex = - 1;

    			// if any duplicate vertices are found in a Face3
    			// we have to remove the face as nothing can be saved
    			for ( var n = 0; n < 3; n ++ ) {

    				if ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {

    					dupIndex = n;
    					faceIndicesToRemove.push( i );
    					break;

    				}

    			}

    		}

    		for ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {

    			var idx = faceIndicesToRemove[ i ];

    			this.faces.splice( idx, 1 );

    			for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {

    				this.faceVertexUvs[ j ].splice( idx, 1 );

    			}

    		}

    		// Use unique set of vertices

    		var diff = this.vertices.length - unique.length;
    		this.vertices = unique;
    		return diff;

    	},

    	sortFacesByMaterialIndex: function () {

    		var faces = this.faces;
    		var length = faces.length;

    		// tag faces

    		for ( var i = 0; i < length; i ++ ) {

    			faces[ i ]._id = i;

    		}

    		// sort faces

    		function materialIndexSort( a, b ) {

    			return a.materialIndex - b.materialIndex;

    		}

    		faces.sort( materialIndexSort );

    		// sort uvs

    		var uvs1 = this.faceVertexUvs[ 0 ];
    		var uvs2 = this.faceVertexUvs[ 1 ];

    		var newUvs1, newUvs2;

    		if ( uvs1 && uvs1.length === length ) newUvs1 = [];
    		if ( uvs2 && uvs2.length === length ) newUvs2 = [];

    		for ( var i = 0; i < length; i ++ ) {

    			var id = faces[ i ]._id;

    			if ( newUvs1 ) newUvs1.push( uvs1[ id ] );
    			if ( newUvs2 ) newUvs2.push( uvs2[ id ] );

    		}

    		if ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;
    		if ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;

    	},

    	toJSON: function () {

    		var data = {
    			metadata: {
    				version: 4.4,
    				type: 'Geometry',
    				generator: 'Geometry.toJSON'
    			}
    		};

    		// standard Geometry serialization

    		data.uuid = this.uuid;
    		data.type = this.type;
    		if ( this.name !== '' ) data.name = this.name;

    		if ( this.parameters !== undefined ) {

    			var parameters = this.parameters;

    			for ( var key in parameters ) {

    				if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

    			}

    			return data;

    		}

    		var vertices = [];

    		for ( var i = 0; i < this.vertices.length; i ++ ) {

    			var vertex = this.vertices[ i ];
    			vertices.push( vertex.x, vertex.y, vertex.z );

    		}

    		var faces = [];
    		var normals = [];
    		var normalsHash = {};
    		var colors = [];
    		var colorsHash = {};
    		var uvs = [];
    		var uvsHash = {};

    		for ( var i = 0; i < this.faces.length; i ++ ) {

    			var face = this.faces[ i ];

    			var hasMaterial = true;
    			var hasFaceUv = false; // deprecated
    			var hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;
    			var hasFaceNormal = face.normal.length() > 0;
    			var hasFaceVertexNormal = face.vertexNormals.length > 0;
    			var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
    			var hasFaceVertexColor = face.vertexColors.length > 0;

    			var faceType = 0;

    			faceType = setBit( faceType, 0, 0 ); // isQuad
    			faceType = setBit( faceType, 1, hasMaterial );
    			faceType = setBit( faceType, 2, hasFaceUv );
    			faceType = setBit( faceType, 3, hasFaceVertexUv );
    			faceType = setBit( faceType, 4, hasFaceNormal );
    			faceType = setBit( faceType, 5, hasFaceVertexNormal );
    			faceType = setBit( faceType, 6, hasFaceColor );
    			faceType = setBit( faceType, 7, hasFaceVertexColor );

    			faces.push( faceType );
    			faces.push( face.a, face.b, face.c );
    			faces.push( face.materialIndex );

    			if ( hasFaceVertexUv ) {

    				var faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];

    				faces.push(
    					getUvIndex( faceVertexUvs[ 0 ] ),
    					getUvIndex( faceVertexUvs[ 1 ] ),
    					getUvIndex( faceVertexUvs[ 2 ] )
    				);

    			}

    			if ( hasFaceNormal ) {

    				faces.push( getNormalIndex( face.normal ) );

    			}

    			if ( hasFaceVertexNormal ) {

    				var vertexNormals = face.vertexNormals;

    				faces.push(
    					getNormalIndex( vertexNormals[ 0 ] ),
    					getNormalIndex( vertexNormals[ 1 ] ),
    					getNormalIndex( vertexNormals[ 2 ] )
    				);

    			}

    			if ( hasFaceColor ) {

    				faces.push( getColorIndex( face.color ) );

    			}

    			if ( hasFaceVertexColor ) {

    				var vertexColors = face.vertexColors;

    				faces.push(
    					getColorIndex( vertexColors[ 0 ] ),
    					getColorIndex( vertexColors[ 1 ] ),
    					getColorIndex( vertexColors[ 2 ] )
    				);

    			}

    		}

    		function setBit( value, position, enabled ) {

    			return enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );

    		}

    		function getNormalIndex( normal ) {

    			var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();

    			if ( normalsHash[ hash ] !== undefined ) {

    				return normalsHash[ hash ];

    			}

    			normalsHash[ hash ] = normals.length / 3;
    			normals.push( normal.x, normal.y, normal.z );

    			return normalsHash[ hash ];

    		}

    		function getColorIndex( color ) {

    			var hash = color.r.toString() + color.g.toString() + color.b.toString();

    			if ( colorsHash[ hash ] !== undefined ) {

    				return colorsHash[ hash ];

    			}

    			colorsHash[ hash ] = colors.length;
    			colors.push( color.getHex() );

    			return colorsHash[ hash ];

    		}

    		function getUvIndex( uv ) {

    			var hash = uv.x.toString() + uv.y.toString();

    			if ( uvsHash[ hash ] !== undefined ) {

    				return uvsHash[ hash ];

    			}

    			uvsHash[ hash ] = uvs.length / 2;
    			uvs.push( uv.x, uv.y );

    			return uvsHash[ hash ];

    		}

    		data.data = {};

    		data.data.vertices = vertices;
    		data.data.normals = normals;
    		if ( colors.length > 0 ) data.data.colors = colors;
    		if ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility
    		data.data.faces = faces;

    		return data;

    	},

    	clone: function () {

    		/*
    		// Handle primitives

    		var parameters = this.parameters;

    		if ( parameters !== undefined ) {

    			var values = [];

    			for ( var key in parameters ) {

    				values.push( parameters[ key ] );

    			}

    			var geometry = Object.create( this.constructor.prototype );
    			this.constructor.apply( geometry, values );
    			return geometry;

    		}

    		return new this.constructor().copy( this );
    		*/

    		return new Geometry().copy( this );

    	},

    	copy: function ( source ) {

    		this.vertices = [];
    		this.faces = [];
    		this.faceVertexUvs = [ [] ];
    		this.colors = [];

    		var vertices = source.vertices;

    		for ( var i = 0, il = vertices.length; i < il; i ++ ) {

    			this.vertices.push( vertices[ i ].clone() );

    		}

    		var colors = source.colors;

    		for ( var i = 0, il = colors.length; i < il; i ++ ) {

    			this.colors.push( colors[ i ].clone() );

    		}

    		var faces = source.faces;

    		for ( var i = 0, il = faces.length; i < il; i ++ ) {

    			this.faces.push( faces[ i ].clone() );

    		}

    		for ( var i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {

    			var faceVertexUvs = source.faceVertexUvs[ i ];

    			if ( this.faceVertexUvs[ i ] === undefined ) {

    				this.faceVertexUvs[ i ] = [];

    			}

    			for ( var j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {

    				var uvs = faceVertexUvs[ j ], uvsCopy = [];

    				for ( var k = 0, kl = uvs.length; k < kl; k ++ ) {

    					var uv = uvs[ k ];

    					uvsCopy.push( uv.clone() );

    				}

    				this.faceVertexUvs[ i ].push( uvsCopy );

    			}

    		}

    		return this;

    	},

    	dispose: function () {

    		this.dispatchEvent( { type: 'dispose' } );

    	}

    } );

    var count$3 = 0;
    function GeometryIdCount() { return count$3++; };

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function DirectGeometry() {

    	Object.defineProperty( this, 'id', { value: GeometryIdCount() } );

    	this.uuid = exports.Math.generateUUID();

    	this.name = '';
    	this.type = 'DirectGeometry';

    	this.indices = [];
    	this.vertices = [];
    	this.normals = [];
    	this.colors = [];
    	this.uvs = [];
    	this.uvs2 = [];

    	this.groups = [];

    	this.morphTargets = {};

    	this.skinWeights = [];
    	this.skinIndices = [];

    	// this.lineDistances = [];

    	this.boundingBox = null;
    	this.boundingSphere = null;

    	// update flags

    	this.verticesNeedUpdate = false;
    	this.normalsNeedUpdate = false;
    	this.colorsNeedUpdate = false;
    	this.uvsNeedUpdate = false;
    	this.groupsNeedUpdate = false;

    }

    Object.assign( DirectGeometry.prototype, EventDispatcher.prototype, {

    	computeBoundingBox: Geometry.prototype.computeBoundingBox,
    	computeBoundingSphere: Geometry.prototype.computeBoundingSphere,

    	computeFaceNormals: function () {

    		console.warn( 'THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.' );

    	},

    	computeVertexNormals: function () {

    		console.warn( 'THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.' );

    	},

    	computeGroups: function ( geometry ) {

    		var group;
    		var groups = [];
    		var materialIndex;

    		var faces = geometry.faces;

    		for ( var i = 0; i < faces.length; i ++ ) {

    			var face = faces[ i ];

    			// materials

    			if ( face.materialIndex !== materialIndex ) {

    				materialIndex = face.materialIndex;

    				if ( group !== undefined ) {

    					group.count = ( i * 3 ) - group.start;
    					groups.push( group );

    				}

    				group = {
    					start: i * 3,
    					materialIndex: materialIndex
    				};

    			}

    		}

    		if ( group !== undefined ) {

    			group.count = ( i * 3 ) - group.start;
    			groups.push( group );

    		}

    		this.groups = groups;

    	},

    	fromGeometry: function ( geometry ) {

    		var faces = geometry.faces;
    		var vertices = geometry.vertices;
    		var faceVertexUvs = geometry.faceVertexUvs;

    		var hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;
    		var hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;

    		// morphs

    		var morphTargets = geometry.morphTargets;
    		var morphTargetsLength = morphTargets.length;

    		var morphTargetsPosition;

    		if ( morphTargetsLength > 0 ) {

    			morphTargetsPosition = [];

    			for ( var i = 0; i < morphTargetsLength; i ++ ) {

    				morphTargetsPosition[ i ] = [];

    			}

    			this.morphTargets.position = morphTargetsPosition;

    		}

    		var morphNormals = geometry.morphNormals;
    		var morphNormalsLength = morphNormals.length;

    		var morphTargetsNormal;

    		if ( morphNormalsLength > 0 ) {

    			morphTargetsNormal = [];

    			for ( var i = 0; i < morphNormalsLength; i ++ ) {

    				morphTargetsNormal[ i ] = [];

    			}

    			this.morphTargets.normal = morphTargetsNormal;

    		}

    		// skins

    		var skinIndices = geometry.skinIndices;
    		var skinWeights = geometry.skinWeights;

    		var hasSkinIndices = skinIndices.length === vertices.length;
    		var hasSkinWeights = skinWeights.length === vertices.length;

    		//

    		for ( var i = 0; i < faces.length; i ++ ) {

    			var face = faces[ i ];

    			this.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );

    			var vertexNormals = face.vertexNormals;

    			if ( vertexNormals.length === 3 ) {

    				this.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );

    			} else {

    				var normal = face.normal;

    				this.normals.push( normal, normal, normal );

    			}

    			var vertexColors = face.vertexColors;

    			if ( vertexColors.length === 3 ) {

    				this.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );

    			} else {

    				var color = face.color;

    				this.colors.push( color, color, color );

    			}

    			if ( hasFaceVertexUv === true ) {

    				var vertexUvs = faceVertexUvs[ 0 ][ i ];

    				if ( vertexUvs !== undefined ) {

    					this.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

    				} else {

    					console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );

    					this.uvs.push( new Vector2(), new Vector2(), new Vector2() );

    				}

    			}

    			if ( hasFaceVertexUv2 === true ) {

    				var vertexUvs = faceVertexUvs[ 1 ][ i ];

    				if ( vertexUvs !== undefined ) {

    					this.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

    				} else {

    					console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );

    					this.uvs2.push( new Vector2(), new Vector2(), new Vector2() );

    				}

    			}

    			// morphs

    			for ( var j = 0; j < morphTargetsLength; j ++ ) {

    				var morphTarget = morphTargets[ j ].vertices;

    				morphTargetsPosition[ j ].push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );

    			}

    			for ( var j = 0; j < morphNormalsLength; j ++ ) {

    				var morphNormal = morphNormals[ j ].vertexNormals[ i ];

    				morphTargetsNormal[ j ].push( morphNormal.a, morphNormal.b, morphNormal.c );

    			}

    			// skins

    			if ( hasSkinIndices ) {

    				this.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );

    			}

    			if ( hasSkinWeights ) {

    				this.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );

    			}

    		}

    		this.computeGroups( geometry );

    		this.verticesNeedUpdate = geometry.verticesNeedUpdate;
    		this.normalsNeedUpdate = geometry.normalsNeedUpdate;
    		this.colorsNeedUpdate = geometry.colorsNeedUpdate;
    		this.uvsNeedUpdate = geometry.uvsNeedUpdate;
    		this.groupsNeedUpdate = geometry.groupsNeedUpdate;

    		return this;

    	},

    	dispose: function () {

    		this.dispatchEvent( { type: 'dispose' } );

    	}

    } );

    /**
     * @author alteredq / http://alteredqualia.com/
     * @author mrdoob / http://mrdoob.com/
     */

    function BufferGeometry() {

    	Object.defineProperty( this, 'id', { value: GeometryIdCount() } );

    	this.uuid = exports.Math.generateUUID();

    	this.name = '';
    	this.type = 'BufferGeometry';

    	this.index = null;
    	this.attributes = {};

    	this.morphAttributes = {};

    	this.groups = [];

    	this.boundingBox = null;
    	this.boundingSphere = null;

    	this.drawRange = { start: 0, count: Infinity };

    }

    Object.assign( BufferGeometry.prototype, EventDispatcher.prototype, {

    	isBufferGeometry: true,

    	getIndex: function () {

    		return this.index;

    	},

    	setIndex: function ( index ) {

    		this.index = index;

    	},

    	addAttribute: function ( name, attribute ) {

    		if ( (attribute && attribute.isBufferAttribute) === false && (attribute && attribute.isInterleavedBufferAttribute) === false ) {

    			console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );

    			this.addAttribute( name, new BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );

    			return;

    		}

    		if ( name === 'index' ) {

    			console.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );
    			this.setIndex( attribute );

    			return;

    		}

    		this.attributes[ name ] = attribute;

    		return this;

    	},

    	getAttribute: function ( name ) {

    		return this.attributes[ name ];

    	},

    	removeAttribute: function ( name ) {

    		delete this.attributes[ name ];

    		return this;

    	},

    	addGroup: function ( start, count, materialIndex ) {

    		this.groups.push( {

    			start: start,
    			count: count,
    			materialIndex: materialIndex !== undefined ? materialIndex : 0

    		} );

    	},

    	clearGroups: function () {

    		this.groups = [];

    	},

    	setDrawRange: function ( start, count ) {

    		this.drawRange.start = start;
    		this.drawRange.count = count;

    	},

    	applyMatrix: function ( matrix ) {

    		var position = this.attributes.position;

    		if ( position !== undefined ) {

    			matrix.applyToVector3Array( position.array );
    			position.needsUpdate = true;

    		}

    		var normal = this.attributes.normal;

    		if ( normal !== undefined ) {

    			var normalMatrix = new Matrix3().getNormalMatrix( matrix );

    			normalMatrix.applyToVector3Array( normal.array );
    			normal.needsUpdate = true;

    		}

    		if ( this.boundingBox !== null ) {

    			this.computeBoundingBox();

    		}

    		if ( this.boundingSphere !== null ) {

    			this.computeBoundingSphere();

    		}

    		return this;

    	},

    	rotateX: function () {

    		// rotate geometry around world x-axis

    		var m1;

    		return function rotateX( angle ) {

    			if ( m1 === undefined ) m1 = new Matrix4();

    			m1.makeRotationX( angle );

    			this.applyMatrix( m1 );

    			return this;

    		};

    	}(),

    	rotateY: function () {

    		// rotate geometry around world y-axis

    		var m1;

    		return function rotateY( angle ) {

    			if ( m1 === undefined ) m1 = new Matrix4();

    			m1.makeRotationY( angle );

    			this.applyMatrix( m1 );

    			return this;

    		};

    	}(),

    	rotateZ: function () {

    		// rotate geometry around world z-axis

    		var m1;

    		return function rotateZ( angle ) {

    			if ( m1 === undefined ) m1 = new Matrix4();

    			m1.makeRotationZ( angle );

    			this.applyMatrix( m1 );

    			return this;

    		};

    	}(),

    	translate: function () {

    		// translate geometry

    		var m1;

    		return function translate( x, y, z ) {

    			if ( m1 === undefined ) m1 = new Matrix4();

    			m1.makeTranslation( x, y, z );

    			this.applyMatrix( m1 );

    			return this;

    		};

    	}(),

    	scale: function () {

    		// scale geometry

    		var m1;

    		return function scale( x, y, z ) {

    			if ( m1 === undefined ) m1 = new Matrix4();

    			m1.makeScale( x, y, z );

    			this.applyMatrix( m1 );

    			return this;

    		};

    	}(),

    	lookAt: function () {

    		var obj;

    		return function lookAt( vector ) {

    			if ( obj === undefined ) obj = new Object3D();

    			obj.lookAt( vector );

    			obj.updateMatrix();

    			this.applyMatrix( obj.matrix );

    		};

    	}(),

    	center: function () {

    		this.computeBoundingBox();

    		var offset = this.boundingBox.getCenter().negate();

    		this.translate( offset.x, offset.y, offset.z );

    		return offset;

    	},

    	setFromObject: function ( object ) {

    		// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );

    		var geometry = object.geometry;

    		if ( (object && object.isPoints) || (object && object.isLine) ) {

    			var positions = new Float32Attribute( geometry.vertices.length * 3, 3 );
    			var colors = new Float32Attribute( geometry.colors.length * 3, 3 );

    			this.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );
    			this.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );

    			if ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {

    				var lineDistances = new Float32Attribute( geometry.lineDistances.length, 1 );

    				this.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );

    			}

    			if ( geometry.boundingSphere !== null ) {

    				this.boundingSphere = geometry.boundingSphere.clone();

    			}

    			if ( geometry.boundingBox !== null ) {

    				this.boundingBox = geometry.boundingBox.clone();

    			}

    		} else if ( (object && object.isMesh) ) {

    			if ( (geometry && geometry.isGeometry) ) {

    				this.fromGeometry( geometry );

    			}

    		}

    		return this;

    	},

    	updateFromObject: function ( object ) {

    		var geometry = object.geometry;

    		if ( (object && object.isMesh) ) {

    			var direct = geometry.__directGeometry;

    			if ( geometry.elementsNeedUpdate === true ) {

    				direct = undefined;
    				geometry.elementsNeedUpdate = false;

    			}

    			if ( direct === undefined ) {

    				return this.fromGeometry( geometry );

    			}

    			direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
    			direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
    			direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
    			direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
    			direct.groupsNeedUpdate = geometry.groupsNeedUpdate;

    			geometry.verticesNeedUpdate = false;
    			geometry.normalsNeedUpdate = false;
    			geometry.colorsNeedUpdate = false;
    			geometry.uvsNeedUpdate = false;
    			geometry.groupsNeedUpdate = false;

    			geometry = direct;

    		}

    		var attribute;

    		if ( geometry.verticesNeedUpdate === true ) {

    			attribute = this.attributes.position;

    			if ( attribute !== undefined ) {

    				attribute.copyVector3sArray( geometry.vertices );
    				attribute.needsUpdate = true;

    			}

    			geometry.verticesNeedUpdate = false;

    		}

    		if ( geometry.normalsNeedUpdate === true ) {

    			attribute = this.attributes.normal;

    			if ( attribute !== undefined ) {

    				attribute.copyVector3sArray( geometry.normals );
    				attribute.needsUpdate = true;

    			}

    			geometry.normalsNeedUpdate = false;

    		}

    		if ( geometry.colorsNeedUpdate === true ) {

    			attribute = this.attributes.color;

    			if ( attribute !== undefined ) {

    				attribute.copyColorsArray( geometry.colors );
    				attribute.needsUpdate = true;

    			}

    			geometry.colorsNeedUpdate = false;

    		}

    		if ( geometry.uvsNeedUpdate ) {

    			attribute = this.attributes.uv;

    			if ( attribute !== undefined ) {

    				attribute.copyVector2sArray( geometry.uvs );
    				attribute.needsUpdate = true;

    			}

    			geometry.uvsNeedUpdate = false;

    		}

    		if ( geometry.lineDistancesNeedUpdate ) {

    			attribute = this.attributes.lineDistance;

    			if ( attribute !== undefined ) {

    				attribute.copyArray( geometry.lineDistances );
    				attribute.needsUpdate = true;

    			}

    			geometry.lineDistancesNeedUpdate = false;

    		}

    		if ( geometry.groupsNeedUpdate ) {

    			geometry.computeGroups( object.geometry );
    			this.groups = geometry.groups;

    			geometry.groupsNeedUpdate = false;

    		}

    		return this;

    	},

    	fromGeometry: function ( geometry ) {

    		geometry.__directGeometry = new DirectGeometry().fromGeometry( geometry );

    		return this.fromDirectGeometry( geometry.__directGeometry );

    	},

    	fromDirectGeometry: function ( geometry ) {

    		var positions = new Float32Array( geometry.vertices.length * 3 );
    		this.addAttribute( 'position', new BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );

    		if ( geometry.normals.length > 0 ) {

    			var normals = new Float32Array( geometry.normals.length * 3 );
    			this.addAttribute( 'normal', new BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );

    		}

    		if ( geometry.colors.length > 0 ) {

    			var colors = new Float32Array( geometry.colors.length * 3 );
    			this.addAttribute( 'color', new BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );

    		}

    		if ( geometry.uvs.length > 0 ) {

    			var uvs = new Float32Array( geometry.uvs.length * 2 );
    			this.addAttribute( 'uv', new BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );

    		}

    		if ( geometry.uvs2.length > 0 ) {

    			var uvs2 = new Float32Array( geometry.uvs2.length * 2 );
    			this.addAttribute( 'uv2', new BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );

    		}

    		if ( geometry.indices.length > 0 ) {

    			var TypeArray = geometry.vertices.length > 65535 ? Uint32Array : Uint16Array;
    			var indices = new TypeArray( geometry.indices.length * 3 );
    			this.setIndex( new BufferAttribute( indices, 1 ).copyIndicesArray( geometry.indices ) );

    		}

    		// groups

    		this.groups = geometry.groups;

    		// morphs

    		for ( var name in geometry.morphTargets ) {

    			var array = [];
    			var morphTargets = geometry.morphTargets[ name ];

    			for ( var i = 0, l = morphTargets.length; i < l; i ++ ) {

    				var morphTarget = morphTargets[ i ];

    				var attribute = new Float32Attribute( morphTarget.length * 3, 3 );

    				array.push( attribute.copyVector3sArray( morphTarget ) );

    			}

    			this.morphAttributes[ name ] = array;

    		}

    		// skinning

    		if ( geometry.skinIndices.length > 0 ) {

    			var skinIndices = new Float32Attribute( geometry.skinIndices.length * 4, 4 );
    			this.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );

    		}

    		if ( geometry.skinWeights.length > 0 ) {

    			var skinWeights = new Float32Attribute( geometry.skinWeights.length * 4, 4 );
    			this.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );

    		}

    		//

    		if ( geometry.boundingSphere !== null ) {

    			this.boundingSphere = geometry.boundingSphere.clone();

    		}

    		if ( geometry.boundingBox !== null ) {

    			this.boundingBox = geometry.boundingBox.clone();

    		}

    		return this;

    	},

    	computeBoundingBox: function () {

    		if ( this.boundingBox === null ) {

    			this.boundingBox = new Box3();

    		}

    		var positions = this.attributes.position.array;

    		if ( positions !== undefined ) {

    			this.boundingBox.setFromArray( positions );

    		} else {

    			this.boundingBox.makeEmpty();

    		}

    		if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

    			console.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );

    		}

    	},

    	computeBoundingSphere: function () {

    		var box = new Box3();
    		var vector = new Vector3();

    		return function computeBoundingSphere() {

    			if ( this.boundingSphere === null ) {

    				this.boundingSphere = new Sphere();

    			}

    			var positions = this.attributes.position;

    			if ( positions ) {

    				var array = positions.array;
    				var center = this.boundingSphere.center;

    				box.setFromArray( array );
    				box.getCenter( center );

    				// hoping to find a boundingSphere with a radius smaller than the
    				// boundingSphere of the boundingBox: sqrt(3) smaller in the best case

    				var maxRadiusSq = 0;

    				for ( var i = 0, il = array.length; i < il; i += 3 ) {

    					vector.fromArray( array, i );
    					maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );

    				}

    				this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

    				if ( isNaN( this.boundingSphere.radius ) ) {

    					console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );

    				}

    			}

    		};

    	}(),

    	computeFaceNormals: function () {

    		// backwards compatibility

    	},

    	computeVertexNormals: function () {

    		var index = this.index;
    		var attributes = this.attributes;
    		var groups = this.groups;

    		if ( attributes.position ) {

    			var positions = attributes.position.array;

    			if ( attributes.normal === undefined ) {

    				this.addAttribute( 'normal', new BufferAttribute( new Float32Array( positions.length ), 3 ) );

    			} else {

    				// reset existing normals to zero

    				var array = attributes.normal.array;

    				for ( var i = 0, il = array.length; i < il; i ++ ) {

    					array[ i ] = 0;

    				}

    			}

    			var normals = attributes.normal.array;

    			var vA, vB, vC,

    			pA = new Vector3(),
    			pB = new Vector3(),
    			pC = new Vector3(),

    			cb = new Vector3(),
    			ab = new Vector3();

    			// indexed elements

    			if ( index ) {

    				var indices = index.array;

    				if ( groups.length === 0 ) {

    					this.addGroup( 0, indices.length );

    				}

    				for ( var j = 0, jl = groups.length; j < jl; ++ j ) {

    					var group = groups[ j ];

    					var start = group.start;
    					var count = group.count;

    					for ( var i = start, il = start + count; i < il; i += 3 ) {

    						vA = indices[ i + 0 ] * 3;
    						vB = indices[ i + 1 ] * 3;
    						vC = indices[ i + 2 ] * 3;

    						pA.fromArray( positions, vA );
    						pB.fromArray( positions, vB );
    						pC.fromArray( positions, vC );

    						cb.subVectors( pC, pB );
    						ab.subVectors( pA, pB );
    						cb.cross( ab );

    						normals[ vA ] += cb.x;
    						normals[ vA + 1 ] += cb.y;
    						normals[ vA + 2 ] += cb.z;

    						normals[ vB ] += cb.x;
    						normals[ vB + 1 ] += cb.y;
    						normals[ vB + 2 ] += cb.z;

    						normals[ vC ] += cb.x;
    						normals[ vC + 1 ] += cb.y;
    						normals[ vC + 2 ] += cb.z;

    					}

    				}

    			} else {

    				// non-indexed elements (unconnected triangle soup)

    				for ( var i = 0, il = positions.length; i < il; i += 9 ) {

    					pA.fromArray( positions, i );
    					pB.fromArray( positions, i + 3 );
    					pC.fromArray( positions, i + 6 );

    					cb.subVectors( pC, pB );
    					ab.subVectors( pA, pB );
    					cb.cross( ab );

    					normals[ i ] = cb.x;
    					normals[ i + 1 ] = cb.y;
    					normals[ i + 2 ] = cb.z;

    					normals[ i + 3 ] = cb.x;
    					normals[ i + 4 ] = cb.y;
    					normals[ i + 5 ] = cb.z;

    					normals[ i + 6 ] = cb.x;
    					normals[ i + 7 ] = cb.y;
    					normals[ i + 8 ] = cb.z;

    				}

    			}

    			this.normalizeNormals();

    			attributes.normal.needsUpdate = true;

    		}

    	},

    	merge: function ( geometry, offset ) {

    		if ( (geometry && geometry.isBufferGeometry) === false ) {

    			console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
    			return;

    		}

    		if ( offset === undefined ) offset = 0;

    		var attributes = this.attributes;

    		for ( var key in attributes ) {

    			if ( geometry.attributes[ key ] === undefined ) continue;

    			var attribute1 = attributes[ key ];
    			var attributeArray1 = attribute1.array;

    			var attribute2 = geometry.attributes[ key ];
    			var attributeArray2 = attribute2.array;

    			var attributeSize = attribute2.itemSize;

    			for ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {

    				attributeArray1[ j ] = attributeArray2[ i ];

    			}

    		}

    		return this;

    	},

    	normalizeNormals: function () {

    		var normals = this.attributes.normal.array;

    		var x, y, z, n;

    		for ( var i = 0, il = normals.length; i < il; i += 3 ) {

    			x = normals[ i ];
    			y = normals[ i + 1 ];
    			z = normals[ i + 2 ];

    			n = 1.0 / Math.sqrt( x * x + y * y + z * z );

    			normals[ i ] *= n;
    			normals[ i + 1 ] *= n;
    			normals[ i + 2 ] *= n;

    		}

    	},

    	toNonIndexed: function () {

    		if ( this.index === null ) {

    			console.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );
    			return this;

    		}

    		var geometry2 = new BufferGeometry();

    		var indices = this.index.array;
    		var attributes = this.attributes;

    		for ( var name in attributes ) {

    			var attribute = attributes[ name ];

    			var array = attribute.array;
    			var itemSize = attribute.itemSize;

    			var array2 = new array.constructor( indices.length * itemSize );

    			var index = 0, index2 = 0;

    			for ( var i = 0, l = indices.length; i < l; i ++ ) {

    				index = indices[ i ] * itemSize;

    				for ( var j = 0; j < itemSize; j ++ ) {

    					array2[ index2 ++ ] = array[ index ++ ];

    				}

    			}

    			geometry2.addAttribute( name, new BufferAttribute( array2, itemSize ) );

    		}

    		return geometry2;

    	},

    	toJSON: function () {

    		var data = {
    			metadata: {
    				version: 4.4,
    				type: 'BufferGeometry',
    				generator: 'BufferGeometry.toJSON'
    			}
    		};

    		// standard BufferGeometry serialization

    		data.uuid = this.uuid;
    		data.type = this.type;
    		if ( this.name !== '' ) data.name = this.name;

    		if ( this.parameters !== undefined ) {

    			var parameters = this.parameters;

    			for ( var key in parameters ) {

    				if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

    			}

    			return data;

    		}

    		data.data = { attributes: {} };

    		var index = this.index;

    		if ( index !== null ) {

    			var array = Array.prototype.slice.call( index.array );

    			data.data.index = {
    				type: index.array.constructor.name,
    				array: array
    			};

    		}

    		var attributes = this.attributes;

    		for ( var key in attributes ) {

    			var attribute = attributes[ key ];

    			var array = Array.prototype.slice.call( attribute.array );

    			data.data.attributes[ key ] = {
    				itemSize: attribute.itemSize,
    				type: attribute.array.constructor.name,
    				array: array,
    				normalized: attribute.normalized
    			};

    		}

    		var groups = this.groups;

    		if ( groups.length > 0 ) {

    			data.data.groups = JSON.parse( JSON.stringify( groups ) );

    		}

    		var boundingSphere = this.boundingSphere;

    		if ( boundingSphere !== null ) {

    			data.data.boundingSphere = {
    				center: boundingSphere.center.toArray(),
    				radius: boundingSphere.radius
    			};

    		}

    		return data;

    	},

    	clone: function () {

    		/*
    		// Handle primitives

    		var parameters = this.parameters;

    		if ( parameters !== undefined ) {

    			var values = [];

    			for ( var key in parameters ) {

    				values.push( parameters[ key ] );

    			}

    			var geometry = Object.create( this.constructor.prototype );
    			this.constructor.apply( geometry, values );
    			return geometry;

    		}

    		return new this.constructor().copy( this );
    		*/

    		return new BufferGeometry().copy( this );

    	},

    	copy: function ( source ) {

    		var index = source.index;

    		if ( index !== null ) {

    			this.setIndex( index.clone() );

    		}

    		var attributes = source.attributes;

    		for ( var name in attributes ) {

    			var attribute = attributes[ name ];
    			this.addAttribute( name, attribute.clone() );

    		}

    		var groups = source.groups;

    		for ( var i = 0, l = groups.length; i < l; i ++ ) {

    			var group = groups[ i ];
    			this.addGroup( group.start, group.count, group.materialIndex );

    		}

    		return this;

    	},

    	dispose: function () {

    		this.dispatchEvent( { type: 'dispose' } );

    	}

    } );

    BufferGeometry.MaxIndex = 65535;

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     * @author mikael emtinger / http://gomo.se/
     * @author jonobr1 / http://jonobr1.com/
     */

    function Mesh( geometry, material ) {

    	Object3D.call( this );

    	this.type = 'Mesh';

    	this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
    	this.material = material !== undefined ? material : new MeshBasicMaterial( { color: Math.random() * 0xffffff } );

    	this.drawMode = TrianglesDrawMode;

    	this.updateMorphTargets();

    }

    Mesh.prototype = Object.assign( Object.create( Object3D.prototype ), {

    	constructor: Mesh,

    	isMesh: true,

    	setDrawMode: function ( value ) {

    		this.drawMode = value;

    	},

    	copy: function ( source ) {

    		Object3D.prototype.copy.call( this, source );

    		this.drawMode = source.drawMode;

    		return this;

    	},

    	updateMorphTargets: function () {

    		var morphTargets = this.geometry.morphTargets;

    		if ( morphTargets !== undefined && morphTargets.length > 0 ) {

    			this.morphTargetInfluences = [];
    			this.morphTargetDictionary = {};

    			for ( var m = 0, ml = morphTargets.length; m < ml; m ++ ) {

    				this.morphTargetInfluences.push( 0 );
    				this.morphTargetDictionary[ morphTargets[ m ].name ] = m;

    			}

    		}

    	},

    	raycast: ( function () {

    		var inverseMatrix = new Matrix4();
    		var ray = new Ray();
    		var sphere = new Sphere();

    		var vA = new Vector3();
    		var vB = new Vector3();
    		var vC = new Vector3();

    		var tempA = new Vector3();
    		var tempB = new Vector3();
    		var tempC = new Vector3();

    		var uvA = new Vector2();
    		var uvB = new Vector2();
    		var uvC = new Vector2();

    		var barycoord = new Vector3();

    		var intersectionPoint = new Vector3();
    		var intersectionPointWorld = new Vector3();

    		function uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {

    			Triangle.barycoordFromPoint( point, p1, p2, p3, barycoord );

    			uv1.multiplyScalar( barycoord.x );
    			uv2.multiplyScalar( barycoord.y );
    			uv3.multiplyScalar( barycoord.z );

    			uv1.add( uv2 ).add( uv3 );

    			return uv1.clone();

    		}

    		function checkIntersection( object, raycaster, ray, pA, pB, pC, point ) {

    			var intersect;
    			var material = object.material;

    			if ( material.side === BackSide ) {

    				intersect = ray.intersectTriangle( pC, pB, pA, true, point );

    			} else {

    				intersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );

    			}

    			if ( intersect === null ) return null;

    			intersectionPointWorld.copy( point );
    			intersectionPointWorld.applyMatrix4( object.matrixWorld );

    			var distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );

    			if ( distance < raycaster.near || distance > raycaster.far ) return null;

    			return {
    				distance: distance,
    				point: intersectionPointWorld.clone(),
    				object: object
    			};

    		}

    		function checkBufferGeometryIntersection( object, raycaster, ray, positions, uvs, a, b, c ) {

    			vA.fromArray( positions, a * 3 );
    			vB.fromArray( positions, b * 3 );
    			vC.fromArray( positions, c * 3 );

    			var intersection = checkIntersection( object, raycaster, ray, vA, vB, vC, intersectionPoint );

    			if ( intersection ) {

    				if ( uvs ) {

    					uvA.fromArray( uvs, a * 2 );
    					uvB.fromArray( uvs, b * 2 );
    					uvC.fromArray( uvs, c * 2 );

    					intersection.uv = uvIntersection( intersectionPoint,  vA, vB, vC,  uvA, uvB, uvC );

    				}

    				intersection.face = new Face3( a, b, c, Triangle.normal( vA, vB, vC ) );
    				intersection.faceIndex = a;

    			}

    			return intersection;

    		}

    		return function raycast( raycaster, intersects ) {

    			var geometry = this.geometry;
    			var material = this.material;
    			var matrixWorld = this.matrixWorld;

    			if ( material === undefined ) return;

    			// Checking boundingSphere distance to ray

    			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

    			sphere.copy( geometry.boundingSphere );
    			sphere.applyMatrix4( matrixWorld );

    			if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;

    			//

    			inverseMatrix.getInverse( matrixWorld );
    			ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

    			// Check boundingBox before continuing

    			if ( geometry.boundingBox !== null ) {

    				if ( ray.intersectsBox( geometry.boundingBox ) === false ) return;

    			}

    			var uvs, intersection;

    			if ( (geometry && geometry.isBufferGeometry) ) {

    				var a, b, c;
    				var index = geometry.index;
    				var attributes = geometry.attributes;
    				var positions = attributes.position.array;

    				if ( attributes.uv !== undefined ) {

    					uvs = attributes.uv.array;

    				}

    				if ( index !== null ) {

    					var indices = index.array;

    					for ( var i = 0, l = indices.length; i < l; i += 3 ) {

    						a = indices[ i ];
    						b = indices[ i + 1 ];
    						c = indices[ i + 2 ];

    						intersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );

    						if ( intersection ) {

    							intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indices buffer semantics
    							intersects.push( intersection );

    						}

    					}

    				} else {


    					for ( var i = 0, l = positions.length; i < l; i += 9 ) {

    						a = i / 3;
    						b = a + 1;
    						c = a + 2;

    						intersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );

    						if ( intersection ) {

    							intersection.index = a; // triangle number in positions buffer semantics
    							intersects.push( intersection );

    						}

    					}

    				}

    			} else if ( (geometry && geometry.isGeometry) ) {

    				var fvA, fvB, fvC;
    				var isFaceMaterial = (material && material.isMultiMaterial);
    				var materials = isFaceMaterial === true ? material.materials : null;

    				var vertices = geometry.vertices;
    				var faces = geometry.faces;
    				var faceVertexUvs = geometry.faceVertexUvs[ 0 ];
    				if ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;

    				for ( var f = 0, fl = faces.length; f < fl; f ++ ) {

    					var face = faces[ f ];
    					var faceMaterial = isFaceMaterial === true ? materials[ face.materialIndex ] : material;

    					if ( faceMaterial === undefined ) continue;

    					fvA = vertices[ face.a ];
    					fvB = vertices[ face.b ];
    					fvC = vertices[ face.c ];

    					if ( faceMaterial.morphTargets === true ) {

    						var morphTargets = geometry.morphTargets;
    						var morphInfluences = this.morphTargetInfluences;

    						vA.set( 0, 0, 0 );
    						vB.set( 0, 0, 0 );
    						vC.set( 0, 0, 0 );

    						for ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {

    							var influence = morphInfluences[ t ];

    							if ( influence === 0 ) continue;

    							var targets = morphTargets[ t ].vertices;

    							vA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );
    							vB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );
    							vC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );

    						}

    						vA.add( fvA );
    						vB.add( fvB );
    						vC.add( fvC );

    						fvA = vA;
    						fvB = vB;
    						fvC = vC;

    					}

    					intersection = checkIntersection( this, raycaster, ray, fvA, fvB, fvC, intersectionPoint );

    					if ( intersection ) {

    						if ( uvs ) {

    							var uvs_f = uvs[ f ];
    							uvA.copy( uvs_f[ 0 ] );
    							uvB.copy( uvs_f[ 1 ] );
    							uvC.copy( uvs_f[ 2 ] );

    							intersection.uv = uvIntersection( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC );

    						}

    						intersection.face = face;
    						intersection.faceIndex = f;
    						intersects.push( intersection );

    					}

    				}

    			}

    		};

    	}() ),

    	clone: function () {

    		return new this.constructor( this.geometry, this.material ).copy( this );

    	}

    } );

    /**
     * @author Mugen87 / https://github.com/Mugen87
     */

    function BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {

    	BufferGeometry.call( this );

    	this.type = 'BoxBufferGeometry';

    	this.parameters = {
    		width: width,
    		height: height,
    		depth: depth,
    		widthSegments: widthSegments,
    		heightSegments: heightSegments,
    		depthSegments: depthSegments
    	};

    	var scope = this;

    	// segments
    	widthSegments = Math.floor( widthSegments ) || 1;
    	heightSegments = Math.floor( heightSegments ) || 1;
    	depthSegments = Math.floor( depthSegments ) || 1;

    	// these are used to calculate buffer length
    	var vertexCount = calculateVertexCount( widthSegments, heightSegments, depthSegments );
    	var indexCount = calculateIndexCount( widthSegments, heightSegments, depthSegments );

    	// buffers
    	var indices = new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount );
    	var vertices = new Float32Array( vertexCount * 3 );
    	var normals = new Float32Array( vertexCount * 3 );
    	var uvs = new Float32Array( vertexCount * 2 );

    	// offset variables
    	var vertexBufferOffset = 0;
    	var uvBufferOffset = 0;
    	var indexBufferOffset = 0;
    	var numberOfVertices = 0;

    	// group variables
    	var groupStart = 0;

    	// build each side of the box geometry
    	buildPlane( 'z', 'y', 'x', - 1, - 1, depth, height,   width,  depthSegments, heightSegments, 0 ); // px
    	buildPlane( 'z', 'y', 'x',   1, - 1, depth, height, - width,  depthSegments, heightSegments, 1 ); // nx
    	buildPlane( 'x', 'z', 'y',   1,   1, width, depth,    height, widthSegments, depthSegments,  2 ); // py
    	buildPlane( 'x', 'z', 'y',   1, - 1, width, depth,  - height, widthSegments, depthSegments,  3 ); // ny
    	buildPlane( 'x', 'y', 'z',   1, - 1, width, height,   depth,  widthSegments, heightSegments, 4 ); // pz
    	buildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth,  widthSegments, heightSegments, 5 ); // nz

    	// build geometry
    	this.setIndex( new BufferAttribute( indices, 1 ) );
    	this.addAttribute( 'position', new BufferAttribute( vertices, 3 ) );
    	this.addAttribute( 'normal', new BufferAttribute( normals, 3 ) );
    	this.addAttribute( 'uv', new BufferAttribute( uvs, 2 ) );

    	// helper functions

    	function calculateVertexCount( w, h, d ) {

    		var vertices = 0;

    		// calculate the amount of vertices for each side (plane)
    		vertices += (w + 1) * (h + 1) * 2; // xy
    		vertices += (w + 1) * (d + 1) * 2; // xz
    		vertices += (d + 1) * (h + 1) * 2; // zy

    		return vertices;

    	}

    	function calculateIndexCount( w, h, d ) {

    		var index = 0;

    		// calculate the amount of squares for each side
    		index += w * h * 2; // xy
    		index += w * d * 2; // xz
    		index += d * h * 2; // zy

    		return index * 6; // two triangles per square => six vertices per square

    	}

    	function buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {

    		var segmentWidth	= width / gridX;
    		var segmentHeight = height / gridY;

    		var widthHalf = width / 2;
    		var heightHalf = height / 2;
    		var depthHalf = depth / 2;

    		var gridX1 = gridX + 1;
    		var gridY1 = gridY + 1;

    		var vertexCounter = 0;
    		var groupCount = 0;

    		var vector = new Vector3();

    		// generate vertices, normals and uvs

    		for ( var iy = 0; iy < gridY1; iy ++ ) {

    			var y = iy * segmentHeight - heightHalf;

    			for ( var ix = 0; ix < gridX1; ix ++ ) {

    				var x = ix * segmentWidth - widthHalf;

    				// set values to correct vector component
    				vector[ u ] = x * udir;
    				vector[ v ] = y * vdir;
    				vector[ w ] = depthHalf;

    				// now apply vector to vertex buffer
    				vertices[ vertexBufferOffset ] = vector.x;
    				vertices[ vertexBufferOffset + 1 ] = vector.y;
    				vertices[ vertexBufferOffset + 2 ] = vector.z;

    				// set values to correct vector component
    				vector[ u ] = 0;
    				vector[ v ] = 0;
    				vector[ w ] = depth > 0 ? 1 : - 1;

    				// now apply vector to normal buffer
    				normals[ vertexBufferOffset ] = vector.x;
    				normals[ vertexBufferOffset + 1 ] = vector.y;
    				normals[ vertexBufferOffset + 2 ] = vector.z;

    				// uvs
    				uvs[ uvBufferOffset ] = ix / gridX;
    				uvs[ uvBufferOffset + 1 ] = 1 - ( iy / gridY );

    				// update offsets and counters
    				vertexBufferOffset += 3;
    				uvBufferOffset += 2;
    				vertexCounter += 1;

    			}

    		}

    		// 1. you need three indices to draw a single face
    		// 2. a single segment consists of two faces
    		// 3. so we need to generate six (2*3) indices per segment

    		for ( iy = 0; iy < gridY; iy ++ ) {

    			for ( ix = 0; ix < gridX; ix ++ ) {

    				// indices
    				var a = numberOfVertices + ix + gridX1 * iy;
    				var b = numberOfVertices + ix + gridX1 * ( iy + 1 );
    				var c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );
    				var d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;

    				// face one
    				indices[ indexBufferOffset ] = a;
    				indices[ indexBufferOffset + 1 ] = b;
    				indices[ indexBufferOffset + 2 ] = d;

    				// face two
    				indices[ indexBufferOffset + 3 ] = b;
    				indices[ indexBufferOffset + 4 ] = c;
    				indices[ indexBufferOffset + 5 ] = d;

    				// update offsets and counters
    				indexBufferOffset += 6;
    				groupCount += 6;

    			}

    		}

    		// add a group to the geometry. this will ensure multi material support
    		scope.addGroup( groupStart, groupCount, materialIndex );

    		// calculate new start value for groups
    		groupStart += groupCount;

    		// update total number of vertices
    		numberOfVertices += vertexCounter;

    	}

    }

    BoxBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
    BoxBufferGeometry.prototype.constructor = BoxBufferGeometry;

    /**
     * @author mrdoob / http://mrdoob.com/
     * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
     */

    function PlaneBufferGeometry( width, height, widthSegments, heightSegments ) {

    	BufferGeometry.call( this );

    	this.type = 'PlaneBufferGeometry';

    	this.parameters = {
    		width: width,
    		height: height,
    		widthSegments: widthSegments,
    		heightSegments: heightSegments
    	};

    	var width_half = width / 2;
    	var height_half = height / 2;

    	var gridX = Math.floor( widthSegments ) || 1;
    	var gridY = Math.floor( heightSegments ) || 1;

    	var gridX1 = gridX + 1;
    	var gridY1 = gridY + 1;

    	var segment_width = width / gridX;
    	var segment_height = height / gridY;

    	var vertices = new Float32Array( gridX1 * gridY1 * 3 );
    	var normals = new Float32Array( gridX1 * gridY1 * 3 );
    	var uvs = new Float32Array( gridX1 * gridY1 * 2 );

    	var offset = 0;
    	var offset2 = 0;

    	for ( var iy = 0; iy < gridY1; iy ++ ) {

    		var y = iy * segment_height - height_half;

    		for ( var ix = 0; ix < gridX1; ix ++ ) {

    			var x = ix * segment_width - width_half;

    			vertices[ offset ] = x;
    			vertices[ offset + 1 ] = - y;

    			normals[ offset + 2 ] = 1;

    			uvs[ offset2 ] = ix / gridX;
    			uvs[ offset2 + 1 ] = 1 - ( iy / gridY );

    			offset += 3;
    			offset2 += 2;

    		}

    	}

    	offset = 0;

    	var indices = new ( ( vertices.length / 3 ) > 65535 ? Uint32Array : Uint16Array )( gridX * gridY * 6 );

    	for ( var iy = 0; iy < gridY; iy ++ ) {

    		for ( var ix = 0; ix < gridX; ix ++ ) {

    			var a = ix + gridX1 * iy;
    			var b = ix + gridX1 * ( iy + 1 );
    			var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
    			var d = ( ix + 1 ) + gridX1 * iy;

    			indices[ offset ] = a;
    			indices[ offset + 1 ] = b;
    			indices[ offset + 2 ] = d;

    			indices[ offset + 3 ] = b;
    			indices[ offset + 4 ] = c;
    			indices[ offset + 5 ] = d;

    			offset += 6;

    		}

    	}

    	this.setIndex( new BufferAttribute( indices, 1 ) );
    	this.addAttribute( 'position', new BufferAttribute( vertices, 3 ) );
    	this.addAttribute( 'normal', new BufferAttribute( normals, 3 ) );
    	this.addAttribute( 'uv', new BufferAttribute( uvs, 2 ) );

    }

    PlaneBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
    PlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author mikael emtinger / http://gomo.se/
     * @author WestLangley / http://github.com/WestLangley
    */

    function Camera() {

    	Object3D.call( this );

    	this.type = 'Camera';

    	this.matrixWorldInverse = new Matrix4();
    	this.projectionMatrix = new Matrix4();

    }

    Camera.prototype = Object.create( Object3D.prototype );
    Camera.prototype.constructor = Camera;

    Camera.prototype.isCamera = true;

    Camera.prototype.getWorldDirection = function () {

    	var quaternion = new Quaternion();

    	return function getWorldDirection( optionalTarget ) {

    		var result = optionalTarget || new Vector3();

    		this.getWorldQuaternion( quaternion );

    		return result.set( 0, 0, - 1 ).applyQuaternion( quaternion );

    	};

    }();

    Camera.prototype.lookAt = function () {

    	// This routine does not support cameras with rotated and/or translated parent(s)

    	var m1 = new Matrix4();

    	return function lookAt( vector ) {

    		m1.lookAt( this.position, vector, this.up );

    		this.quaternion.setFromRotationMatrix( m1 );

    	};

    }();

    Camera.prototype.clone = function () {

    	return new this.constructor().copy( this );

    };

    Camera.prototype.copy = function ( source ) {

    	Object3D.prototype.copy.call( this, source );

    	this.matrixWorldInverse.copy( source.matrixWorldInverse );
    	this.projectionMatrix.copy( source.projectionMatrix );

    	return this;

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author greggman / http://games.greggman.com/
     * @author zz85 / http://www.lab4games.net/zz85/blog
     * @author tschw
     */

    function PerspectiveCamera( fov, aspect, near, far ) {

    	Camera.call( this );

    	this.type = 'PerspectiveCamera';

    	this.fov = fov !== undefined ? fov : 50;
    	this.zoom = 1;

    	this.near = near !== undefined ? near : 0.1;
    	this.far = far !== undefined ? far : 2000;
    	this.focus = 10;

    	this.aspect = aspect !== undefined ? aspect : 1;
    	this.view = null;

    	this.filmGauge = 35;	// width of the film (default in millimeters)
    	this.filmOffset = 0;	// horizontal film offset (same unit as gauge)

    	this.updateProjectionMatrix();

    }

    PerspectiveCamera.prototype = Object.assign( Object.create( Camera.prototype ), {

    	constructor: PerspectiveCamera,

    	isPerspectiveCamera: true,

    	copy: function ( source ) {

    		Camera.prototype.copy.call( this, source );

    		this.fov = source.fov;
    		this.zoom = source.zoom;

    		this.near = source.near;
    		this.far = source.far;
    		this.focus = source.focus;

    		this.aspect = source.aspect;
    		this.view = source.view === null ? null : Object.assign( {}, source.view );

    		this.filmGauge = source.filmGauge;
    		this.filmOffset = source.filmOffset;

    		return this;

    	},

    	/**
    	 * Sets the FOV by focal length in respect to the current .filmGauge.
    	 *
    	 * The default film gauge is 35, so that the focal length can be specified for
    	 * a 35mm (full frame) camera.
    	 *
    	 * Values for focal length and film gauge must have the same unit.
    	 */
    	setFocalLength: function ( focalLength ) {

    		// see http://www.bobatkins.com/photography/technical/field_of_view.html
    		var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;

    		this.fov = exports.Math.RAD2DEG * 2 * Math.atan( vExtentSlope );
    		this.updateProjectionMatrix();

    	},

    	/**
    	 * Calculates the focal length from the current .fov and .filmGauge.
    	 */
    	getFocalLength: function () {

    		var vExtentSlope = Math.tan( exports.Math.DEG2RAD * 0.5 * this.fov );

    		return 0.5 * this.getFilmHeight() / vExtentSlope;

    	},

    	getEffectiveFOV: function () {

    		return exports.Math.RAD2DEG * 2 * Math.atan(
    				Math.tan( exports.Math.DEG2RAD * 0.5 * this.fov ) / this.zoom );

    	},

    	getFilmWidth: function () {

    		// film not completely covered in portrait format (aspect < 1)
    		return this.filmGauge * Math.min( this.aspect, 1 );

    	},

    	getFilmHeight: function () {

    		// film not completely covered in landscape format (aspect > 1)
    		return this.filmGauge / Math.max( this.aspect, 1 );

    	},

    	/**
    	 * Sets an offset in a larger frustum. This is useful for multi-window or
    	 * multi-monitor/multi-machine setups.
    	 *
    	 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
    	 * the monitors are in grid like this
    	 *
    	 *   +---+---+---+
    	 *   | A | B | C |
    	 *   +---+---+---+
    	 *   | D | E | F |
    	 *   +---+---+---+
    	 *
    	 * then for each monitor you would call it like this
    	 *
    	 *   var w = 1920;
    	 *   var h = 1080;
    	 *   var fullWidth = w * 3;
    	 *   var fullHeight = h * 2;
    	 *
    	 *   --A--
    	 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
    	 *   --B--
    	 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
    	 *   --C--
    	 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
    	 *   --D--
    	 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
    	 *   --E--
    	 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
    	 *   --F--
    	 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
    	 *
    	 *   Note there is no reason monitors have to be the same size or in a grid.
    	 */
    	setViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {

    		this.aspect = fullWidth / fullHeight;

    		this.view = {
    			fullWidth: fullWidth,
    			fullHeight: fullHeight,
    			offsetX: x,
    			offsetY: y,
    			width: width,
    			height: height
    		};

    		this.updateProjectionMatrix();

    	},

    	clearViewOffset: function() {

    		this.view = null;
    		this.updateProjectionMatrix();

    	},

    	updateProjectionMatrix: function () {

    		var near = this.near,
    			top = near * Math.tan(
    					exports.Math.DEG2RAD * 0.5 * this.fov ) / this.zoom,
    			height = 2 * top,
    			width = this.aspect * height,
    			left = - 0.5 * width,
    			view = this.view;

    		if ( view !== null ) {

    			var fullWidth = view.fullWidth,
    				fullHeight = view.fullHeight;

    			left += view.offsetX * width / fullWidth;
    			top -= view.offsetY * height / fullHeight;
    			width *= view.width / fullWidth;
    			height *= view.height / fullHeight;

    		}

    		var skew = this.filmOffset;
    		if ( skew !== 0 ) left += near * skew / this.getFilmWidth();

    		this.projectionMatrix.makeFrustum(
    				left, left + width, top - height, top, near, this.far );

    	},

    	toJSON: function ( meta ) {

    		var data = Object3D.prototype.toJSON.call( this, meta );

    		data.object.fov = this.fov;
    		data.object.zoom = this.zoom;

    		data.object.near = this.near;
    		data.object.far = this.far;
    		data.object.focus = this.focus;

    		data.object.aspect = this.aspect;

    		if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

    		data.object.filmGauge = this.filmGauge;
    		data.object.filmOffset = this.filmOffset;

    		return data;

    	}

    } );

    /**
     * @author alteredq / http://alteredqualia.com/
     * @author arose / http://github.com/arose
     */

    function OrthographicCamera( left, right, top, bottom, near, far ) {

    	Camera.call( this );

    	this.type = 'OrthographicCamera';

    	this.zoom = 1;
    	this.view = null;

    	this.left = left;
    	this.right = right;
    	this.top = top;
    	this.bottom = bottom;

    	this.near = ( near !== undefined ) ? near : 0.1;
    	this.far = ( far !== undefined ) ? far : 2000;

    	this.updateProjectionMatrix();

    }

    OrthographicCamera.prototype = Object.assign( Object.create( Camera.prototype ), {

    	constructor: OrthographicCamera,

    	isOrthographicCamera: true,

    	copy: function ( source ) {

    		Camera.prototype.copy.call( this, source );

    		this.left = source.left;
    		this.right = source.right;
    		this.top = source.top;
    		this.bottom = source.bottom;
    		this.near = source.near;
    		this.far = source.far;

    		this.zoom = source.zoom;
    		this.view = source.view === null ? null : Object.assign( {}, source.view );

    		return this;

    	},

    	setViewOffset: function( fullWidth, fullHeight, x, y, width, height ) {

    		this.view = {
    			fullWidth: fullWidth,
    			fullHeight: fullHeight,
    			offsetX: x,
    			offsetY: y,
    			width: width,
    			height: height
    		};

    		this.updateProjectionMatrix();

    	},

    	clearViewOffset: function() {

    		this.view = null;
    		this.updateProjectionMatrix();

    	},

    	updateProjectionMatrix: function () {

    		var dx = ( this.right - this.left ) / ( 2 * this.zoom );
    		var dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
    		var cx = ( this.right + this.left ) / 2;
    		var cy = ( this.top + this.bottom ) / 2;

    		var left = cx - dx;
    		var right = cx + dx;
    		var top = cy + dy;
    		var bottom = cy - dy;

    		if ( this.view !== null ) {

    			var zoomW = this.zoom / ( this.view.width / this.view.fullWidth );
    			var zoomH = this.zoom / ( this.view.height / this.view.fullHeight );
    			var scaleW = ( this.right - this.left ) / this.view.width;
    			var scaleH = ( this.top - this.bottom ) / this.view.height;

    			left += scaleW * ( this.view.offsetX / zoomW );
    			right = left + scaleW * ( this.view.width / zoomW );
    			top -= scaleH * ( this.view.offsetY / zoomH );
    			bottom = top - scaleH * ( this.view.height / zoomH );

    		}

    		this.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );

    	},

    	toJSON: function ( meta ) {

    		var data = Object3D.prototype.toJSON.call( this, meta );

    		data.object.zoom = this.zoom;
    		data.object.left = this.left;
    		data.object.right = this.right;
    		data.object.top = this.top;
    		data.object.bottom = this.bottom;
    		data.object.near = this.near;
    		data.object.far = this.far;

    		if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

    		return data;

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function WebGLIndexedBufferRenderer( gl, extensions, infoRender ) {

    	var mode;

    	function setMode( value ) {

    		mode = value;

    	}

    	var type, size;

    	function setIndex( index ) {

    		if ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {

    			type = gl.UNSIGNED_INT;
    			size = 4;

    		} else {

    			type = gl.UNSIGNED_SHORT;
    			size = 2;

    		}

    	}

    	function render( start, count ) {

    		gl.drawElements( mode, count, type, start * size );

    		infoRender.calls ++;
    		infoRender.vertices += count;

    		if ( mode === gl.TRIANGLES ) infoRender.faces += count / 3;

    	}

    	function renderInstances( geometry, start, count ) {

    		var extension = extensions.get( 'ANGLE_instanced_arrays' );

    		if ( extension === null ) {

    			console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
    			return;

    		}

    		extension.drawElementsInstancedANGLE( mode, count, type, start * size, geometry.maxInstancedCount );

    		infoRender.calls ++;
    		infoRender.vertices += count * geometry.maxInstancedCount;

    		if ( mode === gl.TRIANGLES ) infoRender.faces += geometry.maxInstancedCount * count / 3;

    	}

    	return {

    		setMode: setMode,
    		setIndex: setIndex,
    		render: render,
    		renderInstances: renderInstances

    	};

    }

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function WebGLBufferRenderer( gl, extensions, infoRender ) {

    	var mode;

    	function setMode( value ) {

    		mode = value;

    	}

    	function render( start, count ) {

    		gl.drawArrays( mode, start, count );

    		infoRender.calls ++;
    		infoRender.vertices += count;

    		if ( mode === gl.TRIANGLES ) infoRender.faces += count / 3;

    	}

    	function renderInstances( geometry ) {

    		var extension = extensions.get( 'ANGLE_instanced_arrays' );

    		if ( extension === null ) {

    			console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
    			return;

    		}

    		var position = geometry.attributes.position;

    		var count = 0;

    		if ( (position && position.isInterleavedBufferAttribute) ) {

    			count = position.data.count;

    			extension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );

    		} else {

    			count = position.count;

    			extension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );

    		}

    		infoRender.calls ++;
    		infoRender.vertices += count * geometry.maxInstancedCount;

    		if ( mode === gl.TRIANGLES ) infoRender.faces += geometry.maxInstancedCount * count / 3;

    	}

    	return {
    		setMode: setMode,
    		render: render,
    		renderInstances: renderInstances
    	};

    }

    function WebGLLights() {

    	var lights = {};

    	return {

    		get: function ( light ) {

    			if ( lights[ light.id ] !== undefined ) {

    				return lights[ light.id ];

    			}

    			var uniforms;

    			switch ( light.type ) {

    				case 'DirectionalLight':
    					uniforms = {
    						direction: new Vector3(),
    						color: new Color(),

    						shadow: false,
    						shadowBias: 0,
    						shadowRadius: 1,
    						shadowMapSize: new Vector2()
    					};
    					break;

    				case 'SpotLight':
    					uniforms = {
    						position: new Vector3(),
    						direction: new Vector3(),
    						color: new Color(),
    						distance: 0,
    						coneCos: 0,
    						penumbraCos: 0,
    						decay: 0,

    						shadow: false,
    						shadowBias: 0,
    						shadowRadius: 1,
    						shadowMapSize: new Vector2()
    					};
    					break;

    				case 'PointLight':
    					uniforms = {
    						position: new Vector3(),
    						color: new Color(),
    						distance: 0,
    						decay: 0,

    						shadow: false,
    						shadowBias: 0,
    						shadowRadius: 1,
    						shadowMapSize: new Vector2()
    					};
    					break;

    				case 'HemisphereLight':
    					uniforms = {
    						direction: new Vector3(),
    						skyColor: new Color(),
    						groundColor: new Color()
    					};
    					break;

    			}

    			lights[ light.id ] = uniforms;

    			return uniforms;

    		}

    	};

    }

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function addLineNumbers( string ) {

    	var lines = string.split( '\n' );

    	for ( var i = 0; i < lines.length; i ++ ) {

    		lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];

    	}

    	return lines.join( '\n' );

    }

    function WebGLShader( gl, type, string ) {

    	var shader = gl.createShader( type );

    	gl.shaderSource( shader, string );
    	gl.compileShader( shader );

    	if ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {

    		console.error( 'THREE.WebGLShader: Shader couldn\'t compile.' );

    	}

    	if ( gl.getShaderInfoLog( shader ) !== '' ) {

    		console.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );

    	}

    	// --enable-privileged-webgl-extension
    	// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

    	return shader;

    }

    var programIdCount = 0;

    function getEncodingComponents( encoding ) {

    	switch ( encoding ) {

    		case LinearEncoding:
    			return [ 'Linear','( value )' ];
    		case sRGBEncoding:
    			return [ 'sRGB','( value )' ];
    		case RGBEEncoding:
    			return [ 'RGBE','( value )' ];
    		case RGBM7Encoding:
    			return [ 'RGBM','( value, 7.0 )' ];
    		case RGBM16Encoding:
    			return [ 'RGBM','( value, 16.0 )' ];
    		case RGBDEncoding:
    			return [ 'RGBD','( value, 256.0 )' ];
    		case GammaEncoding:
    			return [ 'Gamma','( value, float( GAMMA_FACTOR ) )' ];
    		default:
    			throw new Error( 'unsupported encoding: ' + encoding );

    	}

    }

    function getTexelDecodingFunction( functionName, encoding ) {

    	var components = getEncodingComponents( encoding );
    	return "vec4 " + functionName + "( vec4 value ) { return " + components[ 0 ] + "ToLinear" + components[ 1 ] + "; }";

    }

    function getTexelEncodingFunction( functionName, encoding ) {

    	var components = getEncodingComponents( encoding );
    	return "vec4 " + functionName + "( vec4 value ) { return LinearTo" + components[ 0 ] + components[ 1 ] + "; }";

    }

    function getToneMappingFunction( functionName, toneMapping ) {

    	var toneMappingName;

    	switch ( toneMapping ) {

    		case LinearToneMapping:
    			toneMappingName = "Linear";
    			break;

    		case ReinhardToneMapping:
    			toneMappingName = "Reinhard";
    			break;

    		case Uncharted2ToneMapping:
    			toneMappingName = "Uncharted2";
    			break;

    		case CineonToneMapping:
    			toneMappingName = "OptimizedCineon";
    			break;

    		default:
    			throw new Error( 'unsupported toneMapping: ' + toneMapping );

    	}

    	return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";

    }

    function generateExtensions( extensions, parameters, rendererExtensions ) {

    	extensions = extensions || {};

    	var chunks = [
    		( extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap || parameters.flatShading ) ? '#extension GL_OES_standard_derivatives : enable' : '',
    		( extensions.fragDepth || parameters.logarithmicDepthBuffer ) && rendererExtensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',
    		( extensions.drawBuffers ) && rendererExtensions.get( 'WEBGL_draw_buffers' ) ? '#extension GL_EXT_draw_buffers : require' : '',
    		( extensions.shaderTextureLOD || parameters.envMap ) && rendererExtensions.get( 'EXT_shader_texture_lod' ) ? '#extension GL_EXT_shader_texture_lod : enable' : '',
    	];

    	return chunks.filter( filterEmptyLine ).join( '\n' );

    }

    function generateDefines( defines ) {

    	var chunks = [];

    	for ( var name in defines ) {

    		var value = defines[ name ];

    		if ( value === false ) continue;

    		chunks.push( '#define ' + name + ' ' + value );

    	}

    	return chunks.join( '\n' );

    }

    function fetchAttributeLocations( gl, program, identifiers ) {

    	var attributes = {};

    	var n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );

    	for ( var i = 0; i < n; i ++ ) {

    		var info = gl.getActiveAttrib( program, i );
    		var name = info.name;

    		// console.log("THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:", name, i );

    		attributes[ name ] = gl.getAttribLocation( program, name );

    	}

    	return attributes;

    }

    function filterEmptyLine( string ) {

    	return string !== '';

    }

    function replaceLightNums( string, parameters ) {

    	return string
    		.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )
    		.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )
    		.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )
    		.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights );

    }

    function parseIncludes( string ) {

    	var pattern = /#include +<([\w\d.]+)>/g;

    	function replace( match, include ) {

    		var replace = ShaderChunk[ include ];

    		if ( replace === undefined ) {

    			throw new Error( 'Can not resolve #include <' + include + '>' );

    		}

    		return parseIncludes( replace );

    	}

    	return string.replace( pattern, replace );

    }

    function unrollLoops( string ) {

    	var pattern = /for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;

    	function replace( match, start, end, snippet ) {

    		var unroll = '';

    		for ( var i = parseInt( start ); i < parseInt( end ); i ++ ) {

    			unroll += snippet.replace( /\[ i \]/g, '[ ' + i + ' ]' );

    		}

    		return unroll;

    	}

    	return string.replace( pattern, replace );

    }

    function WebGLProgram( renderer, code, material, parameters ) {

    	var gl = renderer.context;

    	var extensions = material.extensions;
    	var defines = material.defines;

    	var vertexShader = material.__webglShader.vertexShader;
    	var fragmentShader = material.__webglShader.fragmentShader;

    	var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

    	if ( parameters.shadowMapType === PCFShadowMap ) {

    		shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';

    	} else if ( parameters.shadowMapType === PCFSoftShadowMap ) {

    		shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';

    	}

    	var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
    	var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
    	var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';

    	if ( parameters.envMap ) {

    		switch ( material.envMap.mapping ) {

    			case CubeReflectionMapping:
    			case CubeRefractionMapping:
    				envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
    				break;

    			case CubeUVReflectionMapping:
    			case CubeUVRefractionMapping:
    				envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
    				break;

    			case EquirectangularReflectionMapping:
    			case EquirectangularRefractionMapping:
    				envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
    				break;

    			case SphericalReflectionMapping:
    				envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
    				break;

    		}

    		switch ( material.envMap.mapping ) {

    			case CubeRefractionMapping:
    			case EquirectangularRefractionMapping:
    				envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
    				break;

    		}

    		switch ( material.combine ) {

    			case MultiplyOperation:
    				envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
    				break;

    			case MixOperation:
    				envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
    				break;

    			case AddOperation:
    				envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
    				break;

    		}

    	}

    	var gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;

    	// console.log( 'building new program ' );

    	//

    	var customExtensions = generateExtensions( extensions, parameters, renderer.extensions );

    	var customDefines = generateDefines( defines );

    	//

    	var program = gl.createProgram();

    	var prefixVertex, prefixFragment;

    	if ( material.isRawShaderMaterial ) {

    		prefixVertex = [

    			customDefines,

    			'\n'

    		].filter( filterEmptyLine ).join( '\n' );

    		prefixFragment = [

    			customExtensions,
    			customDefines,

    			'\n'

    		].filter( filterEmptyLine ).join( '\n' );

    	} else {

    		prefixVertex = [

    			'precision ' + parameters.precision + ' float;',
    			'precision ' + parameters.precision + ' int;',

    			'#define SHADER_NAME ' + material.__webglShader.name,

    			customDefines,

    			parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',

    			'#define GAMMA_FACTOR ' + gammaFactorDefine,

    			'#define MAX_BONES ' + parameters.maxBones,

    			parameters.map ? '#define USE_MAP' : '',
    			parameters.envMap ? '#define USE_ENVMAP' : '',
    			parameters.envMap ? '#define ' + envMapModeDefine : '',
    			parameters.lightMap ? '#define USE_LIGHTMAP' : '',
    			parameters.aoMap ? '#define USE_AOMAP' : '',
    			parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
    			parameters.bumpMap ? '#define USE_BUMPMAP' : '',
    			parameters.normalMap ? '#define USE_NORMALMAP' : '',
    			parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
    			parameters.specularMap ? '#define USE_SPECULARMAP' : '',
    			parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
    			parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
    			parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
    			parameters.vertexColors ? '#define USE_COLOR' : '',

    			parameters.flatShading ? '#define FLAT_SHADED' : '',

    			parameters.skinning ? '#define USE_SKINNING' : '',
    			parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',

    			parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
    			parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
    			parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
    			parameters.flipSided ? '#define FLIP_SIDED' : '',

    			'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,

    			parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
    			parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

    			parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

    			parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
    			parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

    			'uniform mat4 modelMatrix;',
    			'uniform mat4 modelViewMatrix;',
    			'uniform mat4 projectionMatrix;',
    			'uniform mat4 viewMatrix;',
    			'uniform mat3 normalMatrix;',
    			'uniform vec3 cameraPosition;',

    			'attribute vec3 position;',
    			'attribute vec3 normal;',
    			'attribute vec2 uv;',

    			'#ifdef USE_COLOR',

    			'	attribute vec3 color;',

    			'#endif',

    			'#ifdef USE_MORPHTARGETS',

    			'	attribute vec3 morphTarget0;',
    			'	attribute vec3 morphTarget1;',
    			'	attribute vec3 morphTarget2;',
    			'	attribute vec3 morphTarget3;',

    			'	#ifdef USE_MORPHNORMALS',

    			'		attribute vec3 morphNormal0;',
    			'		attribute vec3 morphNormal1;',
    			'		attribute vec3 morphNormal2;',
    			'		attribute vec3 morphNormal3;',

    			'	#else',

    			'		attribute vec3 morphTarget4;',
    			'		attribute vec3 morphTarget5;',
    			'		attribute vec3 morphTarget6;',
    			'		attribute vec3 morphTarget7;',

    			'	#endif',

    			'#endif',

    			'#ifdef USE_SKINNING',

    			'	attribute vec4 skinIndex;',
    			'	attribute vec4 skinWeight;',

    			'#endif',

    			'\n'

    		].filter( filterEmptyLine ).join( '\n' );

    		prefixFragment = [

    			customExtensions,

    			'precision ' + parameters.precision + ' float;',
    			'precision ' + parameters.precision + ' int;',

    			'#define SHADER_NAME ' + material.__webglShader.name,

    			customDefines,

    			parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',

    			'#define GAMMA_FACTOR ' + gammaFactorDefine,

    			( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
    			( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',

    			parameters.map ? '#define USE_MAP' : '',
    			parameters.envMap ? '#define USE_ENVMAP' : '',
    			parameters.envMap ? '#define ' + envMapTypeDefine : '',
    			parameters.envMap ? '#define ' + envMapModeDefine : '',
    			parameters.envMap ? '#define ' + envMapBlendingDefine : '',
    			parameters.lightMap ? '#define USE_LIGHTMAP' : '',
    			parameters.aoMap ? '#define USE_AOMAP' : '',
    			parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
    			parameters.bumpMap ? '#define USE_BUMPMAP' : '',
    			parameters.normalMap ? '#define USE_NORMALMAP' : '',
    			parameters.specularMap ? '#define USE_SPECULARMAP' : '',
    			parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
    			parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
    			parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
    			parameters.vertexColors ? '#define USE_COLOR' : '',

    			parameters.flatShading ? '#define FLAT_SHADED' : '',

    			parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
    			parameters.flipSided ? '#define FLIP_SIDED' : '',

    			'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,

    			parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
    			parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

    			parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : '',

    			parameters.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : '',

    			parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
    			parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

    			parameters.envMap && renderer.extensions.get( 'EXT_shader_texture_lod' ) ? '#define TEXTURE_LOD_EXT' : '',

    			'uniform mat4 viewMatrix;',
    			'uniform vec3 cameraPosition;',

    			( parameters.toneMapping !== NoToneMapping ) ? "#define TONE_MAPPING" : '',
    			( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '',  // this code is required here because it is used by the toneMapping() function defined below
    			( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( "toneMapping", parameters.toneMapping ) : '',

    			( parameters.outputEncoding || parameters.mapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ) ? ShaderChunk[ 'encodings_pars_fragment' ] : '', // this code is required here because it is used by the various encoding/decoding function defined below
    			parameters.mapEncoding ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',
    			parameters.envMapEncoding ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',
    			parameters.emissiveMapEncoding ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',
    			parameters.outputEncoding ? getTexelEncodingFunction( "linearToOutputTexel", parameters.outputEncoding ) : '',

    			parameters.depthPacking ? "#define DEPTH_PACKING " + material.depthPacking : '',

    			'\n'

    		].filter( filterEmptyLine ).join( '\n' );

    	}

    	vertexShader = parseIncludes( vertexShader, parameters );
    	vertexShader = replaceLightNums( vertexShader, parameters );

    	fragmentShader = parseIncludes( fragmentShader, parameters );
    	fragmentShader = replaceLightNums( fragmentShader, parameters );

    	if ( ! material.isShaderMaterial ) {

    		vertexShader = unrollLoops( vertexShader );
    		fragmentShader = unrollLoops( fragmentShader );

    	}

    	var vertexGlsl = prefixVertex + vertexShader;
    	var fragmentGlsl = prefixFragment + fragmentShader;

    	// console.log( '*VERTEX*', vertexGlsl );
    	// console.log( '*FRAGMENT*', fragmentGlsl );

    	var glVertexShader = WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );
    	var glFragmentShader = WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );

    	gl.attachShader( program, glVertexShader );
    	gl.attachShader( program, glFragmentShader );

    	// Force a particular attribute to index 0.

    	if ( material.index0AttributeName !== undefined ) {

    		gl.bindAttribLocation( program, 0, material.index0AttributeName );

    	} else if ( parameters.morphTargets === true ) {

    		// programs with morphTargets displace position out of attribute 0
    		gl.bindAttribLocation( program, 0, 'position' );

    	}

    	gl.linkProgram( program );

    	var programLog = gl.getProgramInfoLog( program );
    	var vertexLog = gl.getShaderInfoLog( glVertexShader );
    	var fragmentLog = gl.getShaderInfoLog( glFragmentShader );

    	var runnable = true;
    	var haveDiagnostics = true;

    	// console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );
    	// console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );

    	if ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {

    		runnable = false;

    		console.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );

    	} else if ( programLog !== '' ) {

    		console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );

    	} else if ( vertexLog === '' || fragmentLog === '' ) {

    		haveDiagnostics = false;

    	}

    	if ( haveDiagnostics ) {

    		this.diagnostics = {

    			runnable: runnable,
    			material: material,

    			programLog: programLog,

    			vertexShader: {

    				log: vertexLog,
    				prefix: prefixVertex

    			},

    			fragmentShader: {

    				log: fragmentLog,
    				prefix: prefixFragment

    			}

    		};

    	}

    	// clean up

    	gl.deleteShader( glVertexShader );
    	gl.deleteShader( glFragmentShader );

    	// set up caching for uniform locations

    	var cachedUniforms;

    	this.getUniforms = function() {

    		if ( cachedUniforms === undefined ) {

    			cachedUniforms =
    					new WebGLUniforms( gl, program, renderer );

    		}

    		return cachedUniforms;

    	};

    	// set up caching for attribute locations

    	var cachedAttributes;

    	this.getAttributes = function() {

    		if ( cachedAttributes === undefined ) {

    			cachedAttributes = fetchAttributeLocations( gl, program );

    		}

    		return cachedAttributes;

    	};

    	// free resource

    	this.destroy = function() {

    		gl.deleteProgram( program );
    		this.program = undefined;

    	};

    	// DEPRECATED

    	Object.defineProperties( this, {

    		uniforms: {
    			get: function() {

    				console.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );
    				return this.getUniforms();

    			}
    		},

    		attributes: {
    			get: function() {

    				console.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );
    				return this.getAttributes();

    			}
    		}

    	} );


    	//

    	this.id = programIdCount ++;
    	this.code = code;
    	this.usedTimes = 1;
    	this.program = program;
    	this.vertexShader = glVertexShader;
    	this.fragmentShader = glFragmentShader;

    	return this;

    }

    function WebGLPrograms( renderer, capabilities ) {

    	var programs = [];

    	var shaderIDs = {
    		MeshDepthMaterial: 'depth',
    		MeshNormalMaterial: 'normal',
    		MeshBasicMaterial: 'basic',
    		MeshLambertMaterial: 'lambert',
    		MeshPhongMaterial: 'phong',
    		MeshStandardMaterial: 'physical',
    		MeshPhysicalMaterial: 'physical',
    		LineBasicMaterial: 'basic',
    		LineDashedMaterial: 'dashed',
    		PointsMaterial: 'points'
    	};

    	var parameterNames = [
    		"precision", "supportsVertexTextures", "map", "mapEncoding", "envMap", "envMapMode", "envMapEncoding",
    		"lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "displacementMap", "specularMap",
    		"roughnessMap", "metalnessMap",
    		"alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp",
    		"flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning",
    		"maxBones", "useVertexTexture", "morphTargets", "morphNormals",
    		"maxMorphTargets", "maxMorphNormals", "premultipliedAlpha",
    		"numDirLights", "numPointLights", "numSpotLights", "numHemiLights",
    		"shadowMapEnabled", "shadowMapType", "toneMapping", 'physicallyCorrectLights',
    		"alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "depthPacking"
    	];


    	function allocateBones( object ) {

    		if ( capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture ) {

    			return 1024;

    		} else {

    			// default for when object is not specified
    			// ( for example when prebuilding shader to be used with multiple objects )
    			//
    			//  - leave some extra space for other uniforms
    			//  - limit here is ANGLE's 254 max uniform vectors
    			//    (up to 54 should be safe)

    			var nVertexUniforms = capabilities.maxVertexUniforms;
    			var nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );

    			var maxBones = nVertexMatrices;

    			if ( object !== undefined && (object && object.isSkinnedMesh) ) {

    				maxBones = Math.min( object.skeleton.bones.length, maxBones );

    				if ( maxBones < object.skeleton.bones.length ) {

    					console.warn( 'WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)' );

    				}

    			}

    			return maxBones;

    		}

    	}

    	function getTextureEncodingFromMap( map, gammaOverrideLinear ) {

    		var encoding;

    		if ( ! map ) {

    			encoding = LinearEncoding;

    		} else if ( (map && map.isTexture) ) {

    			encoding = map.encoding;

    		} else if ( (map && map.isWebGLRenderTarget) ) {

    			console.warn( "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead." );
    			encoding = map.texture.encoding;

    		}

    		// add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.
    		if ( encoding === LinearEncoding && gammaOverrideLinear ) {

    			encoding = GammaEncoding;

    		}

    		return encoding;

    	}

    	this.getParameters = function ( material, lights, fog, nClipPlanes, object ) {

    		var shaderID = shaderIDs[ material.type ];

    		// heuristics to create shader parameters according to lights in the scene
    		// (not to blow over maxLights budget)

    		var maxBones = allocateBones( object );
    		var precision = renderer.getPrecision();

    		if ( material.precision !== null ) {

    			precision = capabilities.getMaxPrecision( material.precision );

    			if ( precision !== material.precision ) {

    				console.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );

    			}

    		}

    		var currentRenderTarget = renderer.getCurrentRenderTarget();

    		var parameters = {

    			shaderID: shaderID,

    			precision: precision,
    			supportsVertexTextures: capabilities.vertexTextures,
    			outputEncoding: getTextureEncodingFromMap( ( ! currentRenderTarget ) ? null : currentRenderTarget.texture, renderer.gammaOutput ),
    			map: !! material.map,
    			mapEncoding: getTextureEncodingFromMap( material.map, renderer.gammaInput ),
    			envMap: !! material.envMap,
    			envMapMode: material.envMap && material.envMap.mapping,
    			envMapEncoding: getTextureEncodingFromMap( material.envMap, renderer.gammaInput ),
    			envMapCubeUV: ( !! material.envMap ) && ( ( material.envMap.mapping === CubeUVReflectionMapping ) || ( material.envMap.mapping === CubeUVRefractionMapping ) ),
    			lightMap: !! material.lightMap,
    			aoMap: !! material.aoMap,
    			emissiveMap: !! material.emissiveMap,
    			emissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap, renderer.gammaInput ),
    			bumpMap: !! material.bumpMap,
    			normalMap: !! material.normalMap,
    			displacementMap: !! material.displacementMap,
    			roughnessMap: !! material.roughnessMap,
    			metalnessMap: !! material.metalnessMap,
    			specularMap: !! material.specularMap,
    			alphaMap: !! material.alphaMap,

    			combine: material.combine,

    			vertexColors: material.vertexColors,

    			fog: !! fog,
    			useFog: material.fog,
    			fogExp: (fog && fog.isFogExp2),

    			flatShading: material.shading === FlatShading,

    			sizeAttenuation: material.sizeAttenuation,
    			logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,

    			skinning: material.skinning,
    			maxBones: maxBones,
    			useVertexTexture: capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture,

    			morphTargets: material.morphTargets,
    			morphNormals: material.morphNormals,
    			maxMorphTargets: renderer.maxMorphTargets,
    			maxMorphNormals: renderer.maxMorphNormals,

    			numDirLights: lights.directional.length,
    			numPointLights: lights.point.length,
    			numSpotLights: lights.spot.length,
    			numHemiLights: lights.hemi.length,

    			numClippingPlanes: nClipPlanes,

    			shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && lights.shadows.length > 0,
    			shadowMapType: renderer.shadowMap.type,

    			toneMapping: renderer.toneMapping,
    			physicallyCorrectLights: renderer.physicallyCorrectLights,

    			premultipliedAlpha: material.premultipliedAlpha,

    			alphaTest: material.alphaTest,
    			doubleSided: material.side === DoubleSide,
    			flipSided: material.side === BackSide,

    			depthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false

    		};

    		return parameters;

    	};

    	this.getProgramCode = function ( material, parameters ) {

    		var array = [];

    		if ( parameters.shaderID ) {

    			array.push( parameters.shaderID );

    		} else {

    			array.push( material.fragmentShader );
    			array.push( material.vertexShader );

    		}

    		if ( material.defines !== undefined ) {

    			for ( var name in material.defines ) {

    				array.push( name );
    				array.push( material.defines[ name ] );

    			}

    		}

    		for ( var i = 0; i < parameterNames.length; i ++ ) {

    			array.push( parameters[ parameterNames[ i ] ] );

    		}

    		return array.join();

    	};

    	this.acquireProgram = function ( material, parameters, code ) {

    		var program;

    		// Check if code has been already compiled
    		for ( var p = 0, pl = programs.length; p < pl; p ++ ) {

    			var programInfo = programs[ p ];

    			if ( programInfo.code === code ) {

    				program = programInfo;
    				++ program.usedTimes;

    				break;

    			}

    		}

    		if ( program === undefined ) {

    			program = new WebGLProgram( renderer, code, material, parameters );
    			programs.push( program );

    		}

    		return program;

    	};

    	this.releaseProgram = function( program ) {

    		if ( -- program.usedTimes === 0 ) {

    			// Remove from unordered set
    			var i = programs.indexOf( program );
    			programs[ i ] = programs[ programs.length - 1 ];
    			programs.pop();

    			// Free WebGL resources
    			program.destroy();

    		}

    	};

    	// Exposed for resource monitoring & error feedback via renderer.info:
    	this.programs = programs;

    }

    function WebGLGeometries( gl, properties, info ) {

    	var geometries = {};

    	function onGeometryDispose( event ) {

    		var geometry = event.target;
    		var buffergeometry = geometries[ geometry.id ];

    		if ( buffergeometry.index !== null ) {

    			deleteAttribute( buffergeometry.index );

    		}

    		deleteAttributes( buffergeometry.attributes );

    		geometry.removeEventListener( 'dispose', onGeometryDispose );

    		delete geometries[ geometry.id ];

    		// TODO

    		var property = properties.get( geometry );

    		if ( property.wireframe ) {

    			deleteAttribute( property.wireframe );

    		}

    		properties.delete( geometry );

    		var bufferproperty = properties.get( buffergeometry );

    		if ( bufferproperty.wireframe ) {

    			deleteAttribute( bufferproperty.wireframe );

    		}

    		properties.delete( buffergeometry );

    		//

    		info.memory.geometries --;

    	}

    	function getAttributeBuffer( attribute ) {

    		if ( attribute.isInterleavedBufferAttribute ) {

    			return properties.get( attribute.data ).__webglBuffer;

    		}

    		return properties.get( attribute ).__webglBuffer;

    	}

    	function deleteAttribute( attribute ) {

    		var buffer = getAttributeBuffer( attribute );

    		if ( buffer !== undefined ) {

    			gl.deleteBuffer( buffer );
    			removeAttributeBuffer( attribute );

    		}

    	}

    	function deleteAttributes( attributes ) {

    		for ( var name in attributes ) {

    			deleteAttribute( attributes[ name ] );

    		}

    	}

    	function removeAttributeBuffer( attribute ) {

    		if ( attribute.isInterleavedBufferAttribute ) {

    			properties.delete( attribute.data );

    		} else {

    			properties.delete( attribute );

    		}

    	}

    	return {

    		get: function ( object ) {

    			var geometry = object.geometry;

    			if ( geometries[ geometry.id ] !== undefined ) {

    				return geometries[ geometry.id ];

    			}

    			geometry.addEventListener( 'dispose', onGeometryDispose );

    			var buffergeometry;

    			if ( geometry.isBufferGeometry ) {

    				buffergeometry = geometry;

    			} else if ( geometry.isGeometry ) {

    				if ( geometry._bufferGeometry === undefined ) {

    					geometry._bufferGeometry = new BufferGeometry().setFromObject( object );

    				}

    				buffergeometry = geometry._bufferGeometry;

    			}

    			geometries[ geometry.id ] = buffergeometry;

    			info.memory.geometries ++;

    			return buffergeometry;

    		}

    	};

    }

    function WebGLObjects( gl, properties, info ) {

    	var geometries = new WebGLGeometries( gl, properties, info );

    	//

    	function update( object ) {

    		// TODO: Avoid updating twice (when using shadowMap). Maybe add frame counter.

    		var geometry = geometries.get( object );

    		if ( object.geometry.isGeometry ) {

    			geometry.updateFromObject( object );

    		}

    		var index = geometry.index;
    		var attributes = geometry.attributes;

    		if ( index !== null ) {

    			updateAttribute( index, gl.ELEMENT_ARRAY_BUFFER );

    		}

    		for ( var name in attributes ) {

    			updateAttribute( attributes[ name ], gl.ARRAY_BUFFER );

    		}

    		// morph targets

    		var morphAttributes = geometry.morphAttributes;

    		for ( var name in morphAttributes ) {

    			var array = morphAttributes[ name ];

    			for ( var i = 0, l = array.length; i < l; i ++ ) {

    				updateAttribute( array[ i ], gl.ARRAY_BUFFER );

    			}

    		}

    		return geometry;

    	}

    	function updateAttribute( attribute, bufferType ) {

    		var data = ( attribute.isInterleavedBufferAttribute ) ? attribute.data : attribute;

    		var attributeProperties = properties.get( data );

    		if ( attributeProperties.__webglBuffer === undefined ) {

    			createBuffer( attributeProperties, data, bufferType );

    		} else if ( attributeProperties.version !== data.version ) {

    			updateBuffer( attributeProperties, data, bufferType );

    		}

    	}

    	function createBuffer( attributeProperties, data, bufferType ) {

    		attributeProperties.__webglBuffer = gl.createBuffer();
    		gl.bindBuffer( bufferType, attributeProperties.__webglBuffer );

    		var usage = data.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;

    		gl.bufferData( bufferType, data.array, usage );

    		attributeProperties.version = data.version;

    	}

    	function updateBuffer( attributeProperties, data, bufferType ) {

    		gl.bindBuffer( bufferType, attributeProperties.__webglBuffer );

    		if ( data.dynamic === false || data.updateRange.count === - 1 ) {

    			// Not using update ranges

    			gl.bufferSubData( bufferType, 0, data.array );

    		} else if ( data.updateRange.count === 0 ) {

    			console.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );

    		} else {

    			gl.bufferSubData( bufferType, data.updateRange.offset * data.array.BYTES_PER_ELEMENT,
    							  data.array.subarray( data.updateRange.offset, data.updateRange.offset + data.updateRange.count ) );

    			data.updateRange.count = 0; // reset range

    		}

    		attributeProperties.version = data.version;

    	}

    	function getAttributeBuffer( attribute ) {

    		if ( attribute.isInterleavedBufferAttribute ) {

    			return properties.get( attribute.data ).__webglBuffer;

    		}

    		return properties.get( attribute ).__webglBuffer;

    	}

    	function getWireframeAttribute( geometry ) {

    		var property = properties.get( geometry );

    		if ( property.wireframe !== undefined ) {

    			return property.wireframe;

    		}

    		var indices = [];

    		var index = geometry.index;
    		var attributes = geometry.attributes;
    		var position = attributes.position;

    		// console.time( 'wireframe' );

    		if ( index !== null ) {

    			var edges = {};
    			var array = index.array;

    			for ( var i = 0, l = array.length; i < l; i += 3 ) {

    				var a = array[ i + 0 ];
    				var b = array[ i + 1 ];
    				var c = array[ i + 2 ];

    				indices.push( a, b, b, c, c, a );

    			}

    		} else {

    			var array = attributes.position.array;

    			for ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {

    				var a = i + 0;
    				var b = i + 1;
    				var c = i + 2;

    				indices.push( a, b, b, c, c, a );

    			}

    		}

    		// console.timeEnd( 'wireframe' );

    		var TypeArray = position.count > 65535 ? Uint32Array : Uint16Array;
    		var attribute = new BufferAttribute( new TypeArray( indices ), 1 );

    		updateAttribute( attribute, gl.ELEMENT_ARRAY_BUFFER );

    		property.wireframe = attribute;

    		return attribute;

    	}

    	return {

    		getAttributeBuffer: getAttributeBuffer,
    		getWireframeAttribute: getWireframeAttribute,

    		update: update

    	};

    }

    function WebGLTextures( _gl, extensions, state, properties, capabilities, paramThreeToGL, info ) {

    	var _infoMemory = info.memory;
    	var _isWebGL2 = ( typeof WebGL2RenderingContext !== 'undefined' && _gl instanceof WebGL2RenderingContext );

    	//

    	function clampToMaxSize( image, maxSize ) {

    		if ( image.width > maxSize || image.height > maxSize ) {

    			// Warning: Scaling through the canvas will only work with images that use
    			// premultiplied alpha.

    			var scale = maxSize / Math.max( image.width, image.height );

    			var canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
    			canvas.width = Math.floor( image.width * scale );
    			canvas.height = Math.floor( image.height * scale );

    			var context = canvas.getContext( '2d' );
    			context.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );

    			console.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );

    			return canvas;

    		}

    		return image;

    	}

    	function isPowerOfTwo( image ) {

    		return exports.Math.isPowerOfTwo( image.width ) && exports.Math.isPowerOfTwo( image.height );

    	}

    	function makePowerOfTwo( image ) {

    		if ( image instanceof HTMLImageElement || image instanceof HTMLCanvasElement ) {

    			var canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
    			canvas.width = exports.Math.nearestPowerOfTwo( image.width );
    			canvas.height = exports.Math.nearestPowerOfTwo( image.height );

    			var context = canvas.getContext( '2d' );
    			context.drawImage( image, 0, 0, canvas.width, canvas.height );

    			console.warn( 'THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );

    			return canvas;

    		}

    		return image;

    	}

    	function textureNeedsPowerOfTwo( texture ) {

    		if ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) return true;
    		if ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) return true;

    		return false;

    	}

    	// Fallback filters for non-power-of-2 textures

    	function filterFallback( f ) {

    		if ( f === NearestFilter || f === NearestMipMapNearestFilter || f === NearestMipMapLinearFilter ) {

    			return _gl.NEAREST;

    		}

    		return _gl.LINEAR;

    	}

    	//

    	function onTextureDispose( event ) {

    		var texture = event.target;

    		texture.removeEventListener( 'dispose', onTextureDispose );

    		deallocateTexture( texture );

    		_infoMemory.textures --;


    	}

    	function onRenderTargetDispose( event ) {

    		var renderTarget = event.target;

    		renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

    		deallocateRenderTarget( renderTarget );

    		_infoMemory.textures --;

    	}

    	//

    	function deallocateTexture( texture ) {

    		var textureProperties = properties.get( texture );

    		if ( texture.image && textureProperties.__image__webglTextureCube ) {

    			// cube texture

    			_gl.deleteTexture( textureProperties.__image__webglTextureCube );

    		} else {

    			// 2D texture

    			if ( textureProperties.__webglInit === undefined ) return;

    			_gl.deleteTexture( textureProperties.__webglTexture );

    		}

    		// remove all webgl properties
    		properties.delete( texture );

    	}

    	function deallocateRenderTarget( renderTarget ) {

    		var renderTargetProperties = properties.get( renderTarget );
    		var textureProperties = properties.get( renderTarget.texture );

    		if ( ! renderTarget ) return;

    		if ( textureProperties.__webglTexture !== undefined ) {

    			_gl.deleteTexture( textureProperties.__webglTexture );

    		}

    		if ( renderTarget.depthTexture ) {

    			renderTarget.depthTexture.dispose();

    		}

    		if ( (renderTarget && renderTarget.isWebGLRenderTargetCube) ) {

    			for ( var i = 0; i < 6; i ++ ) {

    				_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );
    				if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );

    			}

    		} else {

    			_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );
    			if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );

    		}

    		properties.delete( renderTarget.texture );
    		properties.delete( renderTarget );

    	}

    	//



    	function setTexture2D( texture, slot ) {

    		var textureProperties = properties.get( texture );

    		if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

    			var image = texture.image;

    			if ( image === undefined ) {

    				console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined', texture );

    			} else if ( image.complete === false ) {

    				console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture );

    			} else {

    				uploadTexture( textureProperties, texture, slot );
    				return;

    			}

    		}

    		state.activeTexture( _gl.TEXTURE0 + slot );
    		state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );

    	}

    	function setTextureCube( texture, slot ) {

    		var textureProperties = properties.get( texture );

    		if ( texture.image.length === 6 ) {

    			if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

    				if ( ! textureProperties.__image__webglTextureCube ) {

    					texture.addEventListener( 'dispose', onTextureDispose );

    					textureProperties.__image__webglTextureCube = _gl.createTexture();

    					_infoMemory.textures ++;

    				}

    				state.activeTexture( _gl.TEXTURE0 + slot );
    				state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );

    				_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );

    				var isCompressed = (texture && texture.isCompressedTexture);
    				var isDataTexture = (texture.image[ 0 ] && texture.image[ 0 ].isDataTexture);

    				var cubeImage = [];

    				for ( var i = 0; i < 6; i ++ ) {

    					if ( ! isCompressed && ! isDataTexture ) {

    						cubeImage[ i ] = clampToMaxSize( texture.image[ i ], capabilities.maxCubemapSize );

    					} else {

    						cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];

    					}

    				}

    				var image = cubeImage[ 0 ],
    				isPowerOfTwoImage = isPowerOfTwo( image ),
    				glFormat = paramThreeToGL( texture.format ),
    				glType = paramThreeToGL( texture.type );

    				setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage );

    				for ( var i = 0; i < 6; i ++ ) {

    					if ( ! isCompressed ) {

    						if ( isDataTexture ) {

    							state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );

    						} else {

    							state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );

    						}

    					} else {

    						var mipmap, mipmaps = cubeImage[ i ].mipmaps;

    						for ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {

    							mipmap = mipmaps[ j ];

    							if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {

    								if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {

    									state.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

    								} else {

    									console.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()" );

    								}

    							} else {

    								state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

    							}

    						}

    					}

    				}

    				if ( texture.generateMipmaps && isPowerOfTwoImage ) {

    					_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );

    				}

    				textureProperties.__version = texture.version;

    				if ( texture.onUpdate ) texture.onUpdate( texture );

    			} else {

    				state.activeTexture( _gl.TEXTURE0 + slot );
    				state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );

    			}

    		}

    	}

    	function setTextureCubeDynamic( texture, slot ) {

    		state.activeTexture( _gl.TEXTURE0 + slot );
    		state.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( texture ).__webglTexture );

    	}

    	function setTextureParameters( textureType, texture, isPowerOfTwoImage ) {

    		var extension;

    		if ( isPowerOfTwoImage ) {

    			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );
    			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );

    			_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );
    			_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );

    		} else {

    			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
    			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );

    			if ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) {

    				console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', texture );

    			}

    			_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );
    			_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );

    			if ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) {

    				console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', texture );

    			}

    		}

    		extension = extensions.get( 'EXT_texture_filter_anisotropic' );

    		if ( extension ) {

    			if ( texture.type === FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;
    			if ( texture.type === HalfFloatType && extensions.get( 'OES_texture_half_float_linear' ) === null ) return;

    			if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {

    				_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );
    				properties.get( texture ).__currentAnisotropy = texture.anisotropy;

    			}

    		}

    	}

    	function uploadTexture( textureProperties, texture, slot ) {

    		if ( textureProperties.__webglInit === undefined ) {

    			textureProperties.__webglInit = true;

    			texture.addEventListener( 'dispose', onTextureDispose );

    			textureProperties.__webglTexture = _gl.createTexture();

    			_infoMemory.textures ++;

    		}

    		state.activeTexture( _gl.TEXTURE0 + slot );
    		state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );

    		_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
    		_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
    		_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );

    		var image = clampToMaxSize( texture.image, capabilities.maxTextureSize );

    		if ( textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( image ) === false ) {

    			image = makePowerOfTwo( image );

    		}

    		var isPowerOfTwoImage = isPowerOfTwo( image ),
    		glFormat = paramThreeToGL( texture.format ),
    		glType = paramThreeToGL( texture.type );

    		setTextureParameters( _gl.TEXTURE_2D, texture, isPowerOfTwoImage );

    		var mipmap, mipmaps = texture.mipmaps;

    		if ( (texture && texture.isDepthTexture) ) {

    			// populate depth texture with dummy data

    			var internalFormat = _gl.DEPTH_COMPONENT;

    			if ( texture.type === FloatType ) {

    				if ( !_isWebGL2 ) throw new Error('Float Depth Texture only supported in WebGL2.0');
    				internalFormat = _gl.DEPTH_COMPONENT32F;

    			} else if ( _isWebGL2 ) {

    				// WebGL 2.0 requires signed internalformat for glTexImage2D
    				internalFormat = _gl.DEPTH_COMPONENT16;

    			}

    			// Depth stencil textures need the DEPTH_STENCIL internal format
    			// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
    			if ( texture.format === DepthStencilFormat ) {

    				internalFormat = _gl.DEPTH_STENCIL;

    			}

    			state.texImage2D( _gl.TEXTURE_2D, 0, internalFormat, image.width, image.height, 0, glFormat, glType, null );

    		} else if ( (texture && texture.isDataTexture) ) {

    			// use manually created mipmaps if available
    			// if there are no manual mipmaps
    			// set 0 level mipmap and then use GL to generate other mipmap levels

    			if ( mipmaps.length > 0 && isPowerOfTwoImage ) {

    				for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

    					mipmap = mipmaps[ i ];
    					state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

    				}

    				texture.generateMipmaps = false;

    			} else {

    				state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );

    			}

    		} else if ( (texture && texture.isCompressedTexture) ) {

    			for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

    				mipmap = mipmaps[ i ];

    				if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {

    					if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {

    						state.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

    					} else {

    						console.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()" );

    					}

    				} else {

    					state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

    				}

    			}

    		} else {

    			// regular Texture (image, video, canvas)

    			// use manually created mipmaps if available
    			// if there are no manual mipmaps
    			// set 0 level mipmap and then use GL to generate other mipmap levels

    			if ( mipmaps.length > 0 && isPowerOfTwoImage ) {

    				for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

    					mipmap = mipmaps[ i ];
    					state.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );

    				}

    				texture.generateMipmaps = false;

    			} else {

    				state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, image );

    			}

    		}

    		if ( texture.generateMipmaps && isPowerOfTwoImage ) _gl.generateMipmap( _gl.TEXTURE_2D );

    		textureProperties.__version = texture.version;

    		if ( texture.onUpdate ) texture.onUpdate( texture );

    	}

    	// Render targets

    	// Setup storage for target texture and bind it to correct framebuffer
    	function setupFrameBufferTexture( framebuffer, renderTarget, attachment, textureTarget ) {

    		var glFormat = paramThreeToGL( renderTarget.texture.format );
    		var glType = paramThreeToGL( renderTarget.texture.type );
    		state.texImage2D( textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );
    		_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
    		_gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );
    		_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );

    	}

    	// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
    	function setupRenderBufferStorage( renderbuffer, renderTarget ) {

    		_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );

    		if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

    			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );
    			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

    		} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

    			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );
    			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

    		} else {

    			// FIXME: We don't support !depth !stencil
    			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );

    		}

    		_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );

    	}

    	// Setup resources for a Depth Texture for a FBO (needs an extension)
    	function setupDepthTexture( framebuffer, renderTarget ) {

    		var isCube = ( (renderTarget && renderTarget.isWebGLRenderTargetCube) );
    		if ( isCube ) throw new Error('Depth Texture with cube render targets is not supported!');

    		_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

    		if ( !( (renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture) ) ) {

    			throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');

    		}

    		// upload an empty depth texture with framebuffer size
    		if ( !properties.get( renderTarget.depthTexture ).__webglTexture ||
    				renderTarget.depthTexture.image.width !== renderTarget.width ||
    				renderTarget.depthTexture.image.height !== renderTarget.height ) {
    			renderTarget.depthTexture.image.width = renderTarget.width;
    			renderTarget.depthTexture.image.height = renderTarget.height;
    			renderTarget.depthTexture.needsUpdate = true;
    		}

    		setTexture2D( renderTarget.depthTexture, 0 );

    		var webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;

    		if ( renderTarget.depthTexture.format === DepthFormat ) {

    			_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );

    		} else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {

    			_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );

    		} else {

    			throw new Error('Unknown depthTexture format')

    		}

    	}

    	// Setup GL resources for a non-texture depth buffer
    	function setupDepthRenderbuffer( renderTarget ) {

    		var renderTargetProperties = properties.get( renderTarget );

    		var isCube = ( (renderTarget && renderTarget.isWebGLRenderTargetCube) );

    		if ( renderTarget.depthTexture ) {

    			if ( isCube ) throw new Error('target.depthTexture not supported in Cube render targets');

    			setupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );

    		} else {

    			if ( isCube ) {

    				renderTargetProperties.__webglDepthbuffer = [];

    				for ( var i = 0; i < 6; i ++ ) {

    					_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );
    					renderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();
    					setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget );

    				}

    			} else {

    				_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );
    				renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
    				setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget );

    			}

    		}

    		_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );

    	}

    	// Set up GL resources for the render target
    	function setupRenderTarget( renderTarget ) {

    		var renderTargetProperties = properties.get( renderTarget );
    		var textureProperties = properties.get( renderTarget.texture );

    		renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

    		textureProperties.__webglTexture = _gl.createTexture();

    		_infoMemory.textures ++;

    		var isCube = ( (renderTarget && renderTarget.isWebGLRenderTargetCube) );
    		var isTargetPowerOfTwo = isPowerOfTwo( renderTarget );

    		// Setup framebuffer

    		if ( isCube ) {

    			renderTargetProperties.__webglFramebuffer = [];

    			for ( var i = 0; i < 6; i ++ ) {

    				renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();

    			}

    		} else {

    			renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

    		}

    		// Setup color buffer

    		if ( isCube ) {

    			state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );
    			setTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo );

    			for ( var i = 0; i < 6; i ++ ) {

    				setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );

    			}

    			if ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );
    			state.bindTexture( _gl.TEXTURE_CUBE_MAP, null );

    		} else {

    			state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );
    			setTextureParameters( _gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo );
    			setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D );

    			if ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );
    			state.bindTexture( _gl.TEXTURE_2D, null );

    		}

    		// Setup depth and stencil buffers

    		if ( renderTarget.depthBuffer ) {

    			setupDepthRenderbuffer( renderTarget );

    		}

    	}

    	function updateRenderTargetMipmap( renderTarget ) {

    		var texture = renderTarget.texture;

    		if ( texture.generateMipmaps && isPowerOfTwo( renderTarget ) &&
    				texture.minFilter !== NearestFilter &&
    				texture.minFilter !== LinearFilter ) {

    			var target = (renderTarget && renderTarget.isWebGLRenderTargetCube) ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
    			var webglTexture = properties.get( texture ).__webglTexture;

    			state.bindTexture( target, webglTexture );
    			_gl.generateMipmap( target );
    			state.bindTexture( target, null );

    		}

    	}

    	this.setTexture2D = setTexture2D;
    	this.setTextureCube = setTextureCube;
    	this.setTextureCubeDynamic = setTextureCubeDynamic;
    	this.setupRenderTarget = setupRenderTarget;
    	this.updateRenderTargetMipmap = updateRenderTargetMipmap;

    }

    /**
     * @author fordacious / fordacious.github.io
     */

    function WebGLProperties() {

    	var properties = {};

    	return {

    		get: function ( object ) {

    			var uuid = object.uuid;
    			var map = properties[ uuid ];

    			if ( map === undefined ) {

    				map = {};
    				properties[ uuid ] = map;

    			}

    			return map;

    		},

    		delete: function ( object ) {

    			delete properties[ object.uuid ];

    		},

    		clear: function () {

    			properties = {};

    		}

    	};

    }

    function WebGLState( gl, extensions, paramThreeToGL ) {

    	function ColorBuffer() {

    		var locked = false;

    		var color = new Vector4();
    		var currentColorMask = null;
    		var currentColorClear = new Vector4();

    		return {

    			setMask: function ( colorMask ) {

    				if ( currentColorMask !== colorMask && ! locked ) {

    					gl.colorMask( colorMask, colorMask, colorMask, colorMask );
    					currentColorMask = colorMask;

    				}

    			},

    			setLocked: function ( lock ) {

    				locked = lock;

    			},

    			setClear: function ( r, g, b, a ) {

    				color.set( r, g, b, a );

    				if ( currentColorClear.equals( color ) === false ) {

    					gl.clearColor( r, g, b, a );
    					currentColorClear.copy( color );

    				}

    			},

    			reset: function () {

    				locked = false;

    				currentColorMask = null;
    				currentColorClear.set( 0, 0, 0, 1 );

    			}

    		};

    	}

    	function DepthBuffer() {

    		var locked = false;

    		var currentDepthMask = null;
    		var currentDepthFunc = null;
    		var currentDepthClear = null;

    		return {

    			setTest: function ( depthTest ) {

    				if ( depthTest ) {

    					enable( gl.DEPTH_TEST );

    				} else {

    					disable( gl.DEPTH_TEST );

    				}

    			},

    			setMask: function ( depthMask ) {

    				if ( currentDepthMask !== depthMask && ! locked ) {

    					gl.depthMask( depthMask );
    					currentDepthMask = depthMask;

    				}

    			},

    			setFunc: function ( depthFunc ) {

    				if ( currentDepthFunc !== depthFunc ) {

    					if ( depthFunc ) {

    						switch ( depthFunc ) {

    							case NeverDepth:

    								gl.depthFunc( gl.NEVER );
    								break;

    							case AlwaysDepth:

    								gl.depthFunc( gl.ALWAYS );
    								break;

    							case LessDepth:

    								gl.depthFunc( gl.LESS );
    								break;

    							case LessEqualDepth:

    								gl.depthFunc( gl.LEQUAL );
    								break;

    							case EqualDepth:

    								gl.depthFunc( gl.EQUAL );
    								break;

    							case GreaterEqualDepth:

    								gl.depthFunc( gl.GEQUAL );
    								break;

    							case GreaterDepth:

    								gl.depthFunc( gl.GREATER );
    								break;

    							case NotEqualDepth:

    								gl.depthFunc( gl.NOTEQUAL );
    								break;

    							default:

    								gl.depthFunc( gl.LEQUAL );

    						}

    					} else {

    						gl.depthFunc( gl.LEQUAL );

    					}

    					currentDepthFunc = depthFunc;

    				}

    			},

    			setLocked: function ( lock ) {

    				locked = lock;

    			},

    			setClear: function ( depth ) {

    				if ( currentDepthClear !== depth ) {

    					gl.clearDepth( depth );
    					currentDepthClear = depth;

    				}

    			},

    			reset: function () {

    				locked = false;

    				currentDepthMask = null;
    				currentDepthFunc = null;
    				currentDepthClear = null;

    			}

    		};

    	}

    	function StencilBuffer() {

    		var locked = false;

    		var currentStencilMask = null;
    		var currentStencilFunc = null;
    		var currentStencilRef = null;
    		var currentStencilFuncMask = null;
    		var currentStencilFail  = null;
    		var currentStencilZFail = null;
    		var currentStencilZPass = null;
    		var currentStencilClear = null;

    		return {

    			setTest: function ( stencilTest ) {

    				if ( stencilTest ) {

    					enable( gl.STENCIL_TEST );

    				} else {

    					disable( gl.STENCIL_TEST );

    				}

    			},

    			setMask: function ( stencilMask ) {

    				if ( currentStencilMask !== stencilMask && ! locked ) {

    					gl.stencilMask( stencilMask );
    					currentStencilMask = stencilMask;

    				}

    			},

    			setFunc: function ( stencilFunc, stencilRef, stencilMask ) {

    				if ( currentStencilFunc !== stencilFunc ||
    				     currentStencilRef 	!== stencilRef 	||
    				     currentStencilFuncMask !== stencilMask ) {

    					gl.stencilFunc( stencilFunc,  stencilRef, stencilMask );

    					currentStencilFunc = stencilFunc;
    					currentStencilRef  = stencilRef;
    					currentStencilFuncMask = stencilMask;

    				}

    			},

    			setOp: function ( stencilFail, stencilZFail, stencilZPass ) {

    				if ( currentStencilFail	 !== stencilFail 	||
    				     currentStencilZFail !== stencilZFail ||
    				     currentStencilZPass !== stencilZPass ) {

    					gl.stencilOp( stencilFail,  stencilZFail, stencilZPass );

    					currentStencilFail  = stencilFail;
    					currentStencilZFail = stencilZFail;
    					currentStencilZPass = stencilZPass;

    				}

    			},

    			setLocked: function ( lock ) {

    				locked = lock;

    			},

    			setClear: function ( stencil ) {

    				if ( currentStencilClear !== stencil ) {

    					gl.clearStencil( stencil );
    					currentStencilClear = stencil;

    				}

    			},

    			reset: function () {

    				locked = false;

    				currentStencilMask = null;
    				currentStencilFunc = null;
    				currentStencilRef = null;
    				currentStencilFuncMask = null;
    				currentStencilFail = null;
    				currentStencilZFail = null;
    				currentStencilZPass = null;
    				currentStencilClear = null;

    			}

    		};

    	}

    	//

    	var colorBuffer = new ColorBuffer();
    	var depthBuffer = new DepthBuffer();
    	var stencilBuffer = new StencilBuffer();

    	var maxVertexAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
    	var newAttributes = new Uint8Array( maxVertexAttributes );
    	var enabledAttributes = new Uint8Array( maxVertexAttributes );
    	var attributeDivisors = new Uint8Array( maxVertexAttributes );

    	var capabilities = {};

    	var compressedTextureFormats = null;

    	var currentBlending = null;
    	var currentBlendEquation = null;
    	var currentBlendSrc = null;
    	var currentBlendDst = null;
    	var currentBlendEquationAlpha = null;
    	var currentBlendSrcAlpha = null;
    	var currentBlendDstAlpha = null;
    	var currentPremultipledAlpha = false;

    	var currentFlipSided = null;
    	var currentCullFace = null;

    	var currentLineWidth = null;

    	var currentPolygonOffsetFactor = null;
    	var currentPolygonOffsetUnits = null;

    	var currentScissorTest = null;

    	var maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );

    	var currentTextureSlot = null;
    	var currentBoundTextures = {};

    	var currentScissor = new Vector4();
    	var currentViewport = new Vector4();

    	function createTexture( type, target, count ) {

    		var data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.
    		var texture = gl.createTexture();

    		gl.bindTexture( type, texture );
    		gl.texParameteri( type, gl.TEXTURE_MIN_FILTER, gl.NEAREST );
    		gl.texParameteri( type, gl.TEXTURE_MAG_FILTER, gl.NEAREST );

    		for ( var i = 0; i < count; i ++ ) {

    			gl.texImage2D( target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );

    		}

    		return texture;

    	}

    	var emptyTextures = {};
    	emptyTextures[ gl.TEXTURE_2D ] = createTexture( gl.TEXTURE_2D, gl.TEXTURE_2D, 1 );
    	emptyTextures[ gl.TEXTURE_CUBE_MAP ] = createTexture( gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6 );

    	//

    	function init() {

    		clearColor( 0, 0, 0, 1 );
    		clearDepth( 1 );
    		clearStencil( 0 );

    		enable( gl.DEPTH_TEST );
    		setDepthFunc( LessEqualDepth );

    		setFlipSided( false );
    		setCullFace( CullFaceBack );
    		enable( gl.CULL_FACE );

    		enable( gl.BLEND );
    		setBlending( NormalBlending );

    	}

    	function initAttributes() {

    		for ( var i = 0, l = newAttributes.length; i < l; i ++ ) {

    			newAttributes[ i ] = 0;

    		}

    	}

    	function enableAttribute( attribute ) {

    		newAttributes[ attribute ] = 1;

    		if ( enabledAttributes[ attribute ] === 0 ) {

    			gl.enableVertexAttribArray( attribute );
    			enabledAttributes[ attribute ] = 1;

    		}

    		if ( attributeDivisors[ attribute ] !== 0 ) {

    			var extension = extensions.get( 'ANGLE_instanced_arrays' );

    			extension.vertexAttribDivisorANGLE( attribute, 0 );
    			attributeDivisors[ attribute ] = 0;

    		}

    	}

    	function enableAttributeAndDivisor( attribute, meshPerAttribute, extension ) {

    		newAttributes[ attribute ] = 1;

    		if ( enabledAttributes[ attribute ] === 0 ) {

    			gl.enableVertexAttribArray( attribute );
    			enabledAttributes[ attribute ] = 1;

    		}

    		if ( attributeDivisors[ attribute ] !== meshPerAttribute ) {

    			extension.vertexAttribDivisorANGLE( attribute, meshPerAttribute );
    			attributeDivisors[ attribute ] = meshPerAttribute;

    		}

    	}

    	function disableUnusedAttributes() {

    		for ( var i = 0, l = enabledAttributes.length; i !== l; ++ i ) {

    			if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {

    				gl.disableVertexAttribArray( i );
    				enabledAttributes[ i ] = 0;

    			}

    		}

    	}

    	function enable( id ) {

    		if ( capabilities[ id ] !== true ) {

    			gl.enable( id );
    			capabilities[ id ] = true;

    		}

    	}

    	function disable( id ) {

    		if ( capabilities[ id ] !== false ) {

    			gl.disable( id );
    			capabilities[ id ] = false;

    		}

    	}

    	function getCompressedTextureFormats() {

    		if ( compressedTextureFormats === null ) {

    			compressedTextureFormats = [];

    			if ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||
    			     extensions.get( 'WEBGL_compressed_texture_s3tc' ) ||
    			     extensions.get( 'WEBGL_compressed_texture_etc1' ) ) {

    				var formats = gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS );

    				for ( var i = 0; i < formats.length; i ++ ) {

    					compressedTextureFormats.push( formats[ i ] );

    				}

    			}

    		}

    		return compressedTextureFormats;

    	}

    	function setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {

    		if ( blending !== NoBlending ) {

    			enable( gl.BLEND );

    		} else {

    			disable( gl.BLEND );
    			currentBlending = blending; // no blending, that is
    			return;

    		}

    		if ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {

    			if ( blending === AdditiveBlending ) {

    				if ( premultipliedAlpha ) {

    					gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
    					gl.blendFuncSeparate( gl.ONE, gl.ONE, gl.ONE, gl.ONE );

    				} else {

    					gl.blendEquation( gl.FUNC_ADD );
    					gl.blendFunc( gl.SRC_ALPHA, gl.ONE );

    				}

    			} else if ( blending === SubtractiveBlending ) {

    				if ( premultipliedAlpha ) {

    					gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
    					gl.blendFuncSeparate( gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA );

    				} else {

    					gl.blendEquation( gl.FUNC_ADD );
    					gl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );

    				}

    			} else if ( blending === MultiplyBlending ) {

    				if ( premultipliedAlpha ) {

    					gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
    					gl.blendFuncSeparate( gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA );

    				} else {

    					gl.blendEquation( gl.FUNC_ADD );
    					gl.blendFunc( gl.ZERO, gl.SRC_COLOR );

    				}

    			} else {

    				if ( premultipliedAlpha ) {

    					gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
    					gl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );

    				} else {

    					gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
    					gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );

    				}

    			}

    			currentBlending = blending;
    			currentPremultipledAlpha = premultipliedAlpha;

    		}

    		if ( blending === CustomBlending ) {

    			blendEquationAlpha = blendEquationAlpha || blendEquation;
    			blendSrcAlpha = blendSrcAlpha || blendSrc;
    			blendDstAlpha = blendDstAlpha || blendDst;

    			if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {

    				gl.blendEquationSeparate( paramThreeToGL( blendEquation ), paramThreeToGL( blendEquationAlpha ) );

    				currentBlendEquation = blendEquation;
    				currentBlendEquationAlpha = blendEquationAlpha;

    			}

    			if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {

    				gl.blendFuncSeparate( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ), paramThreeToGL( blendSrcAlpha ), paramThreeToGL( blendDstAlpha ) );

    				currentBlendSrc = blendSrc;
    				currentBlendDst = blendDst;
    				currentBlendSrcAlpha = blendSrcAlpha;
    				currentBlendDstAlpha = blendDstAlpha;

    			}

    		} else {

    			currentBlendEquation = null;
    			currentBlendSrc = null;
    			currentBlendDst = null;
    			currentBlendEquationAlpha = null;
    			currentBlendSrcAlpha = null;
    			currentBlendDstAlpha = null;

    		}

    	}

    	// TODO Deprecate

    	function setColorWrite( colorWrite ) {

    		colorBuffer.setMask( colorWrite );

    	}

    	function setDepthTest( depthTest ) {

    		depthBuffer.setTest( depthTest );

    	}

    	function setDepthWrite( depthWrite ) {

    		depthBuffer.setMask( depthWrite );

    	}

    	function setDepthFunc( depthFunc ) {

    		depthBuffer.setFunc( depthFunc );

    	}

    	function setStencilTest( stencilTest ) {

    		stencilBuffer.setTest( stencilTest );

    	}

    	function setStencilWrite( stencilWrite ) {

    		stencilBuffer.setMask( stencilWrite );

    	}

    	function setStencilFunc( stencilFunc, stencilRef, stencilMask ) {

    		stencilBuffer.setFunc( stencilFunc, stencilRef, stencilMask );

    	}

    	function setStencilOp( stencilFail, stencilZFail, stencilZPass ) {

    		stencilBuffer.setOp( stencilFail, stencilZFail, stencilZPass );

    	}

    	//

    	function setFlipSided( flipSided ) {

    		if ( currentFlipSided !== flipSided ) {

    			if ( flipSided ) {

    				gl.frontFace( gl.CW );

    			} else {

    				gl.frontFace( gl.CCW );

    			}

    			currentFlipSided = flipSided;

    		}

    	}

    	function setCullFace( cullFace ) {

    		if ( cullFace !== CullFaceNone ) {

    			enable( gl.CULL_FACE );

    			if ( cullFace !== currentCullFace ) {

    				if ( cullFace === CullFaceBack ) {

    					gl.cullFace( gl.BACK );

    				} else if ( cullFace === CullFaceFront ) {

    					gl.cullFace( gl.FRONT );

    				} else {

    					gl.cullFace( gl.FRONT_AND_BACK );

    				}

    			}

    		} else {

    			disable( gl.CULL_FACE );

    		}

    		currentCullFace = cullFace;

    	}

    	function setLineWidth( width ) {

    		if ( width !== currentLineWidth ) {

    			gl.lineWidth( width );

    			currentLineWidth = width;

    		}

    	}

    	function setPolygonOffset( polygonOffset, factor, units ) {

    		if ( polygonOffset ) {

    			enable( gl.POLYGON_OFFSET_FILL );

    			if ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {

    				gl.polygonOffset( factor, units );

    				currentPolygonOffsetFactor = factor;
    				currentPolygonOffsetUnits = units;

    			}

    		} else {

    			disable( gl.POLYGON_OFFSET_FILL );

    		}

    	}

    	function getScissorTest() {

    		return currentScissorTest;

    	}

    	function setScissorTest( scissorTest ) {

    		currentScissorTest = scissorTest;

    		if ( scissorTest ) {

    			enable( gl.SCISSOR_TEST );

    		} else {

    			disable( gl.SCISSOR_TEST );

    		}

    	}

    	// texture

    	function activeTexture( webglSlot ) {

    		if ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;

    		if ( currentTextureSlot !== webglSlot ) {

    			gl.activeTexture( webglSlot );
    			currentTextureSlot = webglSlot;

    		}

    	}

    	function bindTexture( webglType, webglTexture ) {

    		if ( currentTextureSlot === null ) {

    			activeTexture();

    		}

    		var boundTexture = currentBoundTextures[ currentTextureSlot ];

    		if ( boundTexture === undefined ) {

    			boundTexture = { type: undefined, texture: undefined };
    			currentBoundTextures[ currentTextureSlot ] = boundTexture;

    		}

    		if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {

    			gl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );

    			boundTexture.type = webglType;
    			boundTexture.texture = webglTexture;

    		}

    	}

    	function compressedTexImage2D() {

    		try {

    			gl.compressedTexImage2D.apply( gl, arguments );

    		} catch ( error ) {

    			console.error( error );

    		}

    	}

    	function texImage2D() {

    		try {

    			gl.texImage2D.apply( gl, arguments );

    		} catch ( error ) {

    			console.error( error );

    		}

    	}

    	// TODO Deprecate

    	function clearColor( r, g, b, a ) {

    		colorBuffer.setClear( r, g, b, a );

    	}

    	function clearDepth( depth ) {

    		depthBuffer.setClear( depth );

    	}

    	function clearStencil( stencil ) {

    		stencilBuffer.setClear( stencil );

    	}

    	//

    	function scissor( scissor ) {

    		if ( currentScissor.equals( scissor ) === false ) {

    			gl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );
    			currentScissor.copy( scissor );

    		}

    	}

    	function viewport( viewport ) {

    		if ( currentViewport.equals( viewport ) === false ) {

    			gl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );
    			currentViewport.copy( viewport );

    		}

    	}

    	//

    	function reset() {

    		for ( var i = 0; i < enabledAttributes.length; i ++ ) {

    			if ( enabledAttributes[ i ] === 1 ) {

    				gl.disableVertexAttribArray( i );
    				enabledAttributes[ i ] = 0;

    			}

    		}

    		capabilities = {};

    		compressedTextureFormats = null;

    		currentTextureSlot = null;
    		currentBoundTextures = {};

    		currentBlending = null;

    		currentFlipSided = null;
    		currentCullFace = null;

    		colorBuffer.reset();
    		depthBuffer.reset();
    		stencilBuffer.reset();

    	}

    	return {

    		buffers: {
    			color: colorBuffer,
    			depth: depthBuffer,
    			stencil: stencilBuffer
    		},

    		init: init,
    		initAttributes: initAttributes,
    		enableAttribute: enableAttribute,
    		enableAttributeAndDivisor: enableAttributeAndDivisor,
    		disableUnusedAttributes: disableUnusedAttributes,
    		enable: enable,
    		disable: disable,
    		getCompressedTextureFormats: getCompressedTextureFormats,

    		setBlending: setBlending,

    		setColorWrite: setColorWrite,
    		setDepthTest: setDepthTest,
    		setDepthWrite: setDepthWrite,
    		setDepthFunc: setDepthFunc,
    		setStencilTest: setStencilTest,
    		setStencilWrite: setStencilWrite,
    		setStencilFunc: setStencilFunc,
    		setStencilOp: setStencilOp,

    		setFlipSided: setFlipSided,
    		setCullFace: setCullFace,

    		setLineWidth: setLineWidth,
    		setPolygonOffset: setPolygonOffset,

    		getScissorTest: getScissorTest,
    		setScissorTest: setScissorTest,

    		activeTexture: activeTexture,
    		bindTexture: bindTexture,
    		compressedTexImage2D: compressedTexImage2D,
    		texImage2D: texImage2D,

    		clearColor: clearColor,
    		clearDepth: clearDepth,
    		clearStencil: clearStencil,

    		scissor: scissor,
    		viewport: viewport,

    		reset: reset

    	};

    }

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function WebGLCapabilities( gl, extensions, parameters ) {

    	var maxAnisotropy;

    	function getMaxAnisotropy() {

    		if ( maxAnisotropy !== undefined ) return maxAnisotropy;

    		var extension = extensions.get( 'EXT_texture_filter_anisotropic' );

    		if ( extension !== null ) {

    			maxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );

    		} else {

    			maxAnisotropy = 0;

    		}

    		return maxAnisotropy;

    	}

    	function getMaxPrecision( precision ) {

    		if ( precision === 'highp' ) {

    			if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&
    			     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {

    				return 'highp';

    			}

    			precision = 'mediump';

    		}

    		if ( precision === 'mediump' ) {

    			if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&
    			     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {

    				return 'mediump';

    			}

    		}

    		return 'lowp';

    	}

    	var precision = parameters.precision !== undefined ? parameters.precision : 'highp';
    	var maxPrecision = getMaxPrecision( precision );

    	if ( maxPrecision !== precision ) {

    		console.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );
    		precision = maxPrecision;

    	}

    	var logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true && !! extensions.get( 'EXT_frag_depth' );

    	var maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );
    	var maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
    	var maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );
    	var maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );

    	var maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
    	var maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );
    	var maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );
    	var maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );

    	var vertexTextures = maxVertexTextures > 0;
    	var floatFragmentTextures = !! extensions.get( 'OES_texture_float' );
    	var floatVertexTextures = vertexTextures && floatFragmentTextures;

    	return {

    		getMaxAnisotropy: getMaxAnisotropy,
    		getMaxPrecision: getMaxPrecision,

    		precision: precision,
    		logarithmicDepthBuffer: logarithmicDepthBuffer,

    		maxTextures: maxTextures,
    		maxVertexTextures: maxVertexTextures,
    		maxTextureSize: maxTextureSize,
    		maxCubemapSize: maxCubemapSize,

    		maxAttributes: maxAttributes,
    		maxVertexUniforms: maxVertexUniforms,
    		maxVaryings: maxVaryings,
    		maxFragmentUniforms: maxFragmentUniforms,

    		vertexTextures: vertexTextures,
    		floatFragmentTextures: floatFragmentTextures,
    		floatVertexTextures: floatVertexTextures

    	};

    }

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function WebGLExtensions( gl ) {

    	var extensions = {};

    	return {

    		get: function ( name ) {

    			if ( extensions[ name ] !== undefined ) {

    				return extensions[ name ];

    			}

    			var extension;

    			switch ( name ) {

    				case 'WEBGL_depth_texture':
    					extension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );
    					break;

    				case 'EXT_texture_filter_anisotropic':
    					extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
    					break;

    				case 'WEBGL_compressed_texture_s3tc':
    					extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
    					break;

    				case 'WEBGL_compressed_texture_pvrtc':
    					extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
    					break;

    				case 'WEBGL_compressed_texture_etc1':
    					extension = gl.getExtension( 'WEBGL_compressed_texture_etc1' );
    					break;

    				default:
    					extension = gl.getExtension( name );

    			}

    			if ( extension === null ) {

    				console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );

    			}

    			extensions[ name ] = extension;

    			return extension;

    		}

    	};

    }

    function WebGLClipping() {

    	var scope = this,

    		globalState = null,
    		numGlobalPlanes = 0,
    		localClippingEnabled = false,
    		renderingShadows = false,

    		plane = new Plane(),
    		viewNormalMatrix = new Matrix3(),

    		uniform = { value: null, needsUpdate: false };

    	this.uniform = uniform;
    	this.numPlanes = 0;

    	this.init = function( planes, enableLocalClipping, camera ) {

    		var enabled =
    			planes.length !== 0 ||
    			enableLocalClipping ||
    			// enable state of previous frame - the clipping code has to
    			// run another frame in order to reset the state:
    			numGlobalPlanes !== 0 ||
    			localClippingEnabled;

    		localClippingEnabled = enableLocalClipping;

    		globalState = projectPlanes( planes, camera, 0 );
    		numGlobalPlanes = planes.length;

    		return enabled;

    	};

    	this.beginShadows = function() {

    		renderingShadows = true;
    		projectPlanes( null );

    	};

    	this.endShadows = function() {

    		renderingShadows = false;
    		resetGlobalState();

    	};

    	this.setState = function( planes, clipShadows, camera, cache, fromCache ) {

    		if ( ! localClippingEnabled ||
    				planes === null || planes.length === 0 ||
    				renderingShadows && ! clipShadows ) {
    			// there's no local clipping

    			if ( renderingShadows ) {
    				// there's no global clipping

    				projectPlanes( null );

    			} else {

    				resetGlobalState();
    			}

    		} else {

    			var nGlobal = renderingShadows ? 0 : numGlobalPlanes,
    				lGlobal = nGlobal * 4,

    				dstArray = cache.clippingState || null;

    			uniform.value = dstArray; // ensure unique state

    			dstArray = projectPlanes( planes, camera, lGlobal, fromCache );

    			for ( var i = 0; i !== lGlobal; ++ i ) {

    				dstArray[ i ] = globalState[ i ];

    			}

    			cache.clippingState = dstArray;
    			this.numPlanes += nGlobal;

    		}


    	};

    	function resetGlobalState() {

    		if ( uniform.value !== globalState ) {

    			uniform.value = globalState;
    			uniform.needsUpdate = numGlobalPlanes > 0;

    		}

    		scope.numPlanes = numGlobalPlanes;

    	}

    	function projectPlanes( planes, camera, dstOffset, skipTransform ) {

    		var nPlanes = planes !== null ? planes.length : 0,
    			dstArray = null;

    		if ( nPlanes !== 0 ) {

    			dstArray = uniform.value;

    			if ( skipTransform !== true || dstArray === null ) {

    				var flatSize = dstOffset + nPlanes * 4,
    					viewMatrix = camera.matrixWorldInverse;

    				viewNormalMatrix.getNormalMatrix( viewMatrix );

    				if ( dstArray === null || dstArray.length < flatSize ) {

    					dstArray = new Float32Array( flatSize );

    				}

    				for ( var i = 0, i4 = dstOffset;
    									i !== nPlanes; ++ i, i4 += 4 ) {

    					plane.copy( planes[ i ] ).
    							applyMatrix4( viewMatrix, viewNormalMatrix );

    					plane.normal.toArray( dstArray, i4 );
    					dstArray[ i4 + 3 ] = plane.constant;

    				}

    			}

    			uniform.value = dstArray;
    			uniform.needsUpdate = true;

    		}

    		scope.numPlanes = nPlanes;
    		return dstArray;

    	}

    }

    /**
     * @author supereggbert / http://www.paulbrunt.co.uk/
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     * @author szimek / https://github.com/szimek/
     * @author tschw
     */

    function WebGLRenderer( parameters ) {

    	console.log( 'THREE.WebGLRenderer', REVISION );

    	parameters = parameters || {};

    	var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ),
    	_context = parameters.context !== undefined ? parameters.context : null,

    	_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
    	_depth = parameters.depth !== undefined ? parameters.depth : true,
    	_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
    	_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
    	_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
    	_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false;

    	var lights = [];

    	var opaqueObjects = [];
    	var opaqueObjectsLastIndex = - 1;
    	var transparentObjects = [];
    	var transparentObjectsLastIndex = - 1;

    	var morphInfluences = new Float32Array( 8 );

    	var sprites = [];
    	var lensFlares = [];

    	// public properties

    	this.domElement = _canvas;
    	this.context = null;

    	// clearing

    	this.autoClear = true;
    	this.autoClearColor = true;
    	this.autoClearDepth = true;
    	this.autoClearStencil = true;

    	// scene graph

    	this.sortObjects = true;

    	// user-defined clipping

    	this.clippingPlanes = [];
    	this.localClippingEnabled = false;

    	// physically based shading

    	this.gammaFactor = 2.0;	// for backwards compatibility
    	this.gammaInput = false;
    	this.gammaOutput = false;

    	// physical lights

    	this.physicallyCorrectLights = false;

    	// tone mapping

    	this.toneMapping = LinearToneMapping;
    	this.toneMappingExposure = 1.0;
    	this.toneMappingWhitePoint = 1.0;

    	// morphs

    	this.maxMorphTargets = 8;
    	this.maxMorphNormals = 4;

    	// internal properties

    	var _this = this,

    	// internal state cache

    	_currentProgram = null,
    	_currentRenderTarget = null,
    	_currentFramebuffer = null,
    	_currentMaterialId = - 1,
    	_currentGeometryProgram = '',
    	_currentCamera = null,

    	_currentScissor = new Vector4(),
    	_currentScissorTest = null,

    	_currentViewport = new Vector4(),

    	//

    	_usedTextureUnits = 0,

    	//

    	_clearColor = new Color( 0x000000 ),
    	_clearAlpha = 0,

    	_width = _canvas.width,
    	_height = _canvas.height,

    	_pixelRatio = 1,

    	_scissor = new Vector4( 0, 0, _width, _height ),
    	_scissorTest = false,

    	_viewport = new Vector4( 0, 0, _width, _height ),

    	// frustum

    	_frustum = new Frustum(),

    	// clipping

    	_clipping = new WebGLClipping(),
    	_clippingEnabled = false,
    	_localClippingEnabled = false,

    	_sphere = new Sphere(),

    	// camera matrices cache

    	_projScreenMatrix = new Matrix4(),

    	_vector3 = new Vector3(),

    	// light arrays cache

    	_lights = {

    		hash: '',

    		ambient: [ 0, 0, 0 ],
    		directional: [],
    		directionalShadowMap: [],
    		directionalShadowMatrix: [],
    		spot: [],
    		spotShadowMap: [],
    		spotShadowMatrix: [],
    		point: [],
    		pointShadowMap: [],
    		pointShadowMatrix: [],
    		hemi: [],

    		shadows: []

    	},

    	// info

    	_infoRender = {

    		calls: 0,
    		vertices: 0,
    		faces: 0,
    		points: 0

    	};

    	this.info = {

    		render: _infoRender,
    		memory: {

    			geometries: 0,
    			textures: 0

    		},
    		programs: null

    	};


    	// initialize

    	var _gl;

    	try {

    		var attributes = {
    			alpha: _alpha,
    			depth: _depth,
    			stencil: _stencil,
    			antialias: _antialias,
    			premultipliedAlpha: _premultipliedAlpha,
    			preserveDrawingBuffer: _preserveDrawingBuffer
    		};

    		_gl = _context || _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );

    		if ( _gl === null ) {

    			if ( _canvas.getContext( 'webgl' ) !== null ) {

    				throw 'Error creating WebGL context with your selected attributes.';

    			} else {

    				throw 'Error creating WebGL context.';

    			}

    		}

    		// Some experimental-webgl implementations do not have getShaderPrecisionFormat

    		if ( _gl.getShaderPrecisionFormat === undefined ) {

    			_gl.getShaderPrecisionFormat = function () {

    				return { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };

    			};

    		}

    		_canvas.addEventListener( 'webglcontextlost', onContextLost, false );

    	} catch ( error ) {

    		console.error( 'THREE.WebGLRenderer: ' + error );

    	}

    	var extensions = new WebGLExtensions( _gl );

    	extensions.get( 'WEBGL_depth_texture' );
    	extensions.get( 'OES_texture_float' );
    	extensions.get( 'OES_texture_float_linear' );
    	extensions.get( 'OES_texture_half_float' );
    	extensions.get( 'OES_texture_half_float_linear' );
    	extensions.get( 'OES_standard_derivatives' );
    	extensions.get( 'ANGLE_instanced_arrays' );

    	if ( extensions.get( 'OES_element_index_uint' ) ) {

    		BufferGeometry.MaxIndex = 4294967296;

    	}

    	var capabilities = new WebGLCapabilities( _gl, extensions, parameters );

    	var state = new WebGLState( _gl, extensions, paramThreeToGL );
    	var properties = new WebGLProperties();
    	var textures = new WebGLTextures( _gl, extensions, state, properties, capabilities, paramThreeToGL, this.info );
    	var objects = new WebGLObjects( _gl, properties, this.info );
    	var programCache = new WebGLPrograms( this, capabilities );
    	var lightCache = new WebGLLights();

    	this.info.programs = programCache.programs;

    	var bufferRenderer = new WebGLBufferRenderer( _gl, extensions, _infoRender );
    	var indexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, _infoRender );

    	//

    	var backgroundCamera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
    	var backgroundCamera2 = new PerspectiveCamera();
    	var backgroundPlaneMesh = new Mesh(
    		new PlaneBufferGeometry( 2, 2 ),
    		new MeshBasicMaterial( { depthTest: false, depthWrite: false, fog: false } )
    	);
    	var backgroundBoxShader = ShaderLib[ 'cube' ];
    	var backgroundBoxMesh = new Mesh(
    		new BoxBufferGeometry( 5, 5, 5 ),
    		new ShaderMaterial( {
    			uniforms: backgroundBoxShader.uniforms,
    			vertexShader: backgroundBoxShader.vertexShader,
    			fragmentShader: backgroundBoxShader.fragmentShader,
    			side: BackSide,
    			depthTest: false,
    			depthWrite: false,
    			fog: false
    		} )
    	);

    	//

    	function getTargetPixelRatio() {

    		return _currentRenderTarget === null ? _pixelRatio : 1;

    	}

    	function glClearColor( r, g, b, a ) {

    		if ( _premultipliedAlpha === true ) {

    			r *= a; g *= a; b *= a;

    		}

    		state.clearColor( r, g, b, a );

    	}

    	function setDefaultGLState() {

    		state.init();

    		state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );
    		state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );

    		glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

    	}

    	function resetGLState() {

    		_currentProgram = null;
    		_currentCamera = null;

    		_currentGeometryProgram = '';
    		_currentMaterialId = - 1;

    		state.reset();

    	}

    	setDefaultGLState();

    	this.context = _gl;
    	this.capabilities = capabilities;
    	this.extensions = extensions;
    	this.properties = properties;
    	this.state = state;

    	// shadow map

    	var shadowMap = new WebGLShadowMap( this, _lights, objects, capabilities );

    	this.shadowMap = shadowMap;


    	// Plugins

    	var spritePlugin = new SpritePlugin( this, sprites );
    	var lensFlarePlugin = new LensFlarePlugin( this, lensFlares );

    	// API

    	this.getContext = function () {

    		return _gl;

    	};

    	this.getContextAttributes = function () {

    		return _gl.getContextAttributes();

    	};

    	this.forceContextLoss = function () {

    		extensions.get( 'WEBGL_lose_context' ).loseContext();

    	};

    	this.getMaxAnisotropy = function () {

    		return capabilities.getMaxAnisotropy();

    	};

    	this.getPrecision = function () {

    		return capabilities.precision;

    	};

    	this.getPixelRatio = function () {

    		return _pixelRatio;

    	};

    	this.setPixelRatio = function ( value ) {

    		if ( value === undefined ) return;

    		_pixelRatio = value;

    		this.setSize( _viewport.z, _viewport.w, false );

    	};

    	this.getSize = function () {

    		return {
    			width: _width,
    			height: _height
    		};

    	};

    	this.setSize = function ( width, height, updateStyle ) {

    		_width = width;
    		_height = height;

    		_canvas.width = width * _pixelRatio;
    		_canvas.height = height * _pixelRatio;

    		if ( updateStyle !== false ) {

    			_canvas.style.width = width + 'px';
    			_canvas.style.height = height + 'px';

    		}

    		this.setViewport( 0, 0, width, height );

    	};

    	this.setViewport = function ( x, y, width, height ) {

    		state.viewport( _viewport.set( x, y, width, height ) );

    	};

    	this.setScissor = function ( x, y, width, height ) {

    		state.scissor( _scissor.set( x, y, width, height ) );

    	};

    	this.setScissorTest = function ( boolean ) {

    		state.setScissorTest( _scissorTest = boolean );

    	};

    	// Clearing

    	this.getClearColor = function () {

    		return _clearColor;

    	};

    	this.setClearColor = function ( color, alpha ) {

    		_clearColor.set( color );

    		_clearAlpha = alpha !== undefined ? alpha : 1;

    		glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

    	};

    	this.getClearAlpha = function () {

    		return _clearAlpha;

    	};

    	this.setClearAlpha = function ( alpha ) {

    		_clearAlpha = alpha;

    		glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

    	};

    	this.clear = function ( color, depth, stencil ) {

    		var bits = 0;

    		if ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;
    		if ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;
    		if ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;

    		_gl.clear( bits );

    	};

    	this.clearColor = function () {

    		this.clear( true, false, false );

    	};

    	this.clearDepth = function () {

    		this.clear( false, true, false );

    	};

    	this.clearStencil = function () {

    		this.clear( false, false, true );

    	};

    	this.clearTarget = function ( renderTarget, color, depth, stencil ) {

    		this.setRenderTarget( renderTarget );
    		this.clear( color, depth, stencil );

    	};

    	// Reset

    	this.resetGLState = resetGLState;

    	this.dispose = function() {

    		transparentObjects = [];
    		transparentObjectsLastIndex = -1;
    		opaqueObjects = [];
    		opaqueObjectsLastIndex = -1;

    		_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );

    	};

    	// Events

    	function onContextLost( event ) {

    		event.preventDefault();

    		resetGLState();
    		setDefaultGLState();

    		properties.clear();

    	}

    	function onMaterialDispose( event ) {

    		var material = event.target;

    		material.removeEventListener( 'dispose', onMaterialDispose );

    		deallocateMaterial( material );

    	}

    	// Buffer deallocation

    	function deallocateMaterial( material ) {

    		releaseMaterialProgramReference( material );

    		properties.delete( material );

    	}


    	function releaseMaterialProgramReference( material ) {

    		var programInfo = properties.get( material ).program;

    		material.program = undefined;

    		if ( programInfo !== undefined ) {

    			programCache.releaseProgram( programInfo );

    		}

    	}

    	// Buffer rendering

    	this.renderBufferImmediate = function ( object, program, material ) {

    		state.initAttributes();

    		var buffers = properties.get( object );

    		if ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();
    		if ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();
    		if ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();
    		if ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();

    		var attributes = program.getAttributes();

    		if ( object.hasPositions ) {

    			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );
    			_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );

    			state.enableAttribute( attributes.position );
    			_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );

    		}

    		if ( object.hasNormals ) {

    			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );

    			if ( ! material.isMeshPhongMaterial &&
    			     ! material.isMeshStandardMaterial &&
    			       material.shading === FlatShading ) {

    				for ( var i = 0, l = object.count * 3; i < l; i += 9 ) {

    					var array = object.normalArray;

    					var nx = ( array[ i + 0 ] + array[ i + 3 ] + array[ i + 6 ] ) / 3;
    					var ny = ( array[ i + 1 ] + array[ i + 4 ] + array[ i + 7 ] ) / 3;
    					var nz = ( array[ i + 2 ] + array[ i + 5 ] + array[ i + 8 ] ) / 3;

    					array[ i + 0 ] = nx;
    					array[ i + 1 ] = ny;
    					array[ i + 2 ] = nz;

    					array[ i + 3 ] = nx;
    					array[ i + 4 ] = ny;
    					array[ i + 5 ] = nz;

    					array[ i + 6 ] = nx;
    					array[ i + 7 ] = ny;
    					array[ i + 8 ] = nz;

    				}

    			}

    			_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );

    			state.enableAttribute( attributes.normal );

    			_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );

    		}

    		if ( object.hasUvs && material.map ) {

    			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );
    			_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );

    			state.enableAttribute( attributes.uv );

    			_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );

    		}

    		if ( object.hasColors && material.vertexColors !== NoColors ) {

    			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );
    			_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );

    			state.enableAttribute( attributes.color );

    			_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );

    		}

    		state.disableUnusedAttributes();

    		_gl.drawArrays( _gl.TRIANGLES, 0, object.count );

    		object.count = 0;

    	};

    	this.renderBufferDirect = function ( camera, fog, geometry, material, object, group ) {

    		setMaterial( material );

    		var program = setProgram( camera, fog, material, object );

    		var updateBuffers = false;
    		var geometryProgram = geometry.id + '_' + program.id + '_' + material.wireframe;

    		if ( geometryProgram !== _currentGeometryProgram ) {

    			_currentGeometryProgram = geometryProgram;
    			updateBuffers = true;

    		}

    		// morph targets

    		var morphTargetInfluences = object.morphTargetInfluences;

    		if ( morphTargetInfluences !== undefined ) {

    			var activeInfluences = [];

    			for ( var i = 0, l = morphTargetInfluences.length; i < l; i ++ ) {

    				var influence = morphTargetInfluences[ i ];
    				activeInfluences.push( [ influence, i ] );

    			}

    			activeInfluences.sort( absNumericalSort );

    			if ( activeInfluences.length > 8 ) {

    				activeInfluences.length = 8;

    			}

    			var morphAttributes = geometry.morphAttributes;

    			for ( var i = 0, l = activeInfluences.length; i < l; i ++ ) {

    				var influence = activeInfluences[ i ];
    				morphInfluences[ i ] = influence[ 0 ];

    				if ( influence[ 0 ] !== 0 ) {

    					var index = influence[ 1 ];

    					if ( material.morphTargets === true && morphAttributes.position ) geometry.addAttribute( 'morphTarget' + i, morphAttributes.position[ index ] );
    					if ( material.morphNormals === true && morphAttributes.normal ) geometry.addAttribute( 'morphNormal' + i, morphAttributes.normal[ index ] );

    				} else {

    					if ( material.morphTargets === true ) geometry.removeAttribute( 'morphTarget' + i );
    					if ( material.morphNormals === true ) geometry.removeAttribute( 'morphNormal' + i );

    				}

    			}

    			for ( var i = activeInfluences.length, il = morphInfluences.length; i < il; i ++ ) {

    				morphInfluences[ i ] = 0.0;

    			}

    			program.getUniforms().setValue(
    					_gl, 'morphTargetInfluences', morphInfluences );

    			updateBuffers = true;

    		}

    		//

    		var index = geometry.index;
    		var position = geometry.attributes.position;
    		var rangeFactor = 1;

    		if ( material.wireframe === true ) {

    			index = objects.getWireframeAttribute( geometry );
    			rangeFactor = 2;

    		}

    		var renderer;

    		if ( index !== null ) {

    			renderer = indexedBufferRenderer;
    			renderer.setIndex( index );

    		} else {

    			renderer = bufferRenderer;

    		}

    		if ( updateBuffers ) {

    			setupVertexAttributes( material, program, geometry );

    			if ( index !== null ) {

    				_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, objects.getAttributeBuffer( index ) );

    			}

    		}

    		//

    		var dataCount = 0;

    		if ( index !== null ) {

    			dataCount = index.count;

    		} else if ( position !== undefined ) {

    			dataCount = position.count;

    		}

    		var rangeStart = geometry.drawRange.start * rangeFactor;
    		var rangeCount = geometry.drawRange.count * rangeFactor;

    		var groupStart = group !== null ? group.start * rangeFactor : 0;
    		var groupCount = group !== null ? group.count * rangeFactor : Infinity;

    		var drawStart = Math.max( rangeStart, groupStart );
    		var drawEnd = Math.min( dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;

    		var drawCount = Math.max( 0, drawEnd - drawStart + 1 );

    		if ( drawCount === 0 ) return;

    		//

    		if ( object.isMesh ) {

    			if ( material.wireframe === true ) {

    				state.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );
    				renderer.setMode( _gl.LINES );

    			} else {

    				switch ( object.drawMode ) {

    					case TrianglesDrawMode:
    						renderer.setMode( _gl.TRIANGLES );
    						break;

    					case TriangleStripDrawMode:
    						renderer.setMode( _gl.TRIANGLE_STRIP );
    						break;

    					case TriangleFanDrawMode:
    						renderer.setMode( _gl.TRIANGLE_FAN );
    						break;

    				}

    			}


    		} else if ( object.isLine ) {

    			var lineWidth = material.linewidth;

    			if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material

    			state.setLineWidth( lineWidth * getTargetPixelRatio() );

    			if ( object.isLineSegments ) {

    				renderer.setMode( _gl.LINES );

    			} else {

    				renderer.setMode( _gl.LINE_STRIP );

    			}

    		} else if ( object.isPoints ) {

    			renderer.setMode( _gl.POINTS );

    		}

    		if ( geometry && geometry.isInstancedBufferGeometry ) {

    			if ( geometry.maxInstancedCount > 0 ) {

    				renderer.renderInstances( geometry, drawStart, drawCount );

    			}

    		} else {

    			renderer.render( drawStart, drawCount );

    		}

    	};

    	function setupVertexAttributes( material, program, geometry, startIndex ) {

    		var extension;

    		if ( geometry && geometry.isInstancedBufferGeometry ) {

    			extension = extensions.get( 'ANGLE_instanced_arrays' );

    			if ( extension === null ) {

    				console.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
    				return;

    			}

    		}

    		if ( startIndex === undefined ) startIndex = 0;

    		state.initAttributes();

    		var geometryAttributes = geometry.attributes;

    		var programAttributes = program.getAttributes();

    		var materialDefaultAttributeValues = material.defaultAttributeValues;

    		for ( var name in programAttributes ) {

    			var programAttribute = programAttributes[ name ];

    			if ( programAttribute >= 0 ) {

    				var geometryAttribute = geometryAttributes[ name ];

    				if ( geometryAttribute !== undefined ) {

    					var type = _gl.FLOAT;
    					var array = geometryAttribute.array;
    					var normalized = geometryAttribute.normalized;

    					if ( array instanceof Float32Array ) {

    						type = _gl.FLOAT;

    					} else if ( array instanceof Float64Array ) {

    						console.warn( "Unsupported data buffer format: Float64Array" );

    					} else if ( array instanceof Uint16Array ) {

    						type = _gl.UNSIGNED_SHORT;

    					} else if ( array instanceof Int16Array ) {

    						type = _gl.SHORT;

    					} else if ( array instanceof Uint32Array ) {

    						type = _gl.UNSIGNED_INT;

    					} else if ( array instanceof Int32Array ) {

    						type = _gl.INT;

    					} else if ( array instanceof Int8Array ) {

    						type = _gl.BYTE;

    					} else if ( array instanceof Uint8Array ) {

    						type = _gl.UNSIGNED_BYTE;

    					}

    					var size = geometryAttribute.itemSize;
    					var buffer = objects.getAttributeBuffer( geometryAttribute );

    					if ( geometryAttribute && geometryAttribute.isInterleavedBufferAttribute ) {

    						var data = geometryAttribute.data;
    						var stride = data.stride;
    						var offset = geometryAttribute.offset;

    						if ( data && data.isInstancedInterleavedBuffer ) {

    							state.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute, extension );

    							if ( geometry.maxInstancedCount === undefined ) {

    								geometry.maxInstancedCount = data.meshPerAttribute * data.count;

    							}

    						} else {

    							state.enableAttribute( programAttribute );

    						}

    						_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
    						_gl.vertexAttribPointer( programAttribute, size, type, normalized, stride * data.array.BYTES_PER_ELEMENT, ( startIndex * stride + offset ) * data.array.BYTES_PER_ELEMENT );

    					} else {

    						if ( geometryAttribute && geometryAttribute.isInstancedBufferAttribute ) {

    							state.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute, extension );

    							if ( geometry.maxInstancedCount === undefined ) {

    								geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;

    							}

    						} else {

    							state.enableAttribute( programAttribute );

    						}

    						_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
    						_gl.vertexAttribPointer( programAttribute, size, type, normalized, 0, startIndex * size * geometryAttribute.array.BYTES_PER_ELEMENT );

    					}

    				} else if ( materialDefaultAttributeValues !== undefined ) {

    					var value = materialDefaultAttributeValues[ name ];

    					if ( value !== undefined ) {

    						switch ( value.length ) {

    							case 2:
    								_gl.vertexAttrib2fv( programAttribute, value );
    								break;

    							case 3:
    								_gl.vertexAttrib3fv( programAttribute, value );
    								break;

    							case 4:
    								_gl.vertexAttrib4fv( programAttribute, value );
    								break;

    							default:
    								_gl.vertexAttrib1fv( programAttribute, value );

    						}

    					}

    				}

    			}

    		}

    		state.disableUnusedAttributes();

    	}

    	// Sorting

    	function absNumericalSort( a, b ) {

    		return Math.abs( b[ 0 ] ) - Math.abs( a[ 0 ] );

    	}

    	function painterSortStable( a, b ) {

    		if ( a.object.renderOrder !== b.object.renderOrder ) {

    			return a.object.renderOrder - b.object.renderOrder;

    		} else if ( a.material.program && b.material.program && a.material.program !== b.material.program ) {

    			return a.material.program.id - b.material.program.id;

    		} else if ( a.material.id !== b.material.id ) {

    			return a.material.id - b.material.id;

    		} else if ( a.z !== b.z ) {

    			return a.z - b.z;

    		} else {

    			return a.id - b.id;

    		}

    	}

    	function reversePainterSortStable( a, b ) {

    		if ( a.object.renderOrder !== b.object.renderOrder ) {

    			return a.object.renderOrder - b.object.renderOrder;

    		} if ( a.z !== b.z ) {

    			return b.z - a.z;

    		} else {

    			return a.id - b.id;

    		}

    	}

    	// Rendering

    	this.render = function ( scene, camera, renderTarget, forceClear ) {

    		if ( camera !== undefined && camera.isCamera !== true ) {

    			console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
    			return;

    		}

    		var fog = scene.fog;

    		// reset caching for this frame

    		_currentGeometryProgram = '';
    		_currentMaterialId = - 1;
    		_currentCamera = null;

    		// update scene graph

    		if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

    		// update camera matrices and frustum

    		if ( camera.parent === null ) camera.updateMatrixWorld();

    		camera.matrixWorldInverse.getInverse( camera.matrixWorld );

    		_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
    		_frustum.setFromMatrix( _projScreenMatrix );

    		lights.length = 0;

    		opaqueObjectsLastIndex = - 1;
    		transparentObjectsLastIndex = - 1;

    		sprites.length = 0;
    		lensFlares.length = 0;

    		_localClippingEnabled = this.localClippingEnabled;
    		_clippingEnabled = _clipping.init( this.clippingPlanes, _localClippingEnabled, camera );

    		projectObject( scene, camera );

    		opaqueObjects.length = opaqueObjectsLastIndex + 1;
    		transparentObjects.length = transparentObjectsLastIndex + 1;

    		if ( _this.sortObjects === true ) {

    			opaqueObjects.sort( painterSortStable );
    			transparentObjects.sort( reversePainterSortStable );

    		}

    		//

    		if ( _clippingEnabled ) _clipping.beginShadows();

    		setupShadows( lights );

    		shadowMap.render( scene, camera );

    		setupLights( lights, camera );

    		if ( _clippingEnabled ) _clipping.endShadows();

    		//

    		_infoRender.calls = 0;
    		_infoRender.vertices = 0;
    		_infoRender.faces = 0;
    		_infoRender.points = 0;

    		if ( renderTarget === undefined ) {

    			renderTarget = null;

    		}

    		this.setRenderTarget( renderTarget );

    		//

    		var background = scene.background;

    		if ( background === null ) {

    			glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

    		} else if ( background && background.isColor ) {

    			glClearColor( background.r, background.g, background.b, 1 );
    			forceClear = true;

    		}

    		if ( this.autoClear || forceClear ) {

    			this.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );

    		}

    		if ( background && background.isCubeTexture ) {

    			backgroundCamera2.projectionMatrix.copy( camera.projectionMatrix );

    			backgroundCamera2.matrixWorld.extractRotation( camera.matrixWorld );
    			backgroundCamera2.matrixWorldInverse.getInverse( backgroundCamera2.matrixWorld );

    			backgroundBoxMesh.material.uniforms[ "tCube" ].value = background;
    			backgroundBoxMesh.modelViewMatrix.multiplyMatrices( backgroundCamera2.matrixWorldInverse, backgroundBoxMesh.matrixWorld );

    			objects.update( backgroundBoxMesh );

    			_this.renderBufferDirect( backgroundCamera2, null, backgroundBoxMesh.geometry, backgroundBoxMesh.material, backgroundBoxMesh, null );

    		} else if ( background && background.isTexture ) {

    			backgroundPlaneMesh.material.map = background;

    			objects.update( backgroundPlaneMesh );

    			_this.renderBufferDirect( backgroundCamera, null, backgroundPlaneMesh.geometry, backgroundPlaneMesh.material, backgroundPlaneMesh, null );

    		}

    		//

    		if ( scene.overrideMaterial ) {

    			var overrideMaterial = scene.overrideMaterial;

    			renderObjects( opaqueObjects, camera, fog, overrideMaterial );
    			renderObjects( transparentObjects, camera, fog, overrideMaterial );

    		} else {

    			// opaque pass (front-to-back order)

    			state.setBlending( NoBlending );
    			renderObjects( opaqueObjects, camera, fog );

    			// transparent pass (back-to-front order)

    			renderObjects( transparentObjects, camera, fog );

    		}

    		// custom render plugins (post pass)

    		spritePlugin.render( scene, camera );
    		lensFlarePlugin.render( scene, camera, _currentViewport );

    		// Generate mipmap if we're using any kind of mipmap filtering

    		if ( renderTarget ) {

    			textures.updateRenderTargetMipmap( renderTarget );

    		}

    		// Ensure depth buffer writing is enabled so it can be cleared on next render

    		state.setDepthTest( true );
    		state.setDepthWrite( true );
    		state.setColorWrite( true );

    		// _gl.finish();

    	};

    	function pushRenderItem( object, geometry, material, z, group ) {

    		var array, index;

    		// allocate the next position in the appropriate array

    		if ( material.transparent ) {

    			array = transparentObjects;
    			index = ++ transparentObjectsLastIndex;

    		} else {

    			array = opaqueObjects;
    			index = ++ opaqueObjectsLastIndex;

    		}

    		// recycle existing render item or grow the array

    		var renderItem = array[ index ];

    		if ( renderItem !== undefined ) {

    			renderItem.id = object.id;
    			renderItem.object = object;
    			renderItem.geometry = geometry;
    			renderItem.material = material;
    			renderItem.z = _vector3.z;
    			renderItem.group = group;

    		} else {

    			renderItem = {
    				id: object.id,
    				object: object,
    				geometry: geometry,
    				material: material,
    				z: _vector3.z,
    				group: group
    			};

    			// assert( index === array.length );
    			array.push( renderItem );

    		}

    	}

    	// TODO Duplicated code (Frustum)

    	function isObjectViewable( object ) {

    		var geometry = object.geometry;

    		if ( geometry.boundingSphere === null )
    			geometry.computeBoundingSphere();

    		_sphere.copy( geometry.boundingSphere ).
    			applyMatrix4( object.matrixWorld );

    		return isSphereViewable( _sphere );

    	}

    	function isSpriteViewable( sprite ) {

    		_sphere.center.set( 0, 0, 0 );
    		_sphere.radius = 0.7071067811865476;
    		_sphere.applyMatrix4( sprite.matrixWorld );

    		return isSphereViewable( _sphere );

    	}

    	function isSphereViewable( sphere ) {

    		if ( ! _frustum.intersectsSphere( sphere ) ) return false;

    		var numPlanes = _clipping.numPlanes;

    		if ( numPlanes === 0 ) return true;

    		var planes = _this.clippingPlanes,

    			center = sphere.center,
    			negRad = - sphere.radius,
    			i = 0;

    		do {

    			// out when deeper than radius in the negative halfspace
    			if ( planes[ i ].distanceToPoint( center ) < negRad ) return false;

    		} while ( ++ i !== numPlanes );

    		return true;

    	}

    	function projectObject( object, camera ) {

    		if ( object.visible === false ) return;

    		var visible = ( object.layers.mask & camera.layers.mask ) !== 0;

    		if ( visible ) {

    			if ( object.isLight ) {

    				lights.push( object );

    			} else if ( object.isSprite ) {

    				if ( object.frustumCulled === false || isSpriteViewable( object ) === true ) {

    					sprites.push( object );

    				}

    			} else if ( object.isLensFlare ) {

    				lensFlares.push( object );

    			} else if ( object.isImmediateRenderObject ) {

    				if ( _this.sortObjects === true ) {

    					_vector3.setFromMatrixPosition( object.matrixWorld );
    					_vector3.applyProjection( _projScreenMatrix );

    				}

    				pushRenderItem( object, null, object.material, _vector3.z, null );

    			} else if ( object.isMesh || object.isLine || object.isPoints ) {

    				if ( object.isSkinnedMesh ) {

    					object.skeleton.update();

    				}

    				if ( object.frustumCulled === false || isObjectViewable( object ) === true ) {

    					var material = object.material;

    					if ( material.visible === true ) {

    						if ( _this.sortObjects === true ) {

    							_vector3.setFromMatrixPosition( object.matrixWorld );
    							_vector3.applyProjection( _projScreenMatrix );

    						}

    						var geometry = objects.update( object );

    						if ( material.isMultiMaterial ) {

    							var groups = geometry.groups;
    							var materials = material.materials;

    							for ( var i = 0, l = groups.length; i < l; i ++ ) {

    								var group = groups[ i ];
    								var groupMaterial = materials[ group.materialIndex ];

    								if ( groupMaterial.visible === true ) {

    									pushRenderItem( object, geometry, groupMaterial, _vector3.z, group );

    								}

    							}

    						} else {

    							pushRenderItem( object, geometry, material, _vector3.z, null );

    						}

    					}

    				}

    			}

    		}

    		var children = object.children;

    		for ( var i = 0, l = children.length; i < l; i ++ ) {

    			projectObject( children[ i ], camera );

    		}

    	}

    	function renderObjects( renderList, camera, fog, overrideMaterial ) {

    		for ( var i = 0, l = renderList.length; i < l; i ++ ) {

    			var renderItem = renderList[ i ];

    			var object = renderItem.object;
    			var geometry = renderItem.geometry;
    			var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
    			var group = renderItem.group;

    			object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
    			object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

    			if ( object.isImmediateRenderObject ) {

    				setMaterial( material );

    				var program = setProgram( camera, fog, material, object );

    				_currentGeometryProgram = '';

    				object.render( function ( object ) {

    					_this.renderBufferImmediate( object, program, material );

    				} );

    			} else {

    				if ( object.onBeforeRender !== null ) object.onBeforeRender();

    				_this.renderBufferDirect( camera, fog, geometry, material, object, group );

    			}

    		}

    	}

    	function initMaterial( material, fog, object ) {

    		var materialProperties = properties.get( material );

    		var parameters = programCache.getParameters(
    				material, _lights, fog, _clipping.numPlanes, object );

    		var code = programCache.getProgramCode( material, parameters );

    		var program = materialProperties.program;
    		var programChange = true;

    		if ( program === undefined ) {

    			// new material
    			material.addEventListener( 'dispose', onMaterialDispose );

    		} else if ( program.code !== code ) {

    			// changed glsl or parameters
    			releaseMaterialProgramReference( material );

    		} else if ( parameters.shaderID !== undefined ) {

    			// same glsl and uniform list
    			return;

    		} else {

    			// only rebuild uniform list
    			programChange = false;

    		}

    		if ( programChange ) {

    			if ( parameters.shaderID ) {

    				var shader = ShaderLib[ parameters.shaderID ];

    				materialProperties.__webglShader = {
    					name: material.type,
    					uniforms: exports.UniformsUtils.clone( shader.uniforms ),
    					vertexShader: shader.vertexShader,
    					fragmentShader: shader.fragmentShader
    				};

    			} else {

    				materialProperties.__webglShader = {
    					name: material.type,
    					uniforms: material.uniforms,
    					vertexShader: material.vertexShader,
    					fragmentShader: material.fragmentShader
    				};

    			}

    			material.__webglShader = materialProperties.__webglShader;

    			program = programCache.acquireProgram( material, parameters, code );

    			materialProperties.program = program;
    			material.program = program;

    		}

    		var attributes = program.getAttributes();

    		if ( material.morphTargets ) {

    			material.numSupportedMorphTargets = 0;

    			for ( var i = 0; i < _this.maxMorphTargets; i ++ ) {

    				if ( attributes[ 'morphTarget' + i ] >= 0 ) {

    					material.numSupportedMorphTargets ++;

    				}

    			}

    		}

    		if ( material.morphNormals ) {

    			material.numSupportedMorphNormals = 0;

    			for ( var i = 0; i < _this.maxMorphNormals; i ++ ) {

    				if ( attributes[ 'morphNormal' + i ] >= 0 ) {

    					material.numSupportedMorphNormals ++;

    				}

    			}

    		}

    		var uniforms = materialProperties.__webglShader.uniforms;

    		if ( ! material.isShaderMaterial &&
    		     ! material.isRawShaderMaterial ||
    		       material.clipping === true ) {

    			materialProperties.numClippingPlanes = _clipping.numPlanes;
    			uniforms.clippingPlanes = _clipping.uniform;

    		}

    		materialProperties.fog = fog;

    		// store the light setup it was created for

    		materialProperties.lightsHash = _lights.hash;

    		if ( material.lights ) {

    			// wire up the material to this renderer's lighting state

    			uniforms.ambientLightColor.value = _lights.ambient;
    			uniforms.directionalLights.value = _lights.directional;
    			uniforms.spotLights.value = _lights.spot;
    			uniforms.pointLights.value = _lights.point;
    			uniforms.hemisphereLights.value = _lights.hemi;

    			uniforms.directionalShadowMap.value = _lights.directionalShadowMap;
    			uniforms.directionalShadowMatrix.value = _lights.directionalShadowMatrix;
    			uniforms.spotShadowMap.value = _lights.spotShadowMap;
    			uniforms.spotShadowMatrix.value = _lights.spotShadowMatrix;
    			uniforms.pointShadowMap.value = _lights.pointShadowMap;
    			uniforms.pointShadowMatrix.value = _lights.pointShadowMatrix;

    		}

    		var progUniforms = materialProperties.program.getUniforms(),
    			uniformsList =
    					WebGLUniforms.seqWithValue( progUniforms.seq, uniforms );

    		materialProperties.uniformsList = uniformsList;
    		materialProperties.dynamicUniforms =
    				WebGLUniforms.splitDynamic( uniformsList, uniforms );

    	}

    	function setMaterial( material ) {

    		material.side === DoubleSide
    			? state.disable( _gl.CULL_FACE )
    			: state.enable( _gl.CULL_FACE );

    		state.setFlipSided( material.side === BackSide );

    		material.transparent === true
    			? state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha )
    			: state.setBlending( NoBlending );

    		state.setDepthFunc( material.depthFunc );
    		state.setDepthTest( material.depthTest );
    		state.setDepthWrite( material.depthWrite );
    		state.setColorWrite( material.colorWrite );
    		state.setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

    	}

    	function setProgram( camera, fog, material, object ) {

    		_usedTextureUnits = 0;

    		var materialProperties = properties.get( material );

    		if ( _clippingEnabled ) {

    			if ( _localClippingEnabled || camera !== _currentCamera ) {

    				var useCache =
    						camera === _currentCamera &&
    						material.id === _currentMaterialId;

    				// we might want to call this function with some ClippingGroup
    				// object instead of the material, once it becomes feasible
    				// (#8465, #8379)
    				_clipping.setState(
    						material.clippingPlanes, material.clipShadows,
    						camera, materialProperties, useCache );

    			}

    		}

    		if ( material.needsUpdate === false ) {

    			if ( materialProperties.program === undefined ) {

    				material.needsUpdate = true;

    			} else if ( material.fog && materialProperties.fog !== fog ) {

    				material.needsUpdate = true;

    			} else if ( material.lights && materialProperties.lightsHash !== _lights.hash ) {

    				material.needsUpdate = true;

    			} else if ( materialProperties.numClippingPlanes !== undefined &&
    				materialProperties.numClippingPlanes !== _clipping.numPlanes ) {

    				material.needsUpdate = true;

    			}

    		}

    		if ( material.needsUpdate ) {

    			initMaterial( material, fog, object );
    			material.needsUpdate = false;

    		}

    		var refreshProgram = false;
    		var refreshMaterial = false;
    		var refreshLights = false;

    		var program = materialProperties.program,
    			p_uniforms = program.getUniforms(),
    			m_uniforms = materialProperties.__webglShader.uniforms;

    		if ( program.id !== _currentProgram ) {

    			_gl.useProgram( program.program );
    			_currentProgram = program.id;

    			refreshProgram = true;
    			refreshMaterial = true;
    			refreshLights = true;

    		}

    		if ( material.id !== _currentMaterialId ) {

    			_currentMaterialId = material.id;

    			refreshMaterial = true;

    		}

    		if ( refreshProgram || camera !== _currentCamera ) {

    			p_uniforms.set( _gl, camera, 'projectionMatrix' );

    			if ( capabilities.logarithmicDepthBuffer ) {

    				p_uniforms.setValue( _gl, 'logDepthBufFC',
    						2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

    			}


    			if ( camera !== _currentCamera ) {

    				_currentCamera = camera;

    				// lighting uniforms depend on the camera so enforce an update
    				// now, in case this material supports lights - or later, when
    				// the next material that does gets activated:

    				refreshMaterial = true;		// set to true on material change
    				refreshLights = true;		// remains set until update done

    			}

    			// load material specific uniforms
    			// (shader material also gets them for the sake of genericity)

    			if ( material.isShaderMaterial ||
    			     material.isMeshPhongMaterial ||
    			     material.isMeshStandardMaterial ||
    			     material.envMap ) {

    				var uCamPos = p_uniforms.map.cameraPosition;

    				if ( uCamPos !== undefined ) {

    					uCamPos.setValue( _gl,
    							_vector3.setFromMatrixPosition( camera.matrixWorld ) );

    				}

    			}

    			if ( material.isMeshPhongMaterial ||
    			     material.isMeshLambertMaterial ||
    			     material.isMeshBasicMaterial ||
    			     material.isMeshStandardMaterial ||
    			     material.isShaderMaterial ||
    			     material.skinning ) {

    				p_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );

    			}

    			p_uniforms.set( _gl, _this, 'toneMappingExposure' );
    			p_uniforms.set( _gl, _this, 'toneMappingWhitePoint' );

    		}

    		// skinning uniforms must be set even if material didn't change
    		// auto-setting of texture unit for bone texture must go before other textures
    		// not sure why, but otherwise weird things happen

    		if ( material.skinning ) {

    			p_uniforms.setOptional( _gl, object, 'bindMatrix' );
    			p_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );

    			var skeleton = object.skeleton;

    			if ( skeleton ) {

    				if ( capabilities.floatVertexTextures && skeleton.useVertexTexture ) {

    					p_uniforms.set( _gl, skeleton, 'boneTexture' );
    					p_uniforms.set( _gl, skeleton, 'boneTextureWidth' );
    					p_uniforms.set( _gl, skeleton, 'boneTextureHeight' );

    				} else {

    					p_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );

    				}

    			}

    		}

    		if ( refreshMaterial ) {

    			if ( material.lights ) {

    				// the current material requires lighting info

    				// note: all lighting uniforms are always set correctly
    				// they simply reference the renderer's state for their
    				// values
    				//
    				// use the current material's .needsUpdate flags to set
    				// the GL state when required

    				markUniformsLightsNeedsUpdate( m_uniforms, refreshLights );

    			}

    			// refresh uniforms common to several materials

    			if ( fog && material.fog ) {

    				refreshUniformsFog( m_uniforms, fog );

    			}

    			if ( material.isMeshBasicMaterial ||
    			     material.isMeshLambertMaterial ||
    			     material.isMeshPhongMaterial ||
    			     material.isMeshStandardMaterial ||
    			     material.isMeshDepthMaterial ) {

    				refreshUniformsCommon( m_uniforms, material );

    			}

    			// refresh single material specific uniforms

    			if ( material.isLineBasicMaterial ) {

    				refreshUniformsLine( m_uniforms, material );

    			} else if ( material.isLineDashedMaterial ) {

    				refreshUniformsLine( m_uniforms, material );
    				refreshUniformsDash( m_uniforms, material );

    			} else if ( material.isPointsMaterial ) {

    				refreshUniformsPoints( m_uniforms, material );

    			} else if ( material.isMeshLambertMaterial ) {

    				refreshUniformsLambert( m_uniforms, material );

    			} else if ( material.isMeshPhongMaterial ) {

    				refreshUniformsPhong( m_uniforms, material );

    			} else if ( material.isMeshPhysicalMaterial ) {

    				refreshUniformsPhysical( m_uniforms, material );

    			} else if ( material.isMeshStandardMaterial ) {

    				refreshUniformsStandard( m_uniforms, material );

    			} else if ( material.isMeshDepthMaterial ) {

    				if ( material.displacementMap ) {

    					m_uniforms.displacementMap.value = material.displacementMap;
    					m_uniforms.displacementScale.value = material.displacementScale;
    					m_uniforms.displacementBias.value = material.displacementBias;

    				}

    			} else if ( material.isMeshNormalMaterial ) {

    				m_uniforms.opacity.value = material.opacity;

    			}

    			WebGLUniforms.upload(
    					_gl, materialProperties.uniformsList, m_uniforms, _this );

    		}


    		// common matrices

    		p_uniforms.set( _gl, object, 'modelViewMatrix' );
    		p_uniforms.set( _gl, object, 'normalMatrix' );
    		p_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );


    		// dynamic uniforms

    		var dynUniforms = materialProperties.dynamicUniforms;

    		if ( dynUniforms !== null ) {

    			WebGLUniforms.evalDynamic( dynUniforms, m_uniforms, object, material, camera );
    			WebGLUniforms.upload( _gl, dynUniforms, m_uniforms, _this );

    		}

    		return program;

    	}

    	// Uniforms (refresh uniforms objects)

    	function refreshUniformsCommon( uniforms, material ) {

    		uniforms.opacity.value = material.opacity;

    		uniforms.diffuse.value = material.color;

    		if ( material.emissive ) {

    			uniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );

    		}

    		uniforms.map.value = material.map;
    		uniforms.specularMap.value = material.specularMap;
    		uniforms.alphaMap.value = material.alphaMap;

    		if ( material.aoMap ) {

    			uniforms.aoMap.value = material.aoMap;
    			uniforms.aoMapIntensity.value = material.aoMapIntensity;

    		}

    		// uv repeat and offset setting priorities
    		// 1. color map
    		// 2. specular map
    		// 3. normal map
    		// 4. bump map
    		// 5. alpha map
    		// 6. emissive map

    		var uvScaleMap;

    		if ( material.map ) {

    			uvScaleMap = material.map;

    		} else if ( material.specularMap ) {

    			uvScaleMap = material.specularMap;

    		} else if ( material.displacementMap ) {

    			uvScaleMap = material.displacementMap;

    		} else if ( material.normalMap ) {

    			uvScaleMap = material.normalMap;

    		} else if ( material.bumpMap ) {

    			uvScaleMap = material.bumpMap;

    		} else if ( material.roughnessMap ) {

    			uvScaleMap = material.roughnessMap;

    		} else if ( material.metalnessMap ) {

    			uvScaleMap = material.metalnessMap;

    		} else if ( material.alphaMap ) {

    			uvScaleMap = material.alphaMap;

    		} else if ( material.emissiveMap ) {

    			uvScaleMap = material.emissiveMap;

    		}

    		if ( uvScaleMap !== undefined ) {

    			// backwards compatibility
    			if ( uvScaleMap.isWebGLRenderTarget ) {

    				uvScaleMap = uvScaleMap.texture;

    			}

    			var offset = uvScaleMap.offset;
    			var repeat = uvScaleMap.repeat;

    			uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );

    		}

    		uniforms.envMap.value = material.envMap;

    		// don't flip CubeTexture envMaps, flip everything else:
    		//  WebGLRenderTargetCube will be flipped for backwards compatibility
    		//  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture
    		// this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future
    		uniforms.flipEnvMap.value = ( ! ( material.envMap && material.envMap.isCubeTexture ) ) ? 1 : - 1;

    		uniforms.reflectivity.value = material.reflectivity;
    		uniforms.refractionRatio.value = material.refractionRatio;

    	}

    	function refreshUniformsLine( uniforms, material ) {

    		uniforms.diffuse.value = material.color;
    		uniforms.opacity.value = material.opacity;

    	}

    	function refreshUniformsDash( uniforms, material ) {

    		uniforms.dashSize.value = material.dashSize;
    		uniforms.totalSize.value = material.dashSize + material.gapSize;
    		uniforms.scale.value = material.scale;

    	}

    	function refreshUniformsPoints( uniforms, material ) {

    		uniforms.diffuse.value = material.color;
    		uniforms.opacity.value = material.opacity;
    		uniforms.size.value = material.size * _pixelRatio;
    		uniforms.scale.value = _canvas.clientHeight * 0.5;

    		uniforms.map.value = material.map;

    		if ( material.map !== null ) {

    			var offset = material.map.offset;
    			var repeat = material.map.repeat;

    			uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );

    		}

    	}

    	function refreshUniformsFog( uniforms, fog ) {

    		uniforms.fogColor.value = fog.color;

    		if ( fog.isFog ) {

    			uniforms.fogNear.value = fog.near;
    			uniforms.fogFar.value = fog.far;

    		} else if ( fog.isFogExp2 ) {

    			uniforms.fogDensity.value = fog.density;

    		}

    	}

    	function refreshUniformsLambert( uniforms, material ) {

    		if ( material.lightMap ) {

    			uniforms.lightMap.value = material.lightMap;
    			uniforms.lightMapIntensity.value = material.lightMapIntensity;

    		}

    		if ( material.emissiveMap ) {

    			uniforms.emissiveMap.value = material.emissiveMap;

    		}

    	}

    	function refreshUniformsPhong( uniforms, material ) {

    		uniforms.specular.value = material.specular;
    		uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )

    		if ( material.lightMap ) {

    			uniforms.lightMap.value = material.lightMap;
    			uniforms.lightMapIntensity.value = material.lightMapIntensity;

    		}

    		if ( material.emissiveMap ) {

    			uniforms.emissiveMap.value = material.emissiveMap;

    		}

    		if ( material.bumpMap ) {

    			uniforms.bumpMap.value = material.bumpMap;
    			uniforms.bumpScale.value = material.bumpScale;

    		}

    		if ( material.normalMap ) {

    			uniforms.normalMap.value = material.normalMap;
    			uniforms.normalScale.value.copy( material.normalScale );

    		}

    		if ( material.displacementMap ) {

    			uniforms.displacementMap.value = material.displacementMap;
    			uniforms.displacementScale.value = material.displacementScale;
    			uniforms.displacementBias.value = material.displacementBias;

    		}

    	}

    	function refreshUniformsStandard( uniforms, material ) {

    		uniforms.roughness.value = material.roughness;
    		uniforms.metalness.value = material.metalness;

    		if ( material.roughnessMap ) {

    			uniforms.roughnessMap.value = material.roughnessMap;

    		}

    		if ( material.metalnessMap ) {

    			uniforms.metalnessMap.value = material.metalnessMap;

    		}

    		if ( material.lightMap ) {

    			uniforms.lightMap.value = material.lightMap;
    			uniforms.lightMapIntensity.value = material.lightMapIntensity;

    		}

    		if ( material.emissiveMap ) {

    			uniforms.emissiveMap.value = material.emissiveMap;

    		}

    		if ( material.bumpMap ) {

    			uniforms.bumpMap.value = material.bumpMap;
    			uniforms.bumpScale.value = material.bumpScale;

    		}

    		if ( material.normalMap ) {

    			uniforms.normalMap.value = material.normalMap;
    			uniforms.normalScale.value.copy( material.normalScale );

    		}

    		if ( material.displacementMap ) {

    			uniforms.displacementMap.value = material.displacementMap;
    			uniforms.displacementScale.value = material.displacementScale;
    			uniforms.displacementBias.value = material.displacementBias;

    		}

    		if ( material.envMap ) {

    			//uniforms.envMap.value = material.envMap; // part of uniforms common
    			uniforms.envMapIntensity.value = material.envMapIntensity;

    		}

    	}

    	function refreshUniformsPhysical( uniforms, material ) {

    		uniforms.clearCoat.value = material.clearCoat;
    		uniforms.clearCoatRoughness.value = material.clearCoatRoughness;

    		refreshUniformsStandard( uniforms, material );

    	}

    	// If uniforms are marked as clean, they don't need to be loaded to the GPU.

    	function markUniformsLightsNeedsUpdate( uniforms, value ) {

    		uniforms.ambientLightColor.needsUpdate = value;

    		uniforms.directionalLights.needsUpdate = value;
    		uniforms.pointLights.needsUpdate = value;
    		uniforms.spotLights.needsUpdate = value;
    		uniforms.hemisphereLights.needsUpdate = value;

    	}

    	// Lighting

    	function setupShadows( lights ) {

    		var lightShadowsLength = 0;

    		for ( var i = 0, l = lights.length; i < l; i ++ ) {

    			var light = lights[ i ];

    			if ( light.castShadow ) {

    				_lights.shadows[ lightShadowsLength ++ ] = light;

    			}

    		}

    		_lights.shadows.length = lightShadowsLength;

    	}

    	function setupLights( lights, camera ) {

    		var l, ll, light,
    		r = 0, g = 0, b = 0,
    		color,
    		intensity,
    		distance,
    		shadowMap,

    		viewMatrix = camera.matrixWorldInverse,

    		directionalLength = 0,
    		pointLength = 0,
    		spotLength = 0,
    		hemiLength = 0;

    		for ( l = 0, ll = lights.length; l < ll; l ++ ) {

    			light = lights[ l ];

    			color = light.color;
    			intensity = light.intensity;
    			distance = light.distance;

    			shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;

    			if ( light.isAmbientLight ) {

    				r += color.r * intensity;
    				g += color.g * intensity;
    				b += color.b * intensity;

    			} else if ( light.isDirectionalLight ) {

    				var uniforms = lightCache.get( light );

    				uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
    				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
    				_vector3.setFromMatrixPosition( light.target.matrixWorld );
    				uniforms.direction.sub( _vector3 );
    				uniforms.direction.transformDirection( viewMatrix );

    				uniforms.shadow = light.castShadow;

    				if ( light.castShadow ) {

    					uniforms.shadowBias = light.shadow.bias;
    					uniforms.shadowRadius = light.shadow.radius;
    					uniforms.shadowMapSize = light.shadow.mapSize;

    				}

    				_lights.directionalShadowMap[ directionalLength ] = shadowMap;
    				_lights.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;
    				_lights.directional[ directionalLength ++ ] = uniforms;

    			} else if ( light.isSpotLight ) {

    				var uniforms = lightCache.get( light );

    				uniforms.position.setFromMatrixPosition( light.matrixWorld );
    				uniforms.position.applyMatrix4( viewMatrix );

    				uniforms.color.copy( color ).multiplyScalar( intensity );
    				uniforms.distance = distance;

    				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
    				_vector3.setFromMatrixPosition( light.target.matrixWorld );
    				uniforms.direction.sub( _vector3 );
    				uniforms.direction.transformDirection( viewMatrix );

    				uniforms.coneCos = Math.cos( light.angle );
    				uniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );
    				uniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;

    				uniforms.shadow = light.castShadow;

    				if ( light.castShadow ) {

    					uniforms.shadowBias = light.shadow.bias;
    					uniforms.shadowRadius = light.shadow.radius;
    					uniforms.shadowMapSize = light.shadow.mapSize;

    				}

    				_lights.spotShadowMap[ spotLength ] = shadowMap;
    				_lights.spotShadowMatrix[ spotLength ] = light.shadow.matrix;
    				_lights.spot[ spotLength ++ ] = uniforms;

    			} else if ( light.isPointLight ) {

    				var uniforms = lightCache.get( light );

    				uniforms.position.setFromMatrixPosition( light.matrixWorld );
    				uniforms.position.applyMatrix4( viewMatrix );

    				uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
    				uniforms.distance = light.distance;
    				uniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;

    				uniforms.shadow = light.castShadow;

    				if ( light.castShadow ) {

    					uniforms.shadowBias = light.shadow.bias;
    					uniforms.shadowRadius = light.shadow.radius;
    					uniforms.shadowMapSize = light.shadow.mapSize;

    				}

    				_lights.pointShadowMap[ pointLength ] = shadowMap;

    				if ( _lights.pointShadowMatrix[ pointLength ] === undefined ) {

    					_lights.pointShadowMatrix[ pointLength ] = new Matrix4();

    				}

    				// for point lights we set the shadow matrix to be a translation-only matrix
    				// equal to inverse of the light's position
    				_vector3.setFromMatrixPosition( light.matrixWorld ).negate();
    				_lights.pointShadowMatrix[ pointLength ].identity().setPosition( _vector3 );

    				_lights.point[ pointLength ++ ] = uniforms;

    			} else if ( light.isHemisphereLight ) {

    				var uniforms = lightCache.get( light );

    				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
    				uniforms.direction.transformDirection( viewMatrix );
    				uniforms.direction.normalize();

    				uniforms.skyColor.copy( light.color ).multiplyScalar( intensity );
    				uniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );

    				_lights.hemi[ hemiLength ++ ] = uniforms;

    			}

    		}

    		_lights.ambient[ 0 ] = r;
    		_lights.ambient[ 1 ] = g;
    		_lights.ambient[ 2 ] = b;

    		_lights.directional.length = directionalLength;
    		_lights.spot.length = spotLength;
    		_lights.point.length = pointLength;
    		_lights.hemi.length = hemiLength;

    		_lights.hash = directionalLength + ',' + pointLength + ',' + spotLength + ',' + hemiLength + ',' + _lights.shadows.length;

    	}

    	// GL state setting

    	this.setFaceCulling = function ( cullFace, frontFaceDirection ) {

    		state.setCullFace( cullFace );
    		state.setFlipSided( frontFaceDirection === FrontFaceDirectionCW );

    	};

    	// Textures

    	function allocTextureUnit() {

    		var textureUnit = _usedTextureUnits;

    		if ( textureUnit >= capabilities.maxTextures ) {

    			console.warn( 'WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );

    		}

    		_usedTextureUnits += 1;

    		return textureUnit;

    	}

    	this.allocTextureUnit = allocTextureUnit;

    	// this.setTexture2D = setTexture2D;
    	this.setTexture2D = ( function() {

    		var warned = false;

    		// backwards compatibility: peel texture.texture
    		return function setTexture2D( texture, slot ) {

    			if ( texture && texture.isWebGLRenderTarget ) {

    				if ( ! warned ) {

    					console.warn( "THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead." );
    					warned = true;

    				}

    				texture = texture.texture;

    			}

    			textures.setTexture2D( texture, slot );

    		};

    	}() );

    	this.setTexture = ( function() {

    		var warned = false;

    		return function setTexture( texture, slot ) {

    			if ( ! warned ) {

    				console.warn( "THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead." );
    				warned = true;

    			}

    			textures.setTexture2D( texture, slot );

    		};

    	}() );

    	this.setTextureCube = ( function() {

    		var warned = false;

    		return function setTextureCube( texture, slot ) {

    			// backwards compatibility: peel texture.texture
    			if ( texture && texture.isWebGLRenderTargetCube ) {

    				if ( ! warned ) {

    					console.warn( "THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead." );
    					warned = true;

    				}

    				texture = texture.texture;

    			}

    			// currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture
    			// TODO: unify these code paths
    			if ( ( texture && texture.isCubeTexture ) ||
    				 ( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {

    				// CompressedTexture can have Array in image :/

    				// this function alone should take care of cube textures
    				textures.setTextureCube( texture, slot );

    			} else {

    				// assumed: texture property of THREE.WebGLRenderTargetCube

    				textures.setTextureCubeDynamic( texture, slot );

    			}

    		};

    	}() );

    	this.getCurrentRenderTarget = function() {

    		return _currentRenderTarget;

    	};

    	this.setRenderTarget = function ( renderTarget ) {

    		_currentRenderTarget = renderTarget;

    		if ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {

    			textures.setupRenderTarget( renderTarget );

    		}

    		var isCube = ( renderTarget && renderTarget.isWebGLRenderTargetCube );
    		var framebuffer;

    		if ( renderTarget ) {

    			var renderTargetProperties = properties.get( renderTarget );

    			if ( isCube ) {

    				framebuffer = renderTargetProperties.__webglFramebuffer[ renderTarget.activeCubeFace ];

    			} else {

    				framebuffer = renderTargetProperties.__webglFramebuffer;

    			}

    			_currentScissor.copy( renderTarget.scissor );
    			_currentScissorTest = renderTarget.scissorTest;

    			_currentViewport.copy( renderTarget.viewport );

    		} else {

    			framebuffer = null;

    			_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio );
    			_currentScissorTest = _scissorTest;

    			_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio );

    		}

    		if ( _currentFramebuffer !== framebuffer ) {

    			_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
    			_currentFramebuffer = framebuffer;

    		}

    		state.scissor( _currentScissor );
    		state.setScissorTest( _currentScissorTest );

    		state.viewport( _currentViewport );

    		if ( isCube ) {

    			var textureProperties = properties.get( renderTarget.texture );
    			_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel );

    		}

    	};

    	this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) {

    		if ( ( renderTarget && renderTarget.isWebGLRenderTarget ) === false ) {

    			console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
    			return;

    		}

    		var framebuffer = properties.get( renderTarget ).__webglFramebuffer;

    		if ( framebuffer ) {

    			var restore = false;

    			if ( framebuffer !== _currentFramebuffer ) {

    				_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

    				restore = true;

    			}

    			try {

    				var texture = renderTarget.texture;
    				var textureFormat = texture.format;
    				var textureType = texture.type;

    				if ( textureFormat !== RGBAFormat && paramThreeToGL( textureFormat ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {

    					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );
    					return;

    				}

    				if ( textureType !== UnsignedByteType && paramThreeToGL( textureType ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE ) && // IE11, Edge and Chrome Mac < 52 (#9513)
    				     ! ( textureType === FloatType && ( extensions.get( 'OES_texture_float' ) || extensions.get( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox
    				     ! ( textureType === HalfFloatType && extensions.get( 'EXT_color_buffer_half_float' ) ) ) {

    					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );
    					return;

    				}

    				if ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {

    					// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)

    					if ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {

    						_gl.readPixels( x, y, width, height, paramThreeToGL( textureFormat ), paramThreeToGL( textureType ), buffer );

    					}

    				} else {

    					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );

    				}

    			} finally {

    				if ( restore ) {

    					_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );

    				}

    			}

    		}

    	};

    	// Map three.js constants to WebGL constants

    	function paramThreeToGL( p ) {

    		var extension;

    		if ( p === RepeatWrapping ) return _gl.REPEAT;
    		if ( p === ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;
    		if ( p === MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;

    		if ( p === NearestFilter ) return _gl.NEAREST;
    		if ( p === NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;
    		if ( p === NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;

    		if ( p === LinearFilter ) return _gl.LINEAR;
    		if ( p === LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;
    		if ( p === LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;

    		if ( p === UnsignedByteType ) return _gl.UNSIGNED_BYTE;
    		if ( p === UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;
    		if ( p === UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;
    		if ( p === UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;

    		if ( p === ByteType ) return _gl.BYTE;
    		if ( p === ShortType ) return _gl.SHORT;
    		if ( p === UnsignedShortType ) return _gl.UNSIGNED_SHORT;
    		if ( p === IntType ) return _gl.INT;
    		if ( p === UnsignedIntType ) return _gl.UNSIGNED_INT;
    		if ( p === FloatType ) return _gl.FLOAT;

    		extension = extensions.get( 'OES_texture_half_float' );

    		if ( extension !== null ) {

    			if ( p === HalfFloatType ) return extension.HALF_FLOAT_OES;

    		}

    		if ( p === AlphaFormat ) return _gl.ALPHA;
    		if ( p === RGBFormat ) return _gl.RGB;
    		if ( p === RGBAFormat ) return _gl.RGBA;
    		if ( p === LuminanceFormat ) return _gl.LUMINANCE;
    		if ( p === LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;
    		if ( p === DepthFormat ) return _gl.DEPTH_COMPONENT;
    		if ( p === DepthStencilFormat ) return _gl.DEPTH_STENCIL;

    		if ( p === AddEquation ) return _gl.FUNC_ADD;
    		if ( p === SubtractEquation ) return _gl.FUNC_SUBTRACT;
    		if ( p === ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;

    		if ( p === ZeroFactor ) return _gl.ZERO;
    		if ( p === OneFactor ) return _gl.ONE;
    		if ( p === SrcColorFactor ) return _gl.SRC_COLOR;
    		if ( p === OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;
    		if ( p === SrcAlphaFactor ) return _gl.SRC_ALPHA;
    		if ( p === OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;
    		if ( p === DstAlphaFactor ) return _gl.DST_ALPHA;
    		if ( p === OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;

    		if ( p === DstColorFactor ) return _gl.DST_COLOR;
    		if ( p === OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;
    		if ( p === SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;

    		extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

    		if ( extension !== null ) {

    			if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
    			if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
    			if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
    			if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

    		}

    		extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

    		if ( extension !== null ) {

    			if ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
    			if ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
    			if ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
    			if ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

    		}

    		extension = extensions.get( 'WEBGL_compressed_texture_etc1' );

    		if ( extension !== null ) {

    			if ( p === RGB_ETC1_Format ) return extension.COMPRESSED_RGB_ETC1_WEBGL;

    		}

    		extension = extensions.get( 'EXT_blend_minmax' );

    		if ( extension !== null ) {

    			if ( p === MinEquation ) return extension.MIN_EXT;
    			if ( p === MaxEquation ) return extension.MAX_EXT;

    		}

    		extension = extensions.get( 'WEBGL_depth_texture' );

    		if ( extension !== null ){

    			if ( p === UnsignedInt248Type ) return extension.UNSIGNED_INT_24_8_WEBGL;

    		}

    		return 0;

    	}

    }

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     */

    function FogExp2 ( color, density ) {

    	this.name = '';

    	this.color = new Color( color );
    	this.density = ( density !== undefined ) ? density : 0.00025;

    }

    FogExp2.prototype.isFogExp2 = true;

    FogExp2.prototype.clone = function () {

    	return new FogExp2( this.color.getHex(), this.density );

    };

    FogExp2.prototype.toJSON = function ( meta ) {

    	return {
    		type: 'FogExp2',
    		color: this.color.getHex(),
    		density: this.density
    	};

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     */

    function Fog ( color, near, far ) {

    	this.name = '';

    	this.color = new Color( color );

    	this.near = ( near !== undefined ) ? near : 1;
    	this.far = ( far !== undefined ) ? far : 1000;

    }

    Fog.prototype.isFog = true;

    Fog.prototype.clone = function () {

    	return new Fog( this.color.getHex(), this.near, this.far );

    };

    Fog.prototype.toJSON = function ( meta ) {

    	return {
    		type: 'Fog',
    		color: this.color.getHex(),
    		near: this.near,
    		far: this.far
    	};

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function Scene () {

    	Object3D.call( this );

    	this.type = 'Scene';

    	this.background = null;
    	this.fog = null;
    	this.overrideMaterial = null;

    	this.autoUpdate = true; // checked by the renderer

    }

    Scene.prototype = Object.create( Object3D.prototype );

    Scene.prototype.constructor = Scene;

    Scene.prototype.copy = function ( source, recursive ) {

    	Object3D.prototype.copy.call( this, source, recursive );

    	if ( source.background !== null ) this.background = source.background.clone();
    	if ( source.fog !== null ) this.fog = source.fog.clone();
    	if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();

    	this.autoUpdate = source.autoUpdate;
    	this.matrixAutoUpdate = source.matrixAutoUpdate;

    	return this;

    };

    Scene.prototype.toJSON = function ( meta ) {

    	var data = Object3D.prototype.toJSON.call( this, meta );

    	if ( this.background !== null ) data.object.background = this.background.toJSON( meta );
    	if ( this.fog !== null ) data.object.fog = this.fog.toJSON();

    	return data;

    };

    /**
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     */

    function LensFlare( texture, size, distance, blending, color ) {

    	Object3D.call( this );

    	this.lensFlares = [];

    	this.positionScreen = new Vector3();
    	this.customUpdateCallback = undefined;

    	if ( texture !== undefined ) {

    		this.add( texture, size, distance, blending, color );

    	}

    }

    LensFlare.prototype = Object.assign( Object.create( Object3D.prototype ), {

    	constructor: LensFlare,

    	isLensFlare: true,

    	copy: function ( source ) {

    		Object3D.prototype.copy.call( this, source );

    		this.positionScreen.copy( source.positionScreen );
    		this.customUpdateCallback = source.customUpdateCallback;

    		for ( var i = 0, l = source.lensFlares.length; i < l; i ++ ) {

    			this.lensFlares.push( source.lensFlares[ i ] );

    		}

    		return this;

    	},

    	add: function ( texture, size, distance, blending, color, opacity ) {

    		if ( size === undefined ) size = - 1;
    		if ( distance === undefined ) distance = 0;
    		if ( opacity === undefined ) opacity = 1;
    		if ( color === undefined ) color = new Color( 0xffffff );
    		if ( blending === undefined ) blending = NormalBlending;

    		distance = Math.min( distance, Math.max( 0, distance ) );

    		this.lensFlares.push( {
    			texture: texture,	// THREE.Texture
    			size: size, 		// size in pixels (-1 = use texture.width)
    			distance: distance, 	// distance (0-1) from light source (0=at light source)
    			x: 0, y: 0, z: 0,	// screen position (-1 => 1) z = 0 is in front z = 1 is back
    			scale: 1, 		// scale
    			rotation: 0, 		// rotation
    			opacity: opacity,	// opacity
    			color: color,		// color
    			blending: blending	// blending
    		} );

    	},

    	/*
    	 * Update lens flares update positions on all flares based on the screen position
    	 * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.
    	 */

    	updateLensFlares: function () {

    		var f, fl = this.lensFlares.length;
    		var flare;
    		var vecX = - this.positionScreen.x * 2;
    		var vecY = - this.positionScreen.y * 2;

    		for ( f = 0; f < fl; f ++ ) {

    			flare = this.lensFlares[ f ];

    			flare.x = this.positionScreen.x + vecX * flare.distance;
    			flare.y = this.positionScreen.y + vecY * flare.distance;

    			flare.wantedRotation = flare.x * Math.PI * 0.25;
    			flare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;

    		}

    	}

    } );

    /**
     * @author alteredq / http://alteredqualia.com/
     *
     * parameters = {
     *  color: <hex>,
     *  opacity: <float>,
     *  map: new THREE.Texture( <Image> ),
     *
     *	uvOffset: new THREE.Vector2(),
     *	uvScale: new THREE.Vector2()
     * }
     */

    function SpriteMaterial( parameters ) {

    	Material.call( this );

    	this.type = 'SpriteMaterial';

    	this.color = new Color( 0xffffff );
    	this.map = null;

    	this.rotation = 0;

    	this.fog = false;
    	this.lights = false;

    	this.setValues( parameters );

    }

    SpriteMaterial.prototype = Object.create( Material.prototype );
    SpriteMaterial.prototype.constructor = SpriteMaterial;

    SpriteMaterial.prototype.copy = function ( source ) {

    	Material.prototype.copy.call( this, source );

    	this.color.copy( source.color );
    	this.map = source.map;

    	this.rotation = source.rotation;

    	return this;

    };

    /**
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     */

    function Sprite( material ) {

    	Object3D.call( this );

    	this.type = 'Sprite';

    	this.material = ( material !== undefined ) ? material : new SpriteMaterial();

    }

    Sprite.prototype = Object.assign( Object.create( Object3D.prototype ), {

    	constructor: Sprite,

    	isSprite: true,

    	raycast: ( function () {

    		var matrixPosition = new Vector3();

    		return function raycast( raycaster, intersects ) {

    			matrixPosition.setFromMatrixPosition( this.matrixWorld );

    			var distanceSq = raycaster.ray.distanceSqToPoint( matrixPosition );
    			var guessSizeSq = this.scale.x * this.scale.y / 4;

    			if ( distanceSq > guessSizeSq ) {

    				return;

    			}

    			intersects.push( {

    				distance: Math.sqrt( distanceSq ),
    				point: this.position,
    				face: null,
    				object: this

    			} );

    		};

    	}() ),

    	clone: function () {

    		return new this.constructor( this.material ).copy( this );

    	}

    } );

    /**
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     * @author mrdoob / http://mrdoob.com/
     */

    function LOD() {

    	Object3D.call( this );

    	this.type = 'LOD';

    	Object.defineProperties( this, {
    		levels: {
    			enumerable: true,
    			value: []
    		}
    	} );

    }


    LOD.prototype = Object.assign( Object.create( Object3D.prototype ), {

    	constructor: LOD,

    	copy: function ( source ) {

    		Object3D.prototype.copy.call( this, source, false );

    		var levels = source.levels;

    		for ( var i = 0, l = levels.length; i < l; i ++ ) {

    			var level = levels[ i ];

    			this.addLevel( level.object.clone(), level.distance );

    		}

    		return this;

    	},

    	addLevel: function ( object, distance ) {

    		if ( distance === undefined ) distance = 0;

    		distance = Math.abs( distance );

    		var levels = this.levels;

    		for ( var l = 0; l < levels.length; l ++ ) {

    			if ( distance < levels[ l ].distance ) {

    				break;

    			}

    		}

    		levels.splice( l, 0, { distance: distance, object: object } );

    		this.add( object );

    	},

    	getObjectForDistance: function ( distance ) {

    		var levels = this.levels;

    		for ( var i = 1, l = levels.length; i < l; i ++ ) {

    			if ( distance < levels[ i ].distance ) {

    				break;

    			}

    		}

    		return levels[ i - 1 ].object;

    	},

    	raycast: ( function () {

    		var matrixPosition = new Vector3();

    		return function raycast( raycaster, intersects ) {

    			matrixPosition.setFromMatrixPosition( this.matrixWorld );

    			var distance = raycaster.ray.origin.distanceTo( matrixPosition );

    			this.getObjectForDistance( distance ).raycast( raycaster, intersects );

    		};

    	}() ),

    	update: function () {

    		var v1 = new Vector3();
    		var v2 = new Vector3();

    		return function update( camera ) {

    			var levels = this.levels;

    			if ( levels.length > 1 ) {

    				v1.setFromMatrixPosition( camera.matrixWorld );
    				v2.setFromMatrixPosition( this.matrixWorld );

    				var distance = v1.distanceTo( v2 );

    				levels[ 0 ].object.visible = true;

    				for ( var i = 1, l = levels.length; i < l; i ++ ) {

    					if ( distance >= levels[ i ].distance ) {

    						levels[ i - 1 ].object.visible = false;
    						levels[ i ].object.visible = true;

    					} else {

    						break;

    					}

    				}

    				for ( ; i < l; i ++ ) {

    					levels[ i ].object.visible = false;

    				}

    			}

    		};

    	}(),

    	toJSON: function ( meta ) {

    		var data = Object3D.prototype.toJSON.call( this, meta );

    		data.object.levels = [];

    		var levels = this.levels;

    		for ( var i = 0, l = levels.length; i < l; i ++ ) {

    			var level = levels[ i ];

    			data.object.levels.push( {
    				object: level.object.uuid,
    				distance: level.distance
    			} );

    		}

    		return data;

    	}

    } );

    /**
     * @author alteredq / http://alteredqualia.com/
     */

    function DataTexture( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {

    	Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

    	this.image = { data: data, width: width, height: height };

    	this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
    	this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

    	this.flipY = false;
    	this.generateMipmaps  = false;

    }

    DataTexture.prototype = Object.create( Texture.prototype );
    DataTexture.prototype.constructor = DataTexture;

    DataTexture.prototype.isDataTexture = true;

    /**
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     * @author michael guerrero / http://realitymeltdown.com
     * @author ikerr / http://verold.com
     */

    function Skeleton( bones, boneInverses, useVertexTexture ) {

    	this.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;

    	this.identityMatrix = new Matrix4();

    	// copy the bone array

    	bones = bones || [];

    	this.bones = bones.slice( 0 );

    	// create a bone texture or an array of floats

    	if ( this.useVertexTexture ) {

    		// layout (1 matrix = 4 pixels)
    		//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
    		//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
    		//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
    		//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
    		//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)


    		var size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix
    		size = exports.Math.nextPowerOfTwo( Math.ceil( size ) );
    		size = Math.max( size, 4 );

    		this.boneTextureWidth = size;
    		this.boneTextureHeight = size;

    		this.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel
    		this.boneTexture = new DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, RGBAFormat, FloatType );

    	} else {

    		this.boneMatrices = new Float32Array( 16 * this.bones.length );

    	}

    	// use the supplied bone inverses or calculate the inverses

    	if ( boneInverses === undefined ) {

    		this.calculateInverses();

    	} else {

    		if ( this.bones.length === boneInverses.length ) {

    			this.boneInverses = boneInverses.slice( 0 );

    		} else {

    			console.warn( 'THREE.Skeleton bonInverses is the wrong length.' );

    			this.boneInverses = [];

    			for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

    				this.boneInverses.push( new Matrix4() );

    			}

    		}

    	}

    }

    Object.assign( Skeleton.prototype, {

    	calculateInverses: function () {

    		this.boneInverses = [];

    		for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

    			var inverse = new Matrix4();

    			if ( this.bones[ b ] ) {

    				inverse.getInverse( this.bones[ b ].matrixWorld );

    			}

    			this.boneInverses.push( inverse );

    		}

    	},

    	pose: function () {

    		var bone;

    		// recover the bind-time world matrices

    		for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

    			bone = this.bones[ b ];

    			if ( bone ) {

    				bone.matrixWorld.getInverse( this.boneInverses[ b ] );

    			}

    		}

    		// compute the local matrices, positions, rotations and scales

    		for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

    			bone = this.bones[ b ];

    			if ( bone ) {

    				if ( (bone.parent && bone.parent.isBone) ) {

    					bone.matrix.getInverse( bone.parent.matrixWorld );
    					bone.matrix.multiply( bone.matrixWorld );

    				} else {

    					bone.matrix.copy( bone.matrixWorld );

    				}

    				bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

    			}

    		}

    	},

    	update: ( function () {

    		var offsetMatrix = new Matrix4();

    		return function update() {

    			// flatten bone matrices to array

    			for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

    				// compute the offset between the current and the original transform

    				var matrix = this.bones[ b ] ? this.bones[ b ].matrixWorld : this.identityMatrix;

    				offsetMatrix.multiplyMatrices( matrix, this.boneInverses[ b ] );
    				offsetMatrix.toArray( this.boneMatrices, b * 16 );

    			}

    			if ( this.useVertexTexture ) {

    				this.boneTexture.needsUpdate = true;

    			}

    		};

    	} )(),

    	clone: function () {

    		return new Skeleton( this.bones, this.boneInverses, this.useVertexTexture );

    	}

    } );

    /**
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     * @author ikerr / http://verold.com
     */

    function Bone( skin ) {

    	Object3D.call( this );

    	this.type = 'Bone';

    	this.skin = skin;

    }

    Bone.prototype = Object.assign( Object.create( Object3D.prototype ), {

    	constructor: Bone,

    	isBone: true,

    	copy: function ( source ) {

    		Object3D.prototype.copy.call( this, source );

    		this.skin = source.skin;

    		return this;

    	}

    } );

    /**
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     * @author ikerr / http://verold.com
     */

    function SkinnedMesh( geometry, material, useVertexTexture ) {

    	Mesh.call( this, geometry, material );

    	this.type = 'SkinnedMesh';

    	this.bindMode = "attached";
    	this.bindMatrix = new Matrix4();
    	this.bindMatrixInverse = new Matrix4();

    	// init bones

    	// TODO: remove bone creation as there is no reason (other than
    	// convenience) for THREE.SkinnedMesh to do this.

    	var bones = [];

    	if ( this.geometry && this.geometry.bones !== undefined ) {

    		var bone, gbone;

    		for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {

    			gbone = this.geometry.bones[ b ];

    			bone = new Bone( this );
    			bones.push( bone );

    			bone.name = gbone.name;
    			bone.position.fromArray( gbone.pos );
    			bone.quaternion.fromArray( gbone.rotq );
    			if ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );

    		}

    		for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {

    			gbone = this.geometry.bones[ b ];

    			if ( gbone.parent !== - 1 && gbone.parent !== null &&
    					bones[ gbone.parent ] !== undefined ) {

    				bones[ gbone.parent ].add( bones[ b ] );

    			} else {

    				this.add( bones[ b ] );

    			}

    		}

    	}

    	this.normalizeSkinWeights();

    	this.updateMatrixWorld( true );
    	this.bind( new Skeleton( bones, undefined, useVertexTexture ), this.matrixWorld );

    }


    SkinnedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {

    	constructor: SkinnedMesh,

    	isSkinnedMesh: true,

    	bind: function( skeleton, bindMatrix ) {

    		this.skeleton = skeleton;

    		if ( bindMatrix === undefined ) {

    			this.updateMatrixWorld( true );

    			this.skeleton.calculateInverses();

    			bindMatrix = this.matrixWorld;

    		}

    		this.bindMatrix.copy( bindMatrix );
    		this.bindMatrixInverse.getInverse( bindMatrix );

    	},

    	pose: function () {

    		this.skeleton.pose();

    	},

    	normalizeSkinWeights: function () {

    		if ( (this.geometry && this.geometry.isGeometry) ) {

    			for ( var i = 0; i < this.geometry.skinWeights.length; i ++ ) {

    				var sw = this.geometry.skinWeights[ i ];

    				var scale = 1.0 / sw.lengthManhattan();

    				if ( scale !== Infinity ) {

    					sw.multiplyScalar( scale );

    				} else {

    					sw.set( 1, 0, 0, 0 ); // do something reasonable

    				}

    			}

    		} else if ( (this.geometry && this.geometry.isBufferGeometry) ) {

    			var vec = new Vector4();

    			var skinWeight = this.geometry.attributes.skinWeight;

    			for ( var i = 0; i < skinWeight.count; i ++ ) {

    				vec.x = skinWeight.getX( i );
    				vec.y = skinWeight.getY( i );
    				vec.z = skinWeight.getZ( i );
    				vec.w = skinWeight.getW( i );

    				var scale = 1.0 / vec.lengthManhattan();

    				if ( scale !== Infinity ) {

    					vec.multiplyScalar( scale );

    				} else {

    					vec.set( 1, 0, 0, 0 ); // do something reasonable

    				}

    				skinWeight.setXYZW( i, vec.x, vec.y, vec.z, vec.w );

    			}

    		}

    	},

    	updateMatrixWorld: function( force ) {

    		Mesh.prototype.updateMatrixWorld.call( this, true );

    		if ( this.bindMode === "attached" ) {

    			this.bindMatrixInverse.getInverse( this.matrixWorld );

    		} else if ( this.bindMode === "detached" ) {

    			this.bindMatrixInverse.getInverse( this.bindMatrix );

    		} else {

    			console.warn( 'THREE.SkinnedMesh unrecognized bindMode: ' + this.bindMode );

    		}

    	},

    	clone: function() {

    		return new this.constructor( this.geometry, this.material, this.skeleton.useVertexTexture ).copy( this );

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     *
     * parameters = {
     *  color: <hex>,
     *  opacity: <float>,
     *
     *  linewidth: <float>,
     *  linecap: "round",
     *  linejoin: "round"
     * }
     */

    function LineBasicMaterial( parameters ) {

    	Material.call( this );

    	this.type = 'LineBasicMaterial';

    	this.color = new Color( 0xffffff );

    	this.linewidth = 1;
    	this.linecap = 'round';
    	this.linejoin = 'round';

    	this.lights = false;

    	this.setValues( parameters );

    }

    LineBasicMaterial.prototype = Object.create( Material.prototype );
    LineBasicMaterial.prototype.constructor = LineBasicMaterial;

    LineBasicMaterial.prototype.isLineBasicMaterial = true;

    LineBasicMaterial.prototype.copy = function ( source ) {

    	Material.prototype.copy.call( this, source );

    	this.color.copy( source.color );

    	this.linewidth = source.linewidth;
    	this.linecap = source.linecap;
    	this.linejoin = source.linejoin;

    	return this;

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function Line( geometry, material, mode ) {

    	if ( mode === 1 ) {

    		console.warn( 'THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.' );
    		return new LineSegments( geometry, material );

    	}

    	Object3D.call( this );

    	this.type = 'Line';

    	this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
    	this.material = material !== undefined ? material : new LineBasicMaterial( { color: Math.random() * 0xffffff } );

    }

    Line.prototype = Object.assign( Object.create( Object3D.prototype ), {

    	constructor: Line,

    	isLine: true,

    	raycast: ( function () {

    		var inverseMatrix = new Matrix4();
    		var ray = new Ray();
    		var sphere = new Sphere();

    		return function raycast( raycaster, intersects ) {

    			var precision = raycaster.linePrecision;
    			var precisionSq = precision * precision;

    			var geometry = this.geometry;
    			var matrixWorld = this.matrixWorld;

    			// Checking boundingSphere distance to ray

    			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

    			sphere.copy( geometry.boundingSphere );
    			sphere.applyMatrix4( matrixWorld );

    			if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;

    			//

    			inverseMatrix.getInverse( matrixWorld );
    			ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

    			var vStart = new Vector3();
    			var vEnd = new Vector3();
    			var interSegment = new Vector3();
    			var interRay = new Vector3();
    			var step = (this && this.isLineSegments) ? 2 : 1;

    			if ( (geometry && geometry.isBufferGeometry) ) {

    				var index = geometry.index;
    				var attributes = geometry.attributes;
    				var positions = attributes.position.array;

    				if ( index !== null ) {

    					var indices = index.array;

    					for ( var i = 0, l = indices.length - 1; i < l; i += step ) {

    						var a = indices[ i ];
    						var b = indices[ i + 1 ];

    						vStart.fromArray( positions, a * 3 );
    						vEnd.fromArray( positions, b * 3 );

    						var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

    						if ( distSq > precisionSq ) continue;

    						interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

    						var distance = raycaster.ray.origin.distanceTo( interRay );

    						if ( distance < raycaster.near || distance > raycaster.far ) continue;

    						intersects.push( {

    							distance: distance,
    							// What do we want? intersection point on the ray or on the segment??
    							// point: raycaster.ray.at( distance ),
    							point: interSegment.clone().applyMatrix4( this.matrixWorld ),
    							index: i,
    							face: null,
    							faceIndex: null,
    							object: this

    						} );

    					}

    				} else {

    					for ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {

    						vStart.fromArray( positions, 3 * i );
    						vEnd.fromArray( positions, 3 * i + 3 );

    						var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

    						if ( distSq > precisionSq ) continue;

    						interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

    						var distance = raycaster.ray.origin.distanceTo( interRay );

    						if ( distance < raycaster.near || distance > raycaster.far ) continue;

    						intersects.push( {

    							distance: distance,
    							// What do we want? intersection point on the ray or on the segment??
    							// point: raycaster.ray.at( distance ),
    							point: interSegment.clone().applyMatrix4( this.matrixWorld ),
    							index: i,
    							face: null,
    							faceIndex: null,
    							object: this

    						} );

    					}

    				}

    			} else if ( (geometry && geometry.isGeometry) ) {

    				var vertices = geometry.vertices;
    				var nbVertices = vertices.length;

    				for ( var i = 0; i < nbVertices - 1; i += step ) {

    					var distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );

    					if ( distSq > precisionSq ) continue;

    					interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

    					var distance = raycaster.ray.origin.distanceTo( interRay );

    					if ( distance < raycaster.near || distance > raycaster.far ) continue;

    					intersects.push( {

    						distance: distance,
    						// What do we want? intersection point on the ray or on the segment??
    						// point: raycaster.ray.at( distance ),
    						point: interSegment.clone().applyMatrix4( this.matrixWorld ),
    						index: i,
    						face: null,
    						faceIndex: null,
    						object: this

    					} );

    				}

    			}

    		};

    	}() ),

    	clone: function () {

    		return new this.constructor( this.geometry, this.material ).copy( this );

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function LineSegments( geometry, material ) {

    	Line.call( this, geometry, material );

    	this.type = 'LineSegments';

    }

    LineSegments.prototype = Object.assign( Object.create( Line.prototype ), {

    	constructor: LineSegments,

    	isLineSegments: true

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     *
     * parameters = {
     *  color: <hex>,
     *  opacity: <float>,
     *  map: new THREE.Texture( <Image> ),
     *
     *  size: <float>,
     *  sizeAttenuation: <bool>
     * }
     */

    function PointsMaterial( parameters ) {

    	Material.call( this );

    	this.type = 'PointsMaterial';

    	this.color = new Color( 0xffffff );

    	this.map = null;

    	this.size = 1;
    	this.sizeAttenuation = true;

    	this.lights = false;

    	this.setValues( parameters );

    }

    PointsMaterial.prototype = Object.create( Material.prototype );
    PointsMaterial.prototype.constructor = PointsMaterial;

    PointsMaterial.prototype.isPointsMaterial = true;

    PointsMaterial.prototype.copy = function ( source ) {

    	Material.prototype.copy.call( this, source );

    	this.color.copy( source.color );

    	this.map = source.map;

    	this.size = source.size;
    	this.sizeAttenuation = source.sizeAttenuation;

    	return this;

    };

    /**
     * @author alteredq / http://alteredqualia.com/
     */

    function Points( geometry, material ) {

    	Object3D.call( this );

    	this.type = 'Points';

    	this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
    	this.material = material !== undefined ? material : new PointsMaterial( { color: Math.random() * 0xffffff } );

    }

    Points.prototype = Object.assign( Object.create( Object3D.prototype ), {

    	constructor: Points,

    	isPoints: true,

    	raycast: ( function () {

    		var inverseMatrix = new Matrix4();
    		var ray = new Ray();
    		var sphere = new Sphere();

    		return function raycast( raycaster, intersects ) {

    			var object = this;
    			var geometry = this.geometry;
    			var matrixWorld = this.matrixWorld;
    			var threshold = raycaster.params.Points.threshold;

    			// Checking boundingSphere distance to ray

    			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

    			sphere.copy( geometry.boundingSphere );
    			sphere.applyMatrix4( matrixWorld );

    			if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;

    			//

    			inverseMatrix.getInverse( matrixWorld );
    			ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

    			var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
    			var localThresholdSq = localThreshold * localThreshold;
    			var position = new Vector3();

    			function testPoint( point, index ) {

    				var rayPointDistanceSq = ray.distanceSqToPoint( point );

    				if ( rayPointDistanceSq < localThresholdSq ) {

    					var intersectPoint = ray.closestPointToPoint( point );
    					intersectPoint.applyMatrix4( matrixWorld );

    					var distance = raycaster.ray.origin.distanceTo( intersectPoint );

    					if ( distance < raycaster.near || distance > raycaster.far ) return;

    					intersects.push( {

    						distance: distance,
    						distanceToRay: Math.sqrt( rayPointDistanceSq ),
    						point: intersectPoint.clone(),
    						index: index,
    						face: null,
    						object: object

    					} );

    				}

    			}

    			if ( (geometry && geometry.isBufferGeometry) ) {

    				var index = geometry.index;
    				var attributes = geometry.attributes;
    				var positions = attributes.position.array;

    				if ( index !== null ) {

    					var indices = index.array;

    					for ( var i = 0, il = indices.length; i < il; i ++ ) {

    						var a = indices[ i ];

    						position.fromArray( positions, a * 3 );

    						testPoint( position, a );

    					}

    				} else {

    					for ( var i = 0, l = positions.length / 3; i < l; i ++ ) {

    						position.fromArray( positions, i * 3 );

    						testPoint( position, i );

    					}

    				}

    			} else {

    				var vertices = geometry.vertices;

    				for ( var i = 0, l = vertices.length; i < l; i ++ ) {

    					testPoint( vertices[ i ], i );

    				}

    			}

    		};

    	}() ),

    	clone: function () {

    		return new this.constructor( this.geometry, this.material ).copy( this );

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function Group() {

    	Object3D.call( this );

    	this.type = 'Group';

    }

    Group.prototype = Object.assign( Object.create( Object3D.prototype ), {

    	constructor: Group

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function VideoTexture( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

    	Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

    	this.generateMipmaps = false;

    	var scope = this;

    	function update() {

    		requestAnimationFrame( update );

    		if ( video.readyState >= video.HAVE_CURRENT_DATA ) {

    			scope.needsUpdate = true;

    		}

    	}

    	update();

    }

    VideoTexture.prototype = Object.create( Texture.prototype );
    VideoTexture.prototype.constructor = VideoTexture;

    /**
     * @author alteredq / http://alteredqualia.com/
     */

    function CompressedTexture( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {

    	Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

    	this.image = { width: width, height: height };
    	this.mipmaps = mipmaps;

    	// no flipping for cube textures
    	// (also flipping doesn't work for compressed textures )

    	this.flipY = false;

    	// can't generate mipmaps for compressed textures
    	// mips must be embedded in DDS files

    	this.generateMipmaps = false;

    }

    CompressedTexture.prototype = Object.create( Texture.prototype );
    CompressedTexture.prototype.constructor = CompressedTexture;

    CompressedTexture.prototype.isCompressedTexture = true;

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function CanvasTexture( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

    	Texture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

    	this.needsUpdate = true;

    }

    CanvasTexture.prototype = Object.create( Texture.prototype );
    CanvasTexture.prototype.constructor = CanvasTexture;

    /**
     * @author Matt DesLauriers / @mattdesl
     * @author atix / arthursilber.de
     */

    function DepthTexture( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) {

    	format = format !== undefined ? format : DepthFormat;

    	if ( format !== DepthFormat && format !== DepthStencilFormat ) {

    		throw new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' )

    	}

    	Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

    	this.image = { width: width, height: height };

    	this.type = type !== undefined ? type : UnsignedShortType;

    	this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
    	this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

    	this.flipY = false;
    	this.generateMipmaps	= false;

    }

    DepthTexture.prototype = Object.create( Texture.prototype );
    DepthTexture.prototype.constructor = DepthTexture;
    DepthTexture.prototype.isDepthTexture = true;

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function WireframeGeometry( geometry ) {

    	BufferGeometry.call( this );

    	var edge = [ 0, 0 ], hash = {};

    	function sortFunction( a, b ) {

    		return a - b;

    	}

    	var keys = [ 'a', 'b', 'c' ];

    	if ( (geometry && geometry.isGeometry) ) {

    		var vertices = geometry.vertices;
    		var faces = geometry.faces;
    		var numEdges = 0;

    		// allocate maximal size
    		var edges = new Uint32Array( 6 * faces.length );

    		for ( var i = 0, l = faces.length; i < l; i ++ ) {

    			var face = faces[ i ];

    			for ( var j = 0; j < 3; j ++ ) {

    				edge[ 0 ] = face[ keys[ j ] ];
    				edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
    				edge.sort( sortFunction );

    				var key = edge.toString();

    				if ( hash[ key ] === undefined ) {

    					edges[ 2 * numEdges ] = edge[ 0 ];
    					edges[ 2 * numEdges + 1 ] = edge[ 1 ];
    					hash[ key ] = true;
    					numEdges ++;

    				}

    			}

    		}

    		var coords = new Float32Array( numEdges * 2 * 3 );

    		for ( var i = 0, l = numEdges; i < l; i ++ ) {

    			for ( var j = 0; j < 2; j ++ ) {

    				var vertex = vertices[ edges [ 2 * i + j ] ];

    				var index = 6 * i + 3 * j;
    				coords[ index + 0 ] = vertex.x;
    				coords[ index + 1 ] = vertex.y;
    				coords[ index + 2 ] = vertex.z;

    			}

    		}

    		this.addAttribute( 'position', new BufferAttribute( coords, 3 ) );

    	} else if ( (geometry && geometry.isBufferGeometry) ) {

    		if ( geometry.index !== null ) {

    			// Indexed BufferGeometry

    			var indices = geometry.index.array;
    			var vertices = geometry.attributes.position;
    			var groups = geometry.groups;
    			var numEdges = 0;

    			if ( groups.length === 0 ) {

    				geometry.addGroup( 0, indices.length );

    			}

    			// allocate maximal size
    			var edges = new Uint32Array( 2 * indices.length );

    			for ( var o = 0, ol = groups.length; o < ol; ++ o ) {

    				var group = groups[ o ];

    				var start = group.start;
    				var count = group.count;

    				for ( var i = start, il = start + count; i < il; i += 3 ) {

    					for ( var j = 0; j < 3; j ++ ) {

    						edge[ 0 ] = indices[ i + j ];
    						edge[ 1 ] = indices[ i + ( j + 1 ) % 3 ];
    						edge.sort( sortFunction );

    						var key = edge.toString();

    						if ( hash[ key ] === undefined ) {

    							edges[ 2 * numEdges ] = edge[ 0 ];
    							edges[ 2 * numEdges + 1 ] = edge[ 1 ];
    							hash[ key ] = true;
    							numEdges ++;

    						}

    					}

    				}

    			}

    			var coords = new Float32Array( numEdges * 2 * 3 );

    			for ( var i = 0, l = numEdges; i < l; i ++ ) {

    				for ( var j = 0; j < 2; j ++ ) {

    					var index = 6 * i + 3 * j;
    					var index2 = edges[ 2 * i + j ];

    					coords[ index + 0 ] = vertices.getX( index2 );
    					coords[ index + 1 ] = vertices.getY( index2 );
    					coords[ index + 2 ] = vertices.getZ( index2 );

    				}

    			}

    			this.addAttribute( 'position', new BufferAttribute( coords, 3 ) );

    		} else {

    			// non-indexed BufferGeometry

    			var vertices = geometry.attributes.position.array;
    			var numEdges = vertices.length / 3;
    			var numTris = numEdges / 3;

    			var coords = new Float32Array( numEdges * 2 * 3 );

    			for ( var i = 0, l = numTris; i < l; i ++ ) {

    				for ( var j = 0; j < 3; j ++ ) {

    					var index = 18 * i + 6 * j;

    					var index1 = 9 * i + 3 * j;
    					coords[ index + 0 ] = vertices[ index1 ];
    					coords[ index + 1 ] = vertices[ index1 + 1 ];
    					coords[ index + 2 ] = vertices[ index1 + 2 ];

    					var index2 = 9 * i + 3 * ( ( j + 1 ) % 3 );
    					coords[ index + 3 ] = vertices[ index2 ];
    					coords[ index + 4 ] = vertices[ index2 + 1 ];
    					coords[ index + 5 ] = vertices[ index2 + 2 ];

    				}

    			}

    			this.addAttribute( 'position', new BufferAttribute( coords, 3 ) );

    		}

    	}

    }

    WireframeGeometry.prototype = Object.create( BufferGeometry.prototype );
    WireframeGeometry.prototype.constructor = WireframeGeometry;

    /**
     * @author zz85 / https://github.com/zz85
     * Parametric Surfaces Geometry
     * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
     *
     * new THREE.ParametricGeometry( parametricFunction, uSegments, ySegements );
     *
     */

    function ParametricGeometry( func, slices, stacks ) {

    	Geometry.call( this );

    	this.type = 'ParametricGeometry';

    	this.parameters = {
    		func: func,
    		slices: slices,
    		stacks: stacks
    	};

    	var verts = this.vertices;
    	var faces = this.faces;
    	var uvs = this.faceVertexUvs[ 0 ];

    	var i, j, p;
    	var u, v;

    	var sliceCount = slices + 1;

    	for ( i = 0; i <= stacks; i ++ ) {

    		v = i / stacks;

    		for ( j = 0; j <= slices; j ++ ) {

    			u = j / slices;

    			p = func( u, v );
    			verts.push( p );

    		}

    	}

    	var a, b, c, d;
    	var uva, uvb, uvc, uvd;

    	for ( i = 0; i < stacks; i ++ ) {

    		for ( j = 0; j < slices; j ++ ) {

    			a = i * sliceCount + j;
    			b = i * sliceCount + j + 1;
    			c = ( i + 1 ) * sliceCount + j + 1;
    			d = ( i + 1 ) * sliceCount + j;

    			uva = new Vector2( j / slices, i / stacks );
    			uvb = new Vector2( ( j + 1 ) / slices, i / stacks );
    			uvc = new Vector2( ( j + 1 ) / slices, ( i + 1 ) / stacks );
    			uvd = new Vector2( j / slices, ( i + 1 ) / stacks );

    			faces.push( new Face3( a, b, d ) );
    			uvs.push( [ uva, uvb, uvd ] );

    			faces.push( new Face3( b, c, d ) );
    			uvs.push( [ uvb.clone(), uvc, uvd.clone() ] );

    		}

    	}

    	// console.log(this);

    	// magic bullet
    	// var diff = this.mergeVertices();
    	// console.log('removed ', diff, ' vertices by merging');

    	this.computeFaceNormals();
    	this.computeVertexNormals();

    }

    ParametricGeometry.prototype = Object.create( Geometry.prototype );
    ParametricGeometry.prototype.constructor = ParametricGeometry;

    /**
     * @author clockworkgeek / https://github.com/clockworkgeek
     * @author timothypratley / https://github.com/timothypratley
     * @author WestLangley / http://github.com/WestLangley
    */

    function PolyhedronGeometry( vertices, indices, radius, detail ) {

    	Geometry.call( this );

    	this.type = 'PolyhedronGeometry';

    	this.parameters = {
    		vertices: vertices,
    		indices: indices,
    		radius: radius,
    		detail: detail
    	};

    	radius = radius || 1;
    	detail = detail || 0;

    	var that = this;

    	for ( var i = 0, l = vertices.length; i < l; i += 3 ) {

    		prepare( new Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );

    	}

    	var p = this.vertices;

    	var faces = [];

    	for ( var i = 0, j = 0, l = indices.length; i < l; i += 3, j ++ ) {

    		var v1 = p[ indices[ i ] ];
    		var v2 = p[ indices[ i + 1 ] ];
    		var v3 = p[ indices[ i + 2 ] ];

    		faces[ j ] = new Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );

    	}

    	var centroid = new Vector3();

    	for ( var i = 0, l = faces.length; i < l; i ++ ) {

    		subdivide( faces[ i ], detail );

    	}


    	// Handle case when face straddles the seam

    	for ( var i = 0, l = this.faceVertexUvs[ 0 ].length; i < l; i ++ ) {

    		var uvs = this.faceVertexUvs[ 0 ][ i ];

    		var x0 = uvs[ 0 ].x;
    		var x1 = uvs[ 1 ].x;
    		var x2 = uvs[ 2 ].x;

    		var max = Math.max( x0, x1, x2 );
    		var min = Math.min( x0, x1, x2 );

    		if ( max > 0.9 && min < 0.1 ) {

    			// 0.9 is somewhat arbitrary

    			if ( x0 < 0.2 ) uvs[ 0 ].x += 1;
    			if ( x1 < 0.2 ) uvs[ 1 ].x += 1;
    			if ( x2 < 0.2 ) uvs[ 2 ].x += 1;

    		}

    	}


    	// Apply radius

    	for ( var i = 0, l = this.vertices.length; i < l; i ++ ) {

    		this.vertices[ i ].multiplyScalar( radius );

    	}


    	// Merge vertices

    	this.mergeVertices();

    	this.computeFaceNormals();

    	this.boundingSphere = new Sphere( new Vector3(), radius );


    	// Project vector onto sphere's surface

    	function prepare( vector ) {

    		var vertex = vector.normalize().clone();
    		vertex.index = that.vertices.push( vertex ) - 1;

    		// Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.

    		var u = azimuth( vector ) / 2 / Math.PI + 0.5;
    		var v = inclination( vector ) / Math.PI + 0.5;
    		vertex.uv = new Vector2( u, 1 - v );

    		return vertex;

    	}


    	// Approximate a curved face with recursively sub-divided triangles.

    	function make( v1, v2, v3 ) {

    		var face = new Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );
    		that.faces.push( face );

    		centroid.copy( v1 ).add( v2 ).add( v3 ).divideScalar( 3 );

    		var azi = azimuth( centroid );

    		that.faceVertexUvs[ 0 ].push( [
    			correctUV( v1.uv, v1, azi ),
    			correctUV( v2.uv, v2, azi ),
    			correctUV( v3.uv, v3, azi )
    		] );

    	}


    	// Analytically subdivide a face to the required detail level.

    	function subdivide( face, detail ) {

    		var cols = Math.pow( 2, detail );
    		var a = prepare( that.vertices[ face.a ] );
    		var b = prepare( that.vertices[ face.b ] );
    		var c = prepare( that.vertices[ face.c ] );
    		var v = [];

    		// Construct all of the vertices for this subdivision.

    		for ( var i = 0 ; i <= cols; i ++ ) {

    			v[ i ] = [];

    			var aj = prepare( a.clone().lerp( c, i / cols ) );
    			var bj = prepare( b.clone().lerp( c, i / cols ) );
    			var rows = cols - i;

    			for ( var j = 0; j <= rows; j ++ ) {

    				if ( j === 0 && i === cols ) {

    					v[ i ][ j ] = aj;

    				} else {

    					v[ i ][ j ] = prepare( aj.clone().lerp( bj, j / rows ) );

    				}

    			}

    		}

    		// Construct all of the faces.

    		for ( var i = 0; i < cols ; i ++ ) {

    			for ( var j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {

    				var k = Math.floor( j / 2 );

    				if ( j % 2 === 0 ) {

    					make(
    						v[ i ][ k + 1 ],
    						v[ i + 1 ][ k ],
    						v[ i ][ k ]
    					);

    				} else {

    					make(
    						v[ i ][ k + 1 ],
    						v[ i + 1 ][ k + 1 ],
    						v[ i + 1 ][ k ]
    					);

    				}

    			}

    		}

    	}


    	// Angle around the Y axis, counter-clockwise when looking from above.

    	function azimuth( vector ) {

    		return Math.atan2( vector.z, - vector.x );

    	}


    	// Angle above the XZ plane.

    	function inclination( vector ) {

    		return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );

    	}


    	// Texture fixing helper. Spheres have some odd behaviours.

    	function correctUV( uv, vector, azimuth ) {

    		if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) uv = new Vector2( uv.x - 1, uv.y );
    		if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) uv = new Vector2( azimuth / 2 / Math.PI + 0.5, uv.y );
    		return uv.clone();

    	}

    }

    PolyhedronGeometry.prototype = Object.create( Geometry.prototype );
    PolyhedronGeometry.prototype.constructor = PolyhedronGeometry;

    /**
     * @author timothypratley / https://github.com/timothypratley
     */

    function TetrahedronGeometry( radius, detail ) {

    	var vertices = [
    		 1,  1,  1,   - 1, - 1,  1,   - 1,  1, - 1,    1, - 1, - 1
    	];

    	var indices = [
    		 2,  1,  0,    0,  3,  2,    1,  3,  0,    2,  3,  1
    	];

    	PolyhedronGeometry.call( this, vertices, indices, radius, detail );

    	this.type = 'TetrahedronGeometry';

    	this.parameters = {
    		radius: radius,
    		detail: detail
    	};

    }

    TetrahedronGeometry.prototype = Object.create( PolyhedronGeometry.prototype );
    TetrahedronGeometry.prototype.constructor = TetrahedronGeometry;

    /**
     * @author timothypratley / https://github.com/timothypratley
     */

    function OctahedronGeometry( radius, detail ) {

    	var vertices = [
    		1, 0, 0,   - 1, 0, 0,    0, 1, 0,    0, - 1, 0,    0, 0, 1,    0, 0, - 1
    	];

    	var indices = [
    		0, 2, 4,    0, 4, 3,    0, 3, 5,    0, 5, 2,    1, 2, 5,    1, 5, 3,    1, 3, 4,    1, 4, 2
    	];

    	PolyhedronGeometry.call( this, vertices, indices, radius, detail );

    	this.type = 'OctahedronGeometry';

    	this.parameters = {
    		radius: radius,
    		detail: detail
    	};

    }

    OctahedronGeometry.prototype = Object.create( PolyhedronGeometry.prototype );
    OctahedronGeometry.prototype.constructor = OctahedronGeometry;

    /**
     * @author timothypratley / https://github.com/timothypratley
     */

    function IcosahedronGeometry( radius, detail ) {

    	var t = ( 1 + Math.sqrt( 5 ) ) / 2;

    	var vertices = [
    		- 1,  t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,
    		 0, - 1,  t,    0,  1,  t,    0, - 1, - t,    0,  1, - t,
    		 t,  0, - 1,    t,  0,  1,   - t,  0, - 1,   - t,  0,  1
    	];

    	var indices = [
    		 0, 11,  5,    0,  5,  1,    0,  1,  7,    0,  7, 10,    0, 10, 11,
    		 1,  5,  9,    5, 11,  4,   11, 10,  2,   10,  7,  6,    7,  1,  8,
    		 3,  9,  4,    3,  4,  2,    3,  2,  6,    3,  6,  8,    3,  8,  9,
    		 4,  9,  5,    2,  4, 11,    6,  2, 10,    8,  6,  7,    9,  8,  1
    	];

    	PolyhedronGeometry.call( this, vertices, indices, radius, detail );

    	this.type = 'IcosahedronGeometry';

    	this.parameters = {
    		radius: radius,
    		detail: detail
    	};

    }

    IcosahedronGeometry.prototype = Object.create( PolyhedronGeometry.prototype );
    IcosahedronGeometry.prototype.constructor = IcosahedronGeometry;

    /**
     * @author Abe Pazos / https://hamoid.com
     */

    function DodecahedronGeometry( radius, detail ) {

    	var t = ( 1 + Math.sqrt( 5 ) ) / 2;
    	var r = 1 / t;

    	var vertices = [

    		// (±1, ±1, ±1)
    		- 1, - 1, - 1,    - 1, - 1,  1,
    		- 1,  1, - 1,    - 1,  1,  1,
    		 1, - 1, - 1,     1, - 1,  1,
    		 1,  1, - 1,     1,  1,  1,

    		// (0, ±1/φ, ±φ)
    		 0, - r, - t,     0, - r,  t,
    		 0,  r, - t,     0,  r,  t,

    		// (±1/φ, ±φ, 0)
    		- r, - t,  0,    - r,  t,  0,
    		 r, - t,  0,     r,  t,  0,

    		// (±φ, 0, ±1/φ)
    		- t,  0, - r,     t,  0, - r,
    		- t,  0,  r,     t,  0,  r
    	];

    	var indices = [
    		 3, 11,  7,      3,  7, 15,      3, 15, 13,
    		 7, 19, 17,      7, 17,  6,      7,  6, 15,
    		17,  4,  8,     17,  8, 10,     17, 10,  6,
    		 8,  0, 16,      8, 16,  2,      8,  2, 10,
    		 0, 12,  1,      0,  1, 18,      0, 18, 16,
    		 6, 10,  2,      6,  2, 13,      6, 13, 15,
    		 2, 16, 18,      2, 18,  3,      2,  3, 13,
    		18,  1,  9,     18,  9, 11,     18, 11,  3,
    		 4, 14, 12,      4, 12,  0,      4,  0,  8,
    		11,  9,  5,     11,  5, 19,     11, 19,  7,
    		19,  5, 14,     19, 14,  4,     19,  4, 17,
    		 1, 12, 14,      1, 14,  5,      1,  5,  9
    	];

    	PolyhedronGeometry.call( this, vertices, indices, radius, detail );

    	this.type = 'DodecahedronGeometry';

    	this.parameters = {
    		radius: radius,
    		detail: detail
    	};

    }

    DodecahedronGeometry.prototype = Object.create( PolyhedronGeometry.prototype );
    DodecahedronGeometry.prototype.constructor = DodecahedronGeometry;

    /**
     * @author WestLangley / https://github.com/WestLangley
     * @author zz85 / https://github.com/zz85
     * @author miningold / https://github.com/miningold
     * @author jonobr1 / https://github.com/jonobr1
     *
     * Modified from the TorusKnotGeometry by @oosmoxiecode
     *
     * Creates a tube which extrudes along a 3d spline
     *
     * Uses parallel transport frames as described in
     * http://www.cs.indiana.edu/pub/techreports/TR425.pdf
     */

    function TubeGeometry( path, segments, radius, radialSegments, closed, taper ) {

    	Geometry.call( this );

    	this.type = 'TubeGeometry';

    	this.parameters = {
    		path: path,
    		segments: segments,
    		radius: radius,
    		radialSegments: radialSegments,
    		closed: closed,
    		taper: taper
    	};

    	segments = segments || 64;
    	radius = radius || 1;
    	radialSegments = radialSegments || 8;
    	closed = closed || false;
    	taper = taper || TubeGeometry.NoTaper;

    	var grid = [];

    	var scope = this,

    		tangent,
    		normal,
    		binormal,

    		numpoints = segments + 1,

    		u, v, r,

    		cx, cy,
    		pos, pos2 = new Vector3(),
    		i, j,
    		ip, jp,
    		a, b, c, d,
    		uva, uvb, uvc, uvd;

    	var frames = new TubeGeometry.FrenetFrames( path, segments, closed ),
    		tangents = frames.tangents,
    		normals = frames.normals,
    		binormals = frames.binormals;

    	// proxy internals
    	this.tangents = tangents;
    	this.normals = normals;
    	this.binormals = binormals;

    	function vert( x, y, z ) {

    		return scope.vertices.push( new Vector3( x, y, z ) ) - 1;

    	}

    	// construct the grid

    	for ( i = 0; i < numpoints; i ++ ) {

    		grid[ i ] = [];

    		u = i / ( numpoints - 1 );

    		pos = path.getPointAt( u );

    		tangent = tangents[ i ];
    		normal = normals[ i ];
    		binormal = binormals[ i ];

    		r = radius * taper( u );

    		for ( j = 0; j < radialSegments; j ++ ) {

    			v = j / radialSegments * 2 * Math.PI;

    			cx = - r * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.
    			cy = r * Math.sin( v );

    			pos2.copy( pos );
    			pos2.x += cx * normal.x + cy * binormal.x;
    			pos2.y += cx * normal.y + cy * binormal.y;
    			pos2.z += cx * normal.z + cy * binormal.z;

    			grid[ i ][ j ] = vert( pos2.x, pos2.y, pos2.z );

    		}

    	}


    	// construct the mesh

    	for ( i = 0; i < segments; i ++ ) {

    		for ( j = 0; j < radialSegments; j ++ ) {

    			ip = ( closed ) ? ( i + 1 ) % segments : i + 1;
    			jp = ( j + 1 ) % radialSegments;

    			a = grid[ i ][ j ];		// *** NOT NECESSARILY PLANAR ! ***
    			b = grid[ ip ][ j ];
    			c = grid[ ip ][ jp ];
    			d = grid[ i ][ jp ];

    			uva = new Vector2( i / segments, j / radialSegments );
    			uvb = new Vector2( ( i + 1 ) / segments, j / radialSegments );
    			uvc = new Vector2( ( i + 1 ) / segments, ( j + 1 ) / radialSegments );
    			uvd = new Vector2( i / segments, ( j + 1 ) / radialSegments );

    			this.faces.push( new Face3( a, b, d ) );
    			this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

    			this.faces.push( new Face3( b, c, d ) );
    			this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

    		}

    	}

    	this.computeFaceNormals();
    	this.computeVertexNormals();

    }

    TubeGeometry.prototype = Object.create( Geometry.prototype );
    TubeGeometry.prototype.constructor = TubeGeometry;

    TubeGeometry.NoTaper = function ( u ) {

    	return 1;

    };

    TubeGeometry.SinusoidalTaper = function ( u ) {

    	return Math.sin( Math.PI * u );

    };

    // For computing of Frenet frames, exposing the tangents, normals and binormals the spline
    TubeGeometry.FrenetFrames = function ( path, segments, closed ) {

    	var	normal = new Vector3(),

    		tangents = [],
    		normals = [],
    		binormals = [],

    		vec = new Vector3(),
    		mat = new Matrix4(),

    		numpoints = segments + 1,
    		theta,
    		smallest,

    		tx, ty, tz,
    		i, u;


    	// expose internals
    	this.tangents = tangents;
    	this.normals = normals;
    	this.binormals = binormals;

    	// compute the tangent vectors for each segment on the path

    	for ( i = 0; i < numpoints; i ++ ) {

    		u = i / ( numpoints - 1 );

    		tangents[ i ] = path.getTangentAt( u );
    		tangents[ i ].normalize();

    	}

    	initialNormal3();

    	/*
    	function initialNormal1(lastBinormal) {
    		// fixed start binormal. Has dangers of 0 vectors
    		normals[ 0 ] = new THREE.Vector3();
    		binormals[ 0 ] = new THREE.Vector3();
    		if (lastBinormal===undefined) lastBinormal = new THREE.Vector3( 0, 0, 1 );
    		normals[ 0 ].crossVectors( lastBinormal, tangents[ 0 ] ).normalize();
    		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();
    	}

    	function initialNormal2() {

    		// This uses the Frenet-Serret formula for deriving binormal
    		var t2 = path.getTangentAt( epsilon );

    		normals[ 0 ] = new THREE.Vector3().subVectors( t2, tangents[ 0 ] ).normalize();
    		binormals[ 0 ] = new THREE.Vector3().crossVectors( tangents[ 0 ], normals[ 0 ] );

    		normals[ 0 ].crossVectors( binormals[ 0 ], tangents[ 0 ] ).normalize(); // last binormal x tangent
    		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();

    	}
    	*/

    	function initialNormal3() {

    		// select an initial normal vector perpendicular to the first tangent vector,
    		// and in the direction of the smallest tangent xyz component

    		normals[ 0 ] = new Vector3();
    		binormals[ 0 ] = new Vector3();
    		smallest = Number.MAX_VALUE;
    		tx = Math.abs( tangents[ 0 ].x );
    		ty = Math.abs( tangents[ 0 ].y );
    		tz = Math.abs( tangents[ 0 ].z );

    		if ( tx <= smallest ) {

    			smallest = tx;
    			normal.set( 1, 0, 0 );

    		}

    		if ( ty <= smallest ) {

    			smallest = ty;
    			normal.set( 0, 1, 0 );

    		}

    		if ( tz <= smallest ) {

    			normal.set( 0, 0, 1 );

    		}

    		vec.crossVectors( tangents[ 0 ], normal ).normalize();

    		normals[ 0 ].crossVectors( tangents[ 0 ], vec );
    		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );

    	}


    	// compute the slowly-varying normal and binormal vectors for each segment on the path

    	for ( i = 1; i < numpoints; i ++ ) {

    		normals[ i ] = normals[ i - 1 ].clone();

    		binormals[ i ] = binormals[ i - 1 ].clone();

    		vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );

    		if ( vec.length() > Number.EPSILON ) {

    			vec.normalize();

    			theta = Math.acos( exports.Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors

    			normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

    		}

    		binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

    	}


    	// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

    	if ( closed ) {

    		theta = Math.acos( exports.Math.clamp( normals[ 0 ].dot( normals[ numpoints - 1 ] ), - 1, 1 ) );
    		theta /= ( numpoints - 1 );

    		if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ numpoints - 1 ] ) ) > 0 ) {

    			theta = - theta;

    		}

    		for ( i = 1; i < numpoints; i ++ ) {

    			// twist a little...
    			normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
    			binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

    		}

    	}

    };

    /**
     * @author Mugen87 / https://github.com/Mugen87
     *
     * see: http://www.blackpawn.com/texts/pqtorus/
     */
    function TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) {

    	BufferGeometry.call( this );

    	this.type = 'TorusKnotBufferGeometry';

    	this.parameters = {
    		radius: radius,
    		tube: tube,
    		tubularSegments: tubularSegments,
    		radialSegments: radialSegments,
    		p: p,
    		q: q
    	};

    	radius = radius || 100;
    	tube = tube || 40;
    	tubularSegments = Math.floor( tubularSegments ) || 64;
    	radialSegments = Math.floor( radialSegments ) || 8;
    	p = p || 2;
    	q = q || 3;

    	// used to calculate buffer length
    	var vertexCount = ( ( radialSegments + 1 ) * ( tubularSegments + 1 ) );
    	var indexCount = radialSegments * tubularSegments * 2 * 3;

    	// buffers
    	var indices = new BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );
    	var vertices = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
    	var normals = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
    	var uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );

    	// helper variables
    	var i, j, index = 0, indexOffset = 0;

    	var vertex = new Vector3();
    	var normal = new Vector3();
    	var uv = new Vector2();

    	var P1 = new Vector3();
    	var P2 = new Vector3();

    	var B = new Vector3();
    	var T = new Vector3();
    	var N = new Vector3();

    	// generate vertices, normals and uvs

    	for ( i = 0; i <= tubularSegments; ++ i ) {

    		// the radian "u" is used to calculate the position on the torus curve of the current tubular segement

    		var u = i / tubularSegments * p * Math.PI * 2;

    		// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
    		// these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions

    		calculatePositionOnCurve( u, p, q, radius, P1 );
    		calculatePositionOnCurve( u + 0.01, p, q, radius, P2 );

    		// calculate orthonormal basis

    		T.subVectors( P2, P1 );
    		N.addVectors( P2, P1 );
    		B.crossVectors( T, N );
    		N.crossVectors( B, T );

    		// normalize B, N. T can be ignored, we don't use it

    		B.normalize();
    		N.normalize();

    		for ( j = 0; j <= radialSegments; ++ j ) {

    			// now calculate the vertices. they are nothing more than an extrusion of the torus curve.
    			// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.

    			var v = j / radialSegments * Math.PI * 2;
    			var cx = - tube * Math.cos( v );
    			var cy = tube * Math.sin( v );

    			// now calculate the final vertex position.
    			// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve

    			vertex.x = P1.x + ( cx * N.x + cy * B.x );
    			vertex.y = P1.y + ( cx * N.y + cy * B.y );
    			vertex.z = P1.z + ( cx * N.z + cy * B.z );

    			// vertex
    			vertices.setXYZ( index, vertex.x, vertex.y, vertex.z );

    			// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)
    			normal.subVectors( vertex, P1 ).normalize();
    			normals.setXYZ( index, normal.x, normal.y, normal.z );

    			// uv
    			uv.x = i / tubularSegments;
    			uv.y = j / radialSegments;
    			uvs.setXY( index, uv.x, uv.y );

    			// increase index
    			index ++;

    		}

    	}

    	// generate indices

    	for ( j = 1; j <= tubularSegments; j ++ ) {

    		for ( i = 1; i <= radialSegments; i ++ ) {

    			// indices
    			var a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
    			var b = ( radialSegments + 1 ) * j + ( i - 1 );
    			var c = ( radialSegments + 1 ) * j + i;
    			var d = ( radialSegments + 1 ) * ( j - 1 ) + i;

    			// face one
    			indices.setX( indexOffset, a ); indexOffset++;
    			indices.setX( indexOffset, b ); indexOffset++;
    			indices.setX( indexOffset, d ); indexOffset++;

    			// face two
    			indices.setX( indexOffset, b ); indexOffset++;
    			indices.setX( indexOffset, c ); indexOffset++;
    			indices.setX( indexOffset, d ); indexOffset++;

    		}

    	}

    	// build geometry

    	this.setIndex( indices );
    	this.addAttribute( 'position', vertices );
    	this.addAttribute( 'normal', normals );
    	this.addAttribute( 'uv', uvs );

    	// this function calculates the current position on the torus curve

    	function calculatePositionOnCurve( u, p, q, radius, position ) {

    		var cu = Math.cos( u );
    		var su = Math.sin( u );
    		var quOverP = q / p * u;
    		var cs = Math.cos( quOverP );

    		position.x = radius * ( 2 + cs ) * 0.5 * cu;
    		position.y = radius * ( 2 + cs ) * su * 0.5;
    		position.z = radius * Math.sin( quOverP ) * 0.5;

    	}

    }

    TorusKnotBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
    TorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;

    /**
     * @author oosmoxiecode
     */

    function TorusKnotGeometry( radius, tube, tubularSegments, radialSegments, p, q, heightScale ) {

    	Geometry.call( this );

    	this.type = 'TorusKnotGeometry';

    	this.parameters = {
    		radius: radius,
    		tube: tube,
    		tubularSegments: tubularSegments,
    		radialSegments: radialSegments,
    		p: p,
    		q: q
    	};

    	if( heightScale !== undefined ) console.warn( 'THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.' );

    	this.fromBufferGeometry( new TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) );
    	this.mergeVertices();

    }

    TorusKnotGeometry.prototype = Object.create( Geometry.prototype );
    TorusKnotGeometry.prototype.constructor = TorusKnotGeometry;

    /**
     * @author Mugen87 / https://github.com/Mugen87
     */

    function TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) {

    	BufferGeometry.call( this );

    	this.type = 'TorusBufferGeometry';

    	this.parameters = {
    		radius: radius,
    		tube: tube,
    		radialSegments: radialSegments,
    		tubularSegments: tubularSegments,
    		arc: arc
    	};

    	radius = radius || 100;
    	tube = tube || 40;
    	radialSegments = Math.floor( radialSegments ) || 8;
    	tubularSegments = Math.floor( tubularSegments ) || 6;
    	arc = arc || Math.PI * 2;

    	// used to calculate buffer length
    	var vertexCount = ( ( radialSegments + 1 ) * ( tubularSegments + 1 ) );
    	var indexCount = radialSegments * tubularSegments * 2 * 3;

    	// buffers
    	var indices = new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount );
    	var vertices = new Float32Array( vertexCount * 3 );
    	var normals = new Float32Array( vertexCount * 3 );
    	var uvs = new Float32Array( vertexCount * 2 );

    	// offset variables
    	var vertexBufferOffset = 0;
    	var uvBufferOffset = 0;
    	var indexBufferOffset = 0;

    	// helper variables
    	var center = new Vector3();
    	var vertex = new Vector3();
    	var normal = new Vector3();

    	var j, i;

    	// generate vertices, normals and uvs

    	for ( j = 0; j <= radialSegments; j ++ ) {

    		for ( i = 0; i <= tubularSegments; i ++ ) {

    			var u = i / tubularSegments * arc;
    			var v = j / radialSegments * Math.PI * 2;

    			// vertex
    			vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
    			vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
    			vertex.z = tube * Math.sin( v );

    			vertices[ vertexBufferOffset ] = vertex.x;
    			vertices[ vertexBufferOffset + 1 ] = vertex.y;
    			vertices[ vertexBufferOffset + 2 ] = vertex.z;

    			// this vector is used to calculate the normal
    			center.x = radius * Math.cos( u );
    			center.y = radius * Math.sin( u );

    			// normal
    			normal.subVectors( vertex, center ).normalize();

    			normals[ vertexBufferOffset ] = normal.x;
    			normals[ vertexBufferOffset + 1 ] = normal.y;
    			normals[ vertexBufferOffset + 2 ] = normal.z;

    			// uv
    			uvs[ uvBufferOffset ] = i / tubularSegments;
    			uvs[ uvBufferOffset + 1 ] = j / radialSegments;

    			// update offsets
    			vertexBufferOffset += 3;
    			uvBufferOffset += 2;

    		}

    	}

    	// generate indices

    	for ( j = 1; j <= radialSegments; j ++ ) {

    		for ( i = 1; i <= tubularSegments; i ++ ) {

    			// indices
    			var a = ( tubularSegments + 1 ) * j + i - 1;
    			var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
    			var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
    			var d = ( tubularSegments + 1 ) * j + i;

    			// face one
    			indices[ indexBufferOffset ] = a;
    			indices[ indexBufferOffset + 1 ] = b;
    			indices[ indexBufferOffset + 2 ] = d;

    			// face two
    			indices[ indexBufferOffset + 3 ] = b;
    			indices[ indexBufferOffset + 4 ] = c;
    			indices[ indexBufferOffset + 5 ] = d;

    			// update offset
    			indexBufferOffset += 6;

    		}

    	}

    	// build geometry
    	this.setIndex( new BufferAttribute( indices, 1 ) );
    	this.addAttribute( 'position', new BufferAttribute( vertices, 3 ) );
    	this.addAttribute( 'normal', new BufferAttribute( normals, 3 ) );
    	this.addAttribute( 'uv', new BufferAttribute( uvs, 2 ) );

    }

    TorusBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
    TorusBufferGeometry.prototype.constructor = TorusBufferGeometry;

    /**
     * @author oosmoxiecode
     * @author mrdoob / http://mrdoob.com/
     * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888
     */

    function TorusGeometry( radius, tube, radialSegments, tubularSegments, arc ) {

    	Geometry.call( this );

    	this.type = 'TorusGeometry';

    	this.parameters = {
    		radius: radius,
    		tube: tube,
    		radialSegments: radialSegments,
    		tubularSegments: tubularSegments,
    		arc: arc
    	};

    	this.fromBufferGeometry( new TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) );

    }

    TorusGeometry.prototype = Object.create( Geometry.prototype );
    TorusGeometry.prototype.constructor = TorusGeometry;

    /**
     * @author zz85 / http://www.lab4games.net/zz85/blog
     */

    exports.ShapeUtils = {

    	// calculate area of the contour polygon

    	area: function ( contour ) {

    		var n = contour.length;
    		var a = 0.0;

    		for ( var p = n - 1, q = 0; q < n; p = q ++ ) {

    			a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

    		}

    		return a * 0.5;

    	},

    	triangulate: ( function () {

    		/**
    		 * This code is a quick port of code written in C++ which was submitted to
    		 * flipcode.com by John W. Ratcliff  // July 22, 2000
    		 * See original code and more information here:
    		 * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
    		 *
    		 * ported to actionscript by Zevan Rosser
    		 * www.actionsnippet.com
    		 *
    		 * ported to javascript by Joshua Koo
    		 * http://www.lab4games.net/zz85/blog
    		 *
    		 */

    		function snip( contour, u, v, w, n, verts ) {

    			var p;
    			var ax, ay, bx, by;
    			var cx, cy, px, py;

    			ax = contour[ verts[ u ] ].x;
    			ay = contour[ verts[ u ] ].y;

    			bx = contour[ verts[ v ] ].x;
    			by = contour[ verts[ v ] ].y;

    			cx = contour[ verts[ w ] ].x;
    			cy = contour[ verts[ w ] ].y;

    			if ( Number.EPSILON > ( ( ( bx - ax ) * ( cy - ay ) ) - ( ( by - ay ) * ( cx - ax ) ) ) ) return false;

    			var aX, aY, bX, bY, cX, cY;
    			var apx, apy, bpx, bpy, cpx, cpy;
    			var cCROSSap, bCROSScp, aCROSSbp;

    			aX = cx - bx;  aY = cy - by;
    			bX = ax - cx;  bY = ay - cy;
    			cX = bx - ax;  cY = by - ay;

    			for ( p = 0; p < n; p ++ ) {

    				px = contour[ verts[ p ] ].x;
    				py = contour[ verts[ p ] ].y;

    				if ( ( ( px === ax ) && ( py === ay ) ) ||
    					 ( ( px === bx ) && ( py === by ) ) ||
    					 ( ( px === cx ) && ( py === cy ) ) )	continue;

    				apx = px - ax;  apy = py - ay;
    				bpx = px - bx;  bpy = py - by;
    				cpx = px - cx;  cpy = py - cy;

    				// see if p is inside triangle abc

    				aCROSSbp = aX * bpy - aY * bpx;
    				cCROSSap = cX * apy - cY * apx;
    				bCROSScp = bX * cpy - bY * cpx;

    				if ( ( aCROSSbp >= - Number.EPSILON ) && ( bCROSScp >= - Number.EPSILON ) && ( cCROSSap >= - Number.EPSILON ) ) return false;

    			}

    			return true;

    		}

    		// takes in an contour array and returns

    		return function triangulate( contour, indices ) {

    			var n = contour.length;

    			if ( n < 3 ) return null;

    			var result = [],
    				verts = [],
    				vertIndices = [];

    			/* we want a counter-clockwise polygon in verts */

    			var u, v, w;

    			if ( exports.ShapeUtils.area( contour ) > 0.0 ) {

    				for ( v = 0; v < n; v ++ ) verts[ v ] = v;

    			} else {

    				for ( v = 0; v < n; v ++ ) verts[ v ] = ( n - 1 ) - v;

    			}

    			var nv = n;

    			/*  remove nv - 2 vertices, creating 1 triangle every time */

    			var count = 2 * nv;   /* error detection */

    			for ( v = nv - 1; nv > 2; ) {

    				/* if we loop, it is probably a non-simple polygon */

    				if ( ( count -- ) <= 0 ) {

    					//** Triangulate: ERROR - probable bad polygon!

    					//throw ( "Warning, unable to triangulate polygon!" );
    					//return null;
    					// Sometimes warning is fine, especially polygons are triangulated in reverse.
    					console.warn( 'THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()' );

    					if ( indices ) return vertIndices;
    					return result;

    				}

    				/* three consecutive vertices in current polygon, <u,v,w> */

    				u = v; 	 	if ( nv <= u ) u = 0;     /* previous */
    				v = u + 1;  if ( nv <= v ) v = 0;     /* new v    */
    				w = v + 1;  if ( nv <= w ) w = 0;     /* next     */

    				if ( snip( contour, u, v, w, nv, verts ) ) {

    					var a, b, c, s, t;

    					/* true names of the vertices */

    					a = verts[ u ];
    					b = verts[ v ];
    					c = verts[ w ];

    					/* output Triangle */

    					result.push( [ contour[ a ],
    						contour[ b ],
    						contour[ c ] ] );


    					vertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );

    					/* remove v from the remaining polygon */

    					for ( s = v, t = v + 1; t < nv; s ++, t ++ ) {

    						verts[ s ] = verts[ t ];

    					}

    					nv --;

    					/* reset error detection counter */

    					count = 2 * nv;

    				}

    			}

    			if ( indices ) return vertIndices;
    			return result;

    		}

    	} )(),

    	triangulateShape: function ( contour, holes ) {

    		function removeDupEndPts(points) {

    			var l = points.length;

    			if ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {

    				points.pop();

    			}

    		}

    		removeDupEndPts( contour );
    		holes.forEach( removeDupEndPts );

    		function point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {

    			// inOtherPt needs to be collinear to the inSegment
    			if ( inSegPt1.x !== inSegPt2.x ) {

    				if ( inSegPt1.x < inSegPt2.x ) {

    					return	( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );

    				} else {

    					return	( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );

    				}

    			} else {

    				if ( inSegPt1.y < inSegPt2.y ) {

    					return	( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );

    				} else {

    					return	( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );

    				}

    			}

    		}

    		function intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {

    			var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,   seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;
    			var seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,   seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;

    			var seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;
    			var seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;

    			var limit		= seg1dy * seg2dx - seg1dx * seg2dy;
    			var perpSeg1	= seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;

    			if ( Math.abs( limit ) > Number.EPSILON ) {

    				// not parallel

    				var perpSeg2;
    				if ( limit > 0 ) {

    					if ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) ) 		return [];
    					perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
    					if ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) ) 		return [];

    				} else {

    					if ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) ) 		return [];
    					perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
    					if ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) ) 		return [];

    				}

    				// i.e. to reduce rounding errors
    				// intersection at endpoint of segment#1?
    				if ( perpSeg2 === 0 ) {

    					if ( ( inExcludeAdjacentSegs ) &&
    						 ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )		return [];
    					return [ inSeg1Pt1 ];

    				}
    				if ( perpSeg2 === limit ) {

    					if ( ( inExcludeAdjacentSegs ) &&
    						 ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )		return [];
    					return [ inSeg1Pt2 ];

    				}
    				// intersection at endpoint of segment#2?
    				if ( perpSeg1 === 0 )		return [ inSeg2Pt1 ];
    				if ( perpSeg1 === limit )	return [ inSeg2Pt2 ];

    				// return real intersection point
    				var factorSeg1 = perpSeg2 / limit;
    				return	[ { x: inSeg1Pt1.x + factorSeg1 * seg1dx,
    							y: inSeg1Pt1.y + factorSeg1 * seg1dy } ];

    			} else {

    				// parallel or collinear
    				if ( ( perpSeg1 !== 0 ) ||
    					 ( seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy ) ) 			return [];

    				// they are collinear or degenerate
    				var seg1Pt = ( ( seg1dx === 0 ) && ( seg1dy === 0 ) );	// segment1 is just a point?
    				var seg2Pt = ( ( seg2dx === 0 ) && ( seg2dy === 0 ) );	// segment2 is just a point?
    				// both segments are points
    				if ( seg1Pt && seg2Pt ) {

    					if ( ( inSeg1Pt1.x !== inSeg2Pt1.x ) ||
    						 ( inSeg1Pt1.y !== inSeg2Pt1.y ) )		return [];	// they are distinct  points
    					return [ inSeg1Pt1 ];                 						// they are the same point

    				}
    				// segment#1  is a single point
    				if ( seg1Pt ) {

    					if ( ! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )		return [];		// but not in segment#2
    					return [ inSeg1Pt1 ];

    				}
    				// segment#2  is a single point
    				if ( seg2Pt ) {

    					if ( ! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )		return [];		// but not in segment#1
    					return [ inSeg2Pt1 ];

    				}

    				// they are collinear segments, which might overlap
    				var seg1min, seg1max, seg1minVal, seg1maxVal;
    				var seg2min, seg2max, seg2minVal, seg2maxVal;
    				if ( seg1dx !== 0 ) {

    					// the segments are NOT on a vertical line
    					if ( inSeg1Pt1.x < inSeg1Pt2.x ) {

    						seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;
    						seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;

    					} else {

    						seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;
    						seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;

    					}
    					if ( inSeg2Pt1.x < inSeg2Pt2.x ) {

    						seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;
    						seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;

    					} else {

    						seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;
    						seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;

    					}

    				} else {

    					// the segments are on a vertical line
    					if ( inSeg1Pt1.y < inSeg1Pt2.y ) {

    						seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;
    						seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;

    					} else {

    						seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;
    						seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;

    					}
    					if ( inSeg2Pt1.y < inSeg2Pt2.y ) {

    						seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;
    						seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;

    					} else {

    						seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;
    						seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;

    					}

    				}
    				if ( seg1minVal <= seg2minVal ) {

    					if ( seg1maxVal <  seg2minVal )	return [];
    					if ( seg1maxVal === seg2minVal )	{

    						if ( inExcludeAdjacentSegs )		return [];
    						return [ seg2min ];

    					}
    					if ( seg1maxVal <= seg2maxVal )	return [ seg2min, seg1max ];
    					return	[ seg2min, seg2max ];

    				} else {

    					if ( seg1minVal >  seg2maxVal )	return [];
    					if ( seg1minVal === seg2maxVal )	{

    						if ( inExcludeAdjacentSegs )		return [];
    						return [ seg1min ];

    					}
    					if ( seg1maxVal <= seg2maxVal )	return [ seg1min, seg1max ];
    					return	[ seg1min, seg2max ];

    				}

    			}

    		}

    		function isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {

    			// The order of legs is important

    			// translation of all points, so that Vertex is at (0,0)
    			var legFromPtX	= inLegFromPt.x - inVertex.x,  legFromPtY	= inLegFromPt.y - inVertex.y;
    			var legToPtX	= inLegToPt.x	- inVertex.x,  legToPtY		= inLegToPt.y	- inVertex.y;
    			var otherPtX	= inOtherPt.x	- inVertex.x,  otherPtY		= inOtherPt.y	- inVertex.y;

    			// main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.
    			var from2toAngle	= legFromPtX * legToPtY - legFromPtY * legToPtX;
    			var from2otherAngle	= legFromPtX * otherPtY - legFromPtY * otherPtX;

    			if ( Math.abs( from2toAngle ) > Number.EPSILON ) {

    				// angle != 180 deg.

    				var other2toAngle		= otherPtX * legToPtY - otherPtY * legToPtX;
    				// console.log( "from2to: " + from2toAngle + ", from2other: " + from2otherAngle + ", other2to: " + other2toAngle );

    				if ( from2toAngle > 0 ) {

    					// main angle < 180 deg.
    					return	( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );

    				} else {

    					// main angle > 180 deg.
    					return	( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );

    				}

    			} else {

    				// angle == 180 deg.
    				// console.log( "from2to: 180 deg., from2other: " + from2otherAngle  );
    				return	( from2otherAngle > 0 );

    			}

    		}


    		function removeHoles( contour, holes ) {

    			var shape = contour.concat(); // work on this shape
    			var hole;

    			function isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {

    				// Check if hole point lies within angle around shape point
    				var lastShapeIdx = shape.length - 1;

    				var prevShapeIdx = inShapeIdx - 1;
    				if ( prevShapeIdx < 0 )			prevShapeIdx = lastShapeIdx;

    				var nextShapeIdx = inShapeIdx + 1;
    				if ( nextShapeIdx > lastShapeIdx )	nextShapeIdx = 0;

    				var insideAngle = isPointInsideAngle( shape[ inShapeIdx ], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[ inHoleIdx ] );
    				if ( ! insideAngle ) {

    					// console.log( "Vertex (Shape): " + inShapeIdx + ", Point: " + hole[inHoleIdx].x + "/" + hole[inHoleIdx].y );
    					return	false;

    				}

    				// Check if shape point lies within angle around hole point
    				var lastHoleIdx = hole.length - 1;

    				var prevHoleIdx = inHoleIdx - 1;
    				if ( prevHoleIdx < 0 )			prevHoleIdx = lastHoleIdx;

    				var nextHoleIdx = inHoleIdx + 1;
    				if ( nextHoleIdx > lastHoleIdx )	nextHoleIdx = 0;

    				insideAngle = isPointInsideAngle( hole[ inHoleIdx ], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[ inShapeIdx ] );
    				if ( ! insideAngle ) {

    					// console.log( "Vertex (Hole): " + inHoleIdx + ", Point: " + shape[inShapeIdx].x + "/" + shape[inShapeIdx].y );
    					return	false;

    				}

    				return	true;

    			}

    			function intersectsShapeEdge( inShapePt, inHolePt ) {

    				// checks for intersections with shape edges
    				var sIdx, nextIdx, intersection;
    				for ( sIdx = 0; sIdx < shape.length; sIdx ++ ) {

    					nextIdx = sIdx + 1; nextIdx %= shape.length;
    					intersection = intersect_segments_2D( inShapePt, inHolePt, shape[ sIdx ], shape[ nextIdx ], true );
    					if ( intersection.length > 0 )		return	true;

    				}

    				return	false;

    			}

    			var indepHoles = [];

    			function intersectsHoleEdge( inShapePt, inHolePt ) {

    				// checks for intersections with hole edges
    				var ihIdx, chkHole,
    					hIdx, nextIdx, intersection;
    				for ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx ++ ) {

    					chkHole = holes[ indepHoles[ ihIdx ]];
    					for ( hIdx = 0; hIdx < chkHole.length; hIdx ++ ) {

    						nextIdx = hIdx + 1; nextIdx %= chkHole.length;
    						intersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[ hIdx ], chkHole[ nextIdx ], true );
    						if ( intersection.length > 0 )		return	true;

    					}

    				}
    				return	false;

    			}

    			var holeIndex, shapeIndex,
    				shapePt, holePt,
    				holeIdx, cutKey, failedCuts = [],
    				tmpShape1, tmpShape2,
    				tmpHole1, tmpHole2;

    			for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

    				indepHoles.push( h );

    			}

    			var minShapeIndex = 0;
    			var counter = indepHoles.length * 2;
    			while ( indepHoles.length > 0 ) {

    				counter --;
    				if ( counter < 0 ) {

    					console.log( "Infinite Loop! Holes left:" + indepHoles.length + ", Probably Hole outside Shape!" );
    					break;

    				}

    				// search for shape-vertex and hole-vertex,
    				// which can be connected without intersections
    				for ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex ++ ) {

    					shapePt = shape[ shapeIndex ];
    					holeIndex	= - 1;

    					// search for hole which can be reached without intersections
    					for ( var h = 0; h < indepHoles.length; h ++ ) {

    						holeIdx = indepHoles[ h ];

    						// prevent multiple checks
    						cutKey = shapePt.x + ":" + shapePt.y + ":" + holeIdx;
    						if ( failedCuts[ cutKey ] !== undefined )			continue;

    						hole = holes[ holeIdx ];
    						for ( var h2 = 0; h2 < hole.length; h2 ++ ) {

    							holePt = hole[ h2 ];
    							if ( ! isCutLineInsideAngles( shapeIndex, h2 ) )		continue;
    							if ( intersectsShapeEdge( shapePt, holePt ) )		continue;
    							if ( intersectsHoleEdge( shapePt, holePt ) )		continue;

    							holeIndex = h2;
    							indepHoles.splice( h, 1 );

    							tmpShape1 = shape.slice( 0, shapeIndex + 1 );
    							tmpShape2 = shape.slice( shapeIndex );
    							tmpHole1 = hole.slice( holeIndex );
    							tmpHole2 = hole.slice( 0, holeIndex + 1 );

    							shape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );

    							minShapeIndex = shapeIndex;

    							// Debug only, to show the selected cuts
    							// glob_CutLines.push( [ shapePt, holePt ] );

    							break;

    						}
    						if ( holeIndex >= 0 )	break;		// hole-vertex found

    						failedCuts[ cutKey ] = true;			// remember failure

    					}
    					if ( holeIndex >= 0 )	break;		// hole-vertex found

    				}

    			}

    			return shape; 			/* shape with no holes */

    		}


    		var i, il, f, face,
    			key, index,
    			allPointsMap = {};

    		// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.

    		var allpoints = contour.concat();

    		for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

    			Array.prototype.push.apply( allpoints, holes[ h ] );

    		}

    		//console.log( "allpoints",allpoints, allpoints.length );

    		// prepare all points map

    		for ( i = 0, il = allpoints.length; i < il; i ++ ) {

    			key = allpoints[ i ].x + ":" + allpoints[ i ].y;

    			if ( allPointsMap[ key ] !== undefined ) {

    				console.warn( "THREE.ShapeUtils: Duplicate point", key, i );

    			}

    			allPointsMap[ key ] = i;

    		}

    		// remove holes by cutting paths to holes and adding them to the shape
    		var shapeWithoutHoles = removeHoles( contour, holes );

    		var triangles = exports.ShapeUtils.triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape
    		//console.log( "triangles",triangles, triangles.length );

    		// check all face vertices against all points map

    		for ( i = 0, il = triangles.length; i < il; i ++ ) {

    			face = triangles[ i ];

    			for ( f = 0; f < 3; f ++ ) {

    				key = face[ f ].x + ":" + face[ f ].y;

    				index = allPointsMap[ key ];

    				if ( index !== undefined ) {

    					face[ f ] = index;

    				}

    			}

    		}

    		return triangles.concat();

    	},

    	isClockWise: function ( pts ) {

    		return exports.ShapeUtils.area( pts ) < 0;

    	},

    	// Bezier Curves formulas obtained from
    	// http://en.wikipedia.org/wiki/B%C3%A9zier_curve

    	// Quad Bezier Functions

    	b2: ( function () {

    		function b2p0( t, p ) {

    			var k = 1 - t;
    			return k * k * p;

    		}

    		function b2p1( t, p ) {

    			return 2 * ( 1 - t ) * t * p;

    		}

    		function b2p2( t, p ) {

    			return t * t * p;

    		}

    		return function b2( t, p0, p1, p2 ) {

    			return b2p0( t, p0 ) + b2p1( t, p1 ) + b2p2( t, p2 );

    		};

    	} )(),

    	// Cubic Bezier Functions

    	b3: ( function () {

    		function b3p0( t, p ) {

    			var k = 1 - t;
    			return k * k * k * p;

    		}

    		function b3p1( t, p ) {

    			var k = 1 - t;
    			return 3 * k * k * t * p;

    		}

    		function b3p2( t, p ) {

    			var k = 1 - t;
    			return 3 * k * t * t * p;

    		}

    		function b3p3( t, p ) {

    			return t * t * t * p;

    		}

    		return function b3( t, p0, p1, p2, p3 ) {

    			return b3p0( t, p0 ) + b3p1( t, p1 ) + b3p2( t, p2 ) + b3p3( t, p3 );

    		};

    	} )()

    };

    /**
     * @author zz85 / http://www.lab4games.net/zz85/blog
     *
     * Creates extruded geometry from a path shape.
     *
     * parameters = {
     *
     *  curveSegments: <int>, // number of points on the curves
     *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
     *  amount: <int>, // Depth to extrude the shape
     *
     *  bevelEnabled: <bool>, // turn on bevel
     *  bevelThickness: <float>, // how deep into the original shape bevel goes
     *  bevelSize: <float>, // how far from shape outline is bevel
     *  bevelSegments: <int>, // number of bevel layers
     *
     *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)
     *  frames: <THREE.TubeGeometry.FrenetFrames> // containing arrays of tangents, normals, binormals
     *
     *  uvGenerator: <Object> // object that provides UV generator functions
     *
     * }
     **/

    function ExtrudeGeometry( shapes, options ) {

    	if ( typeof( shapes ) === "undefined" ) {

    		shapes = [];
    		return;

    	}

    	Geometry.call( this );

    	this.type = 'ExtrudeGeometry';

    	shapes = Array.isArray( shapes ) ? shapes : [ shapes ];

    	this.addShapeList( shapes, options );

    	this.computeFaceNormals();

    	// can't really use automatic vertex normals
    	// as then front and back sides get smoothed too
    	// should do separate smoothing just for sides

    	//this.computeVertexNormals();

    	//console.log( "took", ( Date.now() - startTime ) );

    }

    ExtrudeGeometry.prototype = Object.create( Geometry.prototype );
    ExtrudeGeometry.prototype.constructor = ExtrudeGeometry;

    ExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {

    	var sl = shapes.length;

    	for ( var s = 0; s < sl; s ++ ) {

    		var shape = shapes[ s ];
    		this.addShape( shape, options );

    	}

    };

    ExtrudeGeometry.prototype.addShape = function ( shape, options ) {

    	var amount = options.amount !== undefined ? options.amount : 100;

    	var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10
    	var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8
    	var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

    	var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false

    	var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

    	var steps = options.steps !== undefined ? options.steps : 1;

    	var extrudePath = options.extrudePath;
    	var extrudePts, extrudeByPath = false;

    	// Use default WorldUVGenerator if no UV generators are specified.
    	var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : ExtrudeGeometry.WorldUVGenerator;

    	var splineTube, binormal, normal, position2;
    	if ( extrudePath ) {

    		extrudePts = extrudePath.getSpacedPoints( steps );

    		extrudeByPath = true;
    		bevelEnabled = false; // bevels not supported for path extrusion

    		// SETUP TNB variables

    		// Reuse TNB from TubeGeomtry for now.
    		// TODO1 - have a .isClosed in spline?

    		splineTube = options.frames !== undefined ? options.frames : new TubeGeometry.FrenetFrames( extrudePath, steps, false );

    		// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

    		binormal = new Vector3();
    		normal = new Vector3();
    		position2 = new Vector3();

    	}

    	// Safeguards if bevels are not enabled

    	if ( ! bevelEnabled ) {

    		bevelSegments = 0;
    		bevelThickness = 0;
    		bevelSize = 0;

    	}

    	// Variables initialization

    	var ahole, h, hl; // looping of holes
    	var scope = this;

    	var shapesOffset = this.vertices.length;

    	var shapePoints = shape.extractPoints( curveSegments );

    	var vertices = shapePoints.shape;
    	var holes = shapePoints.holes;

    	var reverse = ! exports.ShapeUtils.isClockWise( vertices );

    	if ( reverse ) {

    		vertices = vertices.reverse();

    		// Maybe we should also check if holes are in the opposite direction, just to be safe ...

    		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

    			ahole = holes[ h ];

    			if ( exports.ShapeUtils.isClockWise( ahole ) ) {

    				holes[ h ] = ahole.reverse();

    			}

    		}

    		reverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!

    	}


    	var faces = exports.ShapeUtils.triangulateShape( vertices, holes );

    	/* Vertices */

    	var contour = vertices; // vertices has all points but contour has only points of circumference

    	for ( h = 0, hl = holes.length; h < hl; h ++ ) {

    		ahole = holes[ h ];

    		vertices = vertices.concat( ahole );

    	}


    	function scalePt2( pt, vec, size ) {

    		if ( ! vec ) console.error( "THREE.ExtrudeGeometry: vec does not exist" );

    		return vec.clone().multiplyScalar( size ).add( pt );

    	}

    	var b, bs, t, z,
    		vert, vlen = vertices.length,
    		face, flen = faces.length;


    	// Find directions for point movement


    	function getBevelVec( inPt, inPrev, inNext ) {

    		// computes for inPt the corresponding point inPt' on a new contour
    		//   shifted by 1 unit (length of normalized vector) to the left
    		// if we walk along contour clockwise, this new contour is outside the old one
    		//
    		// inPt' is the intersection of the two lines parallel to the two
    		//  adjacent edges of inPt at a distance of 1 unit on the left side.

    		var v_trans_x, v_trans_y, shrink_by = 1;		// resulting translation vector for inPt

    		// good reading for geometry algorithms (here: line-line intersection)
    		// http://geomalgorithms.com/a05-_intersect-1.html

    		var v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
    		var v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;

    		var v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );

    		// check for collinear edges
    		var collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );

    		if ( Math.abs( collinear0 ) > Number.EPSILON ) {

    			// not collinear

    			// length of vectors for normalizing

    			var v_prev_len = Math.sqrt( v_prev_lensq );
    			var v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );

    			// shift adjacent points by unit vectors to the left

    			var ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
    			var ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );

    			var ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
    			var ptNextShift_y = ( inNext.y + v_next_x / v_next_len );

    			// scaling factor for v_prev to intersection point

    			var sf = (  ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
    						( ptNextShift_y - ptPrevShift_y ) * v_next_x    ) /
    					  ( v_prev_x * v_next_y - v_prev_y * v_next_x );

    			// vector from inPt to intersection point

    			v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
    			v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );

    			// Don't normalize!, otherwise sharp corners become ugly
    			//  but prevent crazy spikes
    			var v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );
    			if ( v_trans_lensq <= 2 ) {

    				return	new Vector2( v_trans_x, v_trans_y );

    			} else {

    				shrink_by = Math.sqrt( v_trans_lensq / 2 );

    			}

    		} else {

    			// handle special case of collinear edges

    			var direction_eq = false;		// assumes: opposite
    			if ( v_prev_x > Number.EPSILON ) {

    				if ( v_next_x > Number.EPSILON ) {

    					direction_eq = true;

    				}

    			} else {

    				if ( v_prev_x < - Number.EPSILON ) {

    					if ( v_next_x < - Number.EPSILON ) {

    						direction_eq = true;

    					}

    				} else {

    					if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {

    						direction_eq = true;

    					}

    				}

    			}

    			if ( direction_eq ) {

    				// console.log("Warning: lines are a straight sequence");
    				v_trans_x = - v_prev_y;
    				v_trans_y =  v_prev_x;
    				shrink_by = Math.sqrt( v_prev_lensq );

    			} else {

    				// console.log("Warning: lines are a straight spike");
    				v_trans_x = v_prev_x;
    				v_trans_y = v_prev_y;
    				shrink_by = Math.sqrt( v_prev_lensq / 2 );

    			}

    		}

    		return	new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );

    	}


    	var contourMovements = [];

    	for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

    		if ( j === il ) j = 0;
    		if ( k === il ) k = 0;

    		//  (j)---(i)---(k)
    		// console.log('i,j,k', i, j , k)

    		contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );

    	}

    	var holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();

    	for ( h = 0, hl = holes.length; h < hl; h ++ ) {

    		ahole = holes[ h ];

    		oneHoleMovements = [];

    		for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

    			if ( j === il ) j = 0;
    			if ( k === il ) k = 0;

    			//  (j)---(i)---(k)
    			oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );

    		}

    		holesMovements.push( oneHoleMovements );
    		verticesMovements = verticesMovements.concat( oneHoleMovements );

    	}


    	// Loop bevelSegments, 1 for the front, 1 for the back

    	for ( b = 0; b < bevelSegments; b ++ ) {

    		//for ( b = bevelSegments; b > 0; b -- ) {

    		t = b / bevelSegments;
    		z = bevelThickness * Math.cos( t * Math.PI / 2 );
    		bs = bevelSize * Math.sin( t * Math.PI / 2 );

    		// contract shape

    		for ( i = 0, il = contour.length; i < il; i ++ ) {

    			vert = scalePt2( contour[ i ], contourMovements[ i ], bs );

    			v( vert.x, vert.y,  - z );

    		}

    		// expand holes

    		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

    			ahole = holes[ h ];
    			oneHoleMovements = holesMovements[ h ];

    			for ( i = 0, il = ahole.length; i < il; i ++ ) {

    				vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

    				v( vert.x, vert.y,  - z );

    			}

    		}

    	}

    	bs = bevelSize;

    	// Back facing vertices

    	for ( i = 0; i < vlen; i ++ ) {

    		vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

    		if ( ! extrudeByPath ) {

    			v( vert.x, vert.y, 0 );

    		} else {

    			// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

    			normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );
    			binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );

    			position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );

    			v( position2.x, position2.y, position2.z );

    		}

    	}

    	// Add stepped vertices...
    	// Including front facing vertices

    	var s;

    	for ( s = 1; s <= steps; s ++ ) {

    		for ( i = 0; i < vlen; i ++ ) {

    			vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

    			if ( ! extrudeByPath ) {

    				v( vert.x, vert.y, amount / steps * s );

    			} else {

    				// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

    				normal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );
    				binormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );

    				position2.copy( extrudePts[ s ] ).add( normal ).add( binormal );

    				v( position2.x, position2.y, position2.z );

    			}

    		}

    	}


    	// Add bevel segments planes

    	//for ( b = 1; b <= bevelSegments; b ++ ) {
    	for ( b = bevelSegments - 1; b >= 0; b -- ) {

    		t = b / bevelSegments;
    		z = bevelThickness * Math.cos ( t * Math.PI / 2 );
    		bs = bevelSize * Math.sin( t * Math.PI / 2 );

    		// contract shape

    		for ( i = 0, il = contour.length; i < il; i ++ ) {

    			vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
    			v( vert.x, vert.y,  amount + z );

    		}

    		// expand holes

    		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

    			ahole = holes[ h ];
    			oneHoleMovements = holesMovements[ h ];

    			for ( i = 0, il = ahole.length; i < il; i ++ ) {

    				vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

    				if ( ! extrudeByPath ) {

    					v( vert.x, vert.y,  amount + z );

    				} else {

    					v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );

    				}

    			}

    		}

    	}

    	/* Faces */

    	// Top and bottom faces

    	buildLidFaces();

    	// Sides faces

    	buildSideFaces();


    	/////  Internal functions

    	function buildLidFaces() {

    		if ( bevelEnabled ) {

    			var layer = 0; // steps + 1
    			var offset = vlen * layer;

    			// Bottom faces

    			for ( i = 0; i < flen; i ++ ) {

    				face = faces[ i ];
    				f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );

    			}

    			layer = steps + bevelSegments * 2;
    			offset = vlen * layer;

    			// Top faces

    			for ( i = 0; i < flen; i ++ ) {

    				face = faces[ i ];
    				f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );

    			}

    		} else {

    			// Bottom faces

    			for ( i = 0; i < flen; i ++ ) {

    				face = faces[ i ];
    				f3( face[ 2 ], face[ 1 ], face[ 0 ] );

    			}

    			// Top faces

    			for ( i = 0; i < flen; i ++ ) {

    				face = faces[ i ];
    				f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );

    			}

    		}

    	}

    	// Create faces for the z-sides of the shape

    	function buildSideFaces() {

    		var layeroffset = 0;
    		sidewalls( contour, layeroffset );
    		layeroffset += contour.length;

    		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

    			ahole = holes[ h ];
    			sidewalls( ahole, layeroffset );

    			//, true
    			layeroffset += ahole.length;

    		}

    	}

    	function sidewalls( contour, layeroffset ) {

    		var j, k;
    		i = contour.length;

    		while ( -- i >= 0 ) {

    			j = i;
    			k = i - 1;
    			if ( k < 0 ) k = contour.length - 1;

    			//console.log('b', i,j, i-1, k,vertices.length);

    			var s = 0, sl = steps  + bevelSegments * 2;

    			for ( s = 0; s < sl; s ++ ) {

    				var slen1 = vlen * s;
    				var slen2 = vlen * ( s + 1 );

    				var a = layeroffset + j + slen1,
    					b = layeroffset + k + slen1,
    					c = layeroffset + k + slen2,
    					d = layeroffset + j + slen2;

    				f4( a, b, c, d, contour, s, sl, j, k );

    			}

    		}

    	}


    	function v( x, y, z ) {

    		scope.vertices.push( new Vector3( x, y, z ) );

    	}

    	function f3( a, b, c ) {

    		a += shapesOffset;
    		b += shapesOffset;
    		c += shapesOffset;

    		scope.faces.push( new Face3( a, b, c, null, null, 0 ) );

    		var uvs = uvgen.generateTopUV( scope, a, b, c );

    		scope.faceVertexUvs[ 0 ].push( uvs );

    	}

    	function f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {

    		a += shapesOffset;
    		b += shapesOffset;
    		c += shapesOffset;
    		d += shapesOffset;

    		scope.faces.push( new Face3( a, b, d, null, null, 1 ) );
    		scope.faces.push( new Face3( b, c, d, null, null, 1 ) );

    		var uvs = uvgen.generateSideWallUV( scope, a, b, c, d );

    		scope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );
    		scope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );

    	}

    };

    ExtrudeGeometry.WorldUVGenerator = {

    	generateTopUV: function ( geometry, indexA, indexB, indexC ) {

    		var vertices = geometry.vertices;

    		var a = vertices[ indexA ];
    		var b = vertices[ indexB ];
    		var c = vertices[ indexC ];

    		return [
    			new Vector2( a.x, a.y ),
    			new Vector2( b.x, b.y ),
    			new Vector2( c.x, c.y )
    		];

    	},

    	generateSideWallUV: function ( geometry, indexA, indexB, indexC, indexD ) {

    		var vertices = geometry.vertices;

    		var a = vertices[ indexA ];
    		var b = vertices[ indexB ];
    		var c = vertices[ indexC ];
    		var d = vertices[ indexD ];

    		if ( Math.abs( a.y - b.y ) < 0.01 ) {

    			return [
    				new Vector2( a.x, 1 - a.z ),
    				new Vector2( b.x, 1 - b.z ),
    				new Vector2( c.x, 1 - c.z ),
    				new Vector2( d.x, 1 - d.z )
    			];

    		} else {

    			return [
    				new Vector2( a.y, 1 - a.z ),
    				new Vector2( b.y, 1 - b.z ),
    				new Vector2( c.y, 1 - c.z ),
    				new Vector2( d.y, 1 - d.z )
    			];

    		}

    	}
    };

    /**
     * @author zz85 / http://www.lab4games.net/zz85/blog
     * @author alteredq / http://alteredqualia.com/
     *
     * Text = 3D Text
     *
     * parameters = {
     *  font: <THREE.Font>, // font
     *
     *  size: <float>, // size of the text
     *  height: <float>, // thickness to extrude text
     *  curveSegments: <int>, // number of points on the curves
     *
     *  bevelEnabled: <bool>, // turn on bevel
     *  bevelThickness: <float>, // how deep into text bevel goes
     *  bevelSize: <float> // how far from text outline is bevel
     * }
     */

    function TextGeometry( text, parameters ) {

    	parameters = parameters || {};

    	var font = parameters.font;

    	if ( (font && font.isFont) === false ) {

    		console.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );
    		return new Geometry();

    	}

    	var shapes = font.generateShapes( text, parameters.size, parameters.curveSegments );

    	// translate parameters to ExtrudeGeometry API

    	parameters.amount = parameters.height !== undefined ? parameters.height : 50;

    	// defaults

    	if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;
    	if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;
    	if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;

    	ExtrudeGeometry.call( this, shapes, parameters );

    	this.type = 'TextGeometry';

    }

    TextGeometry.prototype = Object.create( ExtrudeGeometry.prototype );
    TextGeometry.prototype.constructor = TextGeometry;

    /**
     * @author benaadams / https://twitter.com/ben_a_adams
     * based on THREE.SphereGeometry
     */

    function SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

    	BufferGeometry.call( this );

    	this.type = 'SphereBufferGeometry';

    	this.parameters = {
    		radius: radius,
    		widthSegments: widthSegments,
    		heightSegments: heightSegments,
    		phiStart: phiStart,
    		phiLength: phiLength,
    		thetaStart: thetaStart,
    		thetaLength: thetaLength
    	};

    	radius = radius || 50;

    	widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );
    	heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );

    	phiStart = phiStart !== undefined ? phiStart : 0;
    	phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;

    	thetaStart = thetaStart !== undefined ? thetaStart : 0;
    	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;

    	var thetaEnd = thetaStart + thetaLength;

    	var vertexCount = ( ( widthSegments + 1 ) * ( heightSegments + 1 ) );

    	var positions = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
    	var normals = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
    	var uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );

    	var index = 0, vertices = [], normal = new Vector3();

    	for ( var y = 0; y <= heightSegments; y ++ ) {

    		var verticesRow = [];

    		var v = y / heightSegments;

    		for ( var x = 0; x <= widthSegments; x ++ ) {

    			var u = x / widthSegments;

    			var px = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
    			var py = radius * Math.cos( thetaStart + v * thetaLength );
    			var pz = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

    			normal.set( px, py, pz ).normalize();

    			positions.setXYZ( index, px, py, pz );
    			normals.setXYZ( index, normal.x, normal.y, normal.z );
    			uvs.setXY( index, u, 1 - v );

    			verticesRow.push( index );

    			index ++;

    		}

    		vertices.push( verticesRow );

    	}

    	var indices = [];

    	for ( var y = 0; y < heightSegments; y ++ ) {

    		for ( var x = 0; x < widthSegments; x ++ ) {

    			var v1 = vertices[ y ][ x + 1 ];
    			var v2 = vertices[ y ][ x ];
    			var v3 = vertices[ y + 1 ][ x ];
    			var v4 = vertices[ y + 1 ][ x + 1 ];

    			if ( y !== 0 || thetaStart > 0 ) indices.push( v1, v2, v4 );
    			if ( y !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( v2, v3, v4 );

    		}

    	}

    	this.setIndex( new ( positions.count > 65535 ? Uint32Attribute : Uint16Attribute )( indices, 1 ) );
    	this.addAttribute( 'position', positions );
    	this.addAttribute( 'normal', normals );
    	this.addAttribute( 'uv', uvs );

    	this.boundingSphere = new Sphere( new Vector3(), radius );

    }

    SphereBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
    SphereBufferGeometry.prototype.constructor = SphereBufferGeometry;

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function SphereGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

    	Geometry.call( this );

    	this.type = 'SphereGeometry';

    	this.parameters = {
    		radius: radius,
    		widthSegments: widthSegments,
    		heightSegments: heightSegments,
    		phiStart: phiStart,
    		phiLength: phiLength,
    		thetaStart: thetaStart,
    		thetaLength: thetaLength
    	};

    	this.fromBufferGeometry( new SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );

    }

    SphereGeometry.prototype = Object.create( Geometry.prototype );
    SphereGeometry.prototype.constructor = SphereGeometry;

    /**
     * @author Mugen87 / https://github.com/Mugen87
     */

    function RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

    	BufferGeometry.call( this );

    	this.type = 'RingBufferGeometry';

    	this.parameters = {
    		innerRadius: innerRadius,
    		outerRadius: outerRadius,
    		thetaSegments: thetaSegments,
    		phiSegments: phiSegments,
    		thetaStart: thetaStart,
    		thetaLength: thetaLength
    	};

    	innerRadius = innerRadius || 20;
    	outerRadius = outerRadius || 50;

    	thetaStart = thetaStart !== undefined ? thetaStart : 0;
    	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

    	thetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;
    	phiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 1;

    	// these are used to calculate buffer length
    	var vertexCount = ( thetaSegments + 1 ) * ( phiSegments + 1 );
    	var indexCount = thetaSegments * phiSegments * 2 * 3;

    	// buffers
    	var indices = new BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );
    	var vertices = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
    	var normals = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
    	var uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );

    	// some helper variables
    	var index = 0, indexOffset = 0, segment;
    	var radius = innerRadius;
    	var radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );
    	var vertex = new Vector3();
    	var uv = new Vector2();
    	var j, i;

    	// generate vertices, normals and uvs

    	// values are generate from the inside of the ring to the outside

    	for ( j = 0; j <= phiSegments; j ++ ) {

    		for ( i = 0; i <= thetaSegments; i ++ ) {

    			segment = thetaStart + i / thetaSegments * thetaLength;

    			// vertex
    			vertex.x = radius * Math.cos( segment );
    			vertex.y = radius * Math.sin( segment );
    			vertices.setXYZ( index, vertex.x, vertex.y, vertex.z );

    			// normal
    			normals.setXYZ( index, 0, 0, 1 );

    			// uv
    			uv.x = ( vertex.x / outerRadius + 1 ) / 2;
    			uv.y = ( vertex.y / outerRadius + 1 ) / 2;
    			uvs.setXY( index, uv.x, uv.y );

    			// increase index
    			index++;

    		}

    		// increase the radius for next row of vertices
    		radius += radiusStep;

    	}

    	// generate indices

    	for ( j = 0; j < phiSegments; j ++ ) {

    		var thetaSegmentLevel = j * ( thetaSegments + 1 );

    		for ( i = 0; i < thetaSegments; i ++ ) {

    			segment = i + thetaSegmentLevel;

    			// indices
    			var a = segment;
    			var b = segment + thetaSegments + 1;
    			var c = segment + thetaSegments + 2;
    			var d = segment + 1;

    			// face one
    			indices.setX( indexOffset, a ); indexOffset++;
    			indices.setX( indexOffset, b ); indexOffset++;
    			indices.setX( indexOffset, c ); indexOffset++;

    			// face two
    			indices.setX( indexOffset, a ); indexOffset++;
    			indices.setX( indexOffset, c ); indexOffset++;
    			indices.setX( indexOffset, d ); indexOffset++;

    		}

    	}

    	// build geometry

    	this.setIndex( indices );
    	this.addAttribute( 'position', vertices );
    	this.addAttribute( 'normal', normals );
    	this.addAttribute( 'uv', uvs );

    }

    RingBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
    RingBufferGeometry.prototype.constructor = RingBufferGeometry;

    /**
     * @author Kaleb Murphy
     */

    function RingGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

    	Geometry.call( this );

    	this.type = 'RingGeometry';

    	this.parameters = {
    		innerRadius: innerRadius,
    		outerRadius: outerRadius,
    		thetaSegments: thetaSegments,
    		phiSegments: phiSegments,
    		thetaStart: thetaStart,
    		thetaLength: thetaLength
    	};

    	this.fromBufferGeometry( new RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) );

    }

    RingGeometry.prototype = Object.create( Geometry.prototype );
    RingGeometry.prototype.constructor = RingGeometry;

    /**
     * @author mrdoob / http://mrdoob.com/
     * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
     */

    function PlaneGeometry( width, height, widthSegments, heightSegments ) {

    	Geometry.call( this );

    	this.type = 'PlaneGeometry';

    	this.parameters = {
    		width: width,
    		height: height,
    		widthSegments: widthSegments,
    		heightSegments: heightSegments
    	};

    	this.fromBufferGeometry( new PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );

    }

    PlaneGeometry.prototype = Object.create( Geometry.prototype );
    PlaneGeometry.prototype.constructor = PlaneGeometry;

    /**
     * @author Mugen87 / https://github.com/Mugen87
     */

     // points - to create a closed torus, one must use a set of points
     //    like so: [ a, b, c, d, a ], see first is the same as last.
     // segments - the number of circumference segments to create
     // phiStart - the starting radian
     // phiLength - the radian (0 to 2PI) range of the lathed section
     //    2PI is a closed lathe, less than 2PI is a portion.

    function LatheBufferGeometry( points, segments, phiStart, phiLength ) {

    	BufferGeometry.call( this );

    	this.type = 'LatheBufferGeometry';

    	this.parameters = {
    		points: points,
    		segments: segments,
    		phiStart: phiStart,
    		phiLength: phiLength
    	};

    	segments = Math.floor( segments ) || 12;
    	phiStart = phiStart || 0;
    	phiLength = phiLength || Math.PI * 2;

    	// clamp phiLength so it's in range of [ 0, 2PI ]
    	phiLength = exports.Math.clamp( phiLength, 0, Math.PI * 2 );

    	// these are used to calculate buffer length
    	var vertexCount = ( segments + 1 ) * points.length;
    	var indexCount = segments * points.length * 2 * 3;

    	// buffers
    	var indices = new BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );
    	var vertices = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
    	var uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );

    	// helper variables
    	var index = 0, indexOffset = 0, base;
    	var inverseSegments = 1.0 / segments;
    	var vertex = new Vector3();
    	var uv = new Vector2();
    	var i, j;

    	// generate vertices and uvs

    	for ( i = 0; i <= segments; i ++ ) {

    		var phi = phiStart + i * inverseSegments * phiLength;

    		var sin = Math.sin( phi );
    		var cos = Math.cos( phi );

    		for ( j = 0; j <= ( points.length - 1 ); j ++ ) {

    			// vertex
    			vertex.x = points[ j ].x * sin;
    			vertex.y = points[ j ].y;
    			vertex.z = points[ j ].x * cos;
    			vertices.setXYZ( index, vertex.x, vertex.y, vertex.z );

    			// uv
    			uv.x = i / segments;
    			uv.y = j / ( points.length - 1 );
    			uvs.setXY( index, uv.x, uv.y );

    			// increase index
    			index ++;

    		}

    	}

    	// generate indices

    	for ( i = 0; i < segments; i ++ ) {

    		for ( j = 0; j < ( points.length - 1 ); j ++ ) {

    			base = j + i * points.length;

    			// indices
    			var a = base;
    			var b = base + points.length;
    			var c = base + points.length + 1;
    			var d = base + 1;

    			// face one
    			indices.setX( indexOffset, a ); indexOffset++;
    			indices.setX( indexOffset, b ); indexOffset++;
    			indices.setX( indexOffset, d ); indexOffset++;

    			// face two
    			indices.setX( indexOffset, b ); indexOffset++;
    			indices.setX( indexOffset, c ); indexOffset++;
    			indices.setX( indexOffset, d ); indexOffset++;

    		}

    	}

    	// build geometry

    	this.setIndex( indices );
    	this.addAttribute( 'position', vertices );
    	this.addAttribute( 'uv', uvs );

    	// generate normals

    	this.computeVertexNormals();

    	// if the geometry is closed, we need to average the normals along the seam.
    	// because the corresponding vertices are identical (but still have different UVs).

    	if( phiLength === Math.PI * 2 ) {

    		var normals = this.attributes.normal.array;
    		var n1 = new Vector3();
    		var n2 = new Vector3();
    		var n = new Vector3();

    		// this is the buffer offset for the last line of vertices
    		base = segments * points.length * 3;

    		for( i = 0, j = 0; i < points.length; i ++, j += 3 ) {

    			// select the normal of the vertex in the first line
    			n1.x = normals[ j + 0 ];
    			n1.y = normals[ j + 1 ];
    			n1.z = normals[ j + 2 ];

    			// select the normal of the vertex in the last line
    			n2.x = normals[ base + j + 0 ];
    			n2.y = normals[ base + j + 1 ];
    			n2.z = normals[ base + j + 2 ];

    			// average normals
    			n.addVectors( n1, n2 ).normalize();

    			// assign the new values to both normals
    			normals[ j + 0 ] = normals[ base + j + 0 ] = n.x;
    			normals[ j + 1 ] = normals[ base + j + 1 ] = n.y;
    			normals[ j + 2 ] = normals[ base + j + 2 ] = n.z;

    		} // next row

    	}

    }

    LatheBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
    LatheBufferGeometry.prototype.constructor = LatheBufferGeometry;

    /**
     * @author astrodud / http://astrodud.isgreat.org/
     * @author zz85 / https://github.com/zz85
     * @author bhouston / http://clara.io
     */

    // points - to create a closed torus, one must use a set of points
    //    like so: [ a, b, c, d, a ], see first is the same as last.
    // segments - the number of circumference segments to create
    // phiStart - the starting radian
    // phiLength - the radian (0 to 2PI) range of the lathed section
    //    2PI is a closed lathe, less than 2PI is a portion.

    function LatheGeometry( points, segments, phiStart, phiLength ) {

    	Geometry.call( this );

    	this.type = 'LatheGeometry';

    	this.parameters = {
    		points: points,
    		segments: segments,
    		phiStart: phiStart,
    		phiLength: phiLength
    	};

    	this.fromBufferGeometry( new LatheBufferGeometry( points, segments, phiStart, phiLength ) );
    	this.mergeVertices();

    }

    LatheGeometry.prototype = Object.create( Geometry.prototype );
    LatheGeometry.prototype.constructor = LatheGeometry;

    /**
     * @author jonobr1 / http://jonobr1.com
     *
     * Creates a one-sided polygonal geometry from a path shape. Similar to
     * ExtrudeGeometry.
     *
     * parameters = {
     *
     *	curveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.
     *
     *	material: <int> // material index for front and back faces
     *	uvGenerator: <Object> // object that provides UV generator functions
     *
     * }
     **/

    function ShapeGeometry( shapes, options ) {

    	Geometry.call( this );

    	this.type = 'ShapeGeometry';

    	if ( Array.isArray( shapes ) === false ) shapes = [ shapes ];

    	this.addShapeList( shapes, options );

    	this.computeFaceNormals();

    }

    ShapeGeometry.prototype = Object.create( Geometry.prototype );
    ShapeGeometry.prototype.constructor = ShapeGeometry;

    /**
     * Add an array of shapes to THREE.ShapeGeometry.
     */
    ShapeGeometry.prototype.addShapeList = function ( shapes, options ) {

    	for ( var i = 0, l = shapes.length; i < l; i ++ ) {

    		this.addShape( shapes[ i ], options );

    	}

    	return this;

    };

    /**
     * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.
     */
    ShapeGeometry.prototype.addShape = function ( shape, options ) {

    	if ( options === undefined ) options = {};
    	var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

    	var material = options.material;
    	var uvgen = options.UVGenerator === undefined ? ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;

    	//

    	var i, l, hole;

    	var shapesOffset = this.vertices.length;
    	var shapePoints = shape.extractPoints( curveSegments );

    	var vertices = shapePoints.shape;
    	var holes = shapePoints.holes;

    	var reverse = ! exports.ShapeUtils.isClockWise( vertices );

    	if ( reverse ) {

    		vertices = vertices.reverse();

    		// Maybe we should also check if holes are in the opposite direction, just to be safe...

    		for ( i = 0, l = holes.length; i < l; i ++ ) {

    			hole = holes[ i ];

    			if ( exports.ShapeUtils.isClockWise( hole ) ) {

    				holes[ i ] = hole.reverse();

    			}

    		}

    		reverse = false;

    	}

    	var faces = exports.ShapeUtils.triangulateShape( vertices, holes );

    	// Vertices

    	for ( i = 0, l = holes.length; i < l; i ++ ) {

    		hole = holes[ i ];
    		vertices = vertices.concat( hole );

    	}

    	//

    	var vert, vlen = vertices.length;
    	var face, flen = faces.length;

    	for ( i = 0; i < vlen; i ++ ) {

    		vert = vertices[ i ];

    		this.vertices.push( new Vector3( vert.x, vert.y, 0 ) );

    	}

    	for ( i = 0; i < flen; i ++ ) {

    		face = faces[ i ];

    		var a = face[ 0 ] + shapesOffset;
    		var b = face[ 1 ] + shapesOffset;
    		var c = face[ 2 ] + shapesOffset;

    		this.faces.push( new Face3( a, b, c, null, null, material ) );
    		this.faceVertexUvs[ 0 ].push( uvgen.generateTopUV( this, a, b, c ) );

    	}

    };

    /**
     * @author WestLangley / http://github.com/WestLangley
     */

    function EdgesGeometry( geometry, thresholdAngle ) {

    	BufferGeometry.call( this );

    	thresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;

    	var thresholdDot = Math.cos( exports.Math.DEG2RAD * thresholdAngle );

    	var edge = [ 0, 0 ], hash = {};

    	function sortFunction( a, b ) {

    		return a - b;

    	}

    	var keys = [ 'a', 'b', 'c' ];

    	var geometry2;

    	if ( (geometry && geometry.isBufferGeometry) ) {

    		geometry2 = new Geometry();
    		geometry2.fromBufferGeometry( geometry );

    	} else {

    		geometry2 = geometry.clone();

    	}

    	geometry2.mergeVertices();
    	geometry2.computeFaceNormals();

    	var vertices = geometry2.vertices;
    	var faces = geometry2.faces;

    	for ( var i = 0, l = faces.length; i < l; i ++ ) {

    		var face = faces[ i ];

    		for ( var j = 0; j < 3; j ++ ) {

    			edge[ 0 ] = face[ keys[ j ] ];
    			edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
    			edge.sort( sortFunction );

    			var key = edge.toString();

    			if ( hash[ key ] === undefined ) {

    				hash[ key ] = { vert1: edge[ 0 ], vert2: edge[ 1 ], face1: i, face2: undefined };

    			} else {

    				hash[ key ].face2 = i;

    			}

    		}

    	}

    	var coords = [];

    	for ( var key in hash ) {

    		var h = hash[ key ];

    		if ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) <= thresholdDot ) {

    			var vertex = vertices[ h.vert1 ];
    			coords.push( vertex.x );
    			coords.push( vertex.y );
    			coords.push( vertex.z );

    			vertex = vertices[ h.vert2 ];
    			coords.push( vertex.x );
    			coords.push( vertex.y );
    			coords.push( vertex.z );

    		}

    	}

    	this.addAttribute( 'position', new BufferAttribute( new Float32Array( coords ), 3 ) );

    }

    EdgesGeometry.prototype = Object.create( BufferGeometry.prototype );
    EdgesGeometry.prototype.constructor = EdgesGeometry;

    /**
     * @author Mugen87 / https://github.com/Mugen87
     */

    function CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

    	BufferGeometry.call( this );

    	this.type = 'CylinderBufferGeometry';

    	this.parameters = {
    		radiusTop: radiusTop,
    		radiusBottom: radiusBottom,
    		height: height,
    		radialSegments: radialSegments,
    		heightSegments: heightSegments,
    		openEnded: openEnded,
    		thetaStart: thetaStart,
    		thetaLength: thetaLength
    	};

    	var scope = this;

    	radiusTop = radiusTop !== undefined ? radiusTop : 20;
    	radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;
    	height = height !== undefined ? height : 100;

    	radialSegments = Math.floor( radialSegments ) || 8;
    	heightSegments = Math.floor( heightSegments ) || 1;

    	openEnded = openEnded !== undefined ? openEnded : false;
    	thetaStart = thetaStart !== undefined ? thetaStart : 0.0;
    	thetaLength = thetaLength !== undefined ? thetaLength : 2.0 * Math.PI;

    	// used to calculate buffer length

    	var nbCap = 0;

    	if ( openEnded === false ) {

    		if ( radiusTop > 0 ) nbCap ++;
    		if ( radiusBottom > 0 ) nbCap ++;

    	}

    	var vertexCount = calculateVertexCount();
    	var indexCount = calculateIndexCount();

    	// buffers

    	var indices = new BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ), 1 );
    	var vertices = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
    	var normals = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
    	var uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );

    	// helper variables

    	var index = 0,
    	    indexOffset = 0,
    	    indexArray = [],
    	    halfHeight = height / 2;

    	// group variables
    	var groupStart = 0;

    	// generate geometry

    	generateTorso();

    	if ( openEnded === false ) {

    		if ( radiusTop > 0 ) generateCap( true );
    		if ( radiusBottom > 0 ) generateCap( false );

    	}

    	// build geometry

    	this.setIndex( indices );
    	this.addAttribute( 'position', vertices );
    	this.addAttribute( 'normal', normals );
    	this.addAttribute( 'uv', uvs );

    	// helper functions

    	function calculateVertexCount() {

    		var count = ( radialSegments + 1 ) * ( heightSegments + 1 );

    		if ( openEnded === false ) {

    			count += ( ( radialSegments + 1 ) * nbCap ) + ( radialSegments * nbCap );

    		}

    		return count;

    	}

    	function calculateIndexCount() {

    		var count = radialSegments * heightSegments * 2 * 3;

    		if ( openEnded === false ) {

    			count += radialSegments * nbCap * 3;

    		}

    		return count;

    	}

    	function generateTorso() {

    		var x, y;
    		var normal = new Vector3();
    		var vertex = new Vector3();

    		var groupCount = 0;

    		// this will be used to calculate the normal
    		var slope = ( radiusBottom - radiusTop ) / height;

    		// generate vertices, normals and uvs

    		for ( y = 0; y <= heightSegments; y ++ ) {

    			var indexRow = [];

    			var v = y / heightSegments;

    			// calculate the radius of the current row
    			var radius = v * ( radiusBottom - radiusTop ) + radiusTop;

    			for ( x = 0; x <= radialSegments; x ++ ) {

    				var u = x / radialSegments;

    				var theta = u * thetaLength + thetaStart;

    				var sinTheta = Math.sin( theta );
    				var cosTheta = Math.cos( theta );

    				// vertex
    				vertex.x = radius * sinTheta;
    				vertex.y = - v * height + halfHeight;
    				vertex.z = radius * cosTheta;
    				vertices.setXYZ( index, vertex.x, vertex.y, vertex.z );

    				// normal
    				normal.set( sinTheta, slope, cosTheta ).normalize();
    				normals.setXYZ( index, normal.x, normal.y, normal.z );

    				// uv
    				uvs.setXY( index, u, 1 - v );

    				// save index of vertex in respective row
    				indexRow.push( index );

    				// increase index
    				index ++;

    			}

    			// now save vertices of the row in our index array
    			indexArray.push( indexRow );

    		}

    		// generate indices

    		for ( x = 0; x < radialSegments; x ++ ) {

    			for ( y = 0; y < heightSegments; y ++ ) {

    				// we use the index array to access the correct indices
    				var i1 = indexArray[ y ][ x ];
    				var i2 = indexArray[ y + 1 ][ x ];
    				var i3 = indexArray[ y + 1 ][ x + 1 ];
    				var i4 = indexArray[ y ][ x + 1 ];

    				// face one
    				indices.setX( indexOffset, i1 ); indexOffset ++;
    				indices.setX( indexOffset, i2 ); indexOffset ++;
    				indices.setX( indexOffset, i4 ); indexOffset ++;

    				// face two
    				indices.setX( indexOffset, i2 ); indexOffset ++;
    				indices.setX( indexOffset, i3 ); indexOffset ++;
    				indices.setX( indexOffset, i4 ); indexOffset ++;

    				// update counters
    				groupCount += 6;

    			}

    		}

    		// add a group to the geometry. this will ensure multi material support
    		scope.addGroup( groupStart, groupCount, 0 );

    		// calculate new start value for groups
    		groupStart += groupCount;

    	}

    	function generateCap( top ) {

    		var x, centerIndexStart, centerIndexEnd;

    		var uv = new Vector2();
    		var vertex = new Vector3();

    		var groupCount = 0;

    		var radius = ( top === true ) ? radiusTop : radiusBottom;
    		var sign = ( top === true ) ? 1 : - 1;

    		// save the index of the first center vertex
    		centerIndexStart = index;

    		// first we generate the center vertex data of the cap.
    		// because the geometry needs one set of uvs per face,
    		// we must generate a center vertex per face/segment

    		for ( x = 1; x <= radialSegments; x ++ ) {

    			// vertex
    			vertices.setXYZ( index, 0, halfHeight * sign, 0 );

    			// normal
    			normals.setXYZ( index, 0, sign, 0 );

    			// uv
    			uv.x = 0.5;
    			uv.y = 0.5;

    			uvs.setXY( index, uv.x, uv.y );

    			// increase index
    			index ++;

    		}

    		// save the index of the last center vertex
    		centerIndexEnd = index;

    		// now we generate the surrounding vertices, normals and uvs

    		for ( x = 0; x <= radialSegments; x ++ ) {

    			var u = x / radialSegments;
    			var theta = u * thetaLength + thetaStart;

    			var cosTheta = Math.cos( theta );
    			var sinTheta = Math.sin( theta );

    			// vertex
    			vertex.x = radius * sinTheta;
    			vertex.y = halfHeight * sign;
    			vertex.z = radius * cosTheta;
    			vertices.setXYZ( index, vertex.x, vertex.y, vertex.z );

    			// normal
    			normals.setXYZ( index, 0, sign, 0 );

    			// uv
    			uv.x = ( cosTheta * 0.5 ) + 0.5;
    			uv.y = ( sinTheta * 0.5 * sign ) + 0.5;
    			uvs.setXY( index, uv.x, uv.y );

    			// increase index
    			index ++;

    		}

    		// generate indices

    		for ( x = 0; x < radialSegments; x ++ ) {

    			var c = centerIndexStart + x;
    			var i = centerIndexEnd + x;

    			if ( top === true ) {

    				// face top
    				indices.setX( indexOffset, i ); indexOffset ++;
    				indices.setX( indexOffset, i + 1 ); indexOffset ++;
    				indices.setX( indexOffset, c ); indexOffset ++;

    			} else {

    				// face bottom
    				indices.setX( indexOffset, i + 1 ); indexOffset ++;
    				indices.setX( indexOffset, i ); indexOffset ++;
    				indices.setX( indexOffset, c ); indexOffset ++;

    			}

    			// update counters
    			groupCount += 3;

    		}

    		// add a group to the geometry. this will ensure multi material support
    		scope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );

    		// calculate new start value for groups
    		groupStart += groupCount;

    	}

    }

    CylinderBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
    CylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function CylinderGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

    	Geometry.call( this );

    	this.type = 'CylinderGeometry';

    	this.parameters = {
    		radiusTop: radiusTop,
    		radiusBottom: radiusBottom,
    		height: height,
    		radialSegments: radialSegments,
    		heightSegments: heightSegments,
    		openEnded: openEnded,
    		thetaStart: thetaStart,
    		thetaLength: thetaLength
    	};

    	this.fromBufferGeometry( new CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) );
    	this.mergeVertices();

    }

    CylinderGeometry.prototype = Object.create( Geometry.prototype );
    CylinderGeometry.prototype.constructor = CylinderGeometry;

    /**
     * @author abelnation / http://github.com/abelnation
     */

    function ConeGeometry(
    	radius, height,
    	radialSegments, heightSegments,
    	openEnded, thetaStart, thetaLength ) {

    	CylinderGeometry.call( this,
    		0, radius, height,
    		radialSegments, heightSegments,
    		openEnded, thetaStart, thetaLength );

    	this.type = 'ConeGeometry';

    	this.parameters = {
    		radius: radius,
    		height: height,
    		radialSegments: radialSegments,
    		heightSegments: heightSegments,
    		openEnded: openEnded,
    		thetaStart: thetaStart,
    		thetaLength: thetaLength
    	};

    }

    ConeGeometry.prototype = Object.create( CylinderGeometry.prototype );
    ConeGeometry.prototype.constructor = ConeGeometry;

    /*
     * @author: abelnation / http://github.com/abelnation
     */

    function ConeBufferGeometry(
    	radius, height,
    	radialSegments, heightSegments,
    	openEnded, thetaStart, thetaLength ) {

    	CylinderBufferGeometry.call( this,
    		0, radius, height,
    		radialSegments, heightSegments,
    		openEnded, thetaStart, thetaLength );

    	this.type = 'ConeBufferGeometry';

    	this.parameters = {
    		radius: radius,
    		height: height,
    		radialSegments: radialSegments,
    		heightSegments: heightSegments,
    		thetaStart: thetaStart,
    		thetaLength: thetaLength
    	};

    }

    ConeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
    ConeBufferGeometry.prototype.constructor = ConeBufferGeometry;

    /**
     * @author benaadams / https://twitter.com/ben_a_adams
     */

    function CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) {

    	BufferGeometry.call( this );

    	this.type = 'CircleBufferGeometry';

    	this.parameters = {
    		radius: radius,
    		segments: segments,
    		thetaStart: thetaStart,
    		thetaLength: thetaLength
    	};

    	radius = radius || 50;
    	segments = segments !== undefined ? Math.max( 3, segments ) : 8;

    	thetaStart = thetaStart !== undefined ? thetaStart : 0;
    	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

    	var vertices = segments + 2;

    	var positions = new Float32Array( vertices * 3 );
    	var normals = new Float32Array( vertices * 3 );
    	var uvs = new Float32Array( vertices * 2 );

    	// center data is already zero, but need to set a few extras
    	normals[ 2 ] = 1.0;
    	uvs[ 0 ] = 0.5;
    	uvs[ 1 ] = 0.5;

    	for ( var s = 0, i = 3, ii = 2 ; s <= segments; s ++, i += 3, ii += 2 ) {

    		var segment = thetaStart + s / segments * thetaLength;

    		positions[ i ] = radius * Math.cos( segment );
    		positions[ i + 1 ] = radius * Math.sin( segment );

    		normals[ i + 2 ] = 1; // normal z

    		uvs[ ii ] = ( positions[ i ] / radius + 1 ) / 2;
    		uvs[ ii + 1 ] = ( positions[ i + 1 ] / radius + 1 ) / 2;

    	}

    	var indices = [];

    	for ( var i = 1; i <= segments; i ++ ) {

    		indices.push( i, i + 1, 0 );

    	}

    	this.setIndex( new BufferAttribute( new Uint16Array( indices ), 1 ) );
    	this.addAttribute( 'position', new BufferAttribute( positions, 3 ) );
    	this.addAttribute( 'normal', new BufferAttribute( normals, 3 ) );
    	this.addAttribute( 'uv', new BufferAttribute( uvs, 2 ) );

    	this.boundingSphere = new Sphere( new Vector3(), radius );

    }

    CircleBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
    CircleBufferGeometry.prototype.constructor = CircleBufferGeometry;

    /**
     * @author hughes
     */

    function CircleGeometry( radius, segments, thetaStart, thetaLength ) {

    	Geometry.call( this );

    	this.type = 'CircleGeometry';

    	this.parameters = {
    		radius: radius,
    		segments: segments,
    		thetaStart: thetaStart,
    		thetaLength: thetaLength
    	};

    	this.fromBufferGeometry( new CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );

    }

    CircleGeometry.prototype = Object.create( Geometry.prototype );
    CircleGeometry.prototype.constructor = CircleGeometry;

    /**
     * @author mrdoob / http://mrdoob.com/
     * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as
     */

    function BoxGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {

    	Geometry.call( this );

    	this.type = 'BoxGeometry';

    	this.parameters = {
    		width: width,
    		height: height,
    		depth: depth,
    		widthSegments: widthSegments,
    		heightSegments: heightSegments,
    		depthSegments: depthSegments
    	};

    	this.fromBufferGeometry( new BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) );
    	this.mergeVertices();

    }

    BoxGeometry.prototype = Object.create( Geometry.prototype );
    BoxGeometry.prototype.constructor = BoxGeometry;



    var Geometries = Object.freeze({
    	WireframeGeometry: WireframeGeometry,
    	ParametricGeometry: ParametricGeometry,
    	TetrahedronGeometry: TetrahedronGeometry,
    	OctahedronGeometry: OctahedronGeometry,
    	IcosahedronGeometry: IcosahedronGeometry,
    	DodecahedronGeometry: DodecahedronGeometry,
    	PolyhedronGeometry: PolyhedronGeometry,
    	TubeGeometry: TubeGeometry,
    	TorusKnotGeometry: TorusKnotGeometry,
    	TorusKnotBufferGeometry: TorusKnotBufferGeometry,
    	TorusGeometry: TorusGeometry,
    	TorusBufferGeometry: TorusBufferGeometry,
    	TextGeometry: TextGeometry,
    	SphereBufferGeometry: SphereBufferGeometry,
    	SphereGeometry: SphereGeometry,
    	RingGeometry: RingGeometry,
    	RingBufferGeometry: RingBufferGeometry,
    	PlaneBufferGeometry: PlaneBufferGeometry,
    	PlaneGeometry: PlaneGeometry,
    	LatheGeometry: LatheGeometry,
    	LatheBufferGeometry: LatheBufferGeometry,
    	ShapeGeometry: ShapeGeometry,
    	ExtrudeGeometry: ExtrudeGeometry,
    	EdgesGeometry: EdgesGeometry,
    	ConeGeometry: ConeGeometry,
    	ConeBufferGeometry: ConeBufferGeometry,
    	CylinderGeometry: CylinderGeometry,
    	CylinderBufferGeometry: CylinderBufferGeometry,
    	CircleBufferGeometry: CircleBufferGeometry,
    	CircleGeometry: CircleGeometry,
    	BoxBufferGeometry: BoxBufferGeometry,
    	BoxGeometry: BoxGeometry
    });

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function ShadowMaterial() {

    	ShaderMaterial.call( this, {
    		uniforms: exports.UniformsUtils.merge( [
    			UniformsLib[ "lights" ],
    			{
    				opacity: { value: 1.0 }
    			}
    		] ),
    		vertexShader: ShaderChunk[ 'shadow_vert' ],
    		fragmentShader: ShaderChunk[ 'shadow_frag' ]
    	} );

    	this.lights = true;
    	this.transparent = true;

    	Object.defineProperties( this, {
    		opacity: {
    			enumerable: true,
    			get: function () {
    				return this.uniforms.opacity.value;
    			},
    			set: function ( value ) {
    				this.uniforms.opacity.value = value;
    			}
    		}
    	} );

    }

    ShadowMaterial.prototype = Object.create( ShaderMaterial.prototype );
    ShadowMaterial.prototype.constructor = ShadowMaterial;

    ShadowMaterial.prototype.isShadowMaterial = true;

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function RawShaderMaterial( parameters ) {

    	ShaderMaterial.call( this, parameters );

    	this.type = 'RawShaderMaterial';

    }

    RawShaderMaterial.prototype = Object.create( ShaderMaterial.prototype );
    RawShaderMaterial.prototype.constructor = RawShaderMaterial;

    RawShaderMaterial.prototype.isRawShaderMaterial = true;

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function MultiMaterial( materials ) {

    	this.uuid = exports.Math.generateUUID();

    	this.type = 'MultiMaterial';

    	this.materials = materials instanceof Array ? materials : [];

    	this.visible = true;

    }

    MultiMaterial.prototype = {

    	constructor: MultiMaterial,

    	isMultiMaterial: true,

    	toJSON: function ( meta ) {

    		var output = {
    			metadata: {
    				version: 4.2,
    				type: 'material',
    				generator: 'MaterialExporter'
    			},
    			uuid: this.uuid,
    			type: this.type,
    			materials: []
    		};

    		var materials = this.materials;

    		for ( var i = 0, l = materials.length; i < l; i ++ ) {

    			var material = materials[ i ].toJSON( meta );
    			delete material.metadata;

    			output.materials.push( material );

    		}

    		output.visible = this.visible;

    		return output;

    	},

    	clone: function () {

    		var material = new this.constructor();

    		for ( var i = 0; i < this.materials.length; i ++ ) {

    			material.materials.push( this.materials[ i ].clone() );

    		}

    		material.visible = this.visible;

    		return material;

    	}

    };

    /**
     * @author WestLangley / http://github.com/WestLangley
     *
     * parameters = {
     *  color: <hex>,
     *  roughness: <float>,
     *  metalness: <float>,
     *  opacity: <float>,
     *
     *  map: new THREE.Texture( <Image> ),
     *
     *  lightMap: new THREE.Texture( <Image> ),
     *  lightMapIntensity: <float>
     *
     *  aoMap: new THREE.Texture( <Image> ),
     *  aoMapIntensity: <float>
     *
     *  emissive: <hex>,
     *  emissiveIntensity: <float>
     *  emissiveMap: new THREE.Texture( <Image> ),
     *
     *  bumpMap: new THREE.Texture( <Image> ),
     *  bumpScale: <float>,
     *
     *  normalMap: new THREE.Texture( <Image> ),
     *  normalScale: <Vector2>,
     *
     *  displacementMap: new THREE.Texture( <Image> ),
     *  displacementScale: <float>,
     *  displacementBias: <float>,
     *
     *  roughnessMap: new THREE.Texture( <Image> ),
     *
     *  metalnessMap: new THREE.Texture( <Image> ),
     *
     *  alphaMap: new THREE.Texture( <Image> ),
     *
     *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
     *  envMapIntensity: <float>
     *
     *  refractionRatio: <float>,
     *
     *  wireframe: <boolean>,
     *  wireframeLinewidth: <float>,
     *
     *  skinning: <bool>,
     *  morphTargets: <bool>,
     *  morphNormals: <bool>
     * }
     */

    function MeshStandardMaterial( parameters ) {

    	Material.call( this );

    	this.defines = { 'STANDARD': '' };

    	this.type = 'MeshStandardMaterial';

    	this.color = new Color( 0xffffff ); // diffuse
    	this.roughness = 0.5;
    	this.metalness = 0.5;

    	this.map = null;

    	this.lightMap = null;
    	this.lightMapIntensity = 1.0;

    	this.aoMap = null;
    	this.aoMapIntensity = 1.0;

    	this.emissive = new Color( 0x000000 );
    	this.emissiveIntensity = 1.0;
    	this.emissiveMap = null;

    	this.bumpMap = null;
    	this.bumpScale = 1;

    	this.normalMap = null;
    	this.normalScale = new Vector2( 1, 1 );

    	this.displacementMap = null;
    	this.displacementScale = 1;
    	this.displacementBias = 0;

    	this.roughnessMap = null;

    	this.metalnessMap = null;

    	this.alphaMap = null;

    	this.envMap = null;
    	this.envMapIntensity = 1.0;

    	this.refractionRatio = 0.98;

    	this.wireframe = false;
    	this.wireframeLinewidth = 1;
    	this.wireframeLinecap = 'round';
    	this.wireframeLinejoin = 'round';

    	this.skinning = false;
    	this.morphTargets = false;
    	this.morphNormals = false;

    	this.setValues( parameters );

    }

    MeshStandardMaterial.prototype = Object.create( Material.prototype );
    MeshStandardMaterial.prototype.constructor = MeshStandardMaterial;

    MeshStandardMaterial.prototype.isMeshStandardMaterial = true;

    MeshStandardMaterial.prototype.copy = function ( source ) {

    	Material.prototype.copy.call( this, source );

    	this.defines = { 'STANDARD': '' };

    	this.color.copy( source.color );
    	this.roughness = source.roughness;
    	this.metalness = source.metalness;

    	this.map = source.map;

    	this.lightMap = source.lightMap;
    	this.lightMapIntensity = source.lightMapIntensity;

    	this.aoMap = source.aoMap;
    	this.aoMapIntensity = source.aoMapIntensity;

    	this.emissive.copy( source.emissive );
    	this.emissiveMap = source.emissiveMap;
    	this.emissiveIntensity = source.emissiveIntensity;

    	this.bumpMap = source.bumpMap;
    	this.bumpScale = source.bumpScale;

    	this.normalMap = source.normalMap;
    	this.normalScale.copy( source.normalScale );

    	this.displacementMap = source.displacementMap;
    	this.displacementScale = source.displacementScale;
    	this.displacementBias = source.displacementBias;

    	this.roughnessMap = source.roughnessMap;

    	this.metalnessMap = source.metalnessMap;

    	this.alphaMap = source.alphaMap;

    	this.envMap = source.envMap;
    	this.envMapIntensity = source.envMapIntensity;

    	this.refractionRatio = source.refractionRatio;

    	this.wireframe = source.wireframe;
    	this.wireframeLinewidth = source.wireframeLinewidth;
    	this.wireframeLinecap = source.wireframeLinecap;
    	this.wireframeLinejoin = source.wireframeLinejoin;

    	this.skinning = source.skinning;
    	this.morphTargets = source.morphTargets;
    	this.morphNormals = source.morphNormals;

    	return this;

    };

    /**
     * @author WestLangley / http://github.com/WestLangley
     *
     * parameters = {
     *  reflectivity: <float>
     * }
     */

    function MeshPhysicalMaterial( parameters ) {

    	MeshStandardMaterial.call( this );

    	this.defines = { 'PHYSICAL': '' };

    	this.type = 'MeshPhysicalMaterial';

    	this.reflectivity = 0.5; // maps to F0 = 0.04

    	this.clearCoat = 0.0;
    	this.clearCoatRoughness = 0.0;

    	this.setValues( parameters );

    }

    MeshPhysicalMaterial.prototype = Object.create( MeshStandardMaterial.prototype );
    MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;

    MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;

    MeshPhysicalMaterial.prototype.copy = function ( source ) {

    	MeshStandardMaterial.prototype.copy.call( this, source );

    	this.defines = { 'PHYSICAL': '' };

    	this.reflectivity = source.reflectivity;

    	this.clearCoat = source.clearCoat;
    	this.clearCoatRoughness = source.clearCoatRoughness;

    	return this;

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     *
     * parameters = {
     *  color: <hex>,
     *  specular: <hex>,
     *  shininess: <float>,
     *  opacity: <float>,
     *
     *  map: new THREE.Texture( <Image> ),
     *
     *  lightMap: new THREE.Texture( <Image> ),
     *  lightMapIntensity: <float>
     *
     *  aoMap: new THREE.Texture( <Image> ),
     *  aoMapIntensity: <float>
     *
     *  emissive: <hex>,
     *  emissiveIntensity: <float>
     *  emissiveMap: new THREE.Texture( <Image> ),
     *
     *  bumpMap: new THREE.Texture( <Image> ),
     *  bumpScale: <float>,
     *
     *  normalMap: new THREE.Texture( <Image> ),
     *  normalScale: <Vector2>,
     *
     *  displacementMap: new THREE.Texture( <Image> ),
     *  displacementScale: <float>,
     *  displacementBias: <float>,
     *
     *  specularMap: new THREE.Texture( <Image> ),
     *
     *  alphaMap: new THREE.Texture( <Image> ),
     *
     *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
     *  combine: THREE.Multiply,
     *  reflectivity: <float>,
     *  refractionRatio: <float>,
     *
     *  wireframe: <boolean>,
     *  wireframeLinewidth: <float>,
     *
     *  skinning: <bool>,
     *  morphTargets: <bool>,
     *  morphNormals: <bool>
     * }
     */

    function MeshPhongMaterial( parameters ) {

    	Material.call( this );

    	this.type = 'MeshPhongMaterial';

    	this.color = new Color( 0xffffff ); // diffuse
    	this.specular = new Color( 0x111111 );
    	this.shininess = 30;

    	this.map = null;

    	this.lightMap = null;
    	this.lightMapIntensity = 1.0;

    	this.aoMap = null;
    	this.aoMapIntensity = 1.0;

    	this.emissive = new Color( 0x000000 );
    	this.emissiveIntensity = 1.0;
    	this.emissiveMap = null;

    	this.bumpMap = null;
    	this.bumpScale = 1;

    	this.normalMap = null;
    	this.normalScale = new Vector2( 1, 1 );

    	this.displacementMap = null;
    	this.displacementScale = 1;
    	this.displacementBias = 0;

    	this.specularMap = null;

    	this.alphaMap = null;

    	this.envMap = null;
    	this.combine = MultiplyOperation;
    	this.reflectivity = 1;
    	this.refractionRatio = 0.98;

    	this.wireframe = false;
    	this.wireframeLinewidth = 1;
    	this.wireframeLinecap = 'round';
    	this.wireframeLinejoin = 'round';

    	this.skinning = false;
    	this.morphTargets = false;
    	this.morphNormals = false;

    	this.setValues( parameters );

    }

    MeshPhongMaterial.prototype = Object.create( Material.prototype );
    MeshPhongMaterial.prototype.constructor = MeshPhongMaterial;

    MeshPhongMaterial.prototype.isMeshPhongMaterial = true;

    MeshPhongMaterial.prototype.copy = function ( source ) {

    	Material.prototype.copy.call( this, source );

    	this.color.copy( source.color );
    	this.specular.copy( source.specular );
    	this.shininess = source.shininess;

    	this.map = source.map;

    	this.lightMap = source.lightMap;
    	this.lightMapIntensity = source.lightMapIntensity;

    	this.aoMap = source.aoMap;
    	this.aoMapIntensity = source.aoMapIntensity;

    	this.emissive.copy( source.emissive );
    	this.emissiveMap = source.emissiveMap;
    	this.emissiveIntensity = source.emissiveIntensity;

    	this.bumpMap = source.bumpMap;
    	this.bumpScale = source.bumpScale;

    	this.normalMap = source.normalMap;
    	this.normalScale.copy( source.normalScale );

    	this.displacementMap = source.displacementMap;
    	this.displacementScale = source.displacementScale;
    	this.displacementBias = source.displacementBias;

    	this.specularMap = source.specularMap;

    	this.alphaMap = source.alphaMap;

    	this.envMap = source.envMap;
    	this.combine = source.combine;
    	this.reflectivity = source.reflectivity;
    	this.refractionRatio = source.refractionRatio;

    	this.wireframe = source.wireframe;
    	this.wireframeLinewidth = source.wireframeLinewidth;
    	this.wireframeLinecap = source.wireframeLinecap;
    	this.wireframeLinejoin = source.wireframeLinejoin;

    	this.skinning = source.skinning;
    	this.morphTargets = source.morphTargets;
    	this.morphNormals = source.morphNormals;

    	return this;

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     *
     * parameters = {
     *  opacity: <float>,
     *
     *  wireframe: <boolean>,
     *  wireframeLinewidth: <float>
     * }
     */

    function MeshNormalMaterial( parameters ) {

    	Material.call( this, parameters );

    	this.type = 'MeshNormalMaterial';

    	this.wireframe = false;
    	this.wireframeLinewidth = 1;

    	this.fog = false;
    	this.lights = false;
    	this.morphTargets = false;

    	this.setValues( parameters );

    }

    MeshNormalMaterial.prototype = Object.create( Material.prototype );
    MeshNormalMaterial.prototype.constructor = MeshNormalMaterial;

    MeshNormalMaterial.prototype.isMeshNormalMaterial = true;

    MeshNormalMaterial.prototype.copy = function ( source ) {

    	Material.prototype.copy.call( this, source );

    	this.wireframe = source.wireframe;
    	this.wireframeLinewidth = source.wireframeLinewidth;

    	return this;

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     *
     * parameters = {
     *  color: <hex>,
     *  opacity: <float>,
     *
     *  map: new THREE.Texture( <Image> ),
     *
     *  lightMap: new THREE.Texture( <Image> ),
     *  lightMapIntensity: <float>
     *
     *  aoMap: new THREE.Texture( <Image> ),
     *  aoMapIntensity: <float>
     *
     *  emissive: <hex>,
     *  emissiveIntensity: <float>
     *  emissiveMap: new THREE.Texture( <Image> ),
     *
     *  specularMap: new THREE.Texture( <Image> ),
     *
     *  alphaMap: new THREE.Texture( <Image> ),
     *
     *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
     *  combine: THREE.Multiply,
     *  reflectivity: <float>,
     *  refractionRatio: <float>,
     *
     *  wireframe: <boolean>,
     *  wireframeLinewidth: <float>,
     *
     *  skinning: <bool>,
     *  morphTargets: <bool>,
     *  morphNormals: <bool>
     * }
     */

    function MeshLambertMaterial( parameters ) {

    	Material.call( this );

    	this.type = 'MeshLambertMaterial';

    	this.color = new Color( 0xffffff ); // diffuse

    	this.map = null;

    	this.lightMap = null;
    	this.lightMapIntensity = 1.0;

    	this.aoMap = null;
    	this.aoMapIntensity = 1.0;

    	this.emissive = new Color( 0x000000 );
    	this.emissiveIntensity = 1.0;
    	this.emissiveMap = null;

    	this.specularMap = null;

    	this.alphaMap = null;

    	this.envMap = null;
    	this.combine = MultiplyOperation;
    	this.reflectivity = 1;
    	this.refractionRatio = 0.98;

    	this.wireframe = false;
    	this.wireframeLinewidth = 1;
    	this.wireframeLinecap = 'round';
    	this.wireframeLinejoin = 'round';

    	this.skinning = false;
    	this.morphTargets = false;
    	this.morphNormals = false;

    	this.setValues( parameters );

    }

    MeshLambertMaterial.prototype = Object.create( Material.prototype );
    MeshLambertMaterial.prototype.constructor = MeshLambertMaterial;

    MeshLambertMaterial.prototype.isMeshLambertMaterial = true;

    MeshLambertMaterial.prototype.copy = function ( source ) {

    	Material.prototype.copy.call( this, source );

    	this.color.copy( source.color );

    	this.map = source.map;

    	this.lightMap = source.lightMap;
    	this.lightMapIntensity = source.lightMapIntensity;

    	this.aoMap = source.aoMap;
    	this.aoMapIntensity = source.aoMapIntensity;

    	this.emissive.copy( source.emissive );
    	this.emissiveMap = source.emissiveMap;
    	this.emissiveIntensity = source.emissiveIntensity;

    	this.specularMap = source.specularMap;

    	this.alphaMap = source.alphaMap;

    	this.envMap = source.envMap;
    	this.combine = source.combine;
    	this.reflectivity = source.reflectivity;
    	this.refractionRatio = source.refractionRatio;

    	this.wireframe = source.wireframe;
    	this.wireframeLinewidth = source.wireframeLinewidth;
    	this.wireframeLinecap = source.wireframeLinecap;
    	this.wireframeLinejoin = source.wireframeLinejoin;

    	this.skinning = source.skinning;
    	this.morphTargets = source.morphTargets;
    	this.morphNormals = source.morphNormals;

    	return this;

    };

    /**
     * @author alteredq / http://alteredqualia.com/
     *
     * parameters = {
     *  color: <hex>,
     *  opacity: <float>,
     *
     *  linewidth: <float>,
     *
     *  scale: <float>,
     *  dashSize: <float>,
     *  gapSize: <float>
     * }
     */

    function LineDashedMaterial( parameters ) {

    	Material.call( this );

    	this.type = 'LineDashedMaterial';

    	this.color = new Color( 0xffffff );

    	this.linewidth = 1;

    	this.scale = 1;
    	this.dashSize = 3;
    	this.gapSize = 1;

    	this.lights = false;

    	this.setValues( parameters );

    }

    LineDashedMaterial.prototype = Object.create( Material.prototype );
    LineDashedMaterial.prototype.constructor = LineDashedMaterial;

    LineDashedMaterial.prototype.isLineDashedMaterial = true;

    LineDashedMaterial.prototype.copy = function ( source ) {

    	Material.prototype.copy.call( this, source );

    	this.color.copy( source.color );

    	this.linewidth = source.linewidth;

    	this.scale = source.scale;
    	this.dashSize = source.dashSize;
    	this.gapSize = source.gapSize;

    	return this;

    };



    var Materials = Object.freeze({
    	ShadowMaterial: ShadowMaterial,
    	SpriteMaterial: SpriteMaterial,
    	RawShaderMaterial: RawShaderMaterial,
    	ShaderMaterial: ShaderMaterial,
    	PointsMaterial: PointsMaterial,
    	MultiMaterial: MultiMaterial,
    	MeshPhysicalMaterial: MeshPhysicalMaterial,
    	MeshStandardMaterial: MeshStandardMaterial,
    	MeshPhongMaterial: MeshPhongMaterial,
    	MeshNormalMaterial: MeshNormalMaterial,
    	MeshLambertMaterial: MeshLambertMaterial,
    	MeshDepthMaterial: MeshDepthMaterial,
    	MeshBasicMaterial: MeshBasicMaterial,
    	LineDashedMaterial: LineDashedMaterial,
    	LineBasicMaterial: LineBasicMaterial,
    	Material: Material
    });

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    exports.Cache = {

    	enabled: false,

    	files: {},

    	add: function ( key, file ) {

    		if ( this.enabled === false ) return;

    		// console.log( 'THREE.Cache', 'Adding key:', key );

    		this.files[ key ] = file;

    	},

    	get: function ( key ) {

    		if ( this.enabled === false ) return;

    		// console.log( 'THREE.Cache', 'Checking key:', key );

    		return this.files[ key ];

    	},

    	remove: function ( key ) {

    		delete this.files[ key ];

    	},

    	clear: function () {

    		this.files = {};

    	}

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function LoadingManager( onLoad, onProgress, onError ) {

    	var scope = this;

    	var isLoading = false, itemsLoaded = 0, itemsTotal = 0;

    	this.onStart = undefined;
    	this.onLoad = onLoad;
    	this.onProgress = onProgress;
    	this.onError = onError;

    	this.itemStart = function ( url ) {

    		itemsTotal ++;

    		if ( isLoading === false ) {

    			if ( scope.onStart !== undefined ) {

    				scope.onStart( url, itemsLoaded, itemsTotal );

    			}

    		}

    		isLoading = true;

    	};

    	this.itemEnd = function ( url ) {

    		itemsLoaded ++;

    		if ( scope.onProgress !== undefined ) {

    			scope.onProgress( url, itemsLoaded, itemsTotal );

    		}

    		if ( itemsLoaded === itemsTotal ) {

    			isLoading = false;

    			if ( scope.onLoad !== undefined ) {

    				scope.onLoad();

    			}

    		}

    	};

    	this.itemError = function ( url ) {

    		if ( scope.onError !== undefined ) {

    			scope.onError( url );

    		}

    	};

    }

    exports.DefaultLoadingManager = new LoadingManager();

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function XHRLoader( manager ) {

    	this.manager = ( manager !== undefined ) ? manager : exports.DefaultLoadingManager;

    }

    Object.assign( XHRLoader.prototype, {

    	load: function ( url, onLoad, onProgress, onError ) {

    		if ( this.path !== undefined ) url = this.path + url;

    		var scope = this;

    		var cached = exports.Cache.get( url );

    		if ( cached !== undefined ) {

    			scope.manager.itemStart( url );

    			setTimeout( function () {

    				if ( onLoad ) onLoad( cached );

    				scope.manager.itemEnd( url );

    			}, 0 );

    			return cached;

    		}

    		var request = new XMLHttpRequest();
    		request.open( 'GET', url, true );

    		request.addEventListener( 'load', function ( event ) {

    			var response = event.target.response;

    			exports.Cache.add( url, response );

    			if ( this.status === 200 ) {

    				if ( onLoad ) onLoad( response );

    				scope.manager.itemEnd( url );

    			} else if ( this.status === 0 ) {

    				// Some browsers return HTTP Status 0 when using non-http protocol
    				// e.g. 'file://' or 'data://'. Handle as success.

    				console.warn( 'THREE.XHRLoader: HTTP Status 0 received.' );

    				if ( onLoad ) onLoad( response );

    				scope.manager.itemEnd( url );

    			} else {

    				if ( onError ) onError( event );

    				scope.manager.itemError( url );

    			}

    		}, false );

    		if ( onProgress !== undefined ) {

    			request.addEventListener( 'progress', function ( event ) {

    				onProgress( event );

    			}, false );

    		}

    		request.addEventListener( 'error', function ( event ) {

    			if ( onError ) onError( event );

    			scope.manager.itemError( url );

    		}, false );

    		if ( this.responseType !== undefined ) request.responseType = this.responseType;
    		if ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;

    		if ( request.overrideMimeType ) request.overrideMimeType( 'text/plain' );

    		request.send( null );

    		scope.manager.itemStart( url );

    		return request;

    	},

    	setPath: function ( value ) {

    		this.path = value;
    		return this;

    	},

    	setResponseType: function ( value ) {

    		this.responseType = value;
    		return this;

    	},

    	setWithCredentials: function ( value ) {

    		this.withCredentials = value;
    		return this;

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     *
     * Abstract Base class to block based textures loader (dds, pvr, ...)
     */

    function CompressedTextureLoader( manager ) {

    	this.manager = ( manager !== undefined ) ? manager : exports.DefaultLoadingManager;

    	// override in sub classes
    	this._parser = null;

    }

    Object.assign( CompressedTextureLoader.prototype, {

    	load: function ( url, onLoad, onProgress, onError ) {

    		var scope = this;

    		var images = [];

    		var texture = new CompressedTexture();
    		texture.image = images;

    		var loader = new XHRLoader( this.manager );
    		loader.setPath( this.path );
    		loader.setResponseType( 'arraybuffer' );

    		function loadTexture( i ) {

    			loader.load( url[ i ], function ( buffer ) {

    				var texDatas = scope._parser( buffer, true );

    				images[ i ] = {
    					width: texDatas.width,
    					height: texDatas.height,
    					format: texDatas.format,
    					mipmaps: texDatas.mipmaps
    				};

    				loaded += 1;

    				if ( loaded === 6 ) {

    					if ( texDatas.mipmapCount === 1 )
    						texture.minFilter = LinearFilter;

    					texture.format = texDatas.format;
    					texture.needsUpdate = true;

    					if ( onLoad ) onLoad( texture );

    				}

    			}, onProgress, onError );

    		}

    		if ( Array.isArray( url ) ) {

    			var loaded = 0;

    			for ( var i = 0, il = url.length; i < il; ++ i ) {

    				loadTexture( i );

    			}

    		} else {

    			// compressed cubemap texture stored in a single DDS file

    			loader.load( url, function ( buffer ) {

    				var texDatas = scope._parser( buffer, true );

    				if ( texDatas.isCubemap ) {

    					var faces = texDatas.mipmaps.length / texDatas.mipmapCount;

    					for ( var f = 0; f < faces; f ++ ) {

    						images[ f ] = { mipmaps : [] };

    						for ( var i = 0; i < texDatas.mipmapCount; i ++ ) {

    							images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
    							images[ f ].format = texDatas.format;
    							images[ f ].width = texDatas.width;
    							images[ f ].height = texDatas.height;

    						}

    					}

    				} else {

    					texture.image.width = texDatas.width;
    					texture.image.height = texDatas.height;
    					texture.mipmaps = texDatas.mipmaps;

    				}

    				if ( texDatas.mipmapCount === 1 ) {

    					texture.minFilter = LinearFilter;

    				}

    				texture.format = texDatas.format;
    				texture.needsUpdate = true;

    				if ( onLoad ) onLoad( texture );

    			}, onProgress, onError );

    		}

    		return texture;

    	},

    	setPath: function ( value ) {

    		this.path = value;
    		return this;

    	}

    } );

    /**
     * @author Nikos M. / https://github.com/foo123/
     *
     * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
     */

    var DataTextureLoader = BinaryTextureLoader;
    function BinaryTextureLoader( manager ) {

    	this.manager = ( manager !== undefined ) ? manager : exports.DefaultLoadingManager;

    	// override in sub classes
    	this._parser = null;

    }

    Object.assign( BinaryTextureLoader.prototype, {

    	load: function ( url, onLoad, onProgress, onError ) {

    		var scope = this;

    		var texture = new DataTexture();

    		var loader = new XHRLoader( this.manager );
    		loader.setResponseType( 'arraybuffer' );

    		loader.load( url, function ( buffer ) {

    			var texData = scope._parser( buffer );

    			if ( ! texData ) return;

    			if ( undefined !== texData.image ) {

    				texture.image = texData.image;

    			} else if ( undefined !== texData.data ) {

    				texture.image.width = texData.width;
    				texture.image.height = texData.height;
    				texture.image.data = texData.data;

    			}

    			texture.wrapS = undefined !== texData.wrapS ? texData.wrapS : ClampToEdgeWrapping;
    			texture.wrapT = undefined !== texData.wrapT ? texData.wrapT : ClampToEdgeWrapping;

    			texture.magFilter = undefined !== texData.magFilter ? texData.magFilter : LinearFilter;
    			texture.minFilter = undefined !== texData.minFilter ? texData.minFilter : LinearMipMapLinearFilter;

    			texture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;

    			if ( undefined !== texData.format ) {

    				texture.format = texData.format;

    			}
    			if ( undefined !== texData.type ) {

    				texture.type = texData.type;

    			}

    			if ( undefined !== texData.mipmaps ) {

    				texture.mipmaps = texData.mipmaps;

    			}

    			if ( 1 === texData.mipmapCount ) {

    				texture.minFilter = LinearFilter;

    			}

    			texture.needsUpdate = true;

    			if ( onLoad ) onLoad( texture, texData );

    		}, onProgress, onError );


    		return texture;

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function ImageLoader( manager ) {

    	this.manager = ( manager !== undefined ) ? manager : exports.DefaultLoadingManager;

    }

    Object.assign( ImageLoader.prototype, {

    	load: function ( url, onLoad, onProgress, onError ) {

    		var scope = this;

    		var image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );
    		image.onload = function () {

    			image.onload = null;

    			URL.revokeObjectURL( image.src );

    			if ( onLoad ) onLoad( image );

    			scope.manager.itemEnd( url );

    		};

    		if ( url.indexOf( 'data:' ) === 0 ) {

    			image.src = url;

    		} else {

    			var loader = new XHRLoader();
    			loader.setPath( this.path );
    			loader.setResponseType( 'blob' );
    			loader.setWithCredentials( this.withCredentials );
    			loader.load( url, function ( blob ) {

    				image.src = URL.createObjectURL( blob );

    			}, onProgress, onError );

    		}

    		scope.manager.itemStart( url );

    		return image;

    	},

    	setCrossOrigin: function ( value ) {

    		this.crossOrigin = value;
    		return this;

    	},

    	setWithCredentials: function ( value ) {

    		this.withCredentials = value;
    		return this;

    	},

    	setPath: function ( value ) {

    		this.path = value;
    		return this;

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function CubeTextureLoader( manager ) {

    	this.manager = ( manager !== undefined ) ? manager : exports.DefaultLoadingManager;

    }

    Object.assign( CubeTextureLoader.prototype, {

    	load: function ( urls, onLoad, onProgress, onError ) {

    		var texture = new CubeTexture();

    		var loader = new ImageLoader( this.manager );
    		loader.setCrossOrigin( this.crossOrigin );
    		loader.setPath( this.path );

    		var loaded = 0;

    		function loadTexture( i ) {

    			loader.load( urls[ i ], function ( image ) {

    				texture.images[ i ] = image;

    				loaded ++;

    				if ( loaded === 6 ) {

    					texture.needsUpdate = true;

    					if ( onLoad ) onLoad( texture );

    				}

    			}, undefined, onError );

    		}

    		for ( var i = 0; i < urls.length; ++ i ) {

    			loadTexture( i );

    		}

    		return texture;

    	},

    	setCrossOrigin: function ( value ) {

    		this.crossOrigin = value;
    		return this;

    	},

    	setPath: function ( value ) {

    		this.path = value;
    		return this;

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function TextureLoader( manager ) {

    	this.manager = ( manager !== undefined ) ? manager : exports.DefaultLoadingManager;

    }

    Object.assign( TextureLoader.prototype, {

    	load: function ( url, onLoad, onProgress, onError ) {

    		var texture = new Texture();

    		var loader = new ImageLoader( this.manager );
    		loader.setCrossOrigin( this.crossOrigin );
    		loader.setWithCredentials( this.withCredentials );
    		loader.setPath( this.path );
    		loader.load( url, function ( image ) {

    			// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
    			var isJPEG = url.search( /\.(jpg|jpeg)$/ ) > 0 || url.search( /^data\:image\/jpeg/ ) === 0;

    			texture.format = isJPEG ? RGBFormat : RGBAFormat;
    			texture.image = image;
    			texture.needsUpdate = true;

    			if ( onLoad !== undefined ) {

    				onLoad( texture );

    			}

    		}, onProgress, onError );

    		return texture;

    	},

    	setCrossOrigin: function ( value ) {

    		this.crossOrigin = value;
    		return this;

    	},

    	setWithCredentials: function ( value ) {

    		this.withCredentials = value;
    		return this;

    	},

    	setPath: function ( value ) {

    		this.path = value;
    		return this;

    	}



    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     */

    function Light( color, intensity ) {

    	Object3D.call( this );

    	this.type = 'Light';

    	this.color = new Color( color );
    	this.intensity = intensity !== undefined ? intensity : 1;

    	this.receiveShadow = undefined;

    }

    Light.prototype = Object.assign( Object.create( Object3D.prototype ), {

    	constructor: Light,

    	isLight: true,

    	copy: function ( source ) {

    		Object3D.prototype.copy.call( this, source );

    		this.color.copy( source.color );
    		this.intensity = source.intensity;

    		return this;

    	},

    	toJSON: function ( meta ) {

    		var data = Object3D.prototype.toJSON.call( this, meta );

    		data.object.color = this.color.getHex();
    		data.object.intensity = this.intensity;

    		if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();

    		if ( this.distance !== undefined ) data.object.distance = this.distance;
    		if ( this.angle !== undefined ) data.object.angle = this.angle;
    		if ( this.decay !== undefined ) data.object.decay = this.decay;
    		if ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;

    		if ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();

    		return data;

    	}

    } );

    /**
     * @author alteredq / http://alteredqualia.com/
     */

    function HemisphereLight( skyColor, groundColor, intensity ) {

    	Light.call( this, skyColor, intensity );

    	this.type = 'HemisphereLight';

    	this.castShadow = undefined;

    	this.position.copy( Object3D.DefaultUp );
    	this.updateMatrix();

    	this.groundColor = new Color( groundColor );

    }

    HemisphereLight.prototype = Object.assign( Object.create( Light.prototype ), {

    	constructor: HemisphereLight,

    	isHemisphereLight: true,

    	copy: function ( source ) {

    		Light.prototype.copy.call( this, source );

    		this.groundColor.copy( source.groundColor );

    		return this;

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function LightShadow( camera ) {

    	this.camera = camera;

    	this.bias = 0;
    	this.radius = 1;

    	this.mapSize = new Vector2( 512, 512 );

    	this.map = null;
    	this.matrix = new Matrix4();

    }

    Object.assign( LightShadow.prototype, {

    	copy: function ( source ) {

    		this.camera = source.camera.clone();

    		this.bias = source.bias;
    		this.radius = source.radius;

    		this.mapSize.copy( source.mapSize );

    		return this;

    	},

    	clone: function () {

    		return new this.constructor().copy( this );

    	},

    	toJSON: function () {

    		var object = {};

    		if ( this.bias !== 0 ) object.bias = this.bias;
    		if ( this.radius !== 1 ) object.radius = this.radius;
    		if ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();

    		object.camera = this.camera.toJSON( false ).object;
    		delete object.camera.matrix;

    		return object;

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function SpotLightShadow() {

    	LightShadow.call( this, new PerspectiveCamera( 50, 1, 0.5, 500 ) );

    }

    SpotLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {

    	constructor: SpotLightShadow,

    	isSpotLightShadow: true,

    	update: function ( light ) {

    		var fov = exports.Math.RAD2DEG * 2 * light.angle;
    		var aspect = this.mapSize.width / this.mapSize.height;
    		var far = light.distance || 500;

    		var camera = this.camera;

    		if ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {

    			camera.fov = fov;
    			camera.aspect = aspect;
    			camera.far = far;
    			camera.updateProjectionMatrix();

    		}

    	}

    } );

    /**
     * @author alteredq / http://alteredqualia.com/
     */

    function SpotLight( color, intensity, distance, angle, penumbra, decay ) {

    	Light.call( this, color, intensity );

    	this.type = 'SpotLight';

    	this.position.copy( Object3D.DefaultUp );
    	this.updateMatrix();

    	this.target = new Object3D();

    	Object.defineProperty( this, 'power', {
    		get: function () {
    			// intensity = power per solid angle.
    			// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
    			return this.intensity * Math.PI;
    		},
    		set: function ( power ) {
    			// intensity = power per solid angle.
    			// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
    			this.intensity = power / Math.PI;
    		}
    	} );

    	this.distance = ( distance !== undefined ) ? distance : 0;
    	this.angle = ( angle !== undefined ) ? angle : Math.PI / 3;
    	this.penumbra = ( penumbra !== undefined ) ? penumbra : 0;
    	this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.

    	this.shadow = new SpotLightShadow();

    }

    SpotLight.prototype = Object.assign( Object.create( Light.prototype ), {

    	constructor: SpotLight,

    	isSpotLight: true,

    	copy: function ( source ) {

    		Light.prototype.copy.call( this, source );

    		this.distance = source.distance;
    		this.angle = source.angle;
    		this.penumbra = source.penumbra;
    		this.decay = source.decay;

    		this.target = source.target.clone();

    		this.shadow = source.shadow.clone();

    		return this;

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     */


    function PointLight( color, intensity, distance, decay ) {

    	Light.call( this, color, intensity );

    	this.type = 'PointLight';

    	Object.defineProperty( this, 'power', {
    		get: function () {
    			// intensity = power per solid angle.
    			// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
    			return this.intensity * 4 * Math.PI;

    		},
    		set: function ( power ) {
    			// intensity = power per solid angle.
    			// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
    			this.intensity = power / ( 4 * Math.PI );
    		}
    	} );

    	this.distance = ( distance !== undefined ) ? distance : 0;
    	this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.

    	this.shadow = new LightShadow( new PerspectiveCamera( 90, 1, 0.5, 500 ) );

    }

    PointLight.prototype = Object.assign( Object.create( Light.prototype ), {

    	constructor: PointLight,

    	isPointLight: true,

    	copy: function ( source ) {

    		Light.prototype.copy.call( this, source );

    		this.distance = source.distance;
    		this.decay = source.decay;

    		this.shadow = source.shadow.clone();

    		return this;

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function DirectionalLightShadow( light ) {

    	LightShadow.call( this, new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );

    }

    DirectionalLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {

    	constructor: DirectionalLightShadow

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     */

    function DirectionalLight( color, intensity ) {

    	Light.call( this, color, intensity );

    	this.type = 'DirectionalLight';

    	this.position.copy( Object3D.DefaultUp );
    	this.updateMatrix();

    	this.target = new Object3D();

    	this.shadow = new DirectionalLightShadow();

    }

    DirectionalLight.prototype = Object.assign( Object.create( Light.prototype ), {

    	constructor: DirectionalLight,

    	isDirectionalLight: true,

    	copy: function ( source ) {

    		Light.prototype.copy.call( this, source );

    		this.target = source.target.clone();

    		this.shadow = source.shadow.clone();

    		return this;

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function AmbientLight( color, intensity ) {

    	Light.call( this, color, intensity );

    	this.type = 'AmbientLight';

    	this.castShadow = undefined;

    }

    AmbientLight.prototype = Object.assign( Object.create( Light.prototype ), {

    	constructor: AmbientLight,

    	isAmbientLight: true,

    } );

    /**
     * @author tschw
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     */

    exports.AnimationUtils = {

    	// same as Array.prototype.slice, but also works on typed arrays
    	arraySlice: function( array, from, to ) {

    		if ( exports.AnimationUtils.isTypedArray( array ) ) {

    			return new array.constructor( array.subarray( from, to ) );

    		}

    		return array.slice( from, to );

    	},

    	// converts an array to a specific type
    	convertArray: function( array, type, forceClone ) {

    		if ( ! array || // let 'undefined' and 'null' pass
    				! forceClone && array.constructor === type ) return array;

    		if ( typeof type.BYTES_PER_ELEMENT === 'number' ) {

    			return new type( array ); // create typed array

    		}

    		return Array.prototype.slice.call( array ); // create Array

    	},

    	isTypedArray: function( object ) {

    		return ArrayBuffer.isView( object ) &&
    				! ( object instanceof DataView );

    	},

    	// returns an array by which times and values can be sorted
    	getKeyframeOrder: function( times ) {

    		function compareTime( i, j ) {

    			return times[ i ] - times[ j ];

    		}

    		var n = times.length;
    		var result = new Array( n );
    		for ( var i = 0; i !== n; ++ i ) result[ i ] = i;

    		result.sort( compareTime );

    		return result;

    	},

    	// uses the array previously returned by 'getKeyframeOrder' to sort data
    	sortedArray: function( values, stride, order ) {

    		var nValues = values.length;
    		var result = new values.constructor( nValues );

    		for ( var i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {

    			var srcOffset = order[ i ] * stride;

    			for ( var j = 0; j !== stride; ++ j ) {

    				result[ dstOffset ++ ] = values[ srcOffset + j ];

    			}

    		}

    		return result;

    	},

    	// function for parsing AOS keyframe formats
    	flattenJSON: function( jsonKeys, times, values, valuePropertyName ) {

    		var i = 1, key = jsonKeys[ 0 ];

    		while ( key !== undefined && key[ valuePropertyName ] === undefined ) {

    			key = jsonKeys[ i ++ ];

    		}

    		if ( key === undefined ) return; // no data

    		var value = key[ valuePropertyName ];
    		if ( value === undefined ) return; // no data

    		if ( Array.isArray( value ) ) {

    			do {

    				value = key[ valuePropertyName ];

    				if ( value !== undefined ) {

    					times.push( key.time );
    					values.push.apply( values, value ); // push all elements

    				}

    				key = jsonKeys[ i ++ ];

    			} while ( key !== undefined );

    		} else if ( value.toArray !== undefined ) {
    			// ...assume THREE.Math-ish

    			do {

    				value = key[ valuePropertyName ];

    				if ( value !== undefined ) {

    					times.push( key.time );
    					value.toArray( values, values.length );

    				}

    				key = jsonKeys[ i ++ ];

    			} while ( key !== undefined );

    		} else {
    			// otherwise push as-is

    			do {

    				value = key[ valuePropertyName ];

    				if ( value !== undefined ) {

    					times.push( key.time );
    					values.push( value );

    				}

    				key = jsonKeys[ i ++ ];

    			} while ( key !== undefined );

    		}

    	}

    };

    /**
     * Abstract base class of interpolants over parametric samples.
     *
     * The parameter domain is one dimensional, typically the time or a path
     * along a curve defined by the data.
     *
     * The sample values can have any dimensionality and derived classes may
     * apply special interpretations to the data.
     *
     * This class provides the interval seek in a Template Method, deferring
     * the actual interpolation to derived classes.
     *
     * Time complexity is O(1) for linear access crossing at most two points
     * and O(log N) for random access, where N is the number of positions.
     *
     * References:
     *
     * 		http://www.oodesign.com/template-method-pattern.html
     *
     * @author tschw
     */

    function Interpolant(
    		parameterPositions, sampleValues, sampleSize, resultBuffer ) {

    	this.parameterPositions = parameterPositions;
    	this._cachedIndex = 0;

    	this.resultBuffer = resultBuffer !== undefined ?
    			resultBuffer : new sampleValues.constructor( sampleSize );
    	this.sampleValues = sampleValues;
    	this.valueSize = sampleSize;

    }

    Interpolant.prototype = {

    	constructor: Interpolant,

    	evaluate: function( t ) {

    		var pp = this.parameterPositions,
    			i1 = this._cachedIndex,

    			t1 = pp[   i1   ],
    			t0 = pp[ i1 - 1 ];

    		validate_interval: {

    			seek: {

    				var right;

    				linear_scan: {
    //- See http://jsperf.com/comparison-to-undefined/3
    //- slower code:
    //-
    //- 				if ( t >= t1 || t1 === undefined ) {
    					forward_scan: if ( ! ( t < t1 ) ) {

    						for ( var giveUpAt = i1 + 2; ;) {

    							if ( t1 === undefined ) {

    								if ( t < t0 ) break forward_scan;

    								// after end

    								i1 = pp.length;
    								this._cachedIndex = i1;
    								return this.afterEnd_( i1 - 1, t, t0 );

    							}

    							if ( i1 === giveUpAt ) break; // this loop

    							t0 = t1;
    							t1 = pp[ ++ i1 ];

    							if ( t < t1 ) {

    								// we have arrived at the sought interval
    								break seek;

    							}

    						}

    						// prepare binary search on the right side of the index
    						right = pp.length;
    						break linear_scan;

    					}

    //- slower code:
    //-					if ( t < t0 || t0 === undefined ) {
    					if ( ! ( t >= t0 ) ) {

    						// looping?

    						var t1global = pp[ 1 ];

    						if ( t < t1global ) {

    							i1 = 2; // + 1, using the scan for the details
    							t0 = t1global;

    						}

    						// linear reverse scan

    						for ( var giveUpAt = i1 - 2; ;) {

    							if ( t0 === undefined ) {

    								// before start

    								this._cachedIndex = 0;
    								return this.beforeStart_( 0, t, t1 );

    							}

    							if ( i1 === giveUpAt ) break; // this loop

    							t1 = t0;
    							t0 = pp[ -- i1 - 1 ];

    							if ( t >= t0 ) {

    								// we have arrived at the sought interval
    								break seek;

    							}

    						}

    						// prepare binary search on the left side of the index
    						right = i1;
    						i1 = 0;
    						break linear_scan;

    					}

    					// the interval is valid

    					break validate_interval;

    				} // linear scan

    				// binary search

    				while ( i1 < right ) {

    					var mid = ( i1 + right ) >>> 1;

    					if ( t < pp[ mid ] ) {

    						right = mid;

    					} else {

    						i1 = mid + 1;

    					}

    				}

    				t1 = pp[   i1   ];
    				t0 = pp[ i1 - 1 ];

    				// check boundary cases, again

    				if ( t0 === undefined ) {

    					this._cachedIndex = 0;
    					return this.beforeStart_( 0, t, t1 );

    				}

    				if ( t1 === undefined ) {

    					i1 = pp.length;
    					this._cachedIndex = i1;
    					return this.afterEnd_( i1 - 1, t0, t );

    				}

    			} // seek

    			this._cachedIndex = i1;

    			this.intervalChanged_( i1, t0, t1 );

    		} // validate_interval

    		return this.interpolate_( i1, t0, t, t1 );

    	},

    	settings: null, // optional, subclass-specific settings structure
    	// Note: The indirection allows central control of many interpolants.

    	// --- Protected interface

    	DefaultSettings_: {},

    	getSettings_: function() {

    		return this.settings || this.DefaultSettings_;

    	},

    	copySampleValue_: function( index ) {

    		// copies a sample value to the result buffer

    		var result = this.resultBuffer,
    			values = this.sampleValues,
    			stride = this.valueSize,
    			offset = index * stride;

    		for ( var i = 0; i !== stride; ++ i ) {

    			result[ i ] = values[ offset + i ];

    		}

    		return result;

    	},

    	// Template methods for derived classes:

    	interpolate_: function( i1, t0, t, t1 ) {

    		throw new Error( "call to abstract method" );
    		// implementations shall return this.resultBuffer

    	},

    	intervalChanged_: function( i1, t0, t1 ) {

    		// empty

    	}

    };

    Object.assign( Interpolant.prototype, {

    	beforeStart_: //( 0, t, t0 ), returns this.resultBuffer
    		Interpolant.prototype.copySampleValue_,

    	afterEnd_: //( N-1, tN-1, t ), returns this.resultBuffer
    		Interpolant.prototype.copySampleValue_

    } );

    /**
     * Fast and simple cubic spline interpolant.
     *
     * It was derived from a Hermitian construction setting the first derivative
     * at each sample position to the linear slope between neighboring positions
     * over their parameter interval.
     *
     * @author tschw
     */

    function CubicInterpolant(
    		parameterPositions, sampleValues, sampleSize, resultBuffer ) {

    	Interpolant.call(
    			this, parameterPositions, sampleValues, sampleSize, resultBuffer );

    	this._weightPrev = -0;
    	this._offsetPrev = -0;
    	this._weightNext = -0;
    	this._offsetNext = -0;

    }

    CubicInterpolant.prototype =
    		Object.assign( Object.create( Interpolant.prototype ), {

    	constructor: CubicInterpolant,

    	DefaultSettings_: {

    		endingStart: 	ZeroCurvatureEnding,
    		endingEnd:		ZeroCurvatureEnding

    	},

    	intervalChanged_: function( i1, t0, t1 ) {

    		var pp = this.parameterPositions,
    			iPrev = i1 - 2,
    			iNext = i1 + 1,

    			tPrev = pp[ iPrev ],
    			tNext = pp[ iNext ];

    		if ( tPrev === undefined ) {

    			switch ( this.getSettings_().endingStart ) {

    				case ZeroSlopeEnding:

    					// f'(t0) = 0
    					iPrev = i1;
    					tPrev = 2 * t0 - t1;

    					break;

    				case WrapAroundEnding:

    					// use the other end of the curve
    					iPrev = pp.length - 2;
    					tPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];

    					break;

    				default: // ZeroCurvatureEnding

    					// f''(t0) = 0 a.k.a. Natural Spline
    					iPrev = i1;
    					tPrev = t1;

    			}

    		}

    		if ( tNext === undefined ) {

    			switch ( this.getSettings_().endingEnd ) {

    				case ZeroSlopeEnding:

    					// f'(tN) = 0
    					iNext = i1;
    					tNext = 2 * t1 - t0;

    					break;

    				case WrapAroundEnding:

    					// use the other end of the curve
    					iNext = 1;
    					tNext = t1 + pp[ 1 ] - pp[ 0 ];

    					break;

    				default: // ZeroCurvatureEnding

    					// f''(tN) = 0, a.k.a. Natural Spline
    					iNext = i1 - 1;
    					tNext = t0;

    			}

    		}

    		var halfDt = ( t1 - t0 ) * 0.5,
    			stride = this.valueSize;

    		this._weightPrev = halfDt / ( t0 - tPrev );
    		this._weightNext = halfDt / ( tNext - t1 );
    		this._offsetPrev = iPrev * stride;
    		this._offsetNext = iNext * stride;

    	},

    	interpolate_: function( i1, t0, t, t1 ) {

    		var result = this.resultBuffer,
    			values = this.sampleValues,
    			stride = this.valueSize,

    			o1 = i1 * stride,		o0 = o1 - stride,
    			oP = this._offsetPrev, 	oN = this._offsetNext,
    			wP = this._weightPrev,	wN = this._weightNext,

    			p = ( t - t0 ) / ( t1 - t0 ),
    			pp = p * p,
    			ppp = pp * p;

    		// evaluate polynomials

    		var sP =     - wP   * ppp   +         2 * wP    * pp    -          wP   * p;
    		var s0 = ( 1 + wP ) * ppp   + (-1.5 - 2 * wP )  * pp    + ( -0.5 + wP ) * p     + 1;
    		var s1 = (-1 - wN ) * ppp   + ( 1.5 +   wN   )  * pp    +    0.5        * p;
    		var sN =       wN   * ppp   -           wN      * pp;

    		// combine data linearly

    		for ( var i = 0; i !== stride; ++ i ) {

    			result[ i ] =
    					sP * values[ oP + i ] +
    					s0 * values[ o0 + i ] +
    					s1 * values[ o1 + i ] +
    					sN * values[ oN + i ];

    		}

    		return result;

    	}

    } );

    /**
     * @author tschw
     */

    function LinearInterpolant(
    		parameterPositions, sampleValues, sampleSize, resultBuffer ) {

    	Interpolant.call(
    			this, parameterPositions, sampleValues, sampleSize, resultBuffer );

    }

    LinearInterpolant.prototype =
    		Object.assign( Object.create( Interpolant.prototype ), {

    	constructor: LinearInterpolant,

    	interpolate_: function( i1, t0, t, t1 ) {

    		var result = this.resultBuffer,
    			values = this.sampleValues,
    			stride = this.valueSize,

    			offset1 = i1 * stride,
    			offset0 = offset1 - stride,

    			weight1 = ( t - t0 ) / ( t1 - t0 ),
    			weight0 = 1 - weight1;

    		for ( var i = 0; i !== stride; ++ i ) {

    			result[ i ] =
    					values[ offset0 + i ] * weight0 +
    					values[ offset1 + i ] * weight1;

    		}

    		return result;

    	}

    } );

    /**
     *
     * Interpolant that evaluates to the sample value at the position preceeding
     * the parameter.
     *
     * @author tschw
     */

    function DiscreteInterpolant(
    		parameterPositions, sampleValues, sampleSize, resultBuffer ) {

    	Interpolant.call(
    			this, parameterPositions, sampleValues, sampleSize, resultBuffer );

    }

    DiscreteInterpolant.prototype =
    		Object.assign( Object.create( Interpolant.prototype ), {

    	constructor: DiscreteInterpolant,

    	interpolate_: function( i1, t0, t, t1 ) {

    		return this.copySampleValue_( i1 - 1 );

    	}

    } );

    var KeyframeTrackPrototype;

    KeyframeTrackPrototype = {

    	TimeBufferType: Float32Array,
    	ValueBufferType: Float32Array,

    	DefaultInterpolation: InterpolateLinear,

    	InterpolantFactoryMethodDiscrete: function( result ) {

    		return new DiscreteInterpolant(
    				this.times, this.values, this.getValueSize(), result );

    	},

    	InterpolantFactoryMethodLinear: function( result ) {

    		return new LinearInterpolant(
    				this.times, this.values, this.getValueSize(), result );

    	},

    	InterpolantFactoryMethodSmooth: function( result ) {

    		return new CubicInterpolant(
    				this.times, this.values, this.getValueSize(), result );

    	},

    	setInterpolation: function( interpolation ) {

    		var factoryMethod;

    		switch ( interpolation ) {

    			case InterpolateDiscrete:

    				factoryMethod = this.InterpolantFactoryMethodDiscrete;

    				break;

    			case InterpolateLinear:

    				factoryMethod = this.InterpolantFactoryMethodLinear;

    				break;

    			case InterpolateSmooth:

    				factoryMethod = this.InterpolantFactoryMethodSmooth;

    				break;

    		}

    		if ( factoryMethod === undefined ) {

    			var message = "unsupported interpolation for " +
    					this.ValueTypeName + " keyframe track named " + this.name;

    			if ( this.createInterpolant === undefined ) {

    				// fall back to default, unless the default itself is messed up
    				if ( interpolation !== this.DefaultInterpolation ) {

    					this.setInterpolation( this.DefaultInterpolation );

    				} else {

    					throw new Error( message ); // fatal, in this case

    				}

    			}

    			console.warn( message );
    			return;

    		}

    		this.createInterpolant = factoryMethod;

    	},

    	getInterpolation: function() {

    		switch ( this.createInterpolant ) {

    			case this.InterpolantFactoryMethodDiscrete:

    				return InterpolateDiscrete;

    			case this.InterpolantFactoryMethodLinear:

    				return InterpolateLinear;

    			case this.InterpolantFactoryMethodSmooth:

    				return InterpolateSmooth;

    		}

    	},

    	getValueSize: function() {

    		return this.values.length / this.times.length;

    	},

    	// move all keyframes either forwards or backwards in time
    	shift: function( timeOffset ) {

    		if( timeOffset !== 0.0 ) {

    			var times = this.times;

    			for( var i = 0, n = times.length; i !== n; ++ i ) {

    				times[ i ] += timeOffset;

    			}

    		}

    		return this;

    	},

    	// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
    	scale: function( timeScale ) {

    		if( timeScale !== 1.0 ) {

    			var times = this.times;

    			for( var i = 0, n = times.length; i !== n; ++ i ) {

    				times[ i ] *= timeScale;

    			}

    		}

    		return this;

    	},

    	// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
    	// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
    	trim: function( startTime, endTime ) {

    		var times = this.times,
    			nKeys = times.length,
    			from = 0,
    			to = nKeys - 1;

    		while ( from !== nKeys && times[ from ] < startTime ) ++ from;
    		while ( to !== -1 && times[ to ] > endTime ) -- to;

    		++ to; // inclusive -> exclusive bound

    		if( from !== 0 || to !== nKeys ) {

    			// empty tracks are forbidden, so keep at least one keyframe
    			if ( from >= to ) to = Math.max( to , 1 ), from = to - 1;

    			var stride = this.getValueSize();
    			this.times = exports.AnimationUtils.arraySlice( times, from, to );
    			this.values = exports.AnimationUtils.
    					arraySlice( this.values, from * stride, to * stride );

    		}

    		return this;

    	},

    	// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
    	validate: function() {

    		var valid = true;

    		var valueSize = this.getValueSize();
    		if ( valueSize - Math.floor( valueSize ) !== 0 ) {

    			console.error( "invalid value size in track", this );
    			valid = false;

    		}

    		var times = this.times,
    			values = this.values,

    			nKeys = times.length;

    		if( nKeys === 0 ) {

    			console.error( "track is empty", this );
    			valid = false;

    		}

    		var prevTime = null;

    		for( var i = 0; i !== nKeys; i ++ ) {

    			var currTime = times[ i ];

    			if ( typeof currTime === 'number' && isNaN( currTime ) ) {

    				console.error( "time is not a valid number", this, i, currTime );
    				valid = false;
    				break;

    			}

    			if( prevTime !== null && prevTime > currTime ) {

    				console.error( "out of order keys", this, i, currTime, prevTime );
    				valid = false;
    				break;

    			}

    			prevTime = currTime;

    		}

    		if ( values !== undefined ) {

    			if ( exports.AnimationUtils.isTypedArray( values ) ) {

    				for ( var i = 0, n = values.length; i !== n; ++ i ) {

    					var value = values[ i ];

    					if ( isNaN( value ) ) {

    						console.error( "value is not a valid number", this, i, value );
    						valid = false;
    						break;

    					}

    				}

    			}

    		}

    		return valid;

    	},

    	// removes equivalent sequential keys as common in morph target sequences
    	// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
    	optimize: function() {

    		var times = this.times,
    			values = this.values,
    			stride = this.getValueSize(),

    			smoothInterpolation = this.getInterpolation() === InterpolateSmooth,

    			writeIndex = 1,
    			lastIndex = times.length - 1;

    		for( var i = 1; i < lastIndex; ++ i ) {

    			var keep = false;

    			var time = times[ i ];
    			var timeNext = times[ i + 1 ];

    			// remove adjacent keyframes scheduled at the same time

    			if ( time !== timeNext && ( i !== 1 || time !== time[ 0 ] ) ) {

    				if ( ! smoothInterpolation ) {

    					// remove unnecessary keyframes same as their neighbors

    					var offset = i * stride,
    						offsetP = offset - stride,
    						offsetN = offset + stride;

    					for ( var j = 0; j !== stride; ++ j ) {

    						var value = values[ offset + j ];

    						if ( value !== values[ offsetP + j ] ||
    								value !== values[ offsetN + j ] ) {

    							keep = true;
    							break;

    						}

    					}

    				} else keep = true;

    			}

    			// in-place compaction

    			if ( keep ) {

    				if ( i !== writeIndex ) {

    					times[ writeIndex ] = times[ i ];

    					var readOffset = i * stride,
    						writeOffset = writeIndex * stride;

    					for ( var j = 0; j !== stride; ++ j )

    						values[ writeOffset + j ] = values[ readOffset + j ];

    				}

    				++ writeIndex;

    			}

    		}

    		// flush last keyframe (compaction looks ahead)

    		if ( lastIndex > 0 ) {

    			times[ writeIndex ] = times[ lastIndex ];

    			for ( var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j )

    				values[ writeOffset + j ] = values[ readOffset + j ];

    			++ writeIndex;

    		}

    		if ( writeIndex !== times.length ) {

    			this.times = exports.AnimationUtils.arraySlice( times, 0, writeIndex );
    			this.values = exports.AnimationUtils.arraySlice( values, 0, writeIndex * stride );

    		}

    		return this;

    	}

    }

    function KeyframeTrackConstructor( name, times, values, interpolation ) {

    	if( name === undefined ) throw new Error( "track name is undefined" );

    	if( times === undefined || times.length === 0 ) {

    		throw new Error( "no keyframes in track named " + name );

    	}

    	this.name = name;

    	this.times = exports.AnimationUtils.convertArray( times, this.TimeBufferType );
    	this.values = exports.AnimationUtils.convertArray( values, this.ValueBufferType );

    	this.setInterpolation( interpolation || this.DefaultInterpolation );

    	this.validate();
    	this.optimize();

    }

    /**
     *
     * A Track of vectored keyframe values.
     *
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */

    function VectorKeyframeTrack( name, times, values, interpolation ) {

    	KeyframeTrackConstructor.call( this, name, times, values, interpolation );

    }

    VectorKeyframeTrack.prototype =
    		Object.assign( Object.create( KeyframeTrackPrototype ), {

    	constructor: VectorKeyframeTrack,

    	ValueTypeName: 'vector'

    	// ValueBufferType is inherited

    	// DefaultInterpolation is inherited

    } );

    /**
     * Spherical linear unit quaternion interpolant.
     *
     * @author tschw
     */

    function QuaternionLinearInterpolant(
    		parameterPositions, sampleValues, sampleSize, resultBuffer ) {

    	Interpolant.call(
    			this, parameterPositions, sampleValues, sampleSize, resultBuffer );

    }

    QuaternionLinearInterpolant.prototype =
    		Object.assign( Object.create( Interpolant.prototype ), {

    	constructor: QuaternionLinearInterpolant,

    	interpolate_: function( i1, t0, t, t1 ) {

    		var result = this.resultBuffer,
    			values = this.sampleValues,
    			stride = this.valueSize,

    			offset = i1 * stride,

    			alpha = ( t - t0 ) / ( t1 - t0 );

    		for ( var end = offset + stride; offset !== end; offset += 4 ) {

    			Quaternion.slerpFlat( result, 0,
    					values, offset - stride, values, offset, alpha );

    		}

    		return result;

    	}

    } );

    /**
     *
     * A Track of quaternion keyframe values.
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */

    function QuaternionKeyframeTrack( name, times, values, interpolation ) {

    	KeyframeTrackConstructor.call( this, name, times, values, interpolation );

    }

    QuaternionKeyframeTrack.prototype =
    		Object.assign( Object.create( KeyframeTrackPrototype ), {

    	constructor: QuaternionKeyframeTrack,

    	ValueTypeName: 'quaternion',

    	// ValueBufferType is inherited

    	DefaultInterpolation: InterpolateLinear,

    	InterpolantFactoryMethodLinear: function( result ) {

    		return new QuaternionLinearInterpolant(
    				this.times, this.values, this.getValueSize(), result );

    	},

    	InterpolantFactoryMethodSmooth: undefined // not yet implemented

    } );

    /**
     *
     * A Track of numeric keyframe values.
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */

    function NumberKeyframeTrack( name, times, values, interpolation ) {

    	KeyframeTrackConstructor.call( this, name, times, values, interpolation );

    }

    NumberKeyframeTrack.prototype =
    		Object.assign( Object.create( KeyframeTrackPrototype ), {

    	constructor: NumberKeyframeTrack,

    	ValueTypeName: 'number',

    	// ValueBufferType is inherited

    	// DefaultInterpolation is inherited

    } );

    /**
     *
     * A Track that interpolates Strings
     *
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */

    function StringKeyframeTrack( name, times, values, interpolation ) {

    	KeyframeTrackConstructor.call( this, name, times, values, interpolation );

    }

    StringKeyframeTrack.prototype =
    		Object.assign( Object.create( KeyframeTrackPrototype ), {

    	constructor: StringKeyframeTrack,

    	ValueTypeName: 'string',
    	ValueBufferType: Array,

    	DefaultInterpolation: InterpolateDiscrete,

    	InterpolantFactoryMethodLinear: undefined,

    	InterpolantFactoryMethodSmooth: undefined

    } );

    /**
     *
     * A Track of Boolean keyframe values.
     *
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */

    function BooleanKeyframeTrack( name, times, values ) {

    	KeyframeTrackConstructor.call( this, name, times, values );

    }

    BooleanKeyframeTrack.prototype =
    		Object.assign( Object.create( KeyframeTrackPrototype ), {

    	constructor: BooleanKeyframeTrack,

    	ValueTypeName: 'bool',
    	ValueBufferType: Array,

    	DefaultInterpolation: InterpolateDiscrete,

    	InterpolantFactoryMethodLinear: undefined,
    	InterpolantFactoryMethodSmooth: undefined

    	// Note: Actually this track could have a optimized / compressed
    	// representation of a single value and a custom interpolant that
    	// computes "firstValue ^ isOdd( index )".

    } );

    /**
     *
     * A Track of keyframe values that represent color.
     *
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */

    function ColorKeyframeTrack( name, times, values, interpolation ) {

    	KeyframeTrackConstructor.call( this, name, times, values, interpolation );

    }

    ColorKeyframeTrack.prototype =
    		Object.assign( Object.create( KeyframeTrackPrototype ), {

    	constructor: ColorKeyframeTrack,

    	ValueTypeName: 'color'

    	// ValueBufferType is inherited

    	// DefaultInterpolation is inherited


    	// Note: Very basic implementation and nothing special yet.
    	// However, this is the place for color space parameterization.

    } );

    /**
     *
     * A timed sequence of keyframes for a specific property.
     *
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */

    function KeyframeTrack( name, times, values, interpolation ) {

    	KeyframeTrackConstructor.apply( this, arguments );

    }

    KeyframeTrack.prototype = KeyframeTrackPrototype;
    KeyframeTrackPrototype.constructor = KeyframeTrack;

    // Static methods:

    Object.assign( KeyframeTrack, {

    	// Serialization (in static context, because of constructor invocation
    	// and automatic invocation of .toJSON):

    	parse: function( json ) {

    		if( json.type === undefined ) {

    			throw new Error( "track type undefined, can not parse" );

    		}

    		var trackType = KeyframeTrack._getTrackTypeForValueTypeName( json.type );

    		if ( json.times === undefined ) {

    			var times = [], values = [];

    			exports.AnimationUtils.flattenJSON( json.keys, times, values, 'value' );

    			json.times = times;
    			json.values = values;

    		}

    		// derived classes can define a static parse method
    		if ( trackType.parse !== undefined ) {

    			return trackType.parse( json );

    		} else {

    			// by default, we asssume a constructor compatible with the base
    			return new trackType(
    					json.name, json.times, json.values, json.interpolation );

    		}

    	},

    	toJSON: function( track ) {

    		var trackType = track.constructor;

    		var json;

    		// derived classes can define a static toJSON method
    		if ( trackType.toJSON !== undefined ) {

    			json = trackType.toJSON( track );

    		} else {

    			// by default, we assume the data can be serialized as-is
    			json = {

    				'name': track.name,
    				'times': exports.AnimationUtils.convertArray( track.times, Array ),
    				'values': exports.AnimationUtils.convertArray( track.values, Array )

    			};

    			var interpolation = track.getInterpolation();

    			if ( interpolation !== track.DefaultInterpolation ) {

    				json.interpolation = interpolation;

    			}

    		}

    		json.type = track.ValueTypeName; // mandatory

    		return json;

    	},

    	_getTrackTypeForValueTypeName: function( typeName ) {

    		switch( typeName.toLowerCase() ) {

    			case "scalar":
    			case "double":
    			case "float":
    			case "number":
    			case "integer":

    				return NumberKeyframeTrack;

    			case "vector":
    			case "vector2":
    			case "vector3":
    			case "vector4":

    				return VectorKeyframeTrack;

    			case "color":

    				return ColorKeyframeTrack;

    			case "quaternion":

    				return QuaternionKeyframeTrack;

    			case "bool":
    			case "boolean":

    				return BooleanKeyframeTrack;

    			case "string":

    				return StringKeyframeTrack;

    		}

    		throw new Error( "Unsupported typeName: " + typeName );

    	}

    } );

    /**
     *
     * Reusable set of Tracks that represent an animation.
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     */

    function AnimationClip( name, duration, tracks ) {

    	this.name = name;
    	this.tracks = tracks;
    	this.duration = ( duration !== undefined ) ? duration : -1;

    	this.uuid = exports.Math.generateUUID();

    	// this means it should figure out its duration by scanning the tracks
    	if ( this.duration < 0 ) {

    		this.resetDuration();

    	}

    	this.optimize();

    }

    AnimationClip.prototype = {

    	constructor: AnimationClip,

    	resetDuration: function() {

    		var tracks = this.tracks,
    			duration = 0;

    		for ( var i = 0, n = tracks.length; i !== n; ++ i ) {

    			var track = this.tracks[ i ];

    			duration = Math.max(
    					duration, track.times[ track.times.length - 1 ] );

    		}

    		this.duration = duration;

    	},

    	trim: function() {

    		for ( var i = 0; i < this.tracks.length; i ++ ) {

    			this.tracks[ i ].trim( 0, this.duration );

    		}

    		return this;

    	},

    	optimize: function() {

    		for ( var i = 0; i < this.tracks.length; i ++ ) {

    			this.tracks[ i ].optimize();

    		}

    		return this;

    	}

    };

    // Static methods:

    Object.assign( AnimationClip, {

    	parse: function( json ) {

    		var tracks = [],
    			jsonTracks = json.tracks,
    			frameTime = 1.0 / ( json.fps || 1.0 );

    		for ( var i = 0, n = jsonTracks.length; i !== n; ++ i ) {

    			tracks.push( KeyframeTrack.parse( jsonTracks[ i ] ).scale( frameTime ) );

    		}

    		return new AnimationClip( json.name, json.duration, tracks );

    	},


    	toJSON: function( clip ) {

    		var tracks = [],
    			clipTracks = clip.tracks;

    		var json = {

    			'name': clip.name,
    			'duration': clip.duration,
    			'tracks': tracks

    		};

    		for ( var i = 0, n = clipTracks.length; i !== n; ++ i ) {

    			tracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );

    		}

    		return json;

    	},


    	CreateFromMorphTargetSequence: function( name, morphTargetSequence, fps, noLoop ) {

    		var numMorphTargets = morphTargetSequence.length;
    		var tracks = [];

    		for ( var i = 0; i < numMorphTargets; i ++ ) {

    			var times = [];
    			var values = [];

    			times.push(
    					( i + numMorphTargets - 1 ) % numMorphTargets,
    					i,
    					( i + 1 ) % numMorphTargets );

    			values.push( 0, 1, 0 );

    			var order = exports.AnimationUtils.getKeyframeOrder( times );
    			times = exports.AnimationUtils.sortedArray( times, 1, order );
    			values = exports.AnimationUtils.sortedArray( values, 1, order );

    			// if there is a key at the first frame, duplicate it as the
    			// last frame as well for perfect loop.
    			if ( ! noLoop && times[ 0 ] === 0 ) {

    				times.push( numMorphTargets );
    				values.push( values[ 0 ] );

    			}

    			tracks.push(
    					new NumberKeyframeTrack(
    						'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',
    						times, values
    					).scale( 1.0 / fps ) );
    		}

    		return new AnimationClip( name, -1, tracks );

    	},

    	findByName: function( objectOrClipArray, name ) {

    		var clipArray = objectOrClipArray;

    		if ( ! Array.isArray( objectOrClipArray ) ) {

    			var o = objectOrClipArray;
    			clipArray = o.geometry && o.geometry.animations || o.animations;

    		}

    		for ( var i = 0; i < clipArray.length; i ++ ) {

    			if ( clipArray[ i ].name === name ) {

    				return clipArray[ i ];

    			}
    		}

    		return null;

    	},

    	CreateClipsFromMorphTargetSequences: function( morphTargets, fps, noLoop ) {

    		var animationToMorphTargets = {};

    		// tested with https://regex101.com/ on trick sequences
    		// such flamingo_flyA_003, flamingo_run1_003, crdeath0059
    		var pattern = /^([\w-]*?)([\d]+)$/;

    		// sort morph target names into animation groups based
    		// patterns like Walk_001, Walk_002, Run_001, Run_002
    		for ( var i = 0, il = morphTargets.length; i < il; i ++ ) {

    			var morphTarget = morphTargets[ i ];
    			var parts = morphTarget.name.match( pattern );

    			if ( parts && parts.length > 1 ) {

    				var name = parts[ 1 ];

    				var animationMorphTargets = animationToMorphTargets[ name ];
    				if ( ! animationMorphTargets ) {

    					animationToMorphTargets[ name ] = animationMorphTargets = [];

    				}

    				animationMorphTargets.push( morphTarget );

    			}

    		}

    		var clips = [];

    		for ( var name in animationToMorphTargets ) {

    			clips.push( AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );

    		}

    		return clips;

    	},

    	// parse the animation.hierarchy format
    	parseAnimation: function( animation, bones ) {

    		if ( ! animation ) {

    			console.error( "  no animation in JSONLoader data" );
    			return null;

    		}

    		var addNonemptyTrack = function(
    				trackType, trackName, animationKeys, propertyName, destTracks ) {

    			// only return track if there are actually keys.
    			if ( animationKeys.length !== 0 ) {

    				var times = [];
    				var values = [];

    				exports.AnimationUtils.flattenJSON(
    						animationKeys, times, values, propertyName );

    				// empty keys are filtered out, so check again
    				if ( times.length !== 0 ) {

    					destTracks.push( new trackType( trackName, times, values ) );

    				}

    			}

    		};

    		var tracks = [];

    		var clipName = animation.name || 'default';
    		// automatic length determination in AnimationClip.
    		var duration = animation.length || -1;
    		var fps = animation.fps || 30;

    		var hierarchyTracks = animation.hierarchy || [];

    		for ( var h = 0; h < hierarchyTracks.length; h ++ ) {

    			var animationKeys = hierarchyTracks[ h ].keys;

    			// skip empty tracks
    			if ( ! animationKeys || animationKeys.length === 0 ) continue;

    			// process morph targets in a way exactly compatible
    			// with AnimationHandler.init( animation )
    			if ( animationKeys[0].morphTargets ) {

    				// figure out all morph targets used in this track
    				var morphTargetNames = {};
    				for ( var k = 0; k < animationKeys.length; k ++ ) {

    					if ( animationKeys[k].morphTargets ) {

    						for ( var m = 0; m < animationKeys[k].morphTargets.length; m ++ ) {

    							morphTargetNames[ animationKeys[k].morphTargets[m] ] = -1;
    						}

    					}

    				}

    				// create a track for each morph target with all zero
    				// morphTargetInfluences except for the keys in which
    				// the morphTarget is named.
    				for ( var morphTargetName in morphTargetNames ) {

    					var times = [];
    					var values = [];

    					for ( var m = 0;
    							m !== animationKeys[k].morphTargets.length; ++ m ) {

    						var animationKey = animationKeys[k];

    						times.push( animationKey.time );
    						values.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );

    					}

    					tracks.push( new NumberKeyframeTrack(
    							'.morphTargetInfluence[' + morphTargetName + ']', times, values ) );

    				}

    				duration = morphTargetNames.length * ( fps || 1.0 );

    			} else {
    				// ...assume skeletal animation

    				var boneName = '.bones[' + bones[ h ].name + ']';

    				addNonemptyTrack(
    						VectorKeyframeTrack, boneName + '.position',
    						animationKeys, 'pos', tracks );

    				addNonemptyTrack(
    						QuaternionKeyframeTrack, boneName + '.quaternion',
    						animationKeys, 'rot', tracks );

    				addNonemptyTrack(
    						VectorKeyframeTrack, boneName + '.scale',
    						animationKeys, 'scl', tracks );

    			}

    		}

    		if ( tracks.length === 0 ) {

    			return null;

    		}

    		var clip = new AnimationClip( clipName, duration, tracks );

    		return clip;

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function MaterialLoader( manager ) {

    	this.manager = ( manager !== undefined ) ? manager : exports.DefaultLoadingManager;
    	this.textures = {};

    }

    Object.assign( MaterialLoader.prototype, {

    	load: function ( url, onLoad, onProgress, onError ) {

    		var scope = this;

    		var loader = new XHRLoader( scope.manager );
    		loader.load( url, function ( text ) {

    			onLoad( scope.parse( JSON.parse( text ) ) );

    		}, onProgress, onError );

    	},

    	setTextures: function ( value ) {

    		this.textures = value;

    	},

    	parse: function ( json ) {

    		var textures = this.textures;

    		function getTexture( name ) {

    			if ( textures[ name ] === undefined ) {

    				console.warn( 'THREE.MaterialLoader: Undefined texture', name );

    			}

    			return textures[ name ];

    		}

    		var material = new Materials[ json.type ]();

    		if ( json.uuid !== undefined ) material.uuid = json.uuid;
    		if ( json.name !== undefined ) material.name = json.name;
    		if ( json.color !== undefined ) material.color.setHex( json.color );
    		if ( json.roughness !== undefined ) material.roughness = json.roughness;
    		if ( json.metalness !== undefined ) material.metalness = json.metalness;
    		if ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );
    		if ( json.specular !== undefined ) material.specular.setHex( json.specular );
    		if ( json.shininess !== undefined ) material.shininess = json.shininess;
    		if ( json.uniforms !== undefined ) material.uniforms = json.uniforms;
    		if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;
    		if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;
    		if ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;
    		if ( json.fog !== undefined ) material.fog = json.fog;
    		if ( json.shading !== undefined ) material.shading = json.shading;
    		if ( json.blending !== undefined ) material.blending = json.blending;
    		if ( json.side !== undefined ) material.side = json.side;
    		if ( json.opacity !== undefined ) material.opacity = json.opacity;
    		if ( json.transparent !== undefined ) material.transparent = json.transparent;
    		if ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;
    		if ( json.depthTest !== undefined ) material.depthTest = json.depthTest;
    		if ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;
    		if ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;
    		if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;
    		if ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;
    		if ( json.wireframeLinecap !== undefined ) material.wireframeLinecap = json.wireframeLinecap;
    		if ( json.wireframeLinejoin !== undefined ) material.wireframeLinejoin = json.wireframeLinejoin;
    		if ( json.skinning !== undefined ) material.skinning = json.skinning;
    		if ( json.morphTargets !== undefined ) material.morphTargets = json.morphTargets;

    		// for PointsMaterial

    		if ( json.size !== undefined ) material.size = json.size;
    		if ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;

    		// maps

    		if ( json.map !== undefined ) material.map = getTexture( json.map );

    		if ( json.alphaMap !== undefined ) {

    			material.alphaMap = getTexture( json.alphaMap );
    			material.transparent = true;

    		}

    		if ( json.bumpMap !== undefined ) material.bumpMap = getTexture( json.bumpMap );
    		if ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;

    		if ( json.normalMap !== undefined ) material.normalMap = getTexture( json.normalMap );
    		if ( json.normalScale !== undefined ) {

    			var normalScale = json.normalScale;

    			if ( Array.isArray( normalScale ) === false ) {

    				// Blender exporter used to export a scalar. See #7459

    				normalScale = [ normalScale, normalScale ];

    			}

    			material.normalScale = new Vector2().fromArray( normalScale );

    		}

    		if ( json.displacementMap !== undefined ) material.displacementMap = getTexture( json.displacementMap );
    		if ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;
    		if ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;

    		if ( json.roughnessMap !== undefined ) material.roughnessMap = getTexture( json.roughnessMap );
    		if ( json.metalnessMap !== undefined ) material.metalnessMap = getTexture( json.metalnessMap );

    		if ( json.emissiveMap !== undefined ) material.emissiveMap = getTexture( json.emissiveMap );
    		if ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;

    		if ( json.specularMap !== undefined ) material.specularMap = getTexture( json.specularMap );

    		if ( json.envMap !== undefined ) material.envMap = getTexture( json.envMap );

    		if ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;

    		if ( json.lightMap !== undefined ) material.lightMap = getTexture( json.lightMap );
    		if ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;

    		if ( json.aoMap !== undefined ) material.aoMap = getTexture( json.aoMap );
    		if ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;

    		// MultiMaterial

    		if ( json.materials !== undefined ) {

    			for ( var i = 0, l = json.materials.length; i < l; i ++ ) {

    				material.materials.push( this.parse( json.materials[ i ] ) );

    			}

    		}

    		return material;

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function BufferGeometryLoader( manager ) {

    	this.manager = ( manager !== undefined ) ? manager : exports.DefaultLoadingManager;

    }

    Object.assign( BufferGeometryLoader.prototype, {

    	load: function ( url, onLoad, onProgress, onError ) {

    		var scope = this;

    		var loader = new XHRLoader( scope.manager );
    		loader.load( url, function ( text ) {

    			onLoad( scope.parse( JSON.parse( text ) ) );

    		}, onProgress, onError );

    	},

    	parse: function ( json ) {

    		var geometry = new BufferGeometry();

    		var index = json.data.index;

    		var TYPED_ARRAYS = {
    			'Int8Array': Int8Array,
    			'Uint8Array': Uint8Array,
    			'Uint8ClampedArray': Uint8ClampedArray,
    			'Int16Array': Int16Array,
    			'Uint16Array': Uint16Array,
    			'Int32Array': Int32Array,
    			'Uint32Array': Uint32Array,
    			'Float32Array': Float32Array,
    			'Float64Array': Float64Array
    		};

    		if ( index !== undefined ) {

    			var typedArray = new TYPED_ARRAYS[ index.type ]( index.array );
    			geometry.setIndex( new BufferAttribute( typedArray, 1 ) );

    		}

    		var attributes = json.data.attributes;

    		for ( var key in attributes ) {

    			var attribute = attributes[ key ];
    			var typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );

    			geometry.addAttribute( key, new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized ) );

    		}

    		var groups = json.data.groups || json.data.drawcalls || json.data.offsets;

    		if ( groups !== undefined ) {

    			for ( var i = 0, n = groups.length; i !== n; ++ i ) {

    				var group = groups[ i ];

    				geometry.addGroup( group.start, group.count, group.materialIndex );

    			}

    		}

    		var boundingSphere = json.data.boundingSphere;

    		if ( boundingSphere !== undefined ) {

    			var center = new Vector3();

    			if ( boundingSphere.center !== undefined ) {

    				center.fromArray( boundingSphere.center );

    			}

    			geometry.boundingSphere = new Sphere( center, boundingSphere.radius );

    		}

    		return geometry;

    	}

    } );

    /**
     * @author alteredq / http://alteredqualia.com/
     */

    function Loader() {

    	this.onLoadStart = function () {};
    	this.onLoadProgress = function () {};
    	this.onLoadComplete = function () {};

    }

    Loader.prototype = {

    	constructor: Loader,

    	crossOrigin: undefined,

    	extractUrlBase: function ( url ) {

    		var parts = url.split( '/' );

    		if ( parts.length === 1 ) return './';

    		parts.pop();

    		return parts.join( '/' ) + '/';

    	},

    	initMaterials: function ( materials, texturePath, crossOrigin ) {

    		var array = [];

    		for ( var i = 0; i < materials.length; ++ i ) {

    			array[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );

    		}

    		return array;

    	},

    	createMaterial: ( function () {

    		var color, textureLoader, materialLoader;

    		return function createMaterial( m, texturePath, crossOrigin ) {

    			if ( color === undefined ) color = new Color();
    			if ( textureLoader === undefined ) textureLoader = new TextureLoader();
    			if ( materialLoader === undefined ) materialLoader = new MaterialLoader();

    			// convert from old material format

    			var textures = {};

    			function loadTexture( path, repeat, offset, wrap, anisotropy ) {

    				var fullPath = texturePath + path;
    				var loader = Loader.Handlers.get( fullPath );

    				var texture;

    				if ( loader !== null ) {

    					texture = loader.load( fullPath );

    				} else {

    					textureLoader.setCrossOrigin( crossOrigin );
    					texture = textureLoader.load( fullPath );

    				}

    				if ( repeat !== undefined ) {

    					texture.repeat.fromArray( repeat );

    					if ( repeat[ 0 ] !== 1 ) texture.wrapS = RepeatWrapping;
    					if ( repeat[ 1 ] !== 1 ) texture.wrapT = RepeatWrapping;

    				}

    				if ( offset !== undefined ) {

    					texture.offset.fromArray( offset );

    				}

    				if ( wrap !== undefined ) {

    					if ( wrap[ 0 ] === 'repeat' ) texture.wrapS = RepeatWrapping;
    					if ( wrap[ 0 ] === 'mirror' ) texture.wrapS = MirroredRepeatWrapping;

    					if ( wrap[ 1 ] === 'repeat' ) texture.wrapT = RepeatWrapping;
    					if ( wrap[ 1 ] === 'mirror' ) texture.wrapT = MirroredRepeatWrapping;

    				}

    				if ( anisotropy !== undefined ) {

    					texture.anisotropy = anisotropy;

    				}

    				var uuid = exports.Math.generateUUID();

    				textures[ uuid ] = texture;

    				return uuid;

    			}

    			//

    			var json = {
    				uuid: exports.Math.generateUUID(),
    				type: 'MeshLambertMaterial'
    			};

    			for ( var name in m ) {

    				var value = m[ name ];

    				switch ( name ) {
    					case 'DbgColor':
    					case 'DbgIndex':
    					case 'opticalDensity':
    					case 'illumination':
    						break;
    					case 'DbgName':
    						json.name = value;
    						break;
    					case 'blending':
    						json.blending = BlendingMode[ value ];
    						break;
    					case 'colorAmbient':
    					case 'mapAmbient':
    						console.warn( 'THREE.Loader.createMaterial:', name, 'is no longer supported.' );
    						break;
    					case 'colorDiffuse':
    						json.color = color.fromArray( value ).getHex();
    						break;
    					case 'colorSpecular':
    						json.specular = color.fromArray( value ).getHex();
    						break;
    					case 'colorEmissive':
    						json.emissive = color.fromArray( value ).getHex();
    						break;
    					case 'specularCoef':
    						json.shininess = value;
    						break;
    					case 'shading':
    						if ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial';
    						if ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial';
    						if ( value.toLowerCase() === 'standard' ) json.type = 'MeshStandardMaterial';
    						break;
    					case 'mapDiffuse':
    						json.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );
    						break;
    					case 'mapDiffuseRepeat':
    					case 'mapDiffuseOffset':
    					case 'mapDiffuseWrap':
    					case 'mapDiffuseAnisotropy':
    						break;
    					case 'mapEmissive':
    						json.emissiveMap = loadTexture( value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy );
    						break;
    					case 'mapEmissiveRepeat':
    					case 'mapEmissiveOffset':
    					case 'mapEmissiveWrap':
    					case 'mapEmissiveAnisotropy':
    						break;
    					case 'mapLight':
    						json.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );
    						break;
    					case 'mapLightRepeat':
    					case 'mapLightOffset':
    					case 'mapLightWrap':
    					case 'mapLightAnisotropy':
    						break;
    					case 'mapAO':
    						json.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );
    						break;
    					case 'mapAORepeat':
    					case 'mapAOOffset':
    					case 'mapAOWrap':
    					case 'mapAOAnisotropy':
    						break;
    					case 'mapBump':
    						json.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );
    						break;
    					case 'mapBumpScale':
    						json.bumpScale = value;
    						break;
    					case 'mapBumpRepeat':
    					case 'mapBumpOffset':
    					case 'mapBumpWrap':
    					case 'mapBumpAnisotropy':
    						break;
    					case 'mapNormal':
    						json.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );
    						break;
    					case 'mapNormalFactor':
    						json.normalScale = [ value, value ];
    						break;
    					case 'mapNormalRepeat':
    					case 'mapNormalOffset':
    					case 'mapNormalWrap':
    					case 'mapNormalAnisotropy':
    						break;
    					case 'mapSpecular':
    						json.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );
    						break;
    					case 'mapSpecularRepeat':
    					case 'mapSpecularOffset':
    					case 'mapSpecularWrap':
    					case 'mapSpecularAnisotropy':
    						break;
    					case 'mapMetalness':
    						json.metalnessMap = loadTexture( value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy );
    						break;
    					case 'mapMetalnessRepeat':
    					case 'mapMetalnessOffset':
    					case 'mapMetalnessWrap':
    					case 'mapMetalnessAnisotropy':
    						break;
    					case 'mapRoughness':
    						json.roughnessMap = loadTexture( value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy );
    						break;
    					case 'mapRoughnessRepeat':
    					case 'mapRoughnessOffset':
    					case 'mapRoughnessWrap':
    					case 'mapRoughnessAnisotropy':
    						break;
    					case 'mapAlpha':
    						json.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );
    						break;
    					case 'mapAlphaRepeat':
    					case 'mapAlphaOffset':
    					case 'mapAlphaWrap':
    					case 'mapAlphaAnisotropy':
    						break;
    					case 'flipSided':
    						json.side = BackSide;
    						break;
    					case 'doubleSided':
    						json.side = DoubleSide;
    						break;
    					case 'transparency':
    						console.warn( 'THREE.Loader.createMaterial: transparency has been renamed to opacity' );
    						json.opacity = value;
    						break;
    					case 'depthTest':
    					case 'depthWrite':
    					case 'colorWrite':
    					case 'opacity':
    					case 'reflectivity':
    					case 'transparent':
    					case 'visible':
    					case 'wireframe':
    						json[ name ] = value;
    						break;
    					case 'vertexColors':
    						if ( value === true ) json.vertexColors = VertexColors;
    						if ( value === 'face' ) json.vertexColors = FaceColors;
    						break;
    					default:
    						console.error( 'THREE.Loader.createMaterial: Unsupported', name, value );
    						break;
    				}

    			}

    			if ( json.type === 'MeshBasicMaterial' ) delete json.emissive;
    			if ( json.type !== 'MeshPhongMaterial' ) delete json.specular;

    			if ( json.opacity < 1 ) json.transparent = true;

    			materialLoader.setTextures( textures );

    			return materialLoader.parse( json );

    		};

    	} )()

    };

    Loader.Handlers = {

    	handlers: [],

    	add: function ( regex, loader ) {

    		this.handlers.push( regex, loader );

    	},

    	get: function ( file ) {

    		var handlers = this.handlers;

    		for ( var i = 0, l = handlers.length; i < l; i += 2 ) {

    			var regex = handlers[ i ];
    			var loader  = handlers[ i + 1 ];

    			if ( regex.test( file ) ) {

    				return loader;

    			}

    		}

    		return null;

    	}

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     */

    function JSONLoader( manager ) {

    	if ( typeof manager === 'boolean' ) {

    		console.warn( 'THREE.JSONLoader: showStatus parameter has been removed from constructor.' );
    		manager = undefined;

    	}

    	this.manager = ( manager !== undefined ) ? manager : exports.DefaultLoadingManager;

    	this.withCredentials = false;

    }

    Object.assign( JSONLoader.prototype, {

    	load: function( url, onLoad, onProgress, onError ) {

    		var scope = this;

    		var texturePath = this.texturePath && ( typeof this.texturePath === "string" ) ? this.texturePath : Loader.prototype.extractUrlBase( url );

    		var loader = new XHRLoader( this.manager );
    		loader.setWithCredentials( this.withCredentials );
    		loader.load( url, function ( text ) {

    			var json = JSON.parse( text );
    			var metadata = json.metadata;

    			if ( metadata !== undefined ) {

    				var type = metadata.type;

    				if ( type !== undefined ) {

    					if ( type.toLowerCase() === 'object' ) {

    						console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );
    						return;

    					}

    					if ( type.toLowerCase() === 'scene' ) {

    						console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.' );
    						return;

    					}

    				}

    			}

    			var object = scope.parse( json, texturePath );
    			onLoad( object.geometry, object.materials );

    		}, onProgress, onError );

    	},

    	setTexturePath: function ( value ) {

    		this.texturePath = value;

    	},

    	parse: function ( json, texturePath ) {

    		var geometry = new Geometry(),
    		scale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;

    		parseModel( scale );

    		parseSkin();
    		parseMorphing( scale );
    		parseAnimations();

    		geometry.computeFaceNormals();
    		geometry.computeBoundingSphere();

    		function parseModel( scale ) {

    			function isBitSet( value, position ) {

    				return value & ( 1 << position );

    			}

    			var i, j, fi,

    			offset, zLength,

    		colorIndex, normalIndex, uvIndex, materialIndex,

    			type,
    			isQuad,
    			hasMaterial,
    			hasFaceVertexUv,
    			hasFaceNormal, hasFaceVertexNormal,
    			hasFaceColor, hasFaceVertexColor,

    		vertex, face, faceA, faceB, hex, normal,

    			uvLayer, uv, u, v,

    			faces = json.faces,
    			vertices = json.vertices,
    			normals = json.normals,
    			colors = json.colors,

    			nUvLayers = 0;

    			if ( json.uvs !== undefined ) {

    				// disregard empty arrays

    				for ( i = 0; i < json.uvs.length; i ++ ) {

    					if ( json.uvs[ i ].length ) nUvLayers ++;

    				}

    				for ( i = 0; i < nUvLayers; i ++ ) {

    					geometry.faceVertexUvs[ i ] = [];

    				}

    			}

    			offset = 0;
    			zLength = vertices.length;

    			while ( offset < zLength ) {

    				vertex = new Vector3();

    				vertex.x = vertices[ offset ++ ] * scale;
    				vertex.y = vertices[ offset ++ ] * scale;
    				vertex.z = vertices[ offset ++ ] * scale;

    				geometry.vertices.push( vertex );

    			}

    			offset = 0;
    			zLength = faces.length;

    			while ( offset < zLength ) {

    				type = faces[ offset ++ ];


    				isQuad              = isBitSet( type, 0 );
    				hasMaterial         = isBitSet( type, 1 );
    				hasFaceVertexUv     = isBitSet( type, 3 );
    				hasFaceNormal       = isBitSet( type, 4 );
    				hasFaceVertexNormal = isBitSet( type, 5 );
    				hasFaceColor	     = isBitSet( type, 6 );
    				hasFaceVertexColor  = isBitSet( type, 7 );

    				// console.log("type", type, "bits", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);

    				if ( isQuad ) {

    					faceA = new Face3();
    					faceA.a = faces[ offset ];
    					faceA.b = faces[ offset + 1 ];
    					faceA.c = faces[ offset + 3 ];

    					faceB = new Face3();
    					faceB.a = faces[ offset + 1 ];
    					faceB.b = faces[ offset + 2 ];
    					faceB.c = faces[ offset + 3 ];

    					offset += 4;

    					if ( hasMaterial ) {

    						materialIndex = faces[ offset ++ ];
    						faceA.materialIndex = materialIndex;
    						faceB.materialIndex = materialIndex;

    					}

    					// to get face <=> uv index correspondence

    					fi = geometry.faces.length;

    					if ( hasFaceVertexUv ) {

    						for ( i = 0; i < nUvLayers; i ++ ) {

    							uvLayer = json.uvs[ i ];

    							geometry.faceVertexUvs[ i ][ fi ] = [];
    							geometry.faceVertexUvs[ i ][ fi + 1 ] = [];

    							for ( j = 0; j < 4; j ++ ) {

    								uvIndex = faces[ offset ++ ];

    								u = uvLayer[ uvIndex * 2 ];
    								v = uvLayer[ uvIndex * 2 + 1 ];

    								uv = new Vector2( u, v );

    								if ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );
    								if ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );

    							}

    						}

    					}

    					if ( hasFaceNormal ) {

    						normalIndex = faces[ offset ++ ] * 3;

    						faceA.normal.set(
    							normals[ normalIndex ++ ],
    							normals[ normalIndex ++ ],
    							normals[ normalIndex ]
    						);

    						faceB.normal.copy( faceA.normal );

    					}

    					if ( hasFaceVertexNormal ) {

    						for ( i = 0; i < 4; i ++ ) {

    							normalIndex = faces[ offset ++ ] * 3;

    							normal = new Vector3(
    								normals[ normalIndex ++ ],
    								normals[ normalIndex ++ ],
    								normals[ normalIndex ]
    							);


    							if ( i !== 2 ) faceA.vertexNormals.push( normal );
    							if ( i !== 0 ) faceB.vertexNormals.push( normal );

    						}

    					}


    					if ( hasFaceColor ) {

    						colorIndex = faces[ offset ++ ];
    						hex = colors[ colorIndex ];

    						faceA.color.setHex( hex );
    						faceB.color.setHex( hex );

    					}


    					if ( hasFaceVertexColor ) {

    						for ( i = 0; i < 4; i ++ ) {

    							colorIndex = faces[ offset ++ ];
    							hex = colors[ colorIndex ];

    							if ( i !== 2 ) faceA.vertexColors.push( new Color( hex ) );
    							if ( i !== 0 ) faceB.vertexColors.push( new Color( hex ) );

    						}

    					}

    					geometry.faces.push( faceA );
    					geometry.faces.push( faceB );

    				} else {

    					face = new Face3();
    					face.a = faces[ offset ++ ];
    					face.b = faces[ offset ++ ];
    					face.c = faces[ offset ++ ];

    					if ( hasMaterial ) {

    						materialIndex = faces[ offset ++ ];
    						face.materialIndex = materialIndex;

    					}

    					// to get face <=> uv index correspondence

    					fi = geometry.faces.length;

    					if ( hasFaceVertexUv ) {

    						for ( i = 0; i < nUvLayers; i ++ ) {

    							uvLayer = json.uvs[ i ];

    							geometry.faceVertexUvs[ i ][ fi ] = [];

    							for ( j = 0; j < 3; j ++ ) {

    								uvIndex = faces[ offset ++ ];

    								u = uvLayer[ uvIndex * 2 ];
    								v = uvLayer[ uvIndex * 2 + 1 ];

    								uv = new Vector2( u, v );

    								geometry.faceVertexUvs[ i ][ fi ].push( uv );

    							}

    						}

    					}

    					if ( hasFaceNormal ) {

    						normalIndex = faces[ offset ++ ] * 3;

    						face.normal.set(
    							normals[ normalIndex ++ ],
    							normals[ normalIndex ++ ],
    							normals[ normalIndex ]
    						);

    					}

    					if ( hasFaceVertexNormal ) {

    						for ( i = 0; i < 3; i ++ ) {

    							normalIndex = faces[ offset ++ ] * 3;

    							normal = new Vector3(
    								normals[ normalIndex ++ ],
    								normals[ normalIndex ++ ],
    								normals[ normalIndex ]
    							);

    							face.vertexNormals.push( normal );

    						}

    					}


    					if ( hasFaceColor ) {

    						colorIndex = faces[ offset ++ ];
    						face.color.setHex( colors[ colorIndex ] );

    					}


    					if ( hasFaceVertexColor ) {

    						for ( i = 0; i < 3; i ++ ) {

    							colorIndex = faces[ offset ++ ];
    							face.vertexColors.push( new Color( colors[ colorIndex ] ) );

    						}

    					}

    					geometry.faces.push( face );

    				}

    			}

    		}

    		function parseSkin() {

    			var influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;

    			if ( json.skinWeights ) {

    				for ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {

    					var x =                               json.skinWeights[ i ];
    					var y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;
    					var z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;
    					var w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;

    					geometry.skinWeights.push( new Vector4( x, y, z, w ) );

    				}

    			}

    			if ( json.skinIndices ) {

    				for ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {

    					var a =                               json.skinIndices[ i ];
    					var b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;
    					var c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;
    					var d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;

    					geometry.skinIndices.push( new Vector4( a, b, c, d ) );

    				}

    			}

    			geometry.bones = json.bones;

    			if ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {

    				console.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +
    					geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );

    			}

    		}

    		function parseMorphing( scale ) {

    			if ( json.morphTargets !== undefined ) {

    				for ( var i = 0, l = json.morphTargets.length; i < l; i ++ ) {

    					geometry.morphTargets[ i ] = {};
    					geometry.morphTargets[ i ].name = json.morphTargets[ i ].name;
    					geometry.morphTargets[ i ].vertices = [];

    					var dstVertices = geometry.morphTargets[ i ].vertices;
    					var srcVertices = json.morphTargets[ i ].vertices;

    					for ( var v = 0, vl = srcVertices.length; v < vl; v += 3 ) {

    						var vertex = new Vector3();
    						vertex.x = srcVertices[ v ] * scale;
    						vertex.y = srcVertices[ v + 1 ] * scale;
    						vertex.z = srcVertices[ v + 2 ] * scale;

    						dstVertices.push( vertex );

    					}

    				}

    			}

    			if ( json.morphColors !== undefined && json.morphColors.length > 0 ) {

    				console.warn( 'THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.' );

    				var faces = geometry.faces;
    				var morphColors = json.morphColors[ 0 ].colors;

    				for ( var i = 0, l = faces.length; i < l; i ++ ) {

    					faces[ i ].color.fromArray( morphColors, i * 3 );

    				}

    			}

    		}

    		function parseAnimations() {

    			var outputAnimations = [];

    			// parse old style Bone/Hierarchy animations
    			var animations = [];

    			if ( json.animation !== undefined ) {

    				animations.push( json.animation );

    			}

    			if ( json.animations !== undefined ) {

    				if ( json.animations.length ) {

    					animations = animations.concat( json.animations );

    				} else {

    					animations.push( json.animations );

    				}

    			}

    			for ( var i = 0; i < animations.length; i ++ ) {

    				var clip = AnimationClip.parseAnimation( animations[ i ], geometry.bones );
    				if ( clip ) outputAnimations.push( clip );

    			}

    			// parse implicit morph animations
    			if ( geometry.morphTargets ) {

    				// TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.
    				var morphAnimationClips = AnimationClip.CreateClipsFromMorphTargetSequences( geometry.morphTargets, 10 );
    				outputAnimations = outputAnimations.concat( morphAnimationClips );

    			}

    			if ( outputAnimations.length > 0 ) geometry.animations = outputAnimations;

    		}

    		if ( json.materials === undefined || json.materials.length === 0 ) {

    			return { geometry: geometry };

    		} else {

    			var materials = Loader.prototype.initMaterials( json.materials, texturePath, this.crossOrigin );

    			return { geometry: geometry, materials: materials };

    		}

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function ObjectLoader ( manager ) {

    	this.manager = ( manager !== undefined ) ? manager : exports.DefaultLoadingManager;
    	this.texturePath = '';

    }

    Object.assign( ObjectLoader.prototype, {

    	load: function ( url, onLoad, onProgress, onError ) {

    		if ( this.texturePath === '' ) {

    			this.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );

    		}

    		var scope = this;

    		var loader = new XHRLoader( scope.manager );
    		loader.load( url, function ( text ) {

    			scope.parse( JSON.parse( text ), onLoad );

    		}, onProgress, onError );

    	},

    	setTexturePath: function ( value ) {

    		this.texturePath = value;

    	},

    	setCrossOrigin: function ( value ) {

    		this.crossOrigin = value;

    	},

    	parse: function ( json, onLoad ) {

    		var geometries = this.parseGeometries( json.geometries );

    		var images = this.parseImages( json.images, function () {

    			if ( onLoad !== undefined ) onLoad( object );

    		} );

    		var textures  = this.parseTextures( json.textures, images );
    		var materials = this.parseMaterials( json.materials, textures );

    		var object = this.parseObject( json.object, geometries, materials );

    		if ( json.animations ) {

    			object.animations = this.parseAnimations( json.animations );

    		}

    		if ( json.images === undefined || json.images.length === 0 ) {

    			if ( onLoad !== undefined ) onLoad( object );

    		}

    		return object;

    	},

    	parseGeometries: function ( json ) {

    		var geometries = {};

    		if ( json !== undefined ) {

    			var geometryLoader = new JSONLoader();
    			var bufferGeometryLoader = new BufferGeometryLoader();

    			for ( var i = 0, l = json.length; i < l; i ++ ) {

    				var geometry;
    				var data = json[ i ];

    				switch ( data.type ) {

    					case 'PlaneGeometry':
    					case 'PlaneBufferGeometry':

    						geometry = new Geometries[ data.type ](
    							data.width,
    							data.height,
    							data.widthSegments,
    							data.heightSegments
    						);

    						break;

    					case 'BoxGeometry':
    					case 'BoxBufferGeometry':
    					case 'CubeGeometry': // backwards compatible

    						geometry = new Geometries[ data.type ](
    							data.width,
    							data.height,
    							data.depth,
    							data.widthSegments,
    							data.heightSegments,
    							data.depthSegments
    						);

    						break;

    					case 'CircleGeometry':
    					case 'CircleBufferGeometry':

    						geometry = new Geometries[ data.type ](
    							data.radius,
    							data.segments,
    							data.thetaStart,
    							data.thetaLength
    						);

    						break;

    					case 'CylinderGeometry':
    					case 'CylinderBufferGeometry':

    						geometry = new Geometries[ data.type ](
    							data.radiusTop,
    							data.radiusBottom,
    							data.height,
    							data.radialSegments,
    							data.heightSegments,
    							data.openEnded,
    							data.thetaStart,
    							data.thetaLength
    						);

    						break;

    					case 'ConeGeometry':
    					case 'ConeBufferGeometry':

    						geometry = new Geometries[ data.type ](
    							data.radius,
    							data.height,
    							data.radialSegments,
    							data.heightSegments,
    							data.openEnded,
    							data.thetaStart,
    							data.thetaLength
    						);

    						break;

    					case 'SphereGeometry':
    					case 'SphereBufferGeometry':

    						geometry = new Geometries[ data.type ](
    							data.radius,
    							data.widthSegments,
    							data.heightSegments,
    							data.phiStart,
    							data.phiLength,
    							data.thetaStart,
    							data.thetaLength
    						);

    						break;

    					case 'DodecahedronGeometry':
    					case 'IcosahedronGeometry':
    					case 'OctahedronGeometry':
    					case 'TetrahedronGeometry':

    						geometry = new Geometries[ data.type ](
    							data.radius,
    							data.detail
    						);

    						break;

    					case 'RingGeometry':
    					case 'RingBufferGeometry':

    						geometry = new Geometries[ data.type ](
    							data.innerRadius,
    							data.outerRadius,
    							data.thetaSegments,
    							data.phiSegments,
    							data.thetaStart,
    							data.thetaLength
    						);

    						break;

    					case 'TorusGeometry':
    					case 'TorusBufferGeometry':

    						geometry = new Geometries[ data.type ](
    							data.radius,
    							data.tube,
    							data.radialSegments,
    							data.tubularSegments,
    							data.arc
    						);

    						break;

    					case 'TorusKnotGeometry':
    					case 'TorusKnotBufferGeometry':

    						geometry = new Geometries[ data.type ](
    							data.radius,
    							data.tube,
    							data.tubularSegments,
    							data.radialSegments,
    							data.p,
    							data.q
    						);

    						break;

    					case 'LatheGeometry':
    					case 'LatheBufferGeometry':

    						geometry = new Geometries[ data.type ](
    							data.points,
    							data.segments,
    							data.phiStart,
    							data.phiLength
    						);

    						break;

    					case 'BufferGeometry':

    						geometry = bufferGeometryLoader.parse( data );

    						break;

    					case 'Geometry':

    						geometry = geometryLoader.parse( data.data, this.texturePath ).geometry;

    						break;

    					default:

    						console.warn( 'THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"' );

    						continue;

    				}

    				geometry.uuid = data.uuid;

    				if ( data.name !== undefined ) geometry.name = data.name;

    				geometries[ data.uuid ] = geometry;

    			}

    		}

    		return geometries;

    	},

    	parseMaterials: function ( json, textures ) {

    		var materials = {};

    		if ( json !== undefined ) {

    			var loader = new MaterialLoader();
    			loader.setTextures( textures );

    			for ( var i = 0, l = json.length; i < l; i ++ ) {

    				var material = loader.parse( json[ i ] );
    				materials[ material.uuid ] = material;

    			}

    		}

    		return materials;

    	},

    	parseAnimations: function ( json ) {

    		var animations = [];

    		for ( var i = 0; i < json.length; i ++ ) {

    			var clip = AnimationClip.parse( json[ i ] );

    			animations.push( clip );

    		}

    		return animations;

    	},

    	parseImages: function ( json, onLoad ) {

    		var scope = this;
    		var images = {};

    		function loadImage( url ) {

    			scope.manager.itemStart( url );

    			return loader.load( url, function () {

    				scope.manager.itemEnd( url );

    			}, undefined, function () {

    				scope.manager.itemError( url );

    			} );

    		}

    		if ( json !== undefined && json.length > 0 ) {

    			var manager = new LoadingManager( onLoad );

    			var loader = new ImageLoader( manager );
    			loader.setCrossOrigin( this.crossOrigin );

    			for ( var i = 0, l = json.length; i < l; i ++ ) {

    				var image = json[ i ];
    				var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;

    				images[ image.uuid ] = loadImage( path );

    			}

    		}

    		return images;

    	},

    	parseTextures: function ( json, images ) {

    		function parseConstant( value, type ) {

    			if ( typeof( value ) === 'number' ) return value;

    			console.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );

    			return type[ value ];

    		}

    		var textures = {};

    		if ( json !== undefined ) {

    			for ( var i = 0, l = json.length; i < l; i ++ ) {

    				var data = json[ i ];

    				if ( data.image === undefined ) {

    					console.warn( 'THREE.ObjectLoader: No "image" specified for', data.uuid );

    				}

    				if ( images[ data.image ] === undefined ) {

    					console.warn( 'THREE.ObjectLoader: Undefined image', data.image );

    				}

    				var texture = new Texture( images[ data.image ] );
    				texture.needsUpdate = true;

    				texture.uuid = data.uuid;

    				if ( data.name !== undefined ) texture.name = data.name;

    				if ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping, TextureMapping );

    				if ( data.offset !== undefined ) texture.offset.fromArray( data.offset );
    				if ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat );
    				if ( data.wrap !== undefined ) {

    					texture.wrapS = parseConstant( data.wrap[ 0 ], TextureWrapping );
    					texture.wrapT = parseConstant( data.wrap[ 1 ], TextureWrapping );

    				}

    				if ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter, TextureFilter );
    				if ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter, TextureFilter );
    				if ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;

    				if ( data.flipY !== undefined ) texture.flipY = data.flipY;

    				textures[ data.uuid ] = texture;

    			}

    		}

    		return textures;

    	},

    	parseObject: function () {

    		var matrix = new Matrix4();

    		return function parseObject( data, geometries, materials ) {

    			var object;

    			function getGeometry( name ) {

    				if ( geometries[ name ] === undefined ) {

    					console.warn( 'THREE.ObjectLoader: Undefined geometry', name );

    				}

    				return geometries[ name ];

    			}

    			function getMaterial( name ) {

    				if ( name === undefined ) return undefined;

    				if ( materials[ name ] === undefined ) {

    					console.warn( 'THREE.ObjectLoader: Undefined material', name );

    				}

    				return materials[ name ];

    			}

    			switch ( data.type ) {

    				case 'Scene':

    					object = new Scene();

    					if ( data.background !== undefined ) {

    						if ( Number.isInteger( data.background ) ) {

    							object.background = new Color( data.background );

    						}

    					}

    					if ( data.fog !== undefined ) {

    						if ( data.fog.type === 'Fog' ) {

    							object.fog = new Fog( data.fog.color, data.fog.near, data.fog.far );

    						} else if ( data.fog.type === 'FogExp2' ) {

    							object.fog = new FogExp2( data.fog.color, data.fog.density );

    						}

    					}

    					break;

    				case 'PerspectiveCamera':

    					object = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far );

    					if ( data.focus !== undefined ) object.focus = data.focus;
    					if ( data.zoom !== undefined ) object.zoom = data.zoom;
    					if ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;
    					if ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;
    					if ( data.view !== undefined ) object.view = Object.assign( {}, data.view );

    					break;

    				case 'OrthographicCamera':

    					object = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );

    					break;

    				case 'AmbientLight':

    					object = new AmbientLight( data.color, data.intensity );

    					break;

    				case 'DirectionalLight':

    					object = new DirectionalLight( data.color, data.intensity );

    					break;

    				case 'PointLight':

    					object = new PointLight( data.color, data.intensity, data.distance, data.decay );

    					break;

    				case 'SpotLight':

    					object = new SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );

    					break;

    				case 'HemisphereLight':

    					object = new HemisphereLight( data.color, data.groundColor, data.intensity );

    					break;

    				case 'Mesh':

    					var geometry = getGeometry( data.geometry );
    					var material = getMaterial( data.material );

    					if ( geometry.bones && geometry.bones.length > 0 ) {

    						object = new SkinnedMesh( geometry, material );

    					} else {

    						object = new Mesh( geometry, material );

    					}

    					break;

    				case 'LOD':

    					object = new LOD();

    					break;

    				case 'Line':

    					object = new Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );

    					break;

    				case 'LineSegments':

    					object = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );

    					break;

    				case 'PointCloud':
    				case 'Points':

    					object = new Points( getGeometry( data.geometry ), getMaterial( data.material ) );

    					break;

    				case 'Sprite':

    					object = new Sprite( getMaterial( data.material ) );

    					break;

    				case 'Group':

    					object = new Group();

    					break;

    				default:

    					object = new Object3D();

    			}

    			object.uuid = data.uuid;

    			if ( data.name !== undefined ) object.name = data.name;
    			if ( data.matrix !== undefined ) {

    				matrix.fromArray( data.matrix );
    				matrix.decompose( object.position, object.quaternion, object.scale );

    			} else {

    				if ( data.position !== undefined ) object.position.fromArray( data.position );
    				if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
    				if ( data.quaternion !== undefined ) object.quaternion.fromArray( data.quaternion );
    				if ( data.scale !== undefined ) object.scale.fromArray( data.scale );

    			}

    			if ( data.castShadow !== undefined ) object.castShadow = data.castShadow;
    			if ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;

    			if ( data.shadow ) {

    				if ( data.shadow.bias !== undefined ) object.shadow.bias = data.shadow.bias;
    				if ( data.shadow.radius !== undefined ) object.shadow.radius = data.shadow.radius;
    				if ( data.shadow.mapSize !== undefined ) object.shadow.mapSize.fromArray( data.shadow.mapSize );
    				if ( data.shadow.camera !== undefined ) object.shadow.camera = this.parseObject( data.shadow.camera );

    			}

    			if ( data.visible !== undefined ) object.visible = data.visible;
    			if ( data.userData !== undefined ) object.userData = data.userData;

    			if ( data.children !== undefined ) {

    				for ( var child in data.children ) {

    					object.add( this.parseObject( data.children[ child ], geometries, materials ) );

    				}

    			}

    			if ( data.type === 'LOD' ) {

    				var levels = data.levels;

    				for ( var l = 0; l < levels.length; l ++ ) {

    					var level = levels[ l ];
    					var child = object.getObjectByProperty( 'uuid', level.object );

    					if ( child !== undefined ) {

    						object.addLevel( child, level.distance );

    					}

    				}

    			}

    			return object;

    		};

    	}()

    } );

    /**
     * @author zz85 / http://www.lab4games.net/zz85/blog
     * Extensible curve object
     *
     * Some common of Curve methods
     * .getPoint(t), getTangent(t)
     * .getPointAt(u), getTangentAt(u)
     * .getPoints(), .getSpacedPoints()
     * .getLength()
     * .updateArcLengths()
     *
     * This following classes subclasses THREE.Curve:
     *
     * -- 2d classes --
     * THREE.LineCurve
     * THREE.QuadraticBezierCurve
     * THREE.CubicBezierCurve
     * THREE.SplineCurve
     * THREE.ArcCurve
     * THREE.EllipseCurve
     *
     * -- 3d classes --
     * THREE.LineCurve3
     * THREE.QuadraticBezierCurve3
     * THREE.CubicBezierCurve3
     * THREE.SplineCurve3
     *
     * A series of curves can be represented as a THREE.CurvePath
     *
     **/

    /**************************************************************
     *	Abstract Curve base class
     **************************************************************/

    function Curve() {}

    Curve.prototype = {

    	constructor: Curve,

    	// Virtual base class method to overwrite and implement in subclasses
    	//	- t [0 .. 1]

    	getPoint: function ( t ) {

    		console.warn( "THREE.Curve: Warning, getPoint() not implemented!" );
    		return null;

    	},

    	// Get point at relative position in curve according to arc length
    	// - u [0 .. 1]

    	getPointAt: function ( u ) {

    		var t = this.getUtoTmapping( u );
    		return this.getPoint( t );

    	},

    	// Get sequence of points using getPoint( t )

    	getPoints: function ( divisions ) {

    		if ( ! divisions ) divisions = 5;

    		var points = [];

    		for ( var d = 0; d <= divisions; d ++ ) {

    			points.push( this.getPoint( d / divisions ) );

    		}

    		return points;

    	},

    	// Get sequence of points using getPointAt( u )

    	getSpacedPoints: function ( divisions ) {

    		if ( ! divisions ) divisions = 5;

    		var points = [];

    		for ( var d = 0; d <= divisions; d ++ ) {

    			points.push( this.getPointAt( d / divisions ) );

    		}

    		return points;

    	},

    	// Get total curve arc length

    	getLength: function () {

    		var lengths = this.getLengths();
    		return lengths[ lengths.length - 1 ];

    	},

    	// Get list of cumulative segment lengths

    	getLengths: function ( divisions ) {

    		if ( ! divisions ) divisions = ( this.__arcLengthDivisions ) ? ( this.__arcLengthDivisions ) : 200;

    		if ( this.cacheArcLengths
    			&& ( this.cacheArcLengths.length === divisions + 1 )
    			&& ! this.needsUpdate ) {

    			//console.log( "cached", this.cacheArcLengths );
    			return this.cacheArcLengths;

    		}

    		this.needsUpdate = false;

    		var cache = [];
    		var current, last = this.getPoint( 0 );
    		var p, sum = 0;

    		cache.push( 0 );

    		for ( p = 1; p <= divisions; p ++ ) {

    			current = this.getPoint ( p / divisions );
    			sum += current.distanceTo( last );
    			cache.push( sum );
    			last = current;

    		}

    		this.cacheArcLengths = cache;

    		return cache; // { sums: cache, sum:sum }; Sum is in the last element.

    	},

    	updateArcLengths: function() {

    		this.needsUpdate = true;
    		this.getLengths();

    	},

    	// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant

    	getUtoTmapping: function ( u, distance ) {

    		var arcLengths = this.getLengths();

    		var i = 0, il = arcLengths.length;

    		var targetArcLength; // The targeted u distance value to get

    		if ( distance ) {

    			targetArcLength = distance;

    		} else {

    			targetArcLength = u * arcLengths[ il - 1 ];

    		}

    		//var time = Date.now();

    		// binary search for the index with largest value smaller than target u distance

    		var low = 0, high = il - 1, comparison;

    		while ( low <= high ) {

    			i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

    			comparison = arcLengths[ i ] - targetArcLength;

    			if ( comparison < 0 ) {

    				low = i + 1;

    			} else if ( comparison > 0 ) {

    				high = i - 1;

    			} else {

    				high = i;
    				break;

    				// DONE

    			}

    		}

    		i = high;

    		//console.log('b' , i, low, high, Date.now()- time);

    		if ( arcLengths[ i ] === targetArcLength ) {

    			var t = i / ( il - 1 );
    			return t;

    		}

    		// we could get finer grain at lengths, or use simple interpolation between two points

    		var lengthBefore = arcLengths[ i ];
    		var lengthAfter = arcLengths[ i + 1 ];

    		var segmentLength = lengthAfter - lengthBefore;

    		// determine where we are between the 'before' and 'after' points

    		var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

    		// add that fractional amount to t

    		var t = ( i + segmentFraction ) / ( il - 1 );

    		return t;

    	},

    	// Returns a unit vector tangent at t
    	// In case any sub curve does not implement its tangent derivation,
    	// 2 points a small delta apart will be used to find its gradient
    	// which seems to give a reasonable approximation

    	getTangent: function( t ) {

    		var delta = 0.0001;
    		var t1 = t - delta;
    		var t2 = t + delta;

    		// Capping in case of danger

    		if ( t1 < 0 ) t1 = 0;
    		if ( t2 > 1 ) t2 = 1;

    		var pt1 = this.getPoint( t1 );
    		var pt2 = this.getPoint( t2 );

    		var vec = pt2.clone().sub( pt1 );
    		return vec.normalize();

    	},

    	getTangentAt: function ( u ) {

    		var t = this.getUtoTmapping( u );
    		return this.getTangent( t );

    	}

    };

    // TODO: Transformation for Curves?

    /**************************************************************
     *	3D Curves
     **************************************************************/

    // A Factory method for creating new curve subclasses

    Curve.create = function ( constructor, getPointFunc ) {

    	constructor.prototype = Object.create( Curve.prototype );
    	constructor.prototype.constructor = constructor;
    	constructor.prototype.getPoint = getPointFunc;

    	return constructor;

    };

    /**************************************************************
     *	Line
     **************************************************************/

    function LineCurve( v1, v2 ) {

    	this.v1 = v1;
    	this.v2 = v2;

    }

    LineCurve.prototype = Object.create( Curve.prototype );
    LineCurve.prototype.constructor = LineCurve;

    LineCurve.prototype.isLineCurve = true;

    LineCurve.prototype.getPoint = function ( t ) {

    	if ( t === 1 ) {

    		return this.v2.clone();

    	}

    	var point = this.v2.clone().sub( this.v1 );
    	point.multiplyScalar( t ).add( this.v1 );

    	return point;

    };

    // Line curve is linear, so we can overwrite default getPointAt

    LineCurve.prototype.getPointAt = function ( u ) {

    	return this.getPoint( u );

    };

    LineCurve.prototype.getTangent = function( t ) {

    	var tangent = this.v2.clone().sub( this.v1 );

    	return tangent.normalize();

    };

    /**
     * @author zz85 / http://www.lab4games.net/zz85/blog
     *
     **/

    /**************************************************************
     *	Curved Path - a curve path is simply a array of connected
     *  curves, but retains the api of a curve
     **************************************************************/

    function CurvePath() {

    	this.curves = [];

    	this.autoClose = false; // Automatically closes the path

    }

    CurvePath.prototype = Object.assign( Object.create( Curve.prototype ), {

    	constructor: CurvePath,

    	add: function ( curve ) {

    		this.curves.push( curve );

    	},

    	closePath: function () {

    		// Add a line curve if start and end of lines are not connected
    		var startPoint = this.curves[ 0 ].getPoint( 0 );
    		var endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );

    		if ( ! startPoint.equals( endPoint ) ) {

    			this.curves.push( new LineCurve( endPoint, startPoint ) );

    		}

    	},

    	// To get accurate point with reference to
    	// entire path distance at time t,
    	// following has to be done:

    	// 1. Length of each sub path have to be known
    	// 2. Locate and identify type of curve
    	// 3. Get t for the curve
    	// 4. Return curve.getPointAt(t')

    	getPoint: function ( t ) {

    		var d = t * this.getLength();
    		var curveLengths = this.getCurveLengths();
    		var i = 0;

    		// To think about boundaries points.

    		while ( i < curveLengths.length ) {

    			if ( curveLengths[ i ] >= d ) {

    				var diff = curveLengths[ i ] - d;
    				var curve = this.curves[ i ];

    				var segmentLength = curve.getLength();
    				var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;

    				return curve.getPointAt( u );

    			}

    			i ++;

    		}

    		return null;

    		// loop where sum != 0, sum > d , sum+1 <d

    	},

    	// We cannot use the default THREE.Curve getPoint() with getLength() because in
    	// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
    	// getPoint() depends on getLength

    	getLength: function () {

    		var lens = this.getCurveLengths();
    		return lens[ lens.length - 1 ];

    	},

    	// cacheLengths must be recalculated.
    	updateArcLengths: function () {

    		this.needsUpdate = true;
    		this.cacheLengths = null;
    		this.getLengths();

    	},

    	// Compute lengths and cache them
    	// We cannot overwrite getLengths() because UtoT mapping uses it.

    	getCurveLengths: function () {

    		// We use cache values if curves and cache array are same length

    		if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {

    			return this.cacheLengths;

    		}

    		// Get length of sub-curve
    		// Push sums into cached array

    		var lengths = [], sums = 0;

    		for ( var i = 0, l = this.curves.length; i < l; i ++ ) {

    			sums += this.curves[ i ].getLength();
    			lengths.push( sums );

    		}

    		this.cacheLengths = lengths;

    		return lengths;

    	},

    	getSpacedPoints: function ( divisions ) {

    		if ( ! divisions ) divisions = 40;

    		var points = [];

    		for ( var i = 0; i <= divisions; i ++ ) {

    			points.push( this.getPoint( i / divisions ) );

    		}

    		if ( this.autoClose ) {

    			points.push( points[ 0 ] );

    		}

    		return points;

    	},

    	getPoints: function ( divisions ) {

    		divisions = divisions || 12;

    		var points = [], last;

    		for ( var i = 0, curves = this.curves; i < curves.length; i ++ ) {

    			var curve = curves[ i ];
    			var resolution = (curve && curve.isEllipseCurve) ? divisions * 2
    				: (curve && curve.isLineCurve) ? 1
    				: (curve && curve.isSplineCurve) ? divisions * curve.points.length
    				: divisions;

    			var pts = curve.getPoints( resolution );

    			for ( var j = 0; j < pts.length; j++ ) {

    				var point = pts[ j ];

    				if ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates

    				points.push( point );
    				last = point;

    			}

    		}

    		if ( this.autoClose && points.length > 1 && !points[ points.length - 1 ].equals( points[ 0 ] ) ) {

    			points.push( points[ 0 ] );

    		}

    		return points;

    	},

    	/**************************************************************
    	 *	Create Geometries Helpers
    	 **************************************************************/

    	/// Generate geometry from path points (for Line or Points objects)

    	createPointsGeometry: function ( divisions ) {

    		var pts = this.getPoints( divisions );
    		return this.createGeometry( pts );

    	},

    	// Generate geometry from equidistant sampling along the path

    	createSpacedPointsGeometry: function ( divisions ) {

    		var pts = this.getSpacedPoints( divisions );
    		return this.createGeometry( pts );

    	},

    	createGeometry: function ( points ) {

    		var geometry = new Geometry();

    		for ( var i = 0, l = points.length; i < l; i ++ ) {

    			var point = points[ i ];
    			geometry.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );

    		}

    		return geometry;

    	}

    } );

    /**************************************************************
     *	Ellipse curve
     **************************************************************/

    function EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

    	this.aX = aX;
    	this.aY = aY;

    	this.xRadius = xRadius;
    	this.yRadius = yRadius;

    	this.aStartAngle = aStartAngle;
    	this.aEndAngle = aEndAngle;

    	this.aClockwise = aClockwise;

    	this.aRotation = aRotation || 0;

    }

    EllipseCurve.prototype = Object.create( Curve.prototype );
    EllipseCurve.prototype.constructor = EllipseCurve;

    EllipseCurve.prototype.isEllipseCurve = true;

    EllipseCurve.prototype.getPoint = function( t ) {

    	var twoPi = Math.PI * 2;
    	var deltaAngle = this.aEndAngle - this.aStartAngle;
    	var samePoints = Math.abs( deltaAngle ) < Number.EPSILON;

    	// ensures that deltaAngle is 0 .. 2 PI
    	while ( deltaAngle < 0 ) deltaAngle += twoPi;
    	while ( deltaAngle > twoPi ) deltaAngle -= twoPi;

    	if ( deltaAngle < Number.EPSILON ) {

    		if ( samePoints ) {

    			deltaAngle = 0;

    		} else {

    			deltaAngle = twoPi;

    		}

    	}

    	if ( this.aClockwise === true && ! samePoints ) {

    		if ( deltaAngle === twoPi ) {

    			deltaAngle = - twoPi;

    		} else {

    			deltaAngle = deltaAngle - twoPi;

    		}

    	}

    	var angle = this.aStartAngle + t * deltaAngle;
    	var x = this.aX + this.xRadius * Math.cos( angle );
    	var y = this.aY + this.yRadius * Math.sin( angle );

    	if ( this.aRotation !== 0 ) {

    		var cos = Math.cos( this.aRotation );
    		var sin = Math.sin( this.aRotation );

    		var tx = x - this.aX;
    		var ty = y - this.aY;

    		// Rotate the point about the center of the ellipse.
    		x = tx * cos - ty * sin + this.aX;
    		y = tx * sin + ty * cos + this.aY;

    	}

    	return new Vector2( x, y );

    };

    /**
     * @author zz85 / http://www.lab4games.net/zz85/blog
     */

    exports.CurveUtils = {

    	tangentQuadraticBezier: function ( t, p0, p1, p2 ) {

    		return 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );

    	},

    	// Puay Bing, thanks for helping with this derivative!

    	tangentCubicBezier: function ( t, p0, p1, p2, p3 ) {

    		return - 3 * p0 * ( 1 - t ) * ( 1 - t )  +
    			3 * p1 * ( 1 - t ) * ( 1 - t ) - 6 * t * p1 * ( 1 - t ) +
    			6 * t *  p2 * ( 1 - t ) - 3 * t * t * p2 +
    			3 * t * t * p3;

    	},

    	tangentSpline: function ( t, p0, p1, p2, p3 ) {

    		// To check if my formulas are correct

    		var h00 = 6 * t * t - 6 * t; 	// derived from 2t^3 − 3t^2 + 1
    		var h10 = 3 * t * t - 4 * t + 1; // t^3 − 2t^2 + t
    		var h01 = - 6 * t * t + 6 * t; 	// − 2t3 + 3t2
    		var h11 = 3 * t * t - 2 * t;	// t3 − t2

    		return h00 + h10 + h01 + h11;

    	},

    	// Catmull-Rom

    	interpolate: function( p0, p1, p2, p3, t ) {

    		var v0 = ( p2 - p0 ) * 0.5;
    		var v1 = ( p3 - p1 ) * 0.5;
    		var t2 = t * t;
    		var t3 = t * t2;
    		return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

    	}

    };

    /**************************************************************
     *	Spline curve
     **************************************************************/

    function SplineCurve( points /* array of Vector2 */ ) {

    	this.points = ( points === undefined ) ? [] : points;

    }

    SplineCurve.prototype = Object.create( Curve.prototype );
    SplineCurve.prototype.constructor = SplineCurve;

    SplineCurve.prototype.isSplineCurve = true;

    SplineCurve.prototype.getPoint = function ( t ) {

    	var points = this.points;
    	var point = ( points.length - 1 ) * t;

    	var intPoint = Math.floor( point );
    	var weight = point - intPoint;

    	var point0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
    	var point1 = points[ intPoint ];
    	var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
    	var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

    	var interpolate = exports.CurveUtils.interpolate;

    	return new Vector2(
    		interpolate( point0.x, point1.x, point2.x, point3.x, weight ),
    		interpolate( point0.y, point1.y, point2.y, point3.y, weight )
    	);

    };

    /**************************************************************
     *	Cubic Bezier curve
     **************************************************************/

    function CubicBezierCurve( v0, v1, v2, v3 ) {

    	this.v0 = v0;
    	this.v1 = v1;
    	this.v2 = v2;
    	this.v3 = v3;

    }

    CubicBezierCurve.prototype = Object.create( Curve.prototype );
    CubicBezierCurve.prototype.constructor = CubicBezierCurve;

    CubicBezierCurve.prototype.getPoint = function ( t ) {

    	var b3 = exports.ShapeUtils.b3;

    	return new Vector2(
    		b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),
    		b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )
    	);

    };

    CubicBezierCurve.prototype.getTangent = function( t ) {

    	var tangentCubicBezier = exports.CurveUtils.tangentCubicBezier;

    	return new Vector2(
    		tangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),
    		tangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )
    	).normalize();

    };

    /**************************************************************
     *	Quadratic Bezier curve
     **************************************************************/


    function QuadraticBezierCurve( v0, v1, v2 ) {

    	this.v0 = v0;
    	this.v1 = v1;
    	this.v2 = v2;

    }

    QuadraticBezierCurve.prototype = Object.create( Curve.prototype );
    QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;


    QuadraticBezierCurve.prototype.getPoint = function ( t ) {

    	var b2 = exports.ShapeUtils.b2;

    	return new Vector2(
    		b2( t, this.v0.x, this.v1.x, this.v2.x ),
    		b2( t, this.v0.y, this.v1.y, this.v2.y )
    	);

    };


    QuadraticBezierCurve.prototype.getTangent = function( t ) {

    	var tangentQuadraticBezier = exports.CurveUtils.tangentQuadraticBezier;

    	return new Vector2(
    		tangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x ),
    		tangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y )
    	).normalize();

    };

    var PathPrototype = Object.assign( Object.create( CurvePath.prototype ), {

    	fromPoints: function ( vectors ) {

    		this.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );

    		for ( var i = 1, l = vectors.length; i < l; i ++ ) {

    			this.lineTo( vectors[ i ].x, vectors[ i ].y );

    		}

    	},

    	moveTo: function ( x, y ) {

    		this.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?

    	},

    	lineTo: function ( x, y ) {

    		var curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );
    		this.curves.push( curve );

    		this.currentPoint.set( x, y );

    	},

    	quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {

    		var curve = new QuadraticBezierCurve(
    			this.currentPoint.clone(),
    			new Vector2( aCPx, aCPy ),
    			new Vector2( aX, aY )
    		);

    		this.curves.push( curve );

    		this.currentPoint.set( aX, aY );

    	},

    	bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

    		var curve = new CubicBezierCurve(
    			this.currentPoint.clone(),
    			new Vector2( aCP1x, aCP1y ),
    			new Vector2( aCP2x, aCP2y ),
    			new Vector2( aX, aY )
    		);

    		this.curves.push( curve );

    		this.currentPoint.set( aX, aY );

    	},

    	splineThru: function ( pts /*Array of Vector*/ ) {

    		var npts = [ this.currentPoint.clone() ].concat( pts );

    		var curve = new SplineCurve( npts );
    		this.curves.push( curve );

    		this.currentPoint.copy( pts[ pts.length - 1 ] );

    	},

    	arc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

    		var x0 = this.currentPoint.x;
    		var y0 = this.currentPoint.y;

    		this.absarc( aX + x0, aY + y0, aRadius,
    			aStartAngle, aEndAngle, aClockwise );

    	},

    	absarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

    		this.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

    	},

    	ellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

    		var x0 = this.currentPoint.x;
    		var y0 = this.currentPoint.y;

    		this.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

    	},

    	absellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

    		var curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

    		if ( this.curves.length > 0 ) {

    			// if a previous curve is present, attempt to join
    			var firstPoint = curve.getPoint( 0 );

    			if ( ! firstPoint.equals( this.currentPoint ) ) {

    				this.lineTo( firstPoint.x, firstPoint.y );

    			}

    		}

    		this.curves.push( curve );

    		var lastPoint = curve.getPoint( 1 );
    		this.currentPoint.copy( lastPoint );

    	}

    } );

    /**
     * @author zz85 / http://www.lab4games.net/zz85/blog
     * Defines a 2d shape plane using paths.
     **/

    // STEP 1 Create a path.
    // STEP 2 Turn path into shape.
    // STEP 3 ExtrudeGeometry takes in Shape/Shapes
    // STEP 3a - Extract points from each shape, turn to vertices
    // STEP 3b - Triangulate each shape, add faces.

    function Shape() {

    	Path.apply( this, arguments );

    	this.holes = [];

    }

    Shape.prototype = Object.assign( Object.create( PathPrototype ), {

    	constructor: Shape,

    	getPointsHoles: function ( divisions ) {

    		var holesPts = [];

    		for ( var i = 0, l = this.holes.length; i < l; i ++ ) {

    			holesPts[ i ] = this.holes[ i ].getPoints( divisions );

    		}

    		return holesPts;

    	},

    	// Get points of shape and holes (keypoints based on segments parameter)

    	extractAllPoints: function ( divisions ) {

    		return {

    			shape: this.getPoints( divisions ),
    			holes: this.getPointsHoles( divisions )

    		};

    	},

    	extractPoints: function ( divisions ) {

    		return this.extractAllPoints( divisions );

    	}

    } );

    /**
     * @author zz85 / http://www.lab4games.net/zz85/blog
     * Creates free form 2d path using series of points, lines or curves.
     *
     **/

    function Path( points ) {

    	CurvePath.call( this );
    	this.currentPoint = new Vector2();

    	if ( points ) {

    		this.fromPoints( points );

    	}

    }

    Path.prototype = PathPrototype;
    PathPrototype.constructor = Path;


    // minimal class for proxing functions to Path. Replaces old "extractSubpaths()"
    function ShapePath() {
    	this.subPaths = [];
    	this.currentPath = null;
    }

    ShapePath.prototype = {
    	moveTo: function ( x, y ) {
    		this.currentPath = new Path();
    		this.subPaths.push(this.currentPath);
    		this.currentPath.moveTo( x, y );
    	},
    	lineTo: function ( x, y ) {
    		this.currentPath.lineTo( x, y );
    	},
    	quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {
    		this.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );
    	},
    	bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {
    		this.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );
    	},
    	splineThru: function ( pts ) {
    		this.currentPath.splineThru( pts );
    	},

    	toShapes: function ( isCCW, noHoles ) {

    		function toShapesNoHoles( inSubpaths ) {

    			var shapes = [];

    			for ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {

    				var tmpPath = inSubpaths[ i ];

    				var tmpShape = new Shape();
    				tmpShape.curves = tmpPath.curves;

    				shapes.push( tmpShape );

    			}

    			return shapes;

    		}

    		function isPointInsidePolygon( inPt, inPolygon ) {

    			var polyLen = inPolygon.length;

    			// inPt on polygon contour => immediate success    or
    			// toggling of inside/outside at every single! intersection point of an edge
    			//  with the horizontal line through inPt, left of inPt
    			//  not counting lowerY endpoints of edges and whole edges on that line
    			var inside = false;
    			for ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {

    				var edgeLowPt  = inPolygon[ p ];
    				var edgeHighPt = inPolygon[ q ];

    				var edgeDx = edgeHighPt.x - edgeLowPt.x;
    				var edgeDy = edgeHighPt.y - edgeLowPt.y;

    				if ( Math.abs( edgeDy ) > Number.EPSILON ) {

    					// not parallel
    					if ( edgeDy < 0 ) {

    						edgeLowPt  = inPolygon[ q ]; edgeDx = - edgeDx;
    						edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;

    					}
    					if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) 		continue;

    					if ( inPt.y === edgeLowPt.y ) {

    						if ( inPt.x === edgeLowPt.x )		return	true;		// inPt is on contour ?
    						// continue;				// no intersection or edgeLowPt => doesn't count !!!

    					} else {

    						var perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );
    						if ( perpEdge === 0 )				return	true;		// inPt is on contour ?
    						if ( perpEdge < 0 ) 				continue;
    						inside = ! inside;		// true intersection left of inPt

    					}

    				} else {

    					// parallel or collinear
    					if ( inPt.y !== edgeLowPt.y ) 		continue;			// parallel
    					// edge lies on the same horizontal line as inPt
    					if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
    						 ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )		return	true;	// inPt: Point on contour !
    					// continue;

    				}

    			}

    			return	inside;

    		}

    		var isClockWise = exports.ShapeUtils.isClockWise;

    		var subPaths = this.subPaths;
    		if ( subPaths.length === 0 ) return [];

    		if ( noHoles === true )	return	toShapesNoHoles( subPaths );


    		var solid, tmpPath, tmpShape, shapes = [];

    		if ( subPaths.length === 1 ) {

    			tmpPath = subPaths[ 0 ];
    			tmpShape = new Shape();
    			tmpShape.curves = tmpPath.curves;
    			shapes.push( tmpShape );
    			return shapes;

    		}

    		var holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );
    		holesFirst = isCCW ? ! holesFirst : holesFirst;

    		// console.log("Holes first", holesFirst);

    		var betterShapeHoles = [];
    		var newShapes = [];
    		var newShapeHoles = [];
    		var mainIdx = 0;
    		var tmpPoints;

    		newShapes[ mainIdx ] = undefined;
    		newShapeHoles[ mainIdx ] = [];

    		for ( var i = 0, l = subPaths.length; i < l; i ++ ) {

    			tmpPath = subPaths[ i ];
    			tmpPoints = tmpPath.getPoints();
    			solid = isClockWise( tmpPoints );
    			solid = isCCW ? ! solid : solid;

    			if ( solid ) {

    				if ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )	mainIdx ++;

    				newShapes[ mainIdx ] = { s: new Shape(), p: tmpPoints };
    				newShapes[ mainIdx ].s.curves = tmpPath.curves;

    				if ( holesFirst )	mainIdx ++;
    				newShapeHoles[ mainIdx ] = [];

    				//console.log('cw', i);

    			} else {

    				newShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );

    				//console.log('ccw', i);

    			}

    		}

    		// only Holes? -> probably all Shapes with wrong orientation
    		if ( ! newShapes[ 0 ] )	return	toShapesNoHoles( subPaths );


    		if ( newShapes.length > 1 ) {

    			var ambiguous = false;
    			var toChange = [];

    			for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

    				betterShapeHoles[ sIdx ] = [];

    			}

    			for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

    				var sho = newShapeHoles[ sIdx ];

    				for ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {

    					var ho = sho[ hIdx ];
    					var hole_unassigned = true;

    					for ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {

    						if ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {

    							if ( sIdx !== s2Idx )	toChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );
    							if ( hole_unassigned ) {

    								hole_unassigned = false;
    								betterShapeHoles[ s2Idx ].push( ho );

    							} else {

    								ambiguous = true;

    							}

    						}

    					}
    					if ( hole_unassigned ) {

    						betterShapeHoles[ sIdx ].push( ho );

    					}

    				}

    			}
    			// console.log("ambiguous: ", ambiguous);
    			if ( toChange.length > 0 ) {

    				// console.log("to change: ", toChange);
    				if ( ! ambiguous )	newShapeHoles = betterShapeHoles;

    			}

    		}

    		var tmpHoles;

    		for ( var i = 0, il = newShapes.length; i < il; i ++ ) {

    			tmpShape = newShapes[ i ].s;
    			shapes.push( tmpShape );
    			tmpHoles = newShapeHoles[ i ];

    			for ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {

    				tmpShape.holes.push( tmpHoles[ j ].h );

    			}

    		}

    		//console.log("shape", shapes);

    		return shapes;

    	}
    }

    /**
     * @author zz85 / http://www.lab4games.net/zz85/blog
     * @author mrdoob / http://mrdoob.com/
     */

    function Font( data ) {

    	this.data = data;

    }

    Object.assign( Font.prototype, {

    	isFont: true,

    	generateShapes: function ( text, size, divisions ) {

    		function createPaths( text ) {

    			var chars = String( text ).split( '' );
    			var scale = size / data.resolution;
    			var offset = 0;

    			var paths = [];

    			for ( var i = 0; i < chars.length; i ++ ) {

    				var ret = createPath( chars[ i ], scale, offset );
    				offset += ret.offset;

    				paths.push( ret.path );

    			}

    			return paths;

    		}

    		function createPath( c, scale, offset ) {

    			var glyph = data.glyphs[ c ] || data.glyphs[ '?' ];

    			if ( ! glyph ) return;

    			var path = new ShapePath();

    			var pts = [], b2 = exports.ShapeUtils.b2, b3 = exports.ShapeUtils.b3;
    			var x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2, laste;

    			if ( glyph.o ) {

    				var outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );

    				for ( var i = 0, l = outline.length; i < l; ) {

    					var action = outline[ i ++ ];

    					switch ( action ) {

    						case 'm': // moveTo

    							x = outline[ i ++ ] * scale + offset;
    							y = outline[ i ++ ] * scale;

    							path.moveTo( x, y );

    							break;

    						case 'l': // lineTo

    							x = outline[ i ++ ] * scale + offset;
    							y = outline[ i ++ ] * scale;

    							path.lineTo( x, y );

    							break;

    						case 'q': // quadraticCurveTo

    							cpx  = outline[ i ++ ] * scale + offset;
    							cpy  = outline[ i ++ ] * scale;
    							cpx1 = outline[ i ++ ] * scale + offset;
    							cpy1 = outline[ i ++ ] * scale;

    							path.quadraticCurveTo( cpx1, cpy1, cpx, cpy );

    							laste = pts[ pts.length - 1 ];

    							if ( laste ) {

    								cpx0 = laste.x;
    								cpy0 = laste.y;

    								for ( var i2 = 1; i2 <= divisions; i2 ++ ) {

    									var t = i2 / divisions;
    									b2( t, cpx0, cpx1, cpx );
    									b2( t, cpy0, cpy1, cpy );

    								}

    							}

    							break;

    						case 'b': // bezierCurveTo

    							cpx  = outline[ i ++ ] * scale + offset;
    							cpy  = outline[ i ++ ] * scale;
    							cpx1 = outline[ i ++ ] * scale + offset;
    							cpy1 = outline[ i ++ ] * scale;
    							cpx2 = outline[ i ++ ] * scale + offset;
    							cpy2 = outline[ i ++ ] * scale;

    							path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );

    							laste = pts[ pts.length - 1 ];

    							if ( laste ) {

    								cpx0 = laste.x;
    								cpy0 = laste.y;

    								for ( var i2 = 1; i2 <= divisions; i2 ++ ) {

    									var t = i2 / divisions;
    									b3( t, cpx0, cpx1, cpx2, cpx );
    									b3( t, cpy0, cpy1, cpy2, cpy );

    								}

    							}

    							break;

    					}

    				}

    			}

    			return { offset: glyph.ha * scale, path: path };

    		}

    		//

    		if ( size === undefined ) size = 100;
    		if ( divisions === undefined ) divisions = 4;

    		var data = this.data;

    		var paths = createPaths( text );
    		var shapes = [];

    		for ( var p = 0, pl = paths.length; p < pl; p ++ ) {

    			Array.prototype.push.apply( shapes, paths[ p ].toShapes() );

    		}

    		return shapes;

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function FontLoader( manager ) {

    	this.manager = ( manager !== undefined ) ? manager : exports.DefaultLoadingManager;

    }

    Object.assign( FontLoader.prototype, {

    	load: function ( url, onLoad, onProgress, onError ) {

    		var scope = this;

    		var loader = new XHRLoader( this.manager );
    		loader.load( url, function ( text ) {

    			var json;

    			try {

    				json = JSON.parse( text );

    			} catch ( e ) {

    				console.warn( 'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.' );
    				json = JSON.parse( text.substring( 65, text.length - 2 ) );

    			}

    			var font = scope.parse( json );

    			if ( onLoad ) onLoad( font );

    		}, onProgress, onError );

    	},

    	parse: function ( json ) {

    		return new Font( json );

    	}

    } );

    var context;

    function getAudioContext() {

    	if ( context === undefined ) {

    		context = new ( window.AudioContext || window.webkitAudioContext )();

    	}

    	return context;

    }

    /**
     * @author Reece Aaron Lecrivain / http://reecenotes.com/
     */

    function AudioLoader( manager ) {

    	this.manager = ( manager !== undefined ) ? manager : exports.DefaultLoadingManager;

    }

    Object.assign( AudioLoader.prototype, {

    	load: function ( url, onLoad, onProgress, onError ) {

    		var loader = new XHRLoader( this.manager );
    		loader.setResponseType( 'arraybuffer' );
    		loader.load( url, function ( buffer ) {

    			var context = getAudioContext();

    			context.decodeAudioData( buffer, function ( audioBuffer ) {

    				onLoad( audioBuffer );

    			} );

    		}, onProgress, onError );

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function StereoCamera() {

    	this.type = 'StereoCamera';

    	this.aspect = 1;

    	this.eyeSep = 0.064;

    	this.cameraL = new PerspectiveCamera();
    	this.cameraL.layers.enable( 1 );
    	this.cameraL.matrixAutoUpdate = false;

    	this.cameraR = new PerspectiveCamera();
    	this.cameraR.layers.enable( 2 );
    	this.cameraR.matrixAutoUpdate = false;

    }

    Object.assign( StereoCamera.prototype, {

    	update: ( function () {

    		var instance, focus, fov, aspect, near, far, zoom;

    		var eyeRight = new Matrix4();
    		var eyeLeft = new Matrix4();

    		return function update( camera ) {

    			var needsUpdate = instance !== this || focus !== camera.focus || fov !== camera.fov ||
    												aspect !== camera.aspect * this.aspect || near !== camera.near ||
    												far !== camera.far || zoom !== camera.zoom;

    			if ( needsUpdate ) {

    				instance = this;
    				focus = camera.focus;
    				fov = camera.fov;
    				aspect = camera.aspect * this.aspect;
    				near = camera.near;
    				far = camera.far;
    				zoom = camera.zoom;

    				// Off-axis stereoscopic effect based on
    				// http://paulbourke.net/stereographics/stereorender/

    				var projectionMatrix = camera.projectionMatrix.clone();
    				var eyeSep = this.eyeSep / 2;
    				var eyeSepOnProjection = eyeSep * near / focus;
    				var ymax = ( near * Math.tan( exports.Math.DEG2RAD * fov * 0.5 ) ) / zoom;
    				var xmin, xmax;

    				// translate xOffset

    				eyeLeft.elements[ 12 ] = - eyeSep;
    				eyeRight.elements[ 12 ] = eyeSep;

    				// for left eye

    				xmin = - ymax * aspect + eyeSepOnProjection;
    				xmax = ymax * aspect + eyeSepOnProjection;

    				projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );
    				projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

    				this.cameraL.projectionMatrix.copy( projectionMatrix );

    				// for right eye

    				xmin = - ymax * aspect - eyeSepOnProjection;
    				xmax = ymax * aspect - eyeSepOnProjection;

    				projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );
    				projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

    				this.cameraR.projectionMatrix.copy( projectionMatrix );

    			}

    			this.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft );
    			this.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight );

    		};

    	} )()

    } );

    /**
     * Camera for rendering cube maps
     *	- renders scene into axis-aligned cube
     *
     * @author alteredq / http://alteredqualia.com/
     */

    function CubeCamera( near, far, cubeResolution ) {

    	Object3D.call( this );

    	this.type = 'CubeCamera';

    	var fov = 90, aspect = 1;

    	var cameraPX = new PerspectiveCamera( fov, aspect, near, far );
    	cameraPX.up.set( 0, - 1, 0 );
    	cameraPX.lookAt( new Vector3( 1, 0, 0 ) );
    	this.add( cameraPX );

    	var cameraNX = new PerspectiveCamera( fov, aspect, near, far );
    	cameraNX.up.set( 0, - 1, 0 );
    	cameraNX.lookAt( new Vector3( - 1, 0, 0 ) );
    	this.add( cameraNX );

    	var cameraPY = new PerspectiveCamera( fov, aspect, near, far );
    	cameraPY.up.set( 0, 0, 1 );
    	cameraPY.lookAt( new Vector3( 0, 1, 0 ) );
    	this.add( cameraPY );

    	var cameraNY = new PerspectiveCamera( fov, aspect, near, far );
    	cameraNY.up.set( 0, 0, - 1 );
    	cameraNY.lookAt( new Vector3( 0, - 1, 0 ) );
    	this.add( cameraNY );

    	var cameraPZ = new PerspectiveCamera( fov, aspect, near, far );
    	cameraPZ.up.set( 0, - 1, 0 );
    	cameraPZ.lookAt( new Vector3( 0, 0, 1 ) );
    	this.add( cameraPZ );

    	var cameraNZ = new PerspectiveCamera( fov, aspect, near, far );
    	cameraNZ.up.set( 0, - 1, 0 );
    	cameraNZ.lookAt( new Vector3( 0, 0, - 1 ) );
    	this.add( cameraNZ );

    	var options = { format: RGBFormat, magFilter: LinearFilter, minFilter: LinearFilter };

    	this.renderTarget = new WebGLRenderTargetCube( cubeResolution, cubeResolution, options );

    	this.updateCubeMap = function ( renderer, scene ) {

    		if ( this.parent === null ) this.updateMatrixWorld();

    		var renderTarget = this.renderTarget;
    		var generateMipmaps = renderTarget.texture.generateMipmaps;

    		renderTarget.texture.generateMipmaps = false;

    		renderTarget.activeCubeFace = 0;
    		renderer.render( scene, cameraPX, renderTarget );

    		renderTarget.activeCubeFace = 1;
    		renderer.render( scene, cameraNX, renderTarget );

    		renderTarget.activeCubeFace = 2;
    		renderer.render( scene, cameraPY, renderTarget );

    		renderTarget.activeCubeFace = 3;
    		renderer.render( scene, cameraNY, renderTarget );

    		renderTarget.activeCubeFace = 4;
    		renderer.render( scene, cameraPZ, renderTarget );

    		renderTarget.texture.generateMipmaps = generateMipmaps;

    		renderTarget.activeCubeFace = 5;
    		renderer.render( scene, cameraNZ, renderTarget );

    		renderer.setRenderTarget( null );

    	};

    }

    CubeCamera.prototype = Object.create( Object3D.prototype );
    CubeCamera.prototype.constructor = CubeCamera;

    function AudioListener() {

    	Object3D.call( this );

    	this.type = 'AudioListener';

    	this.context = getAudioContext();

    	this.gain = this.context.createGain();
    	this.gain.connect( this.context.destination );

    	this.filter = null;

    }

    AudioListener.prototype = Object.assign( Object.create( Object3D.prototype ), {

    	constructor: AudioListener,

    	getInput: function () {

    		return this.gain;

    	},

    	removeFilter: function ( ) {

    		if ( this.filter !== null ) {

    			this.gain.disconnect( this.filter );
    			this.filter.disconnect( this.context.destination );
    			this.gain.connect( this.context.destination );
    			this.filter = null;

    		}

    	},

    	getFilter: function () {

    		return this.filter;

    	},

    	setFilter: function ( value ) {

    		if ( this.filter !== null ) {

    			this.gain.disconnect( this.filter );
    			this.filter.disconnect( this.context.destination );

    		} else {

    			this.gain.disconnect( this.context.destination );

    		}

    		this.filter = value;
    		this.gain.connect( this.filter );
    		this.filter.connect( this.context.destination );

    	},

    	getMasterVolume: function () {

    		return this.gain.gain.value;

    	},

    	setMasterVolume: function ( value ) {

    		this.gain.gain.value = value;

    	},

    	updateMatrixWorld: ( function () {

    		var position = new Vector3();
    		var quaternion = new Quaternion();
    		var scale = new Vector3();

    		var orientation = new Vector3();

    		return function updateMatrixWorld( force ) {

    			Object3D.prototype.updateMatrixWorld.call( this, force );

    			var listener = this.context.listener;
    			var up = this.up;

    			this.matrixWorld.decompose( position, quaternion, scale );

    			orientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );

    			listener.setPosition( position.x, position.y, position.z );
    			listener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );

    		};

    	} )()

    } );

    function Audio( listener ) {

    	Object3D.call( this );

    	this.type = 'Audio';

    	this.context = listener.context;
    	this.source = this.context.createBufferSource();
    	this.source.onended = this.onEnded.bind( this );

    	this.gain = this.context.createGain();
    	this.gain.connect( listener.getInput() );

    	this.autoplay = false;

    	this.startTime = 0;
    	this.playbackRate = 1;
    	this.isPlaying = false;
    	this.hasPlaybackControl = true;
    	this.sourceType = 'empty';

    	this.filters = [];

    }

    Audio.prototype = Object.assign( Object.create( Object3D.prototype ), {

    	constructor: Audio,

    	getOutput: function () {

    		return this.gain;

    	},

    	setNodeSource: function ( audioNode ) {

    		this.hasPlaybackControl = false;
    		this.sourceType = 'audioNode';
    		this.source = audioNode;
    		this.connect();

    		return this;

    	},

    	setBuffer: function ( audioBuffer ) {

    		this.source.buffer = audioBuffer;
    		this.sourceType = 'buffer';

    		if ( this.autoplay ) this.play();

    		return this;

    	},

    	play: function () {

    		if ( this.isPlaying === true ) {

    			console.warn( 'THREE.Audio: Audio is already playing.' );
    			return;

    		}

    		if ( this.hasPlaybackControl === false ) {

    			console.warn( 'THREE.Audio: this Audio has no playback control.' );
    			return;

    		}

    		var source = this.context.createBufferSource();

    		source.buffer = this.source.buffer;
    		source.loop = this.source.loop;
    		source.onended = this.source.onended;
    		source.start( 0, this.startTime );
    		source.playbackRate.value = this.playbackRate;

    		this.isPlaying = true;

    		this.source = source;

    		return this.connect();

    	},

    	pause: function () {

    		if ( this.hasPlaybackControl === false ) {

    			console.warn( 'THREE.Audio: this Audio has no playback control.' );
    			return;

    		}

    		this.source.stop();
    		this.startTime = this.context.currentTime;
    		this.isPlaying = false;

    		return this;

    	},

    	stop: function () {

    		if ( this.hasPlaybackControl === false ) {

    			console.warn( 'THREE.Audio: this Audio has no playback control.' );
    			return;

    		}

    		this.source.stop();
    		this.startTime = 0;
    		this.isPlaying = false;

    		return this;

    	},

    	connect: function () {

    		if ( this.filters.length > 0 ) {

    			this.source.connect( this.filters[ 0 ] );

    			for ( var i = 1, l = this.filters.length; i < l; i ++ ) {

    				this.filters[ i - 1 ].connect( this.filters[ i ] );

    			}

    			this.filters[ this.filters.length - 1 ].connect( this.getOutput() );

    		} else {

    			this.source.connect( this.getOutput() );

    		}

    		return this;

    	},

    	disconnect: function () {

    		if ( this.filters.length > 0 ) {

    			this.source.disconnect( this.filters[ 0 ] );

    			for ( var i = 1, l = this.filters.length; i < l; i ++ ) {

    				this.filters[ i - 1 ].disconnect( this.filters[ i ] );

    			}

    			this.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );

    		} else {

    			this.source.disconnect( this.getOutput() );

    		}

    		return this;

    	},

    	getFilters: function () {

    		return this.filters;

    	},

    	setFilters: function ( value ) {

    		if ( ! value ) value = [];

    		if ( this.isPlaying === true ) {

    			this.disconnect();
    			this.filters = value;
    			this.connect();

    		} else {

    			this.filters = value;

    		}

    		return this;

    	},

    	getFilter: function () {

    		return this.getFilters()[ 0 ];

    	},

    	setFilter: function ( filter ) {

    		return this.setFilters( filter ? [ filter ] : [] );

    	},

    	setPlaybackRate: function ( value ) {

    		if ( this.hasPlaybackControl === false ) {

    			console.warn( 'THREE.Audio: this Audio has no playback control.' );
    			return;

    		}

    		this.playbackRate = value;

    		if ( this.isPlaying === true ) {

    			this.source.playbackRate.value = this.playbackRate;

    		}

    		return this;

    	},

    	getPlaybackRate: function () {

    		return this.playbackRate;

    	},

    	onEnded: function () {

    		this.isPlaying = false;

    	},

    	getLoop: function () {

    		if ( this.hasPlaybackControl === false ) {

    			console.warn( 'THREE.Audio: this Audio has no playback control.' );
    			return false;

    		}

    		return this.source.loop;

    	},

    	setLoop: function ( value ) {

    		if ( this.hasPlaybackControl === false ) {

    			console.warn( 'THREE.Audio: this Audio has no playback control.' );
    			return;

    		}

    		this.source.loop = value;

    	},

    	getVolume: function () {

    		return this.gain.gain.value;

    	},


    	setVolume: function ( value ) {

    		this.gain.gain.value = value;

    		return this;

    	}

    } );

    function PositionalAudio( listener ) {

    	Audio.call( this, listener );

    	this.panner = this.context.createPanner();
    	this.panner.connect( this.gain );

    }

    PositionalAudio.prototype = Object.assign( Object.create( Audio.prototype ), {

    	constructor: PositionalAudio,

    	getOutput: function () {

    		return this.panner;

    	},

    	getRefDistance: function () {

    		return this.panner.refDistance;

    	},

    	setRefDistance: function ( value ) {

    		this.panner.refDistance = value;

    	},

    	getRolloffFactor: function () {

    		return this.panner.rolloffFactor;

    	},

    	setRolloffFactor: function ( value ) {

    		this.panner.rolloffFactor = value;

    	},

    	getDistanceModel: function () {

    		return this.panner.distanceModel;

    	},

    	setDistanceModel: function ( value ) {

    		this.panner.distanceModel = value;

    	},

    	getMaxDistance: function () {

    		return this.panner.maxDistance;

    	},

    	setMaxDistance: function ( value ) {

    		this.panner.maxDistance = value;

    	},

    	updateMatrixWorld: ( function () {

    		var position = new Vector3();

    		return function updateMatrixWorld( force ) {

    			Object3D.prototype.updateMatrixWorld.call( this, force );

    			position.setFromMatrixPosition( this.matrixWorld );

    			this.panner.setPosition( position.x, position.y, position.z );

    		};

    	} )()


    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function AudioAnalyser( audio, fftSize ) {

    	this.analyser = audio.context.createAnalyser();
    	this.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;

    	this.data = new Uint8Array( this.analyser.frequencyBinCount );

    	audio.getOutput().connect( this.analyser );

    }

    Object.assign( AudioAnalyser.prototype, {

    	getFrequencyData: function () {

    		this.analyser.getByteFrequencyData( this.data );

    		return this.data;

    	},

    	getAverageFrequency: function () {

    		var value = 0, data = this.getFrequencyData();

    		for ( var i = 0; i < data.length; i ++ ) {

    			value += data[ i ];

    		}

    		return value / data.length;

    	}

    } );

    /**
     *
     * Buffered scene graph property that allows weighted accumulation.
     *
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */

    function PropertyMixer( binding, typeName, valueSize ) {

    	this.binding = binding;
    	this.valueSize = valueSize;

    	var bufferType = Float64Array,
    		mixFunction;

    	switch ( typeName ) {

    		case 'quaternion':			mixFunction = this._slerp;		break;

    		case 'string':
    		case 'bool':

    			bufferType = Array,		mixFunction = this._select;		break;

    		default:					mixFunction = this._lerp;

    	}

    	this.buffer = new bufferType( valueSize * 4 );
    	// layout: [ incoming | accu0 | accu1 | orig ]
    	//
    	// interpolators can use .buffer as their .result
    	// the data then goes to 'incoming'
    	//
    	// 'accu0' and 'accu1' are used frame-interleaved for
    	// the cumulative result and are compared to detect
    	// changes
    	//
    	// 'orig' stores the original state of the property

    	this._mixBufferRegion = mixFunction;

    	this.cumulativeWeight = 0;

    	this.useCount = 0;
    	this.referenceCount = 0;

    }

    PropertyMixer.prototype = {

    	constructor: PropertyMixer,

    	// accumulate data in the 'incoming' region into 'accu<i>'
    	accumulate: function( accuIndex, weight ) {

    		// note: happily accumulating nothing when weight = 0, the caller knows
    		// the weight and shouldn't have made the call in the first place

    		var buffer = this.buffer,
    			stride = this.valueSize,
    			offset = accuIndex * stride + stride,

    			currentWeight = this.cumulativeWeight;

    		if ( currentWeight === 0 ) {

    			// accuN := incoming * weight

    			for ( var i = 0; i !== stride; ++ i ) {

    				buffer[ offset + i ] = buffer[ i ];

    			}

    			currentWeight = weight;

    		} else {

    			// accuN := accuN + incoming * weight

    			currentWeight += weight;
    			var mix = weight / currentWeight;
    			this._mixBufferRegion( buffer, offset, 0, mix, stride );

    		}

    		this.cumulativeWeight = currentWeight;

    	},

    	// apply the state of 'accu<i>' to the binding when accus differ
    	apply: function( accuIndex ) {

    		var stride = this.valueSize,
    			buffer = this.buffer,
    			offset = accuIndex * stride + stride,

    			weight = this.cumulativeWeight,

    			binding = this.binding;

    		this.cumulativeWeight = 0;

    		if ( weight < 1 ) {

    			// accuN := accuN + original * ( 1 - cumulativeWeight )

    			var originalValueOffset = stride * 3;

    			this._mixBufferRegion(
    					buffer, offset, originalValueOffset, 1 - weight, stride );

    		}

    		for ( var i = stride, e = stride + stride; i !== e; ++ i ) {

    			if ( buffer[ i ] !== buffer[ i + stride ] ) {

    				// value has changed -> update scene graph

    				binding.setValue( buffer, offset );
    				break;

    			}

    		}

    	},

    	// remember the state of the bound property and copy it to both accus
    	saveOriginalState: function() {

    		var binding = this.binding;

    		var buffer = this.buffer,
    			stride = this.valueSize,

    			originalValueOffset = stride * 3;

    		binding.getValue( buffer, originalValueOffset );

    		// accu[0..1] := orig -- initially detect changes against the original
    		for ( var i = stride, e = originalValueOffset; i !== e; ++ i ) {

    			buffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];

    		}

    		this.cumulativeWeight = 0;

    	},

    	// apply the state previously taken via 'saveOriginalState' to the binding
    	restoreOriginalState: function() {

    		var originalValueOffset = this.valueSize * 3;
    		this.binding.setValue( this.buffer, originalValueOffset );

    	},


    	// mix functions

    	_select: function( buffer, dstOffset, srcOffset, t, stride ) {

    		if ( t >= 0.5 ) {

    			for ( var i = 0; i !== stride; ++ i ) {

    				buffer[ dstOffset + i ] = buffer[ srcOffset + i ];

    			}

    		}

    	},

    	_slerp: function( buffer, dstOffset, srcOffset, t, stride ) {

    		Quaternion.slerpFlat( buffer, dstOffset,
    				buffer, dstOffset, buffer, srcOffset, t );

    	},

    	_lerp: function( buffer, dstOffset, srcOffset, t, stride ) {

    		var s = 1 - t;

    		for ( var i = 0; i !== stride; ++ i ) {

    			var j = dstOffset + i;

    			buffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;

    		}

    	}

    };

    /**
     *
     * A reference to a real property in the scene graph.
     *
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */

    function PropertyBinding( rootNode, path, parsedPath ) {

    	this.path = path;
    	this.parsedPath = parsedPath ||
    			PropertyBinding.parseTrackName( path );

    	this.node = PropertyBinding.findNode(
    			rootNode, this.parsedPath.nodeName ) || rootNode;

    	this.rootNode = rootNode;

    }

    PropertyBinding.prototype = {

    	constructor: PropertyBinding,

    	getValue: function getValue_unbound( targetArray, offset ) {

    		this.bind();
    		this.getValue( targetArray, offset );

    		// Note: This class uses a State pattern on a per-method basis:
    		// 'bind' sets 'this.getValue' / 'setValue' and shadows the
    		// prototype version of these methods with one that represents
    		// the bound state. When the property is not found, the methods
    		// become no-ops.

    	},

    	setValue: function getValue_unbound( sourceArray, offset ) {

    		this.bind();
    		this.setValue( sourceArray, offset );

    	},

    	// create getter / setter pair for a property in the scene graph
    	bind: function() {

    		var targetObject = this.node,
    			parsedPath = this.parsedPath,

    			objectName = parsedPath.objectName,
    			propertyName = parsedPath.propertyName,
    			propertyIndex = parsedPath.propertyIndex;

    		if ( ! targetObject ) {

    			targetObject = PropertyBinding.findNode(
    					this.rootNode, parsedPath.nodeName ) || this.rootNode;

    			this.node = targetObject;

    		}

    		// set fail state so we can just 'return' on error
    		this.getValue = this._getValue_unavailable;
    		this.setValue = this._setValue_unavailable;

     		// ensure there is a value node
    		if ( ! targetObject ) {

    			console.error( "  trying to update node for track: " + this.path + " but it wasn't found." );
    			return;

    		}

    		if ( objectName ) {

    			var objectIndex = parsedPath.objectIndex;

    			// special cases were we need to reach deeper into the hierarchy to get the face materials....
    			switch ( objectName ) {

    				case 'materials':

    					if ( ! targetObject.material ) {

    						console.error( '  can not bind to material as node does not have a material', this );
    						return;

    					}

    					if ( ! targetObject.material.materials ) {

    						console.error( '  can not bind to material.materials as node.material does not have a materials array', this );
    						return;

    					}

    					targetObject = targetObject.material.materials;

    					break;

    				case 'bones':

    					if ( ! targetObject.skeleton ) {

    						console.error( '  can not bind to bones as node does not have a skeleton', this );
    						return;

    					}

    					// potential future optimization: skip this if propertyIndex is already an integer
    					// and convert the integer string to a true integer.

    					targetObject = targetObject.skeleton.bones;

    					// support resolving morphTarget names into indices.
    					for ( var i = 0; i < targetObject.length; i ++ ) {

    						if ( targetObject[ i ].name === objectIndex ) {

    							objectIndex = i;
    							break;

    						}

    					}

    					break;

    				default:

    					if ( targetObject[ objectName ] === undefined ) {

    						console.error( '  can not bind to objectName of node, undefined', this );
    						return;

    					}

    					targetObject = targetObject[ objectName ];

    			}


    			if ( objectIndex !== undefined ) {

    				if ( targetObject[ objectIndex ] === undefined ) {

    					console.error( "  trying to bind to objectIndex of objectName, but is undefined:", this, targetObject );
    					return;

    				}

    				targetObject = targetObject[ objectIndex ];

    			}

    		}

    		// resolve property
    		var nodeProperty = targetObject[ propertyName ];

    		if ( nodeProperty === undefined ) {

    			var nodeName = parsedPath.nodeName;

    			console.error( "  trying to update property for track: " + nodeName +
    					'.' + propertyName + " but it wasn't found.", targetObject );
    			return;

    		}

    		// determine versioning scheme
    		var versioning = this.Versioning.None;

    		if ( targetObject.needsUpdate !== undefined ) { // material

    			versioning = this.Versioning.NeedsUpdate;
    			this.targetObject = targetObject;

    		} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform

    			versioning = this.Versioning.MatrixWorldNeedsUpdate;
    			this.targetObject = targetObject;

    		}

    		// determine how the property gets bound
    		var bindingType = this.BindingType.Direct;

    		if ( propertyIndex !== undefined ) {
    			// access a sub element of the property array (only primitives are supported right now)

    			if ( propertyName === "morphTargetInfluences" ) {
    				// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

    				// support resolving morphTarget names into indices.
    				if ( ! targetObject.geometry ) {

    					console.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry', this );
    					return;

    				}

    				if ( ! targetObject.geometry.morphTargets ) {

    					console.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets', this );
    					return;

    				}

    				for ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {

    					if ( targetObject.geometry.morphTargets[ i ].name === propertyIndex ) {

    						propertyIndex = i;
    						break;

    					}

    				}

    			}

    			bindingType = this.BindingType.ArrayElement;

    			this.resolvedProperty = nodeProperty;
    			this.propertyIndex = propertyIndex;

    		} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {
    			// must use copy for Object3D.Euler/Quaternion

    			bindingType = this.BindingType.HasFromToArray;

    			this.resolvedProperty = nodeProperty;

    		} else if ( nodeProperty.length !== undefined ) {

    			bindingType = this.BindingType.EntireArray;

    			this.resolvedProperty = nodeProperty;

    		} else {

    			this.propertyName = propertyName;

    		}

    		// select getter / setter
    		this.getValue = this.GetterByBindingType[ bindingType ];
    		this.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];

    	},

    	unbind: function() {

    		this.node = null;

    		// back to the prototype version of getValue / setValue
    		// note: avoiding to mutate the shape of 'this' via 'delete'
    		this.getValue = this._getValue_unbound;
    		this.setValue = this._setValue_unbound;

    	}

    };

    Object.assign( PropertyBinding.prototype, { // prototype, continued

    	// these are used to "bind" a nonexistent property
    	_getValue_unavailable: function() {},
    	_setValue_unavailable: function() {},

    	// initial state of these methods that calls 'bind'
    	_getValue_unbound: PropertyBinding.prototype.getValue,
    	_setValue_unbound: PropertyBinding.prototype.setValue,

    	BindingType: {
    		Direct: 0,
    		EntireArray: 1,
    		ArrayElement: 2,
    		HasFromToArray: 3
    	},

    	Versioning: {
    		None: 0,
    		NeedsUpdate: 1,
    		MatrixWorldNeedsUpdate: 2
    	},

    	GetterByBindingType: [

    		function getValue_direct( buffer, offset ) {

    			buffer[ offset ] = this.node[ this.propertyName ];

    		},

    		function getValue_array( buffer, offset ) {

    			var source = this.resolvedProperty;

    			for ( var i = 0, n = source.length; i !== n; ++ i ) {

    				buffer[ offset ++ ] = source[ i ];

    			}

    		},

    		function getValue_arrayElement( buffer, offset ) {

    			buffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];

    		},

    		function getValue_toArray( buffer, offset ) {

    			this.resolvedProperty.toArray( buffer, offset );

    		}

    	],

    	SetterByBindingTypeAndVersioning: [

    		[
    			// Direct

    			function setValue_direct( buffer, offset ) {

    				this.node[ this.propertyName ] = buffer[ offset ];

    			},

    			function setValue_direct_setNeedsUpdate( buffer, offset ) {

    				this.node[ this.propertyName ] = buffer[ offset ];
    				this.targetObject.needsUpdate = true;

    			},

    			function setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {

    				this.node[ this.propertyName ] = buffer[ offset ];
    				this.targetObject.matrixWorldNeedsUpdate = true;

    			}

    		], [

    			// EntireArray

    			function setValue_array( buffer, offset ) {

    				var dest = this.resolvedProperty;

    				for ( var i = 0, n = dest.length; i !== n; ++ i ) {

    					dest[ i ] = buffer[ offset ++ ];

    				}

    			},

    			function setValue_array_setNeedsUpdate( buffer, offset ) {

    				var dest = this.resolvedProperty;

    				for ( var i = 0, n = dest.length; i !== n; ++ i ) {

    					dest[ i ] = buffer[ offset ++ ];

    				}

    				this.targetObject.needsUpdate = true;

    			},

    			function setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {

    				var dest = this.resolvedProperty;

    				for ( var i = 0, n = dest.length; i !== n; ++ i ) {

    					dest[ i ] = buffer[ offset ++ ];

    				}

    				this.targetObject.matrixWorldNeedsUpdate = true;

    			}

    		], [

    			// ArrayElement

    			function setValue_arrayElement( buffer, offset ) {

    				this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];

    			},

    			function setValue_arrayElement_setNeedsUpdate( buffer, offset ) {

    				this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
    				this.targetObject.needsUpdate = true;

    			},

    			function setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {

    				this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
    				this.targetObject.matrixWorldNeedsUpdate = true;

    			}

    		], [

    			// HasToFromArray

    			function setValue_fromArray( buffer, offset ) {

    				this.resolvedProperty.fromArray( buffer, offset );

    			},

    			function setValue_fromArray_setNeedsUpdate( buffer, offset ) {

    				this.resolvedProperty.fromArray( buffer, offset );
    				this.targetObject.needsUpdate = true;

    			},

    			function setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {

    				this.resolvedProperty.fromArray( buffer, offset );
    				this.targetObject.matrixWorldNeedsUpdate = true;

    			}

    		]

    	]

    } );

    PropertyBinding.Composite =
    		function( targetGroup, path, optionalParsedPath ) {

    	var parsedPath = optionalParsedPath ||
    			PropertyBinding.parseTrackName( path );

    	this._targetGroup = targetGroup;
    	this._bindings = targetGroup.subscribe_( path, parsedPath );

    };

    PropertyBinding.Composite.prototype = {

    	constructor: PropertyBinding.Composite,

    	getValue: function( array, offset ) {

    		this.bind(); // bind all binding

    		var firstValidIndex = this._targetGroup.nCachedObjects_,
    			binding = this._bindings[ firstValidIndex ];

    		// and only call .getValue on the first
    		if ( binding !== undefined ) binding.getValue( array, offset );

    	},

    	setValue: function( array, offset ) {

    		var bindings = this._bindings;

    		for ( var i = this._targetGroup.nCachedObjects_,
    				n = bindings.length; i !== n; ++ i ) {

    			bindings[ i ].setValue( array, offset );

    		}

    	},

    	bind: function() {

    		var bindings = this._bindings;

    		for ( var i = this._targetGroup.nCachedObjects_,
    				n = bindings.length; i !== n; ++ i ) {

    			bindings[ i ].bind();

    		}

    	},

    	unbind: function() {

    		var bindings = this._bindings;

    		for ( var i = this._targetGroup.nCachedObjects_,
    				n = bindings.length; i !== n; ++ i ) {

    			bindings[ i ].unbind();

    		}

    	}

    };

    PropertyBinding.create = function( root, path, parsedPath ) {

    	if ( ! ( (root && root.isAnimationObjectGroup) ) ) {

    		return new PropertyBinding( root, path, parsedPath );

    	} else {

    		return new PropertyBinding.Composite( root, path, parsedPath );

    	}

    };

    PropertyBinding.parseTrackName = function( trackName ) {

    	// matches strings in the form of:
    	//    nodeName.property
    	//    nodeName.property[accessor]
    	//    nodeName.material.property[accessor]
    	//    uuid.property[accessor]
    	//    uuid.objectName[objectIndex].propertyName[propertyIndex]
    	//    parentName/nodeName.property
    	//    parentName/parentName/nodeName.property[index]
    	//    .bone[Armature.DEF_cog].position
    	//    scene:helium_balloon_model:helium_balloon_model.position
    	// created and tested via https://regex101.com/#javascript

    	var re = /^((?:\w+[\/:])*)(\w+)?(?:\.(\w+)(?:\[(.+)\])?)?\.(\w+)(?:\[(.+)\])?$/;
    	var matches = re.exec( trackName );

    	if ( ! matches ) {

    		throw new Error( "cannot parse trackName at all: " + trackName );

    	}

    	var results = {
    		// directoryName: matches[ 1 ], // (tschw) currently unused
    		nodeName: matches[ 2 ], 	// allowed to be null, specified root node.
    		objectName: matches[ 3 ],
    		objectIndex: matches[ 4 ],
    		propertyName: matches[ 5 ],
    		propertyIndex: matches[ 6 ]	// allowed to be null, specifies that the whole property is set.
    	};

    	if ( results.propertyName === null || results.propertyName.length === 0 ) {

    		throw new Error( "can not parse propertyName from trackName: " + trackName );

    	}

    	return results;

    };

    PropertyBinding.findNode = function( root, nodeName ) {

    	if ( ! nodeName || nodeName === "" || nodeName === "root" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid ) {

    		return root;

    	}

    	// search into skeleton bones.
    	if ( root.skeleton ) {

    		var searchSkeleton = function( skeleton ) {

    			for( var i = 0; i < skeleton.bones.length; i ++ ) {

    				var bone = skeleton.bones[ i ];

    				if ( bone.name === nodeName ) {

    					return bone;

    				}
    			}

    			return null;

    		};

    		var bone = searchSkeleton( root.skeleton );

    		if ( bone ) {

    			return bone;

    		}
    	}

    	// search into node subtree.
    	if ( root.children ) {

    		var searchNodeSubtree = function( children ) {

    			for( var i = 0; i < children.length; i ++ ) {

    				var childNode = children[ i ];

    				if ( childNode.name === nodeName || childNode.uuid === nodeName ) {

    					return childNode;

    				}

    				var result = searchNodeSubtree( childNode.children );

    				if ( result ) return result;

    			}

    			return null;

    		};

    		var subTreeNode = searchNodeSubtree( root.children );

    		if ( subTreeNode ) {

    			return subTreeNode;

    		}

    	}

    	return null;

    };

    /**
     *
     * A group of objects that receives a shared animation state.
     *
     * Usage:
     *
     * 	-	Add objects you would otherwise pass as 'root' to the
     * 		constructor or the .clipAction method of AnimationMixer.
     *
     * 	-	Instead pass this object as 'root'.
     *
     * 	-	You can also add and remove objects later when the mixer
     * 		is running.
     *
     * Note:
     *
     *  	Objects of this class appear as one object to the mixer,
     *  	so cache control of the individual objects must be done
     *  	on the group.
     *
     * Limitation:
     *
     * 	- 	The animated properties must be compatible among the
     * 		all objects in the group.
     *
     *  -	A single property can either be controlled through a
     *  	target group or directly, but not both.
     *
     * @author tschw
     */

    function AnimationObjectGroup( var_args ) {

    	this.uuid = exports.Math.generateUUID();

    	// cached objects followed by the active ones
    	this._objects = Array.prototype.slice.call( arguments );

    	this.nCachedObjects_ = 0;			// threshold
    	// note: read by PropertyBinding.Composite

    	var indices = {};
    	this._indicesByUUID = indices;		// for bookkeeping

    	for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

    		indices[ arguments[ i ].uuid ] = i;

    	}

    	this._paths = [];					// inside: string
    	this._parsedPaths = [];				// inside: { we don't care, here }
    	this._bindings = []; 				// inside: Array< PropertyBinding >
    	this._bindingsIndicesByPath = {}; 	// inside: indices in these arrays

    	var scope = this;

    	this.stats = {

    		objects: {
    			get total() { return scope._objects.length; },
    			get inUse() { return this.total - scope.nCachedObjects_;  }
    		},

    		get bindingsPerObject() { return scope._bindings.length; }

    	};

    }

    AnimationObjectGroup.prototype = {

    	constructor: AnimationObjectGroup,

    	isAnimationObjectGroup: true,

    	add: function( var_args ) {

    		var objects = this._objects,
    			nObjects = objects.length,
    			nCachedObjects = this.nCachedObjects_,
    			indicesByUUID = this._indicesByUUID,
    			paths = this._paths,
    			parsedPaths = this._parsedPaths,
    			bindings = this._bindings,
    			nBindings = bindings.length;

    		for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

    			var object = arguments[ i ],
    				uuid = object.uuid,
    				index = indicesByUUID[ uuid ];

    			if ( index === undefined ) {

    				// unknown object -> add it to the ACTIVE region

    				index = nObjects ++;
    				indicesByUUID[ uuid ] = index;
    				objects.push( object );

    				// accounting is done, now do the same for all bindings

    				for ( var j = 0, m = nBindings; j !== m; ++ j ) {

    					bindings[ j ].push(
    							new PropertyBinding(
    								object, paths[ j ], parsedPaths[ j ] ) );

    				}

    			} else if ( index < nCachedObjects ) {

    				var knownObject = objects[ index ];

    				// move existing object to the ACTIVE region

    				var firstActiveIndex = -- nCachedObjects,
    					lastCachedObject = objects[ firstActiveIndex ];

    				indicesByUUID[ lastCachedObject.uuid ] = index;
    				objects[ index ] = lastCachedObject;

    				indicesByUUID[ uuid ] = firstActiveIndex;
    				objects[ firstActiveIndex ] = object;

    				// accounting is done, now do the same for all bindings

    				for ( var j = 0, m = nBindings; j !== m; ++ j ) {

    					var bindingsForPath = bindings[ j ],
    						lastCached = bindingsForPath[ firstActiveIndex ],
    						binding = bindingsForPath[ index ];

    					bindingsForPath[ index ] = lastCached;

    					if ( binding === undefined ) {

    						// since we do not bother to create new bindings
    						// for objects that are cached, the binding may
    						// or may not exist

    						binding = new PropertyBinding(
    								object, paths[ j ], parsedPaths[ j ] );

    					}

    					bindingsForPath[ firstActiveIndex ] = binding;

    				}

    			} else if ( objects[ index ] !== knownObject) {

    				console.error( "Different objects with the same UUID " +
    						"detected. Clean the caches or recreate your " +
    						"infrastructure when reloading scenes..." );

    			} // else the object is already where we want it to be

    		} // for arguments

    		this.nCachedObjects_ = nCachedObjects;

    	},

    	remove: function( var_args ) {

    		var objects = this._objects,
    			nCachedObjects = this.nCachedObjects_,
    			indicesByUUID = this._indicesByUUID,
    			bindings = this._bindings,
    			nBindings = bindings.length;

    		for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

    			var object = arguments[ i ],
    				uuid = object.uuid,
    				index = indicesByUUID[ uuid ];

    			if ( index !== undefined && index >= nCachedObjects ) {

    				// move existing object into the CACHED region

    				var lastCachedIndex = nCachedObjects ++,
    					firstActiveObject = objects[ lastCachedIndex ];

    				indicesByUUID[ firstActiveObject.uuid ] = index;
    				objects[ index ] = firstActiveObject;

    				indicesByUUID[ uuid ] = lastCachedIndex;
    				objects[ lastCachedIndex ] = object;

    				// accounting is done, now do the same for all bindings

    				for ( var j = 0, m = nBindings; j !== m; ++ j ) {

    					var bindingsForPath = bindings[ j ],
    						firstActive = bindingsForPath[ lastCachedIndex ],
    						binding = bindingsForPath[ index ];

    					bindingsForPath[ index ] = firstActive;
    					bindingsForPath[ lastCachedIndex ] = binding;

    				}

    			}

    		} // for arguments

    		this.nCachedObjects_ = nCachedObjects;

    	},

    	// remove & forget
    	uncache: function( var_args ) {

    		var objects = this._objects,
    			nObjects = objects.length,
    			nCachedObjects = this.nCachedObjects_,
    			indicesByUUID = this._indicesByUUID,
    			bindings = this._bindings,
    			nBindings = bindings.length;

    		for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

    			var object = arguments[ i ],
    				uuid = object.uuid,
    				index = indicesByUUID[ uuid ];

    			if ( index !== undefined ) {

    				delete indicesByUUID[ uuid ];

    				if ( index < nCachedObjects ) {

    					// object is cached, shrink the CACHED region

    					var firstActiveIndex = -- nCachedObjects,
    						lastCachedObject = objects[ firstActiveIndex ],
    						lastIndex = -- nObjects,
    						lastObject = objects[ lastIndex ];

    					// last cached object takes this object's place
    					indicesByUUID[ lastCachedObject.uuid ] = index;
    					objects[ index ] = lastCachedObject;

    					// last object goes to the activated slot and pop
    					indicesByUUID[ lastObject.uuid ] = firstActiveIndex;
    					objects[ firstActiveIndex ] = lastObject;
    					objects.pop();

    					// accounting is done, now do the same for all bindings

    					for ( var j = 0, m = nBindings; j !== m; ++ j ) {

    						var bindingsForPath = bindings[ j ],
    							lastCached = bindingsForPath[ firstActiveIndex ],
    							last = bindingsForPath[ lastIndex ];

    						bindingsForPath[ index ] = lastCached;
    						bindingsForPath[ firstActiveIndex ] = last;
    						bindingsForPath.pop();

    					}

    				} else {

    					// object is active, just swap with the last and pop

    					var lastIndex = -- nObjects,
    						lastObject = objects[ lastIndex ];

    					indicesByUUID[ lastObject.uuid ] = index;
    					objects[ index ] = lastObject;
    					objects.pop();

    					// accounting is done, now do the same for all bindings

    					for ( var j = 0, m = nBindings; j !== m; ++ j ) {

    						var bindingsForPath = bindings[ j ];

    						bindingsForPath[ index ] = bindingsForPath[ lastIndex ];
    						bindingsForPath.pop();

    					}

    				} // cached or active

    			} // if object is known

    		} // for arguments

    		this.nCachedObjects_ = nCachedObjects;

    	},

    	// Internal interface used by befriended PropertyBinding.Composite:

    	subscribe_: function( path, parsedPath ) {
    		// returns an array of bindings for the given path that is changed
    		// according to the contained objects in the group

    		var indicesByPath = this._bindingsIndicesByPath,
    			index = indicesByPath[ path ],
    			bindings = this._bindings;

    		if ( index !== undefined ) return bindings[ index ];

    		var paths = this._paths,
    			parsedPaths = this._parsedPaths,
    			objects = this._objects,
    			nObjects = objects.length,
    			nCachedObjects = this.nCachedObjects_,
    			bindingsForPath = new Array( nObjects );

    		index = bindings.length;

    		indicesByPath[ path ] = index;

    		paths.push( path );
    		parsedPaths.push( parsedPath );
    		bindings.push( bindingsForPath );

    		for ( var i = nCachedObjects,
    				n = objects.length; i !== n; ++ i ) {

    			var object = objects[ i ];

    			bindingsForPath[ i ] =
    					new PropertyBinding( object, path, parsedPath );

    		}

    		return bindingsForPath;

    	},

    	unsubscribe_: function( path ) {
    		// tells the group to forget about a property path and no longer
    		// update the array previously obtained with 'subscribe_'

    		var indicesByPath = this._bindingsIndicesByPath,
    			index = indicesByPath[ path ];

    		if ( index !== undefined ) {

    			var paths = this._paths,
    				parsedPaths = this._parsedPaths,
    				bindings = this._bindings,
    				lastBindingsIndex = bindings.length - 1,
    				lastBindings = bindings[ lastBindingsIndex ],
    				lastBindingsPath = path[ lastBindingsIndex ];

    			indicesByPath[ lastBindingsPath ] = index;

    			bindings[ index ] = lastBindings;
    			bindings.pop();

    			parsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];
    			parsedPaths.pop();

    			paths[ index ] = paths[ lastBindingsIndex ];
    			paths.pop();

    		}

    	}

    };

    /**
     *
     * Action provided by AnimationMixer for scheduling clip playback on specific
     * objects.
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     *
     */

    function AnimationAction( mixer, clip, localRoot ) {

    	this._mixer = mixer;
    	this._clip = clip;
    	this._localRoot = localRoot || null;

    	var tracks = clip.tracks,
    		nTracks = tracks.length,
    		interpolants = new Array( nTracks );

    	var interpolantSettings = {
    			endingStart: 	ZeroCurvatureEnding,
    			endingEnd:		ZeroCurvatureEnding
    	};

    	for ( var i = 0; i !== nTracks; ++ i ) {

    		var interpolant = tracks[ i ].createInterpolant( null );
    		interpolants[ i ] = interpolant;
    		interpolant.settings = interpolantSettings;

    	}

    	this._interpolantSettings = interpolantSettings;

    	this._interpolants = interpolants;	// bound by the mixer

    	// inside: PropertyMixer (managed by the mixer)
    	this._propertyBindings = new Array( nTracks );

    	this._cacheIndex = null;			// for the memory manager
    	this._byClipCacheIndex = null;		// for the memory manager

    	this._timeScaleInterpolant = null;
    	this._weightInterpolant = null;

    	this.loop = LoopRepeat;
    	this._loopCount = -1;

    	// global mixer time when the action is to be started
    	// it's set back to 'null' upon start of the action
    	this._startTime = null;

    	// scaled local time of the action
    	// gets clamped or wrapped to 0..clip.duration according to loop
    	this.time = 0;

    	this.timeScale = 1;
    	this._effectiveTimeScale = 1;

    	this.weight = 1;
    	this._effectiveWeight = 1;

    	this.repetitions = Infinity; 		// no. of repetitions when looping

    	this.paused = false;				// false -> zero effective time scale
    	this.enabled = true;				// true -> zero effective weight

    	this.clampWhenFinished 	= false;	// keep feeding the last frame?

    	this.zeroSlopeAtStart 	= true;		// for smooth interpolation w/o separate
    	this.zeroSlopeAtEnd		= true;		// clips for start, loop and end

    };

    AnimationAction.prototype = {

    	constructor: AnimationAction,

    	// State & Scheduling

    	play: function() {

    		this._mixer._activateAction( this );

    		return this;

    	},

    	stop: function() {

    		this._mixer._deactivateAction( this );

    		return this.reset();

    	},

    	reset: function() {

    		this.paused = false;
    		this.enabled = true;

    		this.time = 0;			// restart clip
    		this._loopCount = -1;	// forget previous loops
    		this._startTime = null;	// forget scheduling

    		return this.stopFading().stopWarping();

    	},

    	isRunning: function() {

    		return this.enabled && ! this.paused && this.timeScale !== 0 &&
    				this._startTime === null && this._mixer._isActiveAction( this );

    	},

    	// return true when play has been called
    	isScheduled: function() {

    		return this._mixer._isActiveAction( this );

    	},

    	startAt: function( time ) {

    		this._startTime = time;

    		return this;

    	},

    	setLoop: function( mode, repetitions ) {

    		this.loop = mode;
    		this.repetitions = repetitions;

    		return this;

    	},

    	// Weight

    	// set the weight stopping any scheduled fading
    	// although .enabled = false yields an effective weight of zero, this
    	// method does *not* change .enabled, because it would be confusing
    	setEffectiveWeight: function( weight ) {

    		this.weight = weight;

    		// note: same logic as when updated at runtime
    		this._effectiveWeight = this.enabled ? weight : 0;

    		return this.stopFading();

    	},

    	// return the weight considering fading and .enabled
    	getEffectiveWeight: function() {

    		return this._effectiveWeight;

    	},

    	fadeIn: function( duration ) {

    		return this._scheduleFading( duration, 0, 1 );

    	},

    	fadeOut: function( duration ) {

    		return this._scheduleFading( duration, 1, 0 );

    	},

    	crossFadeFrom: function( fadeOutAction, duration, warp ) {

    		fadeOutAction.fadeOut( duration );
    		this.fadeIn( duration );

    		if( warp ) {

    			var fadeInDuration = this._clip.duration,
    				fadeOutDuration = fadeOutAction._clip.duration,

    				startEndRatio = fadeOutDuration / fadeInDuration,
    				endStartRatio = fadeInDuration / fadeOutDuration;

    			fadeOutAction.warp( 1.0, startEndRatio, duration );
    			this.warp( endStartRatio, 1.0, duration );

    		}

    		return this;

    	},

    	crossFadeTo: function( fadeInAction, duration, warp ) {

    		return fadeInAction.crossFadeFrom( this, duration, warp );

    	},

    	stopFading: function() {

    		var weightInterpolant = this._weightInterpolant;

    		if ( weightInterpolant !== null ) {

    			this._weightInterpolant = null;
    			this._mixer._takeBackControlInterpolant( weightInterpolant );

    		}

    		return this;

    	},

    	// Time Scale Control

    	// set the weight stopping any scheduled warping
    	// although .paused = true yields an effective time scale of zero, this
    	// method does *not* change .paused, because it would be confusing
    	setEffectiveTimeScale: function( timeScale ) {

    		this.timeScale = timeScale;
    		this._effectiveTimeScale = this.paused ? 0 :timeScale;

    		return this.stopWarping();

    	},

    	// return the time scale considering warping and .paused
    	getEffectiveTimeScale: function() {

    		return this._effectiveTimeScale;

    	},

    	setDuration: function( duration ) {

    		this.timeScale = this._clip.duration / duration;

    		return this.stopWarping();

    	},

    	syncWith: function( action ) {

    		this.time = action.time;
    		this.timeScale = action.timeScale;

    		return this.stopWarping();

    	},

    	halt: function( duration ) {

    		return this.warp( this._effectiveTimeScale, 0, duration );

    	},

    	warp: function( startTimeScale, endTimeScale, duration ) {

    		var mixer = this._mixer, now = mixer.time,
    			interpolant = this._timeScaleInterpolant,

    			timeScale = this.timeScale;

    		if ( interpolant === null ) {

    			interpolant = mixer._lendControlInterpolant(),
    			this._timeScaleInterpolant = interpolant;

    		}

    		var times = interpolant.parameterPositions,
    			values = interpolant.sampleValues;

    		times[ 0 ] = now;
    		times[ 1 ] = now + duration;

    		values[ 0 ] = startTimeScale / timeScale;
    		values[ 1 ] = endTimeScale / timeScale;

    		return this;

    	},

    	stopWarping: function() {

    		var timeScaleInterpolant = this._timeScaleInterpolant;

    		if ( timeScaleInterpolant !== null ) {

    			this._timeScaleInterpolant = null;
    			this._mixer._takeBackControlInterpolant( timeScaleInterpolant );

    		}

    		return this;

    	},

    	// Object Accessors

    	getMixer: function() {

    		return this._mixer;

    	},

    	getClip: function() {

    		return this._clip;

    	},

    	getRoot: function() {

    		return this._localRoot || this._mixer._root;

    	},

    	// Interna

    	_update: function( time, deltaTime, timeDirection, accuIndex ) {
    		// called by the mixer

    		var startTime = this._startTime;

    		if ( startTime !== null ) {

    			// check for scheduled start of action

    			var timeRunning = ( time - startTime ) * timeDirection;
    			if ( timeRunning < 0 || timeDirection === 0 ) {

    				return; // yet to come / don't decide when delta = 0

    			}

    			// start

    			this._startTime = null; // unschedule
    			deltaTime = timeDirection * timeRunning;

    		}

    		// apply time scale and advance time

    		deltaTime *= this._updateTimeScale( time );
    		var clipTime = this._updateTime( deltaTime );

    		// note: _updateTime may disable the action resulting in
    		// an effective weight of 0

    		var weight = this._updateWeight( time );

    		if ( weight > 0 ) {

    			var interpolants = this._interpolants;
    			var propertyMixers = this._propertyBindings;

    			for ( var j = 0, m = interpolants.length; j !== m; ++ j ) {

    				interpolants[ j ].evaluate( clipTime );
    				propertyMixers[ j ].accumulate( accuIndex, weight );

    			}

    		}

    	},

    	_updateWeight: function( time ) {

    		var weight = 0;

    		if ( this.enabled ) {

    			weight = this.weight;
    			var interpolant = this._weightInterpolant;

    			if ( interpolant !== null ) {

    				var interpolantValue = interpolant.evaluate( time )[ 0 ];

    				weight *= interpolantValue;

    				if ( time > interpolant.parameterPositions[ 1 ] ) {

    					this.stopFading();

    					if ( interpolantValue === 0 ) {

    						// faded out, disable
    						this.enabled = false;

    					}

    				}

    			}

    		}

    		this._effectiveWeight = weight;
    		return weight;

    	},

    	_updateTimeScale: function( time ) {

    		var timeScale = 0;

    		if ( ! this.paused ) {

    			timeScale = this.timeScale;

    			var interpolant = this._timeScaleInterpolant;

    			if ( interpolant !== null ) {

    				var interpolantValue = interpolant.evaluate( time )[ 0 ];

    				timeScale *= interpolantValue;

    				if ( time > interpolant.parameterPositions[ 1 ] ) {

    					this.stopWarping();

    					if ( timeScale === 0 ) {

    						// motion has halted, pause
    						this.paused = true;

    					} else {

    						// warp done - apply final time scale
    						this.timeScale = timeScale;

    					}

    				}

    			}

    		}

    		this._effectiveTimeScale = timeScale;
    		return timeScale;

    	},

    	_updateTime: function( deltaTime ) {

    		var time = this.time + deltaTime;

    		if ( deltaTime === 0 ) return time;

    		var duration = this._clip.duration,

    			loop = this.loop,
    			loopCount = this._loopCount;

    		if ( loop === LoopOnce ) {

    			if ( loopCount === -1 ) {
    				// just started

    				this.loopCount = 0;
    				this._setEndings( true, true, false );

    			}

    			handle_stop: {

    				if ( time >= duration ) {

    					time = duration;

    				} else if ( time < 0 ) {

    					time = 0;

    				} else break handle_stop;

    				if ( this.clampWhenFinished ) this.paused = true;
    				else this.enabled = false;

    				this._mixer.dispatchEvent( {
    					type: 'finished', action: this,
    					direction: deltaTime < 0 ? -1 : 1
    				} );

    			}

    		} else { // repetitive Repeat or PingPong

    			var pingPong = ( loop === LoopPingPong );

    			if ( loopCount === -1 ) {
    				// just started

    				if ( deltaTime >= 0 ) {

    					loopCount = 0;

    					this._setEndings(
    							true, this.repetitions === 0, pingPong );

    				} else {

    					// when looping in reverse direction, the initial
    					// transition through zero counts as a repetition,
    					// so leave loopCount at -1

    					this._setEndings(
    							this.repetitions === 0, true, pingPong );

    				}

    			}

    			if ( time >= duration || time < 0 ) {
    				// wrap around

    				var loopDelta = Math.floor( time / duration ); // signed
    				time -= duration * loopDelta;

    				loopCount += Math.abs( loopDelta );

    				var pending = this.repetitions - loopCount;

    				if ( pending < 0 ) {
    					// have to stop (switch state, clamp time, fire event)

    					if ( this.clampWhenFinished ) this.paused = true;
    					else this.enabled = false;

    					time = deltaTime > 0 ? duration : 0;

    					this._mixer.dispatchEvent( {
    						type: 'finished', action: this,
    						direction: deltaTime > 0 ? 1 : -1
    					} );

    				} else {
    					// keep running

    					if ( pending === 0 ) {
    						// entering the last round

    						var atStart = deltaTime < 0;
    						this._setEndings( atStart, ! atStart, pingPong );

    					} else {

    						this._setEndings( false, false, pingPong );

    					}

    					this._loopCount = loopCount;

    					this._mixer.dispatchEvent( {
    						type: 'loop', action: this, loopDelta: loopDelta
    					} );

    				}

    			}

    			if ( pingPong && ( loopCount & 1 ) === 1 ) {
    				// invert time for the "pong round"

    				this.time = time;
    				return duration - time;

    			}

    		}

    		this.time = time;
    		return time;

    	},

    	_setEndings: function( atStart, atEnd, pingPong ) {

    		var settings = this._interpolantSettings;

    		if ( pingPong ) {

    			settings.endingStart 	= ZeroSlopeEnding;
    			settings.endingEnd		= ZeroSlopeEnding;

    		} else {

    			// assuming for LoopOnce atStart == atEnd == true

    			if ( atStart ) {

    				settings.endingStart = this.zeroSlopeAtStart ?
    						ZeroSlopeEnding : ZeroCurvatureEnding;

    			} else {

    				settings.endingStart = WrapAroundEnding;

    			}

    			if ( atEnd ) {

    				settings.endingEnd = this.zeroSlopeAtEnd ?
    						ZeroSlopeEnding : ZeroCurvatureEnding;

    			} else {

    				settings.endingEnd 	 = WrapAroundEnding;

    			}

    		}

    	},

    	_scheduleFading: function( duration, weightNow, weightThen ) {

    		var mixer = this._mixer, now = mixer.time,
    			interpolant = this._weightInterpolant;

    		if ( interpolant === null ) {

    			interpolant = mixer._lendControlInterpolant(),
    			this._weightInterpolant = interpolant;

    		}

    		var times = interpolant.parameterPositions,
    			values = interpolant.sampleValues;

    		times[ 0 ] = now; 				values[ 0 ] = weightNow;
    		times[ 1 ] = now + duration;	values[ 1 ] = weightThen;

    		return this;

    	}

    };

    /**
     *
     * Player for AnimationClips.
     *
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */

    function AnimationMixer( root ) {

    	this._root = root;
    	this._initMemoryManager();
    	this._accuIndex = 0;

    	this.time = 0;

    	this.timeScale = 1.0;

    }

    Object.assign( AnimationMixer.prototype, EventDispatcher.prototype, {

    	// return an action for a clip optionally using a custom root target
    	// object (this method allocates a lot of dynamic memory in case a
    	// previously unknown clip/root combination is specified)
    	clipAction: function( clip, optionalRoot ) {

    		var root = optionalRoot || this._root,
    			rootUuid = root.uuid,

    			clipObject = typeof clip === 'string' ?
    					AnimationClip.findByName( root, clip ) : clip,

    			clipUuid = clipObject !== null ? clipObject.uuid : clip,

    			actionsForClip = this._actionsByClip[ clipUuid ],
    			prototypeAction = null;

    		if ( actionsForClip !== undefined ) {

    			var existingAction =
    					actionsForClip.actionByRoot[ rootUuid ];

    			if ( existingAction !== undefined ) {

    				return existingAction;

    			}

    			// we know the clip, so we don't have to parse all
    			// the bindings again but can just copy
    			prototypeAction = actionsForClip.knownActions[ 0 ];

    			// also, take the clip from the prototype action
    			if ( clipObject === null )
    				clipObject = prototypeAction._clip;

    		}

    		// clip must be known when specified via string
    		if ( clipObject === null ) return null;

    		// allocate all resources required to run it
    		var newAction = new AnimationAction( this, clipObject, optionalRoot );

    		this._bindAction( newAction, prototypeAction );

    		// and make the action known to the memory manager
    		this._addInactiveAction( newAction, clipUuid, rootUuid );

    		return newAction;

    	},

    	// get an existing action
    	existingAction: function( clip, optionalRoot ) {

    		var root = optionalRoot || this._root,
    			rootUuid = root.uuid,

    			clipObject = typeof clip === 'string' ?
    					AnimationClip.findByName( root, clip ) : clip,

    			clipUuid = clipObject ? clipObject.uuid : clip,

    			actionsForClip = this._actionsByClip[ clipUuid ];

    		if ( actionsForClip !== undefined ) {

    			return actionsForClip.actionByRoot[ rootUuid ] || null;

    		}

    		return null;

    	},

    	// deactivates all previously scheduled actions
    	stopAllAction: function() {

    		var actions = this._actions,
    			nActions = this._nActiveActions,
    			bindings = this._bindings,
    			nBindings = this._nActiveBindings;

    		this._nActiveActions = 0;
    		this._nActiveBindings = 0;

    		for ( var i = 0; i !== nActions; ++ i ) {

    			actions[ i ].reset();

    		}

    		for ( var i = 0; i !== nBindings; ++ i ) {

    			bindings[ i ].useCount = 0;

    		}

    		return this;

    	},

    	// advance the time and update apply the animation
    	update: function( deltaTime ) {

    		deltaTime *= this.timeScale;

    		var actions = this._actions,
    			nActions = this._nActiveActions,

    			time = this.time += deltaTime,
    			timeDirection = Math.sign( deltaTime ),

    			accuIndex = this._accuIndex ^= 1;

    		// run active actions

    		for ( var i = 0; i !== nActions; ++ i ) {

    			var action = actions[ i ];

    			if ( action.enabled ) {

    				action._update( time, deltaTime, timeDirection, accuIndex );

    			}

    		}

    		// update scene graph

    		var bindings = this._bindings,
    			nBindings = this._nActiveBindings;

    		for ( var i = 0; i !== nBindings; ++ i ) {

    			bindings[ i ].apply( accuIndex );

    		}

    		return this;

    	},

    	// return this mixer's root target object
    	getRoot: function() {

    		return this._root;

    	},

    	// free all resources specific to a particular clip
    	uncacheClip: function( clip ) {

    		var actions = this._actions,
    			clipUuid = clip.uuid,
    			actionsByClip = this._actionsByClip,
    			actionsForClip = actionsByClip[ clipUuid ];

    		if ( actionsForClip !== undefined ) {

    			// note: just calling _removeInactiveAction would mess up the
    			// iteration state and also require updating the state we can
    			// just throw away

    			var actionsToRemove = actionsForClip.knownActions;

    			for ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) {

    				var action = actionsToRemove[ i ];

    				this._deactivateAction( action );

    				var cacheIndex = action._cacheIndex,
    					lastInactiveAction = actions[ actions.length - 1 ];

    				action._cacheIndex = null;
    				action._byClipCacheIndex = null;

    				lastInactiveAction._cacheIndex = cacheIndex;
    				actions[ cacheIndex ] = lastInactiveAction;
    				actions.pop();

    				this._removeInactiveBindingsForAction( action );

    			}

    			delete actionsByClip[ clipUuid ];

    		}

    	},

    	// free all resources specific to a particular root target object
    	uncacheRoot: function( root ) {

    		var rootUuid = root.uuid,
    			actionsByClip = this._actionsByClip;

    		for ( var clipUuid in actionsByClip ) {

    			var actionByRoot = actionsByClip[ clipUuid ].actionByRoot,
    				action = actionByRoot[ rootUuid ];

    			if ( action !== undefined ) {

    				this._deactivateAction( action );
    				this._removeInactiveAction( action );

    			}

    		}

    		var bindingsByRoot = this._bindingsByRootAndName,
    			bindingByName = bindingsByRoot[ rootUuid ];

    		if ( bindingByName !== undefined ) {

    			for ( var trackName in bindingByName ) {

    				var binding = bindingByName[ trackName ];
    				binding.restoreOriginalState();
    				this._removeInactiveBinding( binding );

    			}

    		}

    	},

    	// remove a targeted clip from the cache
    	uncacheAction: function( clip, optionalRoot ) {

    		var action = this.existingAction( clip, optionalRoot );

    		if ( action !== null ) {

    			this._deactivateAction( action );
    			this._removeInactiveAction( action );

    		}

    	}

    } );

    // Implementation details:

    Object.assign( AnimationMixer.prototype, {

    	_bindAction: function( action, prototypeAction ) {

    		var root = action._localRoot || this._root,
    			tracks = action._clip.tracks,
    			nTracks = tracks.length,
    			bindings = action._propertyBindings,
    			interpolants = action._interpolants,
    			rootUuid = root.uuid,
    			bindingsByRoot = this._bindingsByRootAndName,
    			bindingsByName = bindingsByRoot[ rootUuid ];

    		if ( bindingsByName === undefined ) {

    			bindingsByName = {};
    			bindingsByRoot[ rootUuid ] = bindingsByName;

    		}

    		for ( var i = 0; i !== nTracks; ++ i ) {

    			var track = tracks[ i ],
    				trackName = track.name,
    				binding = bindingsByName[ trackName ];

    			if ( binding !== undefined ) {

    				bindings[ i ] = binding;

    			} else {

    				binding = bindings[ i ];

    				if ( binding !== undefined ) {

    					// existing binding, make sure the cache knows

    					if ( binding._cacheIndex === null ) {

    						++ binding.referenceCount;
    						this._addInactiveBinding( binding, rootUuid, trackName );

    					}

    					continue;

    				}

    				var path = prototypeAction && prototypeAction.
    						_propertyBindings[ i ].binding.parsedPath;

    				binding = new PropertyMixer(
    						PropertyBinding.create( root, trackName, path ),
    						track.ValueTypeName, track.getValueSize() );

    				++ binding.referenceCount;
    				this._addInactiveBinding( binding, rootUuid, trackName );

    				bindings[ i ] = binding;

    			}

    			interpolants[ i ].resultBuffer = binding.buffer;

    		}

    	},

    	_activateAction: function( action ) {

    		if ( ! this._isActiveAction( action ) ) {

    			if ( action._cacheIndex === null ) {

    				// this action has been forgotten by the cache, but the user
    				// appears to be still using it -> rebind

    				var rootUuid = ( action._localRoot || this._root ).uuid,
    					clipUuid = action._clip.uuid,
    					actionsForClip = this._actionsByClip[ clipUuid ];

    				this._bindAction( action,
    						actionsForClip && actionsForClip.knownActions[ 0 ] );

    				this._addInactiveAction( action, clipUuid, rootUuid );

    			}

    			var bindings = action._propertyBindings;

    			// increment reference counts / sort out state
    			for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

    				var binding = bindings[ i ];

    				if ( binding.useCount ++ === 0 ) {

    					this._lendBinding( binding );
    					binding.saveOriginalState();

    				}

    			}

    			this._lendAction( action );

    		}

    	},

    	_deactivateAction: function( action ) {

    		if ( this._isActiveAction( action ) ) {

    			var bindings = action._propertyBindings;

    			// decrement reference counts / sort out state
    			for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

    				var binding = bindings[ i ];

    				if ( -- binding.useCount === 0 ) {

    					binding.restoreOriginalState();
    					this._takeBackBinding( binding );

    				}

    			}

    			this._takeBackAction( action );

    		}

    	},

    	// Memory manager

    	_initMemoryManager: function() {

    		this._actions = []; // 'nActiveActions' followed by inactive ones
    		this._nActiveActions = 0;

    		this._actionsByClip = {};
    		// inside:
    		// {
    		// 		knownActions: Array< AnimationAction >	- used as prototypes
    		// 		actionByRoot: AnimationAction			- lookup
    		// }


    		this._bindings = []; // 'nActiveBindings' followed by inactive ones
    		this._nActiveBindings = 0;

    		this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >


    		this._controlInterpolants = []; // same game as above
    		this._nActiveControlInterpolants = 0;

    		var scope = this;

    		this.stats = {

    			actions: {
    				get total() { return scope._actions.length; },
    				get inUse() { return scope._nActiveActions; }
    			},
    			bindings: {
    				get total() { return scope._bindings.length; },
    				get inUse() { return scope._nActiveBindings; }
    			},
    			controlInterpolants: {
    				get total() { return scope._controlInterpolants.length; },
    				get inUse() { return scope._nActiveControlInterpolants; }
    			}

    		};

    	},

    	// Memory management for AnimationAction objects

    	_isActiveAction: function( action ) {

    		var index = action._cacheIndex;
    		return index !== null && index < this._nActiveActions;

    	},

    	_addInactiveAction: function( action, clipUuid, rootUuid ) {

    		var actions = this._actions,
    			actionsByClip = this._actionsByClip,
    			actionsForClip = actionsByClip[ clipUuid ];

    		if ( actionsForClip === undefined ) {

    			actionsForClip = {

    				knownActions: [ action ],
    				actionByRoot: {}

    			};

    			action._byClipCacheIndex = 0;

    			actionsByClip[ clipUuid ] = actionsForClip;

    		} else {

    			var knownActions = actionsForClip.knownActions;

    			action._byClipCacheIndex = knownActions.length;
    			knownActions.push( action );

    		}

    		action._cacheIndex = actions.length;
    		actions.push( action );

    		actionsForClip.actionByRoot[ rootUuid ] = action;

    	},

    	_removeInactiveAction: function( action ) {

    		var actions = this._actions,
    			lastInactiveAction = actions[ actions.length - 1 ],
    			cacheIndex = action._cacheIndex;

    		lastInactiveAction._cacheIndex = cacheIndex;
    		actions[ cacheIndex ] = lastInactiveAction;
    		actions.pop();

    		action._cacheIndex = null;


    		var clipUuid = action._clip.uuid,
    			actionsByClip = this._actionsByClip,
    			actionsForClip = actionsByClip[ clipUuid ],
    			knownActionsForClip = actionsForClip.knownActions,

    			lastKnownAction =
    				knownActionsForClip[ knownActionsForClip.length - 1 ],

    			byClipCacheIndex = action._byClipCacheIndex;

    		lastKnownAction._byClipCacheIndex = byClipCacheIndex;
    		knownActionsForClip[ byClipCacheIndex ] = lastKnownAction;
    		knownActionsForClip.pop();

    		action._byClipCacheIndex = null;


    		var actionByRoot = actionsForClip.actionByRoot,
    			rootUuid = ( actions._localRoot || this._root ).uuid;

    		delete actionByRoot[ rootUuid ];

    		if ( knownActionsForClip.length === 0 ) {

    			delete actionsByClip[ clipUuid ];

    		}

    		this._removeInactiveBindingsForAction( action );

    	},

    	_removeInactiveBindingsForAction: function( action ) {

    		var bindings = action._propertyBindings;
    		for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

    			var binding = bindings[ i ];

    			if ( -- binding.referenceCount === 0 ) {

    				this._removeInactiveBinding( binding );

    			}

    		}

    	},

    	_lendAction: function( action ) {

    		// [ active actions |  inactive actions  ]
    		// [  active actions >| inactive actions ]
    		//                 s        a
    		//                  <-swap->
    		//                 a        s

    		var actions = this._actions,
    			prevIndex = action._cacheIndex,

    			lastActiveIndex = this._nActiveActions ++,

    			firstInactiveAction = actions[ lastActiveIndex ];

    		action._cacheIndex = lastActiveIndex;
    		actions[ lastActiveIndex ] = action;

    		firstInactiveAction._cacheIndex = prevIndex;
    		actions[ prevIndex ] = firstInactiveAction;

    	},

    	_takeBackAction: function( action ) {

    		// [  active actions  | inactive actions ]
    		// [ active actions |< inactive actions  ]
    		//        a        s
    		//         <-swap->
    		//        s        a

    		var actions = this._actions,
    			prevIndex = action._cacheIndex,

    			firstInactiveIndex = -- this._nActiveActions,

    			lastActiveAction = actions[ firstInactiveIndex ];

    		action._cacheIndex = firstInactiveIndex;
    		actions[ firstInactiveIndex ] = action;

    		lastActiveAction._cacheIndex = prevIndex;
    		actions[ prevIndex ] = lastActiveAction;

    	},

    	// Memory management for PropertyMixer objects

    	_addInactiveBinding: function( binding, rootUuid, trackName ) {

    		var bindingsByRoot = this._bindingsByRootAndName,
    			bindingByName = bindingsByRoot[ rootUuid ],

    			bindings = this._bindings;

    		if ( bindingByName === undefined ) {

    			bindingByName = {};
    			bindingsByRoot[ rootUuid ] = bindingByName;

    		}

    		bindingByName[ trackName ] = binding;

    		binding._cacheIndex = bindings.length;
    		bindings.push( binding );

    	},

    	_removeInactiveBinding: function( binding ) {

    		var bindings = this._bindings,
    			propBinding = binding.binding,
    			rootUuid = propBinding.rootNode.uuid,
    			trackName = propBinding.path,
    			bindingsByRoot = this._bindingsByRootAndName,
    			bindingByName = bindingsByRoot[ rootUuid ],

    			lastInactiveBinding = bindings[ bindings.length - 1 ],
    			cacheIndex = binding._cacheIndex;

    		lastInactiveBinding._cacheIndex = cacheIndex;
    		bindings[ cacheIndex ] = lastInactiveBinding;
    		bindings.pop();

    		delete bindingByName[ trackName ];

    		remove_empty_map: {

    			for ( var _ in bindingByName ) break remove_empty_map;

    			delete bindingsByRoot[ rootUuid ];

    		}

    	},

    	_lendBinding: function( binding ) {

    		var bindings = this._bindings,
    			prevIndex = binding._cacheIndex,

    			lastActiveIndex = this._nActiveBindings ++,

    			firstInactiveBinding = bindings[ lastActiveIndex ];

    		binding._cacheIndex = lastActiveIndex;
    		bindings[ lastActiveIndex ] = binding;

    		firstInactiveBinding._cacheIndex = prevIndex;
    		bindings[ prevIndex ] = firstInactiveBinding;

    	},

    	_takeBackBinding: function( binding ) {

    		var bindings = this._bindings,
    			prevIndex = binding._cacheIndex,

    			firstInactiveIndex = -- this._nActiveBindings,

    			lastActiveBinding = bindings[ firstInactiveIndex ];

    		binding._cacheIndex = firstInactiveIndex;
    		bindings[ firstInactiveIndex ] = binding;

    		lastActiveBinding._cacheIndex = prevIndex;
    		bindings[ prevIndex ] = lastActiveBinding;

    	},


    	// Memory management of Interpolants for weight and time scale

    	_lendControlInterpolant: function() {

    		var interpolants = this._controlInterpolants,
    			lastActiveIndex = this._nActiveControlInterpolants ++,
    			interpolant = interpolants[ lastActiveIndex ];

    		if ( interpolant === undefined ) {

    			interpolant = new LinearInterpolant(
    					new Float32Array( 2 ), new Float32Array( 2 ),
    						1, this._controlInterpolantsResultBuffer );

    			interpolant.__cacheIndex = lastActiveIndex;
    			interpolants[ lastActiveIndex ] = interpolant;

    		}

    		return interpolant;

    	},

    	_takeBackControlInterpolant: function( interpolant ) {

    		var interpolants = this._controlInterpolants,
    			prevIndex = interpolant.__cacheIndex,

    			firstInactiveIndex = -- this._nActiveControlInterpolants,

    			lastActiveInterpolant = interpolants[ firstInactiveIndex ];

    		interpolant.__cacheIndex = firstInactiveIndex;
    		interpolants[ firstInactiveIndex ] = interpolant;

    		lastActiveInterpolant.__cacheIndex = prevIndex;
    		interpolants[ prevIndex ] = lastActiveInterpolant;

    	},

    	_controlInterpolantsResultBuffer: new Float32Array( 1 )

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function Uniform( value ) {

    	if ( typeof value === 'string' ) {

    		console.warn( 'THREE.Uniform: Type parameter is no longer needed.' );
    		value = arguments[ 1 ];

    	}

    	this.value = value;

    	this.dynamic = false;

    }

    Uniform.prototype = {

    	constructor: Uniform,

    	onUpdate: function ( callback ) {

    		this.dynamic = true;
    		this.onUpdateCallback = callback;

    		return this;

    	}

    };

    /**
     * @author benaadams / https://twitter.com/ben_a_adams
     */

    function InstancedBufferGeometry() {

    	BufferGeometry.call( this );

    	this.type = 'InstancedBufferGeometry';
    	this.maxInstancedCount = undefined;

    }

    InstancedBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
    InstancedBufferGeometry.prototype.constructor = InstancedBufferGeometry;

    InstancedBufferGeometry.prototype.isInstancedBufferGeometry = true;

    InstancedBufferGeometry.prototype.addGroup = function ( start, count, instances ) {

    	this.groups.push( {

    		start: start,
    		count: count,
    		instances: instances

    	} );

    };

    InstancedBufferGeometry.prototype.copy = function ( source ) {

    	var index = source.index;

    	if ( index !== null ) {

    		this.setIndex( index.clone() );

    	}

    	var attributes = source.attributes;

    	for ( var name in attributes ) {

    		var attribute = attributes[ name ];
    		this.addAttribute( name, attribute.clone() );

    	}

    	var groups = source.groups;

    	for ( var i = 0, l = groups.length; i < l; i ++ ) {

    		var group = groups[ i ];
    		this.addGroup( group.start, group.count, group.instances );

    	}

    	return this;

    };

    /**
     * @author benaadams / https://twitter.com/ben_a_adams
     */

    function InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, normalized ) {

    	this.uuid = exports.Math.generateUUID();

    	this.data = interleavedBuffer;
    	this.itemSize = itemSize;
    	this.offset = offset;

    	this.normalized = normalized === true;

    }


    InterleavedBufferAttribute.prototype = {

    	constructor: InterleavedBufferAttribute,

    	isInterleavedBufferAttribute: true,

    	get count() {

    		return this.data.count;

    	},

    	get array() {

    		return this.data.array;

    	},

    	setX: function ( index, x ) {

    		this.data.array[ index * this.data.stride + this.offset ] = x;

    		return this;

    	},

    	setY: function ( index, y ) {

    		this.data.array[ index * this.data.stride + this.offset + 1 ] = y;

    		return this;

    	},

    	setZ: function ( index, z ) {

    		this.data.array[ index * this.data.stride + this.offset + 2 ] = z;

    		return this;

    	},

    	setW: function ( index, w ) {

    		this.data.array[ index * this.data.stride + this.offset + 3 ] = w;

    		return this;

    	},

    	getX: function ( index ) {

    		return this.data.array[ index * this.data.stride + this.offset ];

    	},

    	getY: function ( index ) {

    		return this.data.array[ index * this.data.stride + this.offset + 1 ];

    	},

    	getZ: function ( index ) {

    		return this.data.array[ index * this.data.stride + this.offset + 2 ];

    	},

    	getW: function ( index ) {

    		return this.data.array[ index * this.data.stride + this.offset + 3 ];

    	},

    	setXY: function ( index, x, y ) {

    		index = index * this.data.stride + this.offset;

    		this.data.array[ index + 0 ] = x;
    		this.data.array[ index + 1 ] = y;

    		return this;

    	},

    	setXYZ: function ( index, x, y, z ) {

    		index = index * this.data.stride + this.offset;

    		this.data.array[ index + 0 ] = x;
    		this.data.array[ index + 1 ] = y;
    		this.data.array[ index + 2 ] = z;

    		return this;

    	},

    	setXYZW: function ( index, x, y, z, w ) {

    		index = index * this.data.stride + this.offset;

    		this.data.array[ index + 0 ] = x;
    		this.data.array[ index + 1 ] = y;
    		this.data.array[ index + 2 ] = z;
    		this.data.array[ index + 3 ] = w;

    		return this;

    	}

    };

    /**
     * @author benaadams / https://twitter.com/ben_a_adams
     */

    function InterleavedBuffer( array, stride ) {

    	this.uuid = exports.Math.generateUUID();

    	this.array = array;
    	this.stride = stride;
    	this.count = array !== undefined ? array.length / stride : 0;

    	this.dynamic = false;
    	this.updateRange = { offset: 0, count: - 1 };

    	this.version = 0;

    }

    InterleavedBuffer.prototype = {

    	constructor: InterleavedBuffer,

    	isInterleavedBuffer: true,

    	set needsUpdate( value ) {

    		if ( value === true ) this.version ++;

    	},

    	setDynamic: function ( value ) {

    		this.dynamic = value;

    		return this;

    	},

    	copy: function ( source ) {

    		this.array = new source.array.constructor( source.array );
    		this.count = source.count;
    		this.stride = source.stride;
    		this.dynamic = source.dynamic;

    		return this;

    	},

    	copyAt: function ( index1, attribute, index2 ) {

    		index1 *= this.stride;
    		index2 *= attribute.stride;

    		for ( var i = 0, l = this.stride; i < l; i ++ ) {

    			this.array[ index1 + i ] = attribute.array[ index2 + i ];

    		}

    		return this;

    	},

    	set: function ( value, offset ) {

    		if ( offset === undefined ) offset = 0;

    		this.array.set( value, offset );

    		return this;

    	},

    	clone: function () {

    		return new this.constructor().copy( this );

    	}

    };

    /**
     * @author benaadams / https://twitter.com/ben_a_adams
     */

    function InstancedInterleavedBuffer( array, stride, meshPerAttribute ) {

    	InterleavedBuffer.call( this, array, stride );

    	this.meshPerAttribute = meshPerAttribute || 1;

    }

    InstancedInterleavedBuffer.prototype = Object.create( InterleavedBuffer.prototype );
    InstancedInterleavedBuffer.prototype.constructor = InstancedInterleavedBuffer;

    InstancedInterleavedBuffer.prototype.isInstancedInterleavedBuffer = true;

    InstancedInterleavedBuffer.prototype.copy = function ( source ) {

    	InterleavedBuffer.prototype.copy.call( this, source );

    	this.meshPerAttribute = source.meshPerAttribute;

    	return this;

    };

    /**
     * @author benaadams / https://twitter.com/ben_a_adams
     */

    function InstancedBufferAttribute( array, itemSize, meshPerAttribute ) {

    	BufferAttribute.call( this, array, itemSize );

    	this.meshPerAttribute = meshPerAttribute || 1;

    }

    InstancedBufferAttribute.prototype = Object.create( BufferAttribute.prototype );
    InstancedBufferAttribute.prototype.constructor = InstancedBufferAttribute;

    InstancedBufferAttribute.prototype.isInstancedBufferAttribute = true;

    InstancedBufferAttribute.prototype.copy = function ( source ) {

    	BufferAttribute.prototype.copy.call( this, source );

    	this.meshPerAttribute = source.meshPerAttribute;

    	return this;

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author bhouston / http://clara.io/
     * @author stephomi / http://stephaneginier.com/
     */

    function Raycaster( origin, direction, near, far ) {

    	this.ray = new Ray( origin, direction );
    	// direction is assumed to be normalized (for accurate distance calculations)

    	this.near = near || 0;
    	this.far = far || Infinity;

    	this.params = {
    		Mesh: {},
    		Line: {},
    		LOD: {},
    		Points: { threshold: 1 },
    		Sprite: {}
    	};

    	Object.defineProperties( this.params, {
    		PointCloud: {
    			get: function () {
    				console.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );
    				return this.Points;
    			}
    		}
    	} );

    }

    function ascSort( a, b ) {

    	return a.distance - b.distance;

    }

    function intersectObject( object, raycaster, intersects, recursive ) {

    	if ( object.visible === false ) return;

    	object.raycast( raycaster, intersects );

    	if ( recursive === true ) {

    		var children = object.children;

    		for ( var i = 0, l = children.length; i < l; i ++ ) {

    			intersectObject( children[ i ], raycaster, intersects, true );

    		}

    	}

    }

    //

    Raycaster.prototype = {

    	constructor: Raycaster,

    	linePrecision: 1,

    	set: function ( origin, direction ) {

    		// direction is assumed to be normalized (for accurate distance calculations)

    		this.ray.set( origin, direction );

    	},

    	setFromCamera: function ( coords, camera ) {

    		if ( (camera && camera.isPerspectiveCamera) ) {

    			this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
    			this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();

    		} else if ( (camera && camera.isOrthographicCamera) ) {

    			this.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera
    			this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );

    		} else {

    			console.error( 'THREE.Raycaster: Unsupported camera type.' );

    		}

    	},

    	intersectObject: function ( object, recursive ) {

    		var intersects = [];

    		intersectObject( object, this, intersects, recursive );

    		intersects.sort( ascSort );

    		return intersects;

    	},

    	intersectObjects: function ( objects, recursive ) {

    		var intersects = [];

    		if ( Array.isArray( objects ) === false ) {

    			console.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );
    			return intersects;

    		}

    		for ( var i = 0, l = objects.length; i < l; i ++ ) {

    			intersectObject( objects[ i ], this, intersects, recursive );

    		}

    		intersects.sort( ascSort );

    		return intersects;

    	}

    };

    /**
     * @author alteredq / http://alteredqualia.com/
     */

    function Clock( autoStart ) {

    	this.autoStart = ( autoStart !== undefined ) ? autoStart : true;

    	this.startTime = 0;
    	this.oldTime = 0;
    	this.elapsedTime = 0;

    	this.running = false;

    }

    Clock.prototype = {

    	constructor: Clock,

    	start: function () {

    		this.startTime = ( performance || Date ).now();

    		this.oldTime = this.startTime;
    		this.running = true;

    	},

    	stop: function () {

    		this.getElapsedTime();
    		this.running = false;

    	},

    	getElapsedTime: function () {

    		this.getDelta();
    		return this.elapsedTime;

    	},

    	getDelta: function () {

    		var diff = 0;

    		if ( this.autoStart && ! this.running ) {

    			this.start();

    		}

    		if ( this.running ) {

    			var newTime = ( performance || Date ).now();

    			diff = ( newTime - this.oldTime ) / 1000;
    			this.oldTime = newTime;

    			this.elapsedTime += diff;

    		}

    		return diff;

    	}

    };

    /**
     * Spline from Tween.js, slightly optimized (and trashed)
     * http://sole.github.com/tween.js/examples/05_spline.html
     *
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     */

    function Spline( points ) {

    	this.points = points;

    	var c = [], v3 = { x: 0, y: 0, z: 0 },
    	point, intPoint, weight, w2, w3,
    	pa, pb, pc, pd;

    	this.initFromArray = function ( a ) {

    		this.points = [];

    		for ( var i = 0; i < a.length; i ++ ) {

    			this.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };

    		}

    	};

    	this.getPoint = function ( k ) {

    		point = ( this.points.length - 1 ) * k;
    		intPoint = Math.floor( point );
    		weight = point - intPoint;

    		c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;
    		c[ 1 ] = intPoint;
    		c[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;
    		c[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;

    		pa = this.points[ c[ 0 ] ];
    		pb = this.points[ c[ 1 ] ];
    		pc = this.points[ c[ 2 ] ];
    		pd = this.points[ c[ 3 ] ];

    		w2 = weight * weight;
    		w3 = weight * w2;

    		v3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );
    		v3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );
    		v3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );

    		return v3;

    	};

    	this.getControlPointsArray = function () {

    		var i, p, l = this.points.length,
    			coords = [];

    		for ( i = 0; i < l; i ++ ) {

    			p = this.points[ i ];
    			coords[ i ] = [ p.x, p.y, p.z ];

    		}

    		return coords;

    	};

    	// approximate length by summing linear segments

    	this.getLength = function ( nSubDivisions ) {

    		var i, index, nSamples, position,
    			point = 0, intPoint = 0, oldIntPoint = 0,
    			oldPosition = new Vector3(),
    			tmpVec = new Vector3(),
    			chunkLengths = [],
    			totalLength = 0;

    		// first point has 0 length

    		chunkLengths[ 0 ] = 0;

    		if ( ! nSubDivisions ) nSubDivisions = 100;

    		nSamples = this.points.length * nSubDivisions;

    		oldPosition.copy( this.points[ 0 ] );

    		for ( i = 1; i < nSamples; i ++ ) {

    			index = i / nSamples;

    			position = this.getPoint( index );
    			tmpVec.copy( position );

    			totalLength += tmpVec.distanceTo( oldPosition );

    			oldPosition.copy( position );

    			point = ( this.points.length - 1 ) * index;
    			intPoint = Math.floor( point );

    			if ( intPoint !== oldIntPoint ) {

    				chunkLengths[ intPoint ] = totalLength;
    				oldIntPoint = intPoint;

    			}

    		}

    		// last point ends with total length

    		chunkLengths[ chunkLengths.length ] = totalLength;

    		return { chunks: chunkLengths, total: totalLength };

    	};

    	this.reparametrizeByArcLength = function ( samplingCoef ) {

    		var i, j,
    			index, indexCurrent, indexNext,
    			realDistance,
    			sampling, position,
    			newpoints = [],
    			tmpVec = new Vector3(),
    			sl = this.getLength();

    		newpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );

    		for ( i = 1; i < this.points.length; i ++ ) {

    			//tmpVec.copy( this.points[ i - 1 ] );
    			//linearDistance = tmpVec.distanceTo( this.points[ i ] );

    			realDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];

    			sampling = Math.ceil( samplingCoef * realDistance / sl.total );

    			indexCurrent = ( i - 1 ) / ( this.points.length - 1 );
    			indexNext = i / ( this.points.length - 1 );

    			for ( j = 1; j < sampling - 1; j ++ ) {

    				index = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );

    				position = this.getPoint( index );
    				newpoints.push( tmpVec.copy( position ).clone() );

    			}

    			newpoints.push( tmpVec.copy( this.points[ i ] ).clone() );

    		}

    		this.points = newpoints;

    	};

    	// Catmull-Rom

    	function interpolate( p0, p1, p2, p3, t, t2, t3 ) {

    		var v0 = ( p2 - p0 ) * 0.5,
    			v1 = ( p3 - p1 ) * 0.5;

    		return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;

    	}

    }

    /**
     * @author bhouston / http://clara.io
     * @author WestLangley / http://github.com/WestLangley
     *
     * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
     *
     * The poles (phi) are at the positive and negative y axis.
     * The equator starts at positive z.
     */

    function Spherical( radius, phi, theta ) {

    	this.radius = ( radius !== undefined ) ? radius : 1.0;
    	this.phi = ( phi !== undefined ) ? phi : 0; // up / down towards top and bottom pole
    	this.theta = ( theta !== undefined ) ? theta : 0; // around the equator of the sphere

    	return this;

    }

    Spherical.prototype = {

    	constructor: Spherical,

    	set: function ( radius, phi, theta ) {

    		this.radius = radius;
    		this.phi = phi;
    		this.theta = theta;

    		return this;

    	},

    	clone: function () {

    		return new this.constructor().copy( this );

    	},

    	copy: function ( other ) {

    		this.radius.copy( other.radius );
    		this.phi.copy( other.phi );
    		this.theta.copy( other.theta );

    		return this;

    	},

    	// restrict phi to be betwee EPS and PI-EPS
    	makeSafe: function() {

    		var EPS = 0.000001;
    		this.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );

    		return this;

    	},

    	setFromVector3: function( vec3 ) {

    		this.radius = vec3.length();

    		if ( this.radius === 0 ) {

    			this.theta = 0;
    			this.phi = 0;

    		} else {

    			this.theta = Math.atan2( vec3.x, vec3.z ); // equator angle around y-up axis
    			this.phi = Math.acos( exports.Math.clamp( vec3.y / this.radius, - 1, 1 ) ); // polar angle

    		}

    		return this;

    	},

    };

    /**
     * @author alteredq / http://alteredqualia.com/
     */

    function MorphBlendMesh( geometry, material ) {

    	Mesh.call( this, geometry, material );

    	this.animationsMap = {};
    	this.animationsList = [];

    	// prepare default animation
    	// (all frames played together in 1 second)

    	var numFrames = this.geometry.morphTargets.length;

    	var name = "__default";

    	var startFrame = 0;
    	var endFrame = numFrames - 1;

    	var fps = numFrames / 1;

    	this.createAnimation( name, startFrame, endFrame, fps );
    	this.setAnimationWeight( name, 1 );

    }

    MorphBlendMesh.prototype = Object.create( Mesh.prototype );
    MorphBlendMesh.prototype.constructor = MorphBlendMesh;

    MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {

    	var animation = {

    		start: start,
    		end: end,

    		length: end - start + 1,

    		fps: fps,
    		duration: ( end - start ) / fps,

    		lastFrame: 0,
    		currentFrame: 0,

    		active: false,

    		time: 0,
    		direction: 1,
    		weight: 1,

    		directionBackwards: false,
    		mirroredLoop: false

    	};

    	this.animationsMap[ name ] = animation;
    	this.animationsList.push( animation );

    };

    MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {

    	var pattern = /([a-z]+)_?(\d+)/i;

    	var firstAnimation, frameRanges = {};

    	var geometry = this.geometry;

    	for ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {

    		var morph = geometry.morphTargets[ i ];
    		var chunks = morph.name.match( pattern );

    		if ( chunks && chunks.length > 1 ) {

    			var name = chunks[ 1 ];

    			if ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: - Infinity };

    			var range = frameRanges[ name ];

    			if ( i < range.start ) range.start = i;
    			if ( i > range.end ) range.end = i;

    			if ( ! firstAnimation ) firstAnimation = name;

    		}

    	}

    	for ( var name in frameRanges ) {

    		var range = frameRanges[ name ];
    		this.createAnimation( name, range.start, range.end, fps );

    	}

    	this.firstAnimation = firstAnimation;

    };

    MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {

    	var animation = this.animationsMap[ name ];

    	if ( animation ) {

    		animation.direction = 1;
    		animation.directionBackwards = false;

    	}

    };

    MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {

    	var animation = this.animationsMap[ name ];

    	if ( animation ) {

    		animation.direction = - 1;
    		animation.directionBackwards = true;

    	}

    };

    MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {

    	var animation = this.animationsMap[ name ];

    	if ( animation ) {

    		animation.fps = fps;
    		animation.duration = ( animation.end - animation.start ) / animation.fps;

    	}

    };

    MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {

    	var animation = this.animationsMap[ name ];

    	if ( animation ) {

    		animation.duration = duration;
    		animation.fps = ( animation.end - animation.start ) / animation.duration;

    	}

    };

    MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {

    	var animation = this.animationsMap[ name ];

    	if ( animation ) {

    		animation.weight = weight;

    	}

    };

    MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {

    	var animation = this.animationsMap[ name ];

    	if ( animation ) {

    		animation.time = time;

    	}

    };

    MorphBlendMesh.prototype.getAnimationTime = function ( name ) {

    	var time = 0;

    	var animation = this.animationsMap[ name ];

    	if ( animation ) {

    		time = animation.time;

    	}

    	return time;

    };

    MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {

    	var duration = - 1;

    	var animation = this.animationsMap[ name ];

    	if ( animation ) {

    		duration = animation.duration;

    	}

    	return duration;

    };

    MorphBlendMesh.prototype.playAnimation = function ( name ) {

    	var animation = this.animationsMap[ name ];

    	if ( animation ) {

    		animation.time = 0;
    		animation.active = true;

    	} else {

    		console.warn( "THREE.MorphBlendMesh: animation[" + name + "] undefined in .playAnimation()" );

    	}

    };

    MorphBlendMesh.prototype.stopAnimation = function ( name ) {

    	var animation = this.animationsMap[ name ];

    	if ( animation ) {

    		animation.active = false;

    	}

    };

    MorphBlendMesh.prototype.update = function ( delta ) {

    	for ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {

    		var animation = this.animationsList[ i ];

    		if ( ! animation.active ) continue;

    		var frameTime = animation.duration / animation.length;

    		animation.time += animation.direction * delta;

    		if ( animation.mirroredLoop ) {

    			if ( animation.time > animation.duration || animation.time < 0 ) {

    				animation.direction *= - 1;

    				if ( animation.time > animation.duration ) {

    					animation.time = animation.duration;
    					animation.directionBackwards = true;

    				}

    				if ( animation.time < 0 ) {

    					animation.time = 0;
    					animation.directionBackwards = false;

    				}

    			}

    		} else {

    			animation.time = animation.time % animation.duration;

    			if ( animation.time < 0 ) animation.time += animation.duration;

    		}

    		var keyframe = animation.start + exports.Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );
    		var weight = animation.weight;

    		if ( keyframe !== animation.currentFrame ) {

    			this.morphTargetInfluences[ animation.lastFrame ] = 0;
    			this.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;

    			this.morphTargetInfluences[ keyframe ] = 0;

    			animation.lastFrame = animation.currentFrame;
    			animation.currentFrame = keyframe;

    		}

    		var mix = ( animation.time % frameTime ) / frameTime;

    		if ( animation.directionBackwards ) mix = 1 - mix;

    		if ( animation.currentFrame !== animation.lastFrame ) {

    			this.morphTargetInfluences[ animation.currentFrame ] = mix * weight;
    			this.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;

    		} else {

    			this.morphTargetInfluences[ animation.currentFrame ] = weight;

    		}

    	}

    };

    /**
     * @author alteredq / http://alteredqualia.com/
     */

    function ImmediateRenderObject( material ) {

    	Object3D.call( this );

    	this.material = material;
    	this.render = function ( renderCallback ) {};

    }

    ImmediateRenderObject.prototype = Object.create( Object3D.prototype );
    ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;

    ImmediateRenderObject.prototype.isImmediateRenderObject = true;

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author WestLangley / http://github.com/WestLangley
    */

    function VertexNormalsHelper( object, size, hex, linewidth ) {

    	this.object = object;

    	this.size = ( size !== undefined ) ? size : 1;

    	var color = ( hex !== undefined ) ? hex : 0xff0000;

    	var width = ( linewidth !== undefined ) ? linewidth : 1;

    	//

    	var nNormals = 0;

    	var objGeometry = this.object.geometry;

    	if ( (objGeometry && objGeometry.isGeometry) ) {

    		nNormals = objGeometry.faces.length * 3;

    	} else if ( (objGeometry && objGeometry.isBufferGeometry) ) {

    		nNormals = objGeometry.attributes.normal.count;

    	}

    	//

    	var geometry = new BufferGeometry();

    	var positions = new Float32Attribute( nNormals * 2 * 3, 3 );

    	geometry.addAttribute( 'position', positions );

    	LineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );

    	//

    	this.matrixAutoUpdate = false;

    	this.update();

    }

    VertexNormalsHelper.prototype = Object.create( LineSegments.prototype );
    VertexNormalsHelper.prototype.constructor = VertexNormalsHelper;

    VertexNormalsHelper.prototype.update = ( function () {

    	var v1 = new Vector3();
    	var v2 = new Vector3();
    	var normalMatrix = new Matrix3();

    	return function update() {

    		var keys = [ 'a', 'b', 'c' ];

    		this.object.updateMatrixWorld( true );

    		normalMatrix.getNormalMatrix( this.object.matrixWorld );

    		var matrixWorld = this.object.matrixWorld;

    		var position = this.geometry.attributes.position;

    		//

    		var objGeometry = this.object.geometry;

    		if ( (objGeometry && objGeometry.isGeometry) ) {

    			var vertices = objGeometry.vertices;

    			var faces = objGeometry.faces;

    			var idx = 0;

    			for ( var i = 0, l = faces.length; i < l; i ++ ) {

    				var face = faces[ i ];

    				for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

    					var vertex = vertices[ face[ keys[ j ] ] ];

    					var normal = face.vertexNormals[ j ];

    					v1.copy( vertex ).applyMatrix4( matrixWorld );

    					v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

    					position.setXYZ( idx, v1.x, v1.y, v1.z );

    					idx = idx + 1;

    					position.setXYZ( idx, v2.x, v2.y, v2.z );

    					idx = idx + 1;

    				}

    			}

    		} else if ( (objGeometry && objGeometry.isBufferGeometry) ) {

    			var objPos = objGeometry.attributes.position;

    			var objNorm = objGeometry.attributes.normal;

    			var idx = 0;

    			// for simplicity, ignore index and drawcalls, and render every normal

    			for ( var j = 0, jl = objPos.count; j < jl; j ++ ) {

    				v1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );

    				v2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );

    				v2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

    				position.setXYZ( idx, v1.x, v1.y, v1.z );

    				idx = idx + 1;

    				position.setXYZ( idx, v2.x, v2.y, v2.z );

    				idx = idx + 1;

    			}

    		}

    		position.needsUpdate = true;

    		return this;

    	};

    }() );

    /**
     * @author alteredq / http://alteredqualia.com/
     * @author mrdoob / http://mrdoob.com/
     * @author WestLangley / http://github.com/WestLangley
    */

    function SpotLightHelper( light ) {

    	Object3D.call( this );

    	this.light = light;
    	this.light.updateMatrixWorld();

    	this.matrix = light.matrixWorld;
    	this.matrixAutoUpdate = false;

    	var geometry = new BufferGeometry();

    	var positions = [
    		0, 0, 0,   0,   0,   1,
    		0, 0, 0,   1,   0,   1,
    		0, 0, 0, - 1,   0,   1,
    		0, 0, 0,   0,   1,   1,
    		0, 0, 0,   0, - 1,   1
    	];

    	for ( var i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {

    		var p1 = ( i / l ) * Math.PI * 2;
    		var p2 = ( j / l ) * Math.PI * 2;

    		positions.push(
    			Math.cos( p1 ), Math.sin( p1 ), 1,
    			Math.cos( p2 ), Math.sin( p2 ), 1
    		);

    	}

    	geometry.addAttribute( 'position', new Float32Attribute( positions, 3 ) );

    	var material = new LineBasicMaterial( { fog: false } );

    	this.cone = new LineSegments( geometry, material );
    	this.add( this.cone );

    	this.update();

    }

    SpotLightHelper.prototype = Object.create( Object3D.prototype );
    SpotLightHelper.prototype.constructor = SpotLightHelper;

    SpotLightHelper.prototype.dispose = function () {

    	this.cone.geometry.dispose();
    	this.cone.material.dispose();

    };

    SpotLightHelper.prototype.update = function () {

    	var vector = new Vector3();
    	var vector2 = new Vector3();

    	return function update() {

    		var coneLength = this.light.distance ? this.light.distance : 1000;
    		var coneWidth = coneLength * Math.tan( this.light.angle );

    		this.cone.scale.set( coneWidth, coneWidth, coneLength );

    		vector.setFromMatrixPosition( this.light.matrixWorld );
    		vector2.setFromMatrixPosition( this.light.target.matrixWorld );

    		this.cone.lookAt( vector2.sub( vector ) );

    		this.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

    	};

    }();

    /**
     * @author Sean Griffin / http://twitter.com/sgrif
     * @author Michael Guerrero / http://realitymeltdown.com
     * @author mrdoob / http://mrdoob.com/
     * @author ikerr / http://verold.com
     */

    function SkeletonHelper( object ) {

    	this.bones = this.getBoneList( object );

    	var geometry = new Geometry();

    	for ( var i = 0; i < this.bones.length; i ++ ) {

    		var bone = this.bones[ i ];

    		if ( (bone.parent && bone.parent.isBone) ) {

    			geometry.vertices.push( new Vector3() );
    			geometry.vertices.push( new Vector3() );
    			geometry.colors.push( new Color( 0, 0, 1 ) );
    			geometry.colors.push( new Color( 0, 1, 0 ) );

    		}

    	}

    	geometry.dynamic = true;

    	var material = new LineBasicMaterial( { vertexColors: VertexColors, depthTest: false, depthWrite: false, transparent: true } );

    	LineSegments.call( this, geometry, material );

    	this.root = object;

    	this.matrix = object.matrixWorld;
    	this.matrixAutoUpdate = false;

    	this.update();

    }


    SkeletonHelper.prototype = Object.create( LineSegments.prototype );
    SkeletonHelper.prototype.constructor = SkeletonHelper;

    SkeletonHelper.prototype.getBoneList = function( object ) {

    	var boneList = [];

    	if ( (object && object.isBone) ) {

    		boneList.push( object );

    	}

    	for ( var i = 0; i < object.children.length; i ++ ) {

    		boneList.push.apply( boneList, this.getBoneList( object.children[ i ] ) );

    	}

    	return boneList;

    };

    SkeletonHelper.prototype.update = function () {

    	var geometry = this.geometry;

    	var matrixWorldInv = new Matrix4().getInverse( this.root.matrixWorld );

    	var boneMatrix = new Matrix4();

    	var j = 0;

    	for ( var i = 0; i < this.bones.length; i ++ ) {

    		var bone = this.bones[ i ];

    		if ( (bone.parent && bone.parent.isBone) ) {

    			boneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );
    			geometry.vertices[ j ].setFromMatrixPosition( boneMatrix );

    			boneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );
    			geometry.vertices[ j + 1 ].setFromMatrixPosition( boneMatrix );

    			j += 2;

    		}

    	}

    	geometry.verticesNeedUpdate = true;

    	geometry.computeBoundingSphere();

    };

    /**
     * @author alteredq / http://alteredqualia.com/
     * @author mrdoob / http://mrdoob.com/
     */

    function PointLightHelper( light, sphereSize ) {

    	this.light = light;
    	this.light.updateMatrixWorld();

    	var geometry = new SphereBufferGeometry( sphereSize, 4, 2 );
    	var material = new MeshBasicMaterial( { wireframe: true, fog: false } );
    	material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

    	Mesh.call( this, geometry, material );

    	this.matrix = this.light.matrixWorld;
    	this.matrixAutoUpdate = false;

    	/*
    	var distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
    	var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

    	this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
    	this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

    	var d = light.distance;

    	if ( d === 0.0 ) {

    		this.lightDistance.visible = false;

    	} else {

    		this.lightDistance.scale.set( d, d, d );

    	}

    	this.add( this.lightDistance );
    	*/

    }

    PointLightHelper.prototype = Object.create( Mesh.prototype );
    PointLightHelper.prototype.constructor = PointLightHelper;

    PointLightHelper.prototype.dispose = function () {

    	this.geometry.dispose();
    	this.material.dispose();

    };

    PointLightHelper.prototype.update = function () {

    	this.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

    	/*
    	var d = this.light.distance;

    	if ( d === 0.0 ) {

    		this.lightDistance.visible = false;

    	} else {

    		this.lightDistance.visible = true;
    		this.lightDistance.scale.set( d, d, d );

    	}
    	*/

    };

    /**
     * @author alteredq / http://alteredqualia.com/
     * @author mrdoob / http://mrdoob.com/
     */

    function HemisphereLightHelper( light, sphereSize ) {

    	Object3D.call( this );

    	this.light = light;
    	this.light.updateMatrixWorld();

    	this.matrix = light.matrixWorld;
    	this.matrixAutoUpdate = false;

    	this.colors = [ new Color(), new Color() ];

    	var geometry = new SphereGeometry( sphereSize, 4, 2 );
    	geometry.rotateX( - Math.PI / 2 );

    	for ( var i = 0, il = 8; i < il; i ++ ) {

    		geometry.faces[ i ].color = this.colors[ i < 4 ? 0 : 1 ];

    	}

    	var material = new MeshBasicMaterial( { vertexColors: FaceColors, wireframe: true } );

    	this.lightSphere = new Mesh( geometry, material );
    	this.add( this.lightSphere );

    	this.update();

    }

    HemisphereLightHelper.prototype = Object.create( Object3D.prototype );
    HemisphereLightHelper.prototype.constructor = HemisphereLightHelper;

    HemisphereLightHelper.prototype.dispose = function () {

    	this.lightSphere.geometry.dispose();
    	this.lightSphere.material.dispose();

    };

    HemisphereLightHelper.prototype.update = function () {

    	var vector = new Vector3();

    	return function update() {

    		this.colors[ 0 ].copy( this.light.color ).multiplyScalar( this.light.intensity );
    		this.colors[ 1 ].copy( this.light.groundColor ).multiplyScalar( this.light.intensity );

    		this.lightSphere.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );
    		this.lightSphere.geometry.colorsNeedUpdate = true;

    	};

    }();

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function GridHelper( size, divisions, color1, color2 ) {

    	divisions = divisions || 1;
    	color1 = new Color( color1 !== undefined ? color1 : 0x444444 );
    	color2 = new Color( color2 !== undefined ? color2 : 0x888888 );

    	var center = divisions / 2;
    	var step = ( size * 2 ) / divisions;
    	var vertices = [], colors = [];

    	for ( var i = 0, j = 0, k = - size; i <= divisions; i ++, k += step ) {

    		vertices.push( - size, 0, k, size, 0, k );
    		vertices.push( k, 0, - size, k, 0, size );

    		var color = i === center ? color1 : color2;

    		color.toArray( colors, j ); j += 3;
    		color.toArray( colors, j ); j += 3;
    		color.toArray( colors, j ); j += 3;
    		color.toArray( colors, j ); j += 3;

    	}

    	var geometry = new BufferGeometry();
    	geometry.addAttribute( 'position', new Float32Attribute( vertices, 3 ) );
    	geometry.addAttribute( 'color', new Float32Attribute( colors, 3 ) );

    	var material = new LineBasicMaterial( { vertexColors: VertexColors } );

    	LineSegments.call( this, geometry, material );

    }

    GridHelper.prototype = Object.create( LineSegments.prototype );
    GridHelper.prototype.constructor = GridHelper;

    GridHelper.prototype.setColors = function () {

    	console.error( 'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.' );

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author WestLangley / http://github.com/WestLangley
    */

    function FaceNormalsHelper( object, size, hex, linewidth ) {

    	// FaceNormalsHelper only supports THREE.Geometry

    	this.object = object;

    	this.size = ( size !== undefined ) ? size : 1;

    	var color = ( hex !== undefined ) ? hex : 0xffff00;

    	var width = ( linewidth !== undefined ) ? linewidth : 1;

    	//

    	var nNormals = 0;

    	var objGeometry = this.object.geometry;

    	if ( (objGeometry && objGeometry.isGeometry) ) {

    		nNormals = objGeometry.faces.length;

    	} else {

    		console.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );

    	}

    	//

    	var geometry = new BufferGeometry();

    	var positions = new Float32Attribute( nNormals * 2 * 3, 3 );

    	geometry.addAttribute( 'position', positions );

    	LineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );

    	//

    	this.matrixAutoUpdate = false;
    	this.update();

    }

    FaceNormalsHelper.prototype = Object.create( LineSegments.prototype );
    FaceNormalsHelper.prototype.constructor = FaceNormalsHelper;

    FaceNormalsHelper.prototype.update = ( function () {

    	var v1 = new Vector3();
    	var v2 = new Vector3();
    	var normalMatrix = new Matrix3();

    	return function update() {

    		this.object.updateMatrixWorld( true );

    		normalMatrix.getNormalMatrix( this.object.matrixWorld );

    		var matrixWorld = this.object.matrixWorld;

    		var position = this.geometry.attributes.position;

    		//

    		var objGeometry = this.object.geometry;

    		var vertices = objGeometry.vertices;

    		var faces = objGeometry.faces;

    		var idx = 0;

    		for ( var i = 0, l = faces.length; i < l; i ++ ) {

    			var face = faces[ i ];

    			var normal = face.normal;

    			v1.copy( vertices[ face.a ] )
    				.add( vertices[ face.b ] )
    				.add( vertices[ face.c ] )
    				.divideScalar( 3 )
    				.applyMatrix4( matrixWorld );

    			v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

    			position.setXYZ( idx, v1.x, v1.y, v1.z );

    			idx = idx + 1;

    			position.setXYZ( idx, v2.x, v2.y, v2.z );

    			idx = idx + 1;

    		}

    		position.needsUpdate = true;

    		return this;

    	};

    }() );

    /**
     * @author alteredq / http://alteredqualia.com/
     * @author mrdoob / http://mrdoob.com/
     * @author WestLangley / http://github.com/WestLangley
     */

    function DirectionalLightHelper( light, size ) {

    	Object3D.call( this );

    	this.light = light;
    	this.light.updateMatrixWorld();

    	this.matrix = light.matrixWorld;
    	this.matrixAutoUpdate = false;

    	if ( size === undefined ) size = 1;

    	var geometry = new BufferGeometry();
    	geometry.addAttribute( 'position', new Float32Attribute( [
    		- size,   size, 0,
    		  size,   size, 0,
    		  size, - size, 0,
    		- size, - size, 0,
    		- size,   size, 0
    	], 3 ) );

    	var material = new LineBasicMaterial( { fog: false } );

    	this.add( new Line( geometry, material ) );

    	geometry = new BufferGeometry();
    	geometry.addAttribute( 'position', new Float32Attribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );

    	this.add( new Line( geometry, material ));

    	this.update();

    }

    DirectionalLightHelper.prototype = Object.create( Object3D.prototype );
    DirectionalLightHelper.prototype.constructor = DirectionalLightHelper;

    DirectionalLightHelper.prototype.dispose = function () {

    	var lightPlane = this.children[ 0 ];
    	var targetLine = this.children[ 1 ];

    	lightPlane.geometry.dispose();
    	lightPlane.material.dispose();
    	targetLine.geometry.dispose();
    	targetLine.material.dispose();

    };

    DirectionalLightHelper.prototype.update = function () {

    	var v1 = new Vector3();
    	var v2 = new Vector3();
    	var v3 = new Vector3();

    	return function update() {

    		v1.setFromMatrixPosition( this.light.matrixWorld );
    		v2.setFromMatrixPosition( this.light.target.matrixWorld );
    		v3.subVectors( v2, v1 );

    		var lightPlane = this.children[ 0 ];
    		var targetLine = this.children[ 1 ];

    		lightPlane.lookAt( v3 );
    		lightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

    		targetLine.lookAt( v3 );
    		targetLine.scale.z = v3.length();

    	};

    }();

    /**
     * @author alteredq / http://alteredqualia.com/
     *
     *	- shows frustum, line of sight and up of the camera
     *	- suitable for fast updates
     * 	- based on frustum visualization in lightgl.js shadowmap example
     *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
     */

    function CameraHelper( camera ) {

    	var geometry = new Geometry();
    	var material = new LineBasicMaterial( { color: 0xffffff, vertexColors: FaceColors } );

    	var pointMap = {};

    	// colors

    	var hexFrustum = 0xffaa00;
    	var hexCone = 0xff0000;
    	var hexUp = 0x00aaff;
    	var hexTarget = 0xffffff;
    	var hexCross = 0x333333;

    	// near

    	addLine( "n1", "n2", hexFrustum );
    	addLine( "n2", "n4", hexFrustum );
    	addLine( "n4", "n3", hexFrustum );
    	addLine( "n3", "n1", hexFrustum );

    	// far

    	addLine( "f1", "f2", hexFrustum );
    	addLine( "f2", "f4", hexFrustum );
    	addLine( "f4", "f3", hexFrustum );
    	addLine( "f3", "f1", hexFrustum );

    	// sides

    	addLine( "n1", "f1", hexFrustum );
    	addLine( "n2", "f2", hexFrustum );
    	addLine( "n3", "f3", hexFrustum );
    	addLine( "n4", "f4", hexFrustum );

    	// cone

    	addLine( "p", "n1", hexCone );
    	addLine( "p", "n2", hexCone );
    	addLine( "p", "n3", hexCone );
    	addLine( "p", "n4", hexCone );

    	// up

    	addLine( "u1", "u2", hexUp );
    	addLine( "u2", "u3", hexUp );
    	addLine( "u3", "u1", hexUp );

    	// target

    	addLine( "c", "t", hexTarget );
    	addLine( "p", "c", hexCross );

    	// cross

    	addLine( "cn1", "cn2", hexCross );
    	addLine( "cn3", "cn4", hexCross );

    	addLine( "cf1", "cf2", hexCross );
    	addLine( "cf3", "cf4", hexCross );

    	function addLine( a, b, hex ) {

    		addPoint( a, hex );
    		addPoint( b, hex );

    	}

    	function addPoint( id, hex ) {

    		geometry.vertices.push( new Vector3() );
    		geometry.colors.push( new Color( hex ) );

    		if ( pointMap[ id ] === undefined ) {

    			pointMap[ id ] = [];

    		}

    		pointMap[ id ].push( geometry.vertices.length - 1 );

    	}

    	LineSegments.call( this, geometry, material );

    	this.camera = camera;
    	if( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();

    	this.matrix = camera.matrixWorld;
    	this.matrixAutoUpdate = false;

    	this.pointMap = pointMap;

    	this.update();

    }

    CameraHelper.prototype = Object.create( LineSegments.prototype );
    CameraHelper.prototype.constructor = CameraHelper;

    CameraHelper.prototype.update = function () {

    	var geometry, pointMap;

    	var vector = new Vector3();
    	var camera = new Camera();

    	function setPoint( point, x, y, z ) {

    		vector.set( x, y, z ).unproject( camera );

    		var points = pointMap[ point ];

    		if ( points !== undefined ) {

    			for ( var i = 0, il = points.length; i < il; i ++ ) {

    				geometry.vertices[ points[ i ] ].copy( vector );

    			}

    		}

    	}

    	return function update() {

    		geometry = this.geometry;
    		pointMap = this.pointMap;

    		var w = 1, h = 1;

    		// we need just camera projection matrix
    		// world matrix must be identity

    		camera.projectionMatrix.copy( this.camera.projectionMatrix );

    		// center / target

    		setPoint( "c", 0, 0, - 1 );
    		setPoint( "t", 0, 0,  1 );

    		// near

    		setPoint( "n1", - w, - h, - 1 );
    		setPoint( "n2",   w, - h, - 1 );
    		setPoint( "n3", - w,   h, - 1 );
    		setPoint( "n4",   w,   h, - 1 );

    		// far

    		setPoint( "f1", - w, - h, 1 );
    		setPoint( "f2",   w, - h, 1 );
    		setPoint( "f3", - w,   h, 1 );
    		setPoint( "f4",   w,   h, 1 );

    		// up

    		setPoint( "u1",   w * 0.7, h * 1.1, - 1 );
    		setPoint( "u2", - w * 0.7, h * 1.1, - 1 );
    		setPoint( "u3",         0, h * 2,   - 1 );

    		// cross

    		setPoint( "cf1", - w,   0, 1 );
    		setPoint( "cf2",   w,   0, 1 );
    		setPoint( "cf3",   0, - h, 1 );
    		setPoint( "cf4",   0,   h, 1 );

    		setPoint( "cn1", - w,   0, - 1 );
    		setPoint( "cn2",   w,   0, - 1 );
    		setPoint( "cn3",   0, - h, - 1 );
    		setPoint( "cn4",   0,   h, - 1 );

    		geometry.verticesNeedUpdate = true;

    	};

    }();

    /**
     * @author WestLangley / http://github.com/WestLangley
     */

    // a helper to show the world-axis-aligned bounding box for an object

    function BoundingBoxHelper( object, hex ) {

    	var color = ( hex !== undefined ) ? hex : 0x888888;

    	this.object = object;

    	this.box = new Box3();

    	Mesh.call( this, new BoxGeometry( 1, 1, 1 ), new MeshBasicMaterial( { color: color, wireframe: true } ) );

    }

    BoundingBoxHelper.prototype = Object.create( Mesh.prototype );
    BoundingBoxHelper.prototype.constructor = BoundingBoxHelper;

    BoundingBoxHelper.prototype.update = function () {

    	this.box.setFromObject( this.object );

    	this.box.size( this.scale );

    	this.box.getCenter( this.position );

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function BoxHelper( object, color ) {

    	if ( color === undefined ) color = 0xffff00;

    	var indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );
    	var positions = new Float32Array( 8 * 3 );

    	var geometry = new BufferGeometry();
    	geometry.setIndex( new BufferAttribute( indices, 1 ) );
    	geometry.addAttribute( 'position', new BufferAttribute( positions, 3 ) );

    	LineSegments.call( this, geometry, new LineBasicMaterial( { color: color } ) );

    	if ( object !== undefined ) {

    		this.update( object );

    	}

    }

    BoxHelper.prototype = Object.create( LineSegments.prototype );
    BoxHelper.prototype.constructor = BoxHelper;

    BoxHelper.prototype.update = ( function () {

    	var box = new Box3();

    	return function update( object ) {

    		if ( (object && object.isBox3) ) {

    			box.copy( object );

    		} else {

    			box.setFromObject( object );

    		}

    		if ( box.isEmpty() ) return;

    		var min = box.min;
    		var max = box.max;

    		/*
    		  5____4
    		1/___0/|
    		| 6__|_7
    		2/___3/

    		0: max.x, max.y, max.z
    		1: min.x, max.y, max.z
    		2: min.x, min.y, max.z
    		3: max.x, min.y, max.z
    		4: max.x, max.y, min.z
    		5: min.x, max.y, min.z
    		6: min.x, min.y, min.z
    		7: max.x, min.y, min.z
    		*/

    		var position = this.geometry.attributes.position;
    		var array = position.array;

    		array[  0 ] = max.x; array[  1 ] = max.y; array[  2 ] = max.z;
    		array[  3 ] = min.x; array[  4 ] = max.y; array[  5 ] = max.z;
    		array[  6 ] = min.x; array[  7 ] = min.y; array[  8 ] = max.z;
    		array[  9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;
    		array[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;
    		array[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;
    		array[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;
    		array[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;

    		position.needsUpdate = true;

    		this.geometry.computeBoundingSphere();

    	};

    } )();

    var lineGeometry = new BufferGeometry();
    lineGeometry.addAttribute( 'position', new Float32Attribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );

    var coneGeometry = new CylinderBufferGeometry( 0, 0.5, 1, 5, 1 );
    coneGeometry.translate( 0, - 0.5, 0 );

    function ArrowHelper( dir, origin, length, color, headLength, headWidth ) {

    	// dir is assumed to be normalized

    	Object3D.call( this );

    	if ( color === undefined ) color = 0xffff00;
    	if ( length === undefined ) length = 1;
    	if ( headLength === undefined ) headLength = 0.2 * length;
    	if ( headWidth === undefined ) headWidth = 0.2 * headLength;

    	this.position.copy( origin );

    	this.line = new Line( lineGeometry, new LineBasicMaterial( { color: color } ) );
    	this.line.matrixAutoUpdate = false;
    	this.add( this.line );

    	this.cone = new Mesh( coneGeometry, new MeshBasicMaterial( { color: color } ) );
    	this.cone.matrixAutoUpdate = false;
    	this.add( this.cone );

    	this.setDirection( dir );
    	this.setLength( length, headLength, headWidth );

    }

    ArrowHelper.prototype = Object.create( Object3D.prototype );
    ArrowHelper.prototype.constructor = ArrowHelper;

    ArrowHelper.prototype.setDirection = ( function () {

    	var axis = new Vector3();
    	var radians;

    	return function setDirection( dir ) {

    		// dir is assumed to be normalized

    		if ( dir.y > 0.99999 ) {

    			this.quaternion.set( 0, 0, 0, 1 );

    		} else if ( dir.y < - 0.99999 ) {

    			this.quaternion.set( 1, 0, 0, 0 );

    		} else {

    			axis.set( dir.z, 0, - dir.x ).normalize();

    			radians = Math.acos( dir.y );

    			this.quaternion.setFromAxisAngle( axis, radians );

    		}

    	};

    }() );

    ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {

    	if ( headLength === undefined ) headLength = 0.2 * length;
    	if ( headWidth === undefined ) headWidth = 0.2 * headLength;

    	this.line.scale.set( 1, Math.max( 0, length - headLength ), 1 );
    	this.line.updateMatrix();

    	this.cone.scale.set( headWidth, headLength, headWidth );
    	this.cone.position.y = length;
    	this.cone.updateMatrix();

    };

    ArrowHelper.prototype.setColor = function ( color ) {

    	this.line.material.color.copy( color );
    	this.cone.material.color.copy( color );

    };

    /**
     * @author sroucheray / http://sroucheray.org/
     * @author mrdoob / http://mrdoob.com/
     */

    function AxisHelper( size ) {

    	size = size || 1;

    	var vertices = new Float32Array( [
    		0, 0, 0,  size, 0, 0,
    		0, 0, 0,  0, size, 0,
    		0, 0, 0,  0, 0, size
    	] );

    	var colors = new Float32Array( [
    		1, 0, 0,  1, 0.6, 0,
    		0, 1, 0,  0.6, 1, 0,
    		0, 0, 1,  0, 0.6, 1
    	] );

    	var geometry = new BufferGeometry();
    	geometry.addAttribute( 'position', new BufferAttribute( vertices, 3 ) );
    	geometry.addAttribute( 'color', new BufferAttribute( colors, 3 ) );

    	var material = new LineBasicMaterial( { vertexColors: VertexColors } );

    	LineSegments.call( this, geometry, material );

    }

    AxisHelper.prototype = Object.create( LineSegments.prototype );
    AxisHelper.prototype.constructor = AxisHelper;

    /**
     * @author zz85 https://github.com/zz85
     *
     * Centripetal CatmullRom Curve - which is useful for avoiding
     * cusps and self-intersections in non-uniform catmull rom curves.
     * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
     *
     * curve.type accepts centripetal(default), chordal and catmullrom
     * curve.tension is used for catmullrom which defaults to 0.5
     */

    exports.CatmullRomCurve3 = ( function() {

    	var
    		tmp = new Vector3(),
    		px = new CubicPoly(),
    		py = new CubicPoly(),
    		pz = new CubicPoly();

    	/*
    	Based on an optimized c++ solution in
    	 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
    	 - http://ideone.com/NoEbVM

    	This CubicPoly class could be used for reusing some variables and calculations,
    	but for three.js curve use, it could be possible inlined and flatten into a single function call
    	which can be placed in CurveUtils.
    	*/

    	function CubicPoly() {

    	}

    	/*
    	 * Compute coefficients for a cubic polynomial
    	 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
    	 * such that
    	 *   p(0) = x0, p(1) = x1
    	 *  and
    	 *   p'(0) = t0, p'(1) = t1.
    	 */
    	CubicPoly.prototype.init = function( x0, x1, t0, t1 ) {

    		this.c0 = x0;
    		this.c1 = t0;
    		this.c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;
    		this.c3 = 2 * x0 - 2 * x1 + t0 + t1;

    	};

    	CubicPoly.prototype.initNonuniformCatmullRom = function( x0, x1, x2, x3, dt0, dt1, dt2 ) {

    		// compute tangents when parameterized in [t1,t2]
    		var t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;
    		var t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;

    		// rescale tangents for parametrization in [0,1]
    		t1 *= dt1;
    		t2 *= dt1;

    		// initCubicPoly
    		this.init( x1, x2, t1, t2 );

    	};

    	// standard Catmull-Rom spline: interpolate between x1 and x2 with previous/following points x1/x4
    	CubicPoly.prototype.initCatmullRom = function( x0, x1, x2, x3, tension ) {

    		this.init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );

    	};

    	CubicPoly.prototype.calc = function( t ) {

    		var t2 = t * t;
    		var t3 = t2 * t;
    		return this.c0 + this.c1 * t + this.c2 * t2 + this.c3 * t3;

    	};

    	// Subclass Three.js curve
    	return Curve.create(

    		function ( p /* array of Vector3 */ ) {

    			this.points = p || [];
    			this.closed = false;

    		},

    		function ( t ) {

    			var points = this.points,
    				point, intPoint, weight, l;

    			l = points.length;

    			if ( l < 2 ) console.log( 'duh, you need at least 2 points' );

    			point = ( l - ( this.closed ? 0 : 1 ) ) * t;
    			intPoint = Math.floor( point );
    			weight = point - intPoint;

    			if ( this.closed ) {

    				intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;

    			} else if ( weight === 0 && intPoint === l - 1 ) {

    				intPoint = l - 2;
    				weight = 1;

    			}

    			var p0, p1, p2, p3; // 4 points

    			if ( this.closed || intPoint > 0 ) {

    				p0 = points[ ( intPoint - 1 ) % l ];

    			} else {

    				// extrapolate first point
    				tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );
    				p0 = tmp;

    			}

    			p1 = points[ intPoint % l ];
    			p2 = points[ ( intPoint + 1 ) % l ];

    			if ( this.closed || intPoint + 2 < l ) {

    				p3 = points[ ( intPoint + 2 ) % l ];

    			} else {

    				// extrapolate last point
    				tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );
    				p3 = tmp;

    			}

    			if ( this.type === undefined || this.type === 'centripetal' || this.type === 'chordal' ) {

    				// init Centripetal / Chordal Catmull-Rom
    				var pow = this.type === 'chordal' ? 0.5 : 0.25;
    				var dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );
    				var dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );
    				var dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );

    				// safety check for repeated points
    				if ( dt1 < 1e-4 ) dt1 = 1.0;
    				if ( dt0 < 1e-4 ) dt0 = dt1;
    				if ( dt2 < 1e-4 ) dt2 = dt1;

    				px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );
    				py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );
    				pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );

    			} else if ( this.type === 'catmullrom' ) {

    				var tension = this.tension !== undefined ? this.tension : 0.5;
    				px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, tension );
    				py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, tension );
    				pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, tension );

    			}

    			var v = new Vector3(
    				px.calc( weight ),
    				py.calc( weight ),
    				pz.calc( weight )
    			);

    			return v;

    		}

    	);

    } )();

    /**************************************************************
     *	Closed Spline 3D curve
     **************************************************************/


    function ClosedSplineCurve3( points ) {

    	console.warn( 'THREE.ClosedSplineCurve3 has been deprecated. Please use THREE.CatmullRomCurve3.' );

    	exports.CatmullRomCurve3.call( this, points );
    	this.type = 'catmullrom';
    	this.closed = true;

    }

    ClosedSplineCurve3.prototype = Object.create( exports.CatmullRomCurve3.prototype );

    /**************************************************************
     *	Spline 3D curve
     **************************************************************/


    var SplineCurve3 = Curve.create(

    	function ( points /* array of Vector3 */ ) {

    		console.warn( 'THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3' );
    		this.points = ( points === undefined ) ? [] : points;

    	},

    	function ( t ) {

    		var points = this.points;
    		var point = ( points.length - 1 ) * t;

    		var intPoint = Math.floor( point );
    		var weight = point - intPoint;

    		var point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ];
    		var point1 = points[ intPoint ];
    		var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
    		var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

    		var interpolate = exports.CurveUtils.interpolate;

    		return new Vector3(
    			interpolate( point0.x, point1.x, point2.x, point3.x, weight ),
    			interpolate( point0.y, point1.y, point2.y, point3.y, weight ),
    			interpolate( point0.z, point1.z, point2.z, point3.z, weight )
    		);

    	}

    );

    /**************************************************************
     *	Cubic Bezier 3D curve
     **************************************************************/

    exports.CubicBezierCurve3 = Curve.create(

    	function ( v0, v1, v2, v3 ) {

    		this.v0 = v0;
    		this.v1 = v1;
    		this.v2 = v2;
    		this.v3 = v3;

    	},

    	function ( t ) {

    		var b3 = exports.ShapeUtils.b3;

    		return new Vector3(
    			b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),
    			b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y ),
    			b3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z )
    		);

    	}

    );

    /**************************************************************
     *	Quadratic Bezier 3D curve
     **************************************************************/

    exports.QuadraticBezierCurve3 = Curve.create(

    	function ( v0, v1, v2 ) {

    		this.v0 = v0;
    		this.v1 = v1;
    		this.v2 = v2;

    	},

    	function ( t ) {

    		var b2 = exports.ShapeUtils.b2;		

    		return new Vector3(
    			b2( t, this.v0.x, this.v1.x, this.v2.x ),
    			b2( t, this.v0.y, this.v1.y, this.v2.y ),
    			b2( t, this.v0.z, this.v1.z, this.v2.z )
    		);

    	}

    );

    /**************************************************************
     *	Line3D
     **************************************************************/

    exports.LineCurve3 = Curve.create(

    	function ( v1, v2 ) {

    		this.v1 = v1;
    		this.v2 = v2;

    	},

    	function ( t ) {

    		if ( t === 1 ) {

    			return this.v2.clone();

    		}

    		var vector = new Vector3();

    		vector.subVectors( this.v2, this.v1 ); // diff
    		vector.multiplyScalar( t );
    		vector.add( this.v1 );

    		return vector;

    	}

    );

    /**************************************************************
     *	Arc curve
     **************************************************************/

    function ArcCurve( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

    	EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

    }

    ArcCurve.prototype = Object.create( EllipseCurve.prototype );
    ArcCurve.prototype.constructor = ArcCurve;

    /**
     * @author alteredq / http://alteredqualia.com/
     */

    exports.SceneUtils = {

    	createMultiMaterialObject: function ( geometry, materials ) {

    		var group = new Group();

    		for ( var i = 0, l = materials.length; i < l; i ++ ) {

    			group.add( new Mesh( geometry, materials[ i ] ) );

    		}

    		return group;

    	},

    	detach: function ( child, parent, scene ) {

    		child.applyMatrix( parent.matrixWorld );
    		parent.remove( child );
    		scene.add( child );

    	},

    	attach: function ( child, scene, parent ) {

    		var matrixWorldInverse = new Matrix4();
    		matrixWorldInverse.getInverse( parent.matrixWorld );
    		child.applyMatrix( matrixWorldInverse );

    		scene.remove( child );
    		parent.add( child );

    	}

    };

    function Face4 ( a, b, c, d, normal, color, materialIndex ) {
    	console.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );
    	return new Face3( a, b, c, normal, color, materialIndex );
    }

    var LineStrip = 0;

    var LinePieces = 1;

    function PointCloud ( geometry, material ) {
    	console.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );
    	return new Points( geometry, material );
    }

    function ParticleSystem ( geometry, material ) {
    	console.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );
    	return new Points( geometry, material );
    }

    function PointCloudMaterial ( parameters ) {
    	console.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );
    	return new PointsMaterial( parameters );
    }

    function ParticleBasicMaterial ( parameters ) {
    	console.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );
    	return new PointsMaterial( parameters );
    }

    function ParticleSystemMaterial ( parameters ) {
    	console.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );
    	return new PointsMaterial( parameters );
    }

    function Vertex ( x, y, z ) {
    	console.warn( 'THREE.Vertex has been removed. Use THREE.Vector3 instead.' );
    	return new Vector3( x, y, z );
    }

    //

    function EdgesHelper( object, hex ) {
    	console.warn( 'THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.' );
    	return new LineSegments( new EdgesGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );
    }

    function WireframeHelper( object, hex ) {
    	console.warn( 'THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.' );
    	return new LineSegments( new WireframeGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );
    }

    //

    Object.assign( Box2.prototype, {
    	center: function ( optionalTarget ) {
    		console.warn( 'THREE.Box2: .center() has been renamed to .getCenter().' );
    		return this.getCenter( optionalTarget );
    	},
    	empty: function () {
    		console.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );
    		return this.isEmpty();
    	},
    	isIntersectionBox: function ( box ) {
    		console.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );
    		return this.intersectsBox( box );
    	},
    	size: function ( optionalTarget ) {
    		console.warn( 'THREE.Box2: .size() has been renamed to .getSize().' );
    		return this.getSize( optionalTarget );
    	}
    } );

    Object.assign( Box3.prototype, {
    	center: function ( optionalTarget ) {
    		console.warn( 'THREE.Box3: .center() has been renamed to .getCenter().' );
    		return this.getCenter( optionalTarget );
    	},
    	empty: function () {
    		console.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );
    		return this.isEmpty();
    	},
    	isIntersectionBox: function ( box ) {
    		console.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );
    		return this.intersectsBox( box );
    	},
    	isIntersectionSphere: function ( sphere ) {
    		console.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
    		return this.intersectsSphere( sphere );
    	},
    	size: function ( optionalTarget ) {
    		console.warn( 'THREE.Box3: .size() has been renamed to .getSize().' );
    		return this.getSize( optionalTarget );
    	}
    } );

    Object.assign( Line3.prototype, {
    	center: function ( optionalTarget ) {
    		console.warn( 'THREE.Line3: .center() has been renamed to .getCenter().' );
    		return this.getCenter( optionalTarget );
    	}
    } );

    Object.assign( Matrix3.prototype, {
    	multiplyVector3: function ( vector ) {
    		console.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
    		return vector.applyMatrix3( this );
    	},
    	multiplyVector3Array: function ( a ) {
    		console.warn( 'THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
    		return this.applyToVector3Array( a );
    	}
    } );

    Object.assign( Matrix4.prototype, {
    	extractPosition: function ( m ) {
    		console.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );
    		return this.copyPosition( m );
    	},
    	setRotationFromQuaternion: function ( q ) {
    		console.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );
    		return this.makeRotationFromQuaternion( q );
    	},
    	multiplyVector3: function ( vector ) {
    		console.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );
    		return vector.applyProjection( this );
    	},
    	multiplyVector4: function ( vector ) {
    		console.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
    		return vector.applyMatrix4( this );
    	},
    	multiplyVector3Array: function ( a ) {
    		console.warn( 'THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
    		return this.applyToVector3Array( a );
    	},
    	rotateAxis: function ( v ) {
    		console.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );
    		v.transformDirection( this );
    	},
    	crossVector: function ( vector ) {
    		console.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
    		return vector.applyMatrix4( this );
    	},
    	translate: function ( v ) {
    		console.error( 'THREE.Matrix4: .translate() has been removed.' );
    	},
    	rotateX: function ( angle ) {
    		console.error( 'THREE.Matrix4: .rotateX() has been removed.' );
    	},
    	rotateY: function ( angle ) {
    		console.error( 'THREE.Matrix4: .rotateY() has been removed.' );
    	},
    	rotateZ: function ( angle ) {
    		console.error( 'THREE.Matrix4: .rotateZ() has been removed.' );
    	},
    	rotateByAxis: function ( axis, angle ) {
    		console.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );
    	}
    } );

    Object.assign( Plane.prototype, {
    	isIntersectionLine: function ( line ) {
    		console.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );
    		return this.intersectsLine( line );
    	}
    } );

    Object.assign( Quaternion.prototype, {
    	multiplyVector3: function ( vector ) {
    		console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
    		return vector.applyQuaternion( this );
    	}
    } );

    Object.assign( Ray.prototype, {
    	isIntersectionBox: function ( box ) {
    		console.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );
    		return this.intersectsBox( box );
    	},
    	isIntersectionPlane: function ( plane ) {
    		console.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );
    		return this.intersectsPlane( plane );
    	},
    	isIntersectionSphere: function ( sphere ) {
    		console.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
    		return this.intersectsSphere( sphere );
    	}
    } );

    Object.assign( Shape.prototype, {
    	extrude: function ( options ) {
    		console.warn( 'THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.' );
    		return new ExtrudeGeometry( this, options );
    	},
    	makeGeometry: function ( options ) {
    		console.warn( 'THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.' );
    		return new ShapeGeometry( this, options );
    	}
    } );

    Object.assign( Vector3.prototype, {
    	setEulerFromRotationMatrix: function () {
    		console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );
    	},
    	setEulerFromQuaternion: function () {
    		console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );
    	},
    	getPositionFromMatrix: function ( m ) {
    		console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );
    		return this.setFromMatrixPosition( m );
    	},
    	getScaleFromMatrix: function ( m ) {
    		console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );
    		return this.setFromMatrixScale( m );
    	},
    	getColumnFromMatrix: function ( index, matrix ) {
    		console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );
    		return this.setFromMatrixColumn( matrix, index );
    	}
    } );

    //

    Object.assign( Object3D.prototype, {
    	getChildByName: function ( name ) {
    		console.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );
    		return this.getObjectByName( name );
    	},
    	renderDepth: function ( value ) {
    		console.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );
    	},
    	translate: function ( distance, axis ) {
    		console.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );
    		return this.translateOnAxis( axis, distance );
    	}
    } );

    Object.defineProperties( Object3D.prototype, {
    	eulerOrder: {
    		get: function () {
    			console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
    			return this.rotation.order;
    		},
    		set: function ( value ) {
    			console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
    			this.rotation.order = value;
    		}
    	},
    	useQuaternion: {
    		get: function () {
    			console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );
    		},
    		set: function ( value ) {
    			console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );
    		}
    	}
    } );

    Object.defineProperties( LOD.prototype, {
    	objects: {
    		get: function () {
    			console.warn( 'THREE.LOD: .objects has been renamed to .levels.' );
    			return this.levels;
    		}
    	}
    } );

    //

    PerspectiveCamera.prototype.setLens = function ( focalLength, filmGauge ) {

    	console.warn( "THREE.PerspectiveCamera.setLens is deprecated. " +
    			"Use .setFocalLength and .filmGauge for a photographic setup." );

    	if ( filmGauge !== undefined ) this.filmGauge = filmGauge;
    	this.setFocalLength( focalLength );

    };

    //

    Object.defineProperties( Light.prototype, {
    	onlyShadow: {
    		set: function ( value ) {
    			console.warn( 'THREE.Light: .onlyShadow has been removed.' );
    		}
    	},
    	shadowCameraFov: {
    		set: function ( value ) {
    			console.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );
    			this.shadow.camera.fov = value;
    		}
    	},
    	shadowCameraLeft: {
    		set: function ( value ) {
    			console.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );
    			this.shadow.camera.left = value;
    		}
    	},
    	shadowCameraRight: {
    		set: function ( value ) {
    			console.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );
    			this.shadow.camera.right = value;
    		}
    	},
    	shadowCameraTop: {
    		set: function ( value ) {
    			console.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );
    			this.shadow.camera.top = value;
    		}
    	},
    	shadowCameraBottom: {
    		set: function ( value ) {
    			console.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );
    			this.shadow.camera.bottom = value;
    		}
    	},
    	shadowCameraNear: {
    		set: function ( value ) {
    			console.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );
    			this.shadow.camera.near = value;
    		}
    	},
    	shadowCameraFar: {
    		set: function ( value ) {
    			console.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );
    			this.shadow.camera.far = value;
    		}
    	},
    	shadowCameraVisible: {
    		set: function ( value ) {
    			console.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );
    		}
    	},
    	shadowBias: {
    		set: function ( value ) {
    			console.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );
    			this.shadow.bias = value;
    		}
    	},
    	shadowDarkness: {
    		set: function ( value ) {
    			console.warn( 'THREE.Light: .shadowDarkness has been removed.' );
    		}
    	},
    	shadowMapWidth: {
    		set: function ( value ) {
    			console.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );
    			this.shadow.mapSize.width = value;
    		}
    	},
    	shadowMapHeight: {
    		set: function ( value ) {
    			console.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );
    			this.shadow.mapSize.height = value;
    		}
    	}
    } );

    //

    Object.defineProperties( BufferAttribute.prototype, {
    	length: {
    		get: function () {
    			console.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );
    			return this.array.length;
    		}
    	}
    } );

    Object.assign( BufferGeometry.prototype, {
    	addIndex: function ( index ) {
    		console.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );
    		this.setIndex( index );
    	},
    	addDrawCall: function ( start, count, indexOffset ) {
    		if ( indexOffset !== undefined ) {
    			console.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );
    		}
    		console.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );
    		this.addGroup( start, count );
    	},
    	clearDrawCalls: function () {
    		console.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );
    		this.clearGroups();
    	},
    	computeTangents: function () {
    		console.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );
    	},
    	computeOffsets: function () {
    		console.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );
    	}
    } );

    Object.defineProperties( BufferGeometry.prototype, {
    	drawcalls: {
    		get: function () {
    			console.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );
    			return this.groups;
    		}
    	},
    	offsets: {
    		get: function () {
    			console.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );
    			return this.groups;
    		}
    	}
    } );

    //

    Object.defineProperties( Material.prototype, {
    	wrapAround: {
    		get: function () {
    			console.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );
    		},
    		set: function ( value ) {
    			console.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );
    		}
    	},
    	wrapRGB: {
    		get: function () {
    			console.warn( 'THREE.' + this.type + ': .wrapRGB has been removed.' );
    			return new Color();
    		}
    	}
    } );

    Object.defineProperties( MeshPhongMaterial.prototype, {
    	metal: {
    		get: function () {
    			console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.' );
    			return false;
    		},
    		set: function ( value ) {
    			console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead' );
    		}
    	}
    } );

    Object.defineProperties( ShaderMaterial.prototype, {
    	derivatives: {
    		get: function () {
    			console.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
    			return this.extensions.derivatives;
    		},
    		set: function ( value ) {
    			console.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
    			this.extensions.derivatives = value;
    		}
    	}
    } );

    //

    EventDispatcher.prototype = Object.assign( Object.create( {

    	// Note: Extra base ensures these properties are not 'assign'ed.

    	constructor: EventDispatcher,

    	apply: function ( target ) {

    		console.warn( "THREE.EventDispatcher: .apply is deprecated, " +
    				"just inherit or Object.assign the prototype to mix-in." );

    		Object.assign( target, this );

    	}

    } ), EventDispatcher.prototype );

    //

    Object.assign( WebGLRenderer.prototype, {
    	supportsFloatTextures: function () {
    		console.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).' );
    		return this.extensions.get( 'OES_texture_float' );
    	},
    	supportsHalfFloatTextures: function () {
    		console.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).' );
    		return this.extensions.get( 'OES_texture_half_float' );
    	},
    	supportsStandardDerivatives: function () {
    		console.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).' );
    		return this.extensions.get( 'OES_standard_derivatives' );
    	},
    	supportsCompressedTextureS3TC: function () {
    		console.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).' );
    		return this.extensions.get( 'WEBGL_compressed_texture_s3tc' );
    	},
    	supportsCompressedTexturePVRTC: function () {
    		console.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).' );
    		return this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );
    	},
    	supportsBlendMinMax: function () {
    		console.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).' );
    		return this.extensions.get( 'EXT_blend_minmax' );
    	},
    	supportsVertexTextures: function () {
    		return this.capabilities.vertexTextures;
    	},
    	supportsInstancedArrays: function () {
    		console.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).' );
    		return this.extensions.get( 'ANGLE_instanced_arrays' );
    	},
    	enableScissorTest: function ( boolean ) {
    		console.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );
    		this.setScissorTest( boolean );
    	},
    	initMaterial: function () {
    		console.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );
    	},
    	addPrePlugin: function () {
    		console.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );
    	},
    	addPostPlugin: function () {
    		console.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );
    	},
    	updateShadowMap: function () {
    		console.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );
    	}
    } );

    Object.defineProperties( WebGLRenderer.prototype, {
    	shadowMapEnabled: {
    		get: function () {
    			return this.shadowMap.enabled;
    		},
    		set: function ( value ) {
    			console.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );
    			this.shadowMap.enabled = value;
    		}
    	},
    	shadowMapType: {
    		get: function () {
    			return this.shadowMap.type;
    		},
    		set: function ( value ) {
    			console.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );
    			this.shadowMap.type = value;
    		}
    	},
    	shadowMapCullFace: {
    		get: function () {
    			return this.shadowMap.cullFace;
    		},
    		set: function ( value ) {
    			console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.' );
    			this.shadowMap.cullFace = value;
    		}
    	}
    } );

    Object.defineProperties( WebGLShadowMap.prototype, {
    	cullFace: {
    		get: function () {
    			return this.renderReverseSided ? CullFaceFront : CullFaceBack;
    		},
    		set: function ( cullFace ) {
    			var value = ( cullFace !== CullFaceBack );
    			console.warn( "WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to " + value + "." );
    			this.renderReverseSided = value;
    		}
    	}
    } );

    //

    Object.defineProperties( WebGLRenderTarget.prototype, {
    	wrapS: {
    		get: function () {
    			console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
    			return this.texture.wrapS;
    		},
    		set: function ( value ) {
    			console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
    			this.texture.wrapS = value;
    		}
    	},
    	wrapT: {
    		get: function () {
    			console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
    			return this.texture.wrapT;
    		},
    		set: function ( value ) {
    			console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
    			this.texture.wrapT = value;
    		}
    	},
    	magFilter: {
    		get: function () {
    			console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
    			return this.texture.magFilter;
    		},
    		set: function ( value ) {
    			console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
    			this.texture.magFilter = value;
    		}
    	},
    	minFilter: {
    		get: function () {
    			console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
    			return this.texture.minFilter;
    		},
    		set: function ( value ) {
    			console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
    			this.texture.minFilter = value;
    		}
    	},
    	anisotropy: {
    		get: function () {
    			console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
    			return this.texture.anisotropy;
    		},
    		set: function ( value ) {
    			console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
    			this.texture.anisotropy = value;
    		}
    	},
    	offset: {
    		get: function () {
    			console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
    			return this.texture.offset;
    		},
    		set: function ( value ) {
    			console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
    			this.texture.offset = value;
    		}
    	},
    	repeat: {
    		get: function () {
    			console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
    			return this.texture.repeat;
    		},
    		set: function ( value ) {
    			console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
    			this.texture.repeat = value;
    		}
    	},
    	format: {
    		get: function () {
    			console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
    			return this.texture.format;
    		},
    		set: function ( value ) {
    			console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
    			this.texture.format = value;
    		}
    	},
    	type: {
    		get: function () {
    			console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
    			return this.texture.type;
    		},
    		set: function ( value ) {
    			console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
    			this.texture.type = value;
    		}
    	},
    	generateMipmaps: {
    		get: function () {
    			console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
    			return this.texture.generateMipmaps;
    		},
    		set: function ( value ) {
    			console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
    			this.texture.generateMipmaps = value;
    		}
    	}
    } );

    //

    Object.assign( Audio.prototype, {
    	load: function ( file ) {
    		console.warn( 'THREE.Audio: .load has been deprecated. Please use THREE.AudioLoader.' );
    		var scope = this;
    		var audioLoader = new AudioLoader();
    		audioLoader.load( file, function ( buffer ) {
    			scope.setBuffer( buffer );
    		} );
    		return this;
    	}
    } );

    Object.assign( AudioAnalyser.prototype, {
    	getData: function ( file ) {
    		console.warn( 'THREE.AudioAnalyser: .getData() is now .getFrequencyData().' );
    		return this.getFrequencyData();
    	}
    } );

    //

    var GeometryUtils = {

    	merge: function ( geometry1, geometry2, materialIndexOffset ) {

    		console.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );

    		var matrix;

    		if ( geometry2.isMesh ) {

    			geometry2.matrixAutoUpdate && geometry2.updateMatrix();

    			matrix = geometry2.matrix;
    			geometry2 = geometry2.geometry;

    		}

    		geometry1.merge( geometry2, matrix, materialIndexOffset );

    	},

    	center: function ( geometry ) {

    		console.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );
    		return geometry.center();

    	}

    };

    var ImageUtils = {

    	crossOrigin: undefined,

    	loadTexture: function ( url, mapping, onLoad, onError ) {

    		console.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );

    		var loader = new TextureLoader();
    		loader.setCrossOrigin( this.crossOrigin );

    		var texture = loader.load( url, onLoad, undefined, onError );

    		if ( mapping ) texture.mapping = mapping;

    		return texture;

    	},

    	loadTextureCube: function ( urls, mapping, onLoad, onError ) {

    		console.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );

    		var loader = new CubeTextureLoader();
    		loader.setCrossOrigin( this.crossOrigin );

    		var texture = loader.load( urls, onLoad, undefined, onError );

    		if ( mapping ) texture.mapping = mapping;

    		return texture;

    	},

    	loadCompressedTexture: function () {

    		console.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );

    	},

    	loadCompressedTextureCube: function () {

    		console.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );

    	}

    };

    //

    function Projector () {

    	console.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );

    	this.projectVector = function ( vector, camera ) {

    		console.warn( 'THREE.Projector: .projectVector() is now vector.project().' );
    		vector.project( camera );

    	};

    	this.unprojectVector = function ( vector, camera ) {

    		console.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );
    		vector.unproject( camera );

    	};

    	this.pickingRay = function ( vector, camera ) {

    		console.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );

    	};

    }

    //

    function CanvasRenderer () {

    	console.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );

    	this.domElement = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
    	this.clear = function () {};
    	this.render = function () {};
    	this.setClearColor = function () {};
    	this.setSize = function () {};

    }

    Object.defineProperty( exports, 'AudioContext', {
    	get: function () {
    		return exports.getAudioContext();
    	}
    });

    exports.WebGLRenderTargetCube = WebGLRenderTargetCube;
    exports.WebGLRenderTarget = WebGLRenderTarget;
    exports.WebGLRenderer = WebGLRenderer;
    exports.ShaderLib = ShaderLib;
    exports.UniformsLib = UniformsLib;
    exports.ShaderChunk = ShaderChunk;
    exports.FogExp2 = FogExp2;
    exports.Fog = Fog;
    exports.Scene = Scene;
    exports.LensFlare = LensFlare;
    exports.Sprite = Sprite;
    exports.LOD = LOD;
    exports.SkinnedMesh = SkinnedMesh;
    exports.Skeleton = Skeleton;
    exports.Bone = Bone;
    exports.Mesh = Mesh;
    exports.LineSegments = LineSegments;
    exports.Line = Line;
    exports.Points = Points;
    exports.Group = Group;
    exports.VideoTexture = VideoTexture;
    exports.DataTexture = DataTexture;
    exports.CompressedTexture = CompressedTexture;
    exports.CubeTexture = CubeTexture;
    exports.CanvasTexture = CanvasTexture;
    exports.DepthTexture = DepthTexture;
    exports.TextureIdCount = TextureIdCount;
    exports.Texture = Texture;
    exports.MaterialIdCount = MaterialIdCount;
    exports.CompressedTextureLoader = CompressedTextureLoader;
    exports.BinaryTextureLoader = BinaryTextureLoader;
    exports.DataTextureLoader = DataTextureLoader;
    exports.CubeTextureLoader = CubeTextureLoader;
    exports.TextureLoader = TextureLoader;
    exports.ObjectLoader = ObjectLoader;
    exports.MaterialLoader = MaterialLoader;
    exports.BufferGeometryLoader = BufferGeometryLoader;
    exports.LoadingManager = LoadingManager;
    exports.JSONLoader = JSONLoader;
    exports.ImageLoader = ImageLoader;
    exports.FontLoader = FontLoader;
    exports.XHRLoader = XHRLoader;
    exports.Loader = Loader;
    exports.AudioLoader = AudioLoader;
    exports.SpotLightShadow = SpotLightShadow;
    exports.SpotLight = SpotLight;
    exports.PointLight = PointLight;
    exports.HemisphereLight = HemisphereLight;
    exports.DirectionalLightShadow = DirectionalLightShadow;
    exports.DirectionalLight = DirectionalLight;
    exports.AmbientLight = AmbientLight;
    exports.LightShadow = LightShadow;
    exports.Light = Light;
    exports.StereoCamera = StereoCamera;
    exports.PerspectiveCamera = PerspectiveCamera;
    exports.OrthographicCamera = OrthographicCamera;
    exports.CubeCamera = CubeCamera;
    exports.Camera = Camera;
    exports.AudioListener = AudioListener;
    exports.PositionalAudio = PositionalAudio;
    exports.getAudioContext = getAudioContext;
    exports.AudioAnalyser = AudioAnalyser;
    exports.Audio = Audio;
    exports.VectorKeyframeTrack = VectorKeyframeTrack;
    exports.StringKeyframeTrack = StringKeyframeTrack;
    exports.QuaternionKeyframeTrack = QuaternionKeyframeTrack;
    exports.NumberKeyframeTrack = NumberKeyframeTrack;
    exports.ColorKeyframeTrack = ColorKeyframeTrack;
    exports.BooleanKeyframeTrack = BooleanKeyframeTrack;
    exports.PropertyMixer = PropertyMixer;
    exports.PropertyBinding = PropertyBinding;
    exports.KeyframeTrack = KeyframeTrack;
    exports.AnimationObjectGroup = AnimationObjectGroup;
    exports.AnimationMixer = AnimationMixer;
    exports.AnimationClip = AnimationClip;
    exports.Uniform = Uniform;
    exports.InstancedBufferGeometry = InstancedBufferGeometry;
    exports.BufferGeometry = BufferGeometry;
    exports.GeometryIdCount = GeometryIdCount;
    exports.Geometry = Geometry;
    exports.InterleavedBufferAttribute = InterleavedBufferAttribute;
    exports.InstancedInterleavedBuffer = InstancedInterleavedBuffer;
    exports.InterleavedBuffer = InterleavedBuffer;
    exports.InstancedBufferAttribute = InstancedBufferAttribute;
    exports.DynamicBufferAttribute = DynamicBufferAttribute;
    exports.Float64Attribute = Float64Attribute;
    exports.Float32Attribute = Float32Attribute;
    exports.Uint32Attribute = Uint32Attribute;
    exports.Int32Attribute = Int32Attribute;
    exports.Uint16Attribute = Uint16Attribute;
    exports.Int16Attribute = Int16Attribute;
    exports.Uint8ClampedAttribute = Uint8ClampedAttribute;
    exports.Uint8Attribute = Uint8Attribute;
    exports.Int8Attribute = Int8Attribute;
    exports.BufferAttribute = BufferAttribute;
    exports.Face3 = Face3;
    exports.Object3DIdCount = Object3DIdCount;
    exports.Object3D = Object3D;
    exports.Raycaster = Raycaster;
    exports.Layers = Layers;
    exports.EventDispatcher = EventDispatcher;
    exports.Clock = Clock;
    exports.QuaternionLinearInterpolant = QuaternionLinearInterpolant;
    exports.LinearInterpolant = LinearInterpolant;
    exports.DiscreteInterpolant = DiscreteInterpolant;
    exports.CubicInterpolant = CubicInterpolant;
    exports.Interpolant = Interpolant;
    exports.Triangle = Triangle;
    exports.Spline = Spline;
    exports.Spherical = Spherical;
    exports.Plane = Plane;
    exports.Frustum = Frustum;
    exports.Sphere = Sphere;
    exports.Ray = Ray;
    exports.Matrix4 = Matrix4;
    exports.Matrix3 = Matrix3;
    exports.Box3 = Box3;
    exports.Box2 = Box2;
    exports.Line3 = Line3;
    exports.Euler = Euler;
    exports.Vector4 = Vector4;
    exports.Vector3 = Vector3;
    exports.Vector2 = Vector2;
    exports.Quaternion = Quaternion;
    exports.Color = Color;
    exports.MorphBlendMesh = MorphBlendMesh;
    exports.ImmediateRenderObject = ImmediateRenderObject;
    exports.VertexNormalsHelper = VertexNormalsHelper;
    exports.SpotLightHelper = SpotLightHelper;
    exports.SkeletonHelper = SkeletonHelper;
    exports.PointLightHelper = PointLightHelper;
    exports.HemisphereLightHelper = HemisphereLightHelper;
    exports.GridHelper = GridHelper;
    exports.FaceNormalsHelper = FaceNormalsHelper;
    exports.DirectionalLightHelper = DirectionalLightHelper;
    exports.CameraHelper = CameraHelper;
    exports.BoundingBoxHelper = BoundingBoxHelper;
    exports.BoxHelper = BoxHelper;
    exports.ArrowHelper = ArrowHelper;
    exports.AxisHelper = AxisHelper;
    exports.ClosedSplineCurve3 = ClosedSplineCurve3;
    exports.SplineCurve3 = SplineCurve3;
    exports.ArcCurve = ArcCurve;
    exports.EllipseCurve = EllipseCurve;
    exports.SplineCurve = SplineCurve;
    exports.CubicBezierCurve = CubicBezierCurve;
    exports.QuadraticBezierCurve = QuadraticBezierCurve;
    exports.LineCurve = LineCurve;
    exports.Shape = Shape;
    exports.ShapePath = ShapePath;
    exports.Path = Path;
    exports.Font = Font;
    exports.CurvePath = CurvePath;
    exports.Curve = Curve;
    exports.WireframeGeometry = WireframeGeometry;
    exports.ParametricGeometry = ParametricGeometry;
    exports.TetrahedronGeometry = TetrahedronGeometry;
    exports.OctahedronGeometry = OctahedronGeometry;
    exports.IcosahedronGeometry = IcosahedronGeometry;
    exports.DodecahedronGeometry = DodecahedronGeometry;
    exports.PolyhedronGeometry = PolyhedronGeometry;
    exports.TubeGeometry = TubeGeometry;
    exports.TorusKnotGeometry = TorusKnotGeometry;
    exports.TorusKnotBufferGeometry = TorusKnotBufferGeometry;
    exports.TorusGeometry = TorusGeometry;
    exports.TorusBufferGeometry = TorusBufferGeometry;
    exports.TextGeometry = TextGeometry;
    exports.SphereBufferGeometry = SphereBufferGeometry;
    exports.SphereGeometry = SphereGeometry;
    exports.RingGeometry = RingGeometry;
    exports.RingBufferGeometry = RingBufferGeometry;
    exports.PlaneBufferGeometry = PlaneBufferGeometry;
    exports.PlaneGeometry = PlaneGeometry;
    exports.LatheGeometry = LatheGeometry;
    exports.LatheBufferGeometry = LatheBufferGeometry;
    exports.ShapeGeometry = ShapeGeometry;
    exports.ExtrudeGeometry = ExtrudeGeometry;
    exports.EdgesGeometry = EdgesGeometry;
    exports.ConeGeometry = ConeGeometry;
    exports.ConeBufferGeometry = ConeBufferGeometry;
    exports.CylinderGeometry = CylinderGeometry;
    exports.CylinderBufferGeometry = CylinderBufferGeometry;
    exports.CircleBufferGeometry = CircleBufferGeometry;
    exports.CircleGeometry = CircleGeometry;
    exports.BoxBufferGeometry = BoxBufferGeometry;
    exports.BoxGeometry = BoxGeometry;
    exports.ShadowMaterial = ShadowMaterial;
    exports.SpriteMaterial = SpriteMaterial;
    exports.RawShaderMaterial = RawShaderMaterial;
    exports.ShaderMaterial = ShaderMaterial;
    exports.PointsMaterial = PointsMaterial;
    exports.MultiMaterial = MultiMaterial;
    exports.MeshPhysicalMaterial = MeshPhysicalMaterial;
    exports.MeshStandardMaterial = MeshStandardMaterial;
    exports.MeshPhongMaterial = MeshPhongMaterial;
    exports.MeshNormalMaterial = MeshNormalMaterial;
    exports.MeshLambertMaterial = MeshLambertMaterial;
    exports.MeshDepthMaterial = MeshDepthMaterial;
    exports.MeshBasicMaterial = MeshBasicMaterial;
    exports.LineDashedMaterial = LineDashedMaterial;
    exports.LineBasicMaterial = LineBasicMaterial;
    exports.Material = Material;
    exports.REVISION = REVISION;
    exports.MOUSE = MOUSE;
    exports.CullFaceNone = CullFaceNone;
    exports.CullFaceBack = CullFaceBack;
    exports.CullFaceFront = CullFaceFront;
    exports.CullFaceFrontBack = CullFaceFrontBack;
    exports.FrontFaceDirectionCW = FrontFaceDirectionCW;
    exports.FrontFaceDirectionCCW = FrontFaceDirectionCCW;
    exports.BasicShadowMap = BasicShadowMap;
    exports.PCFShadowMap = PCFShadowMap;
    exports.PCFSoftShadowMap = PCFSoftShadowMap;
    exports.FrontSide = FrontSide;
    exports.BackSide = BackSide;
    exports.DoubleSide = DoubleSide;
    exports.FlatShading = FlatShading;
    exports.SmoothShading = SmoothShading;
    exports.NoColors = NoColors;
    exports.FaceColors = FaceColors;
    exports.VertexColors = VertexColors;
    exports.NoBlending = NoBlending;
    exports.NormalBlending = NormalBlending;
    exports.AdditiveBlending = AdditiveBlending;
    exports.SubtractiveBlending = SubtractiveBlending;
    exports.MultiplyBlending = MultiplyBlending;
    exports.CustomBlending = CustomBlending;
    exports.BlendingMode = BlendingMode;
    exports.AddEquation = AddEquation;
    exports.SubtractEquation = SubtractEquation;
    exports.ReverseSubtractEquation = ReverseSubtractEquation;
    exports.MinEquation = MinEquation;
    exports.MaxEquation = MaxEquation;
    exports.ZeroFactor = ZeroFactor;
    exports.OneFactor = OneFactor;
    exports.SrcColorFactor = SrcColorFactor;
    exports.OneMinusSrcColorFactor = OneMinusSrcColorFactor;
    exports.SrcAlphaFactor = SrcAlphaFactor;
    exports.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor;
    exports.DstAlphaFactor = DstAlphaFactor;
    exports.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor;
    exports.DstColorFactor = DstColorFactor;
    exports.OneMinusDstColorFactor = OneMinusDstColorFactor;
    exports.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor;
    exports.NeverDepth = NeverDepth;
    exports.AlwaysDepth = AlwaysDepth;
    exports.LessDepth = LessDepth;
    exports.LessEqualDepth = LessEqualDepth;
    exports.EqualDepth = EqualDepth;
    exports.GreaterEqualDepth = GreaterEqualDepth;
    exports.GreaterDepth = GreaterDepth;
    exports.NotEqualDepth = NotEqualDepth;
    exports.MultiplyOperation = MultiplyOperation;
    exports.MixOperation = MixOperation;
    exports.AddOperation = AddOperation;
    exports.NoToneMapping = NoToneMapping;
    exports.LinearToneMapping = LinearToneMapping;
    exports.ReinhardToneMapping = ReinhardToneMapping;
    exports.Uncharted2ToneMapping = Uncharted2ToneMapping;
    exports.CineonToneMapping = CineonToneMapping;
    exports.UVMapping = UVMapping;
    exports.CubeReflectionMapping = CubeReflectionMapping;
    exports.CubeRefractionMapping = CubeRefractionMapping;
    exports.EquirectangularReflectionMapping = EquirectangularReflectionMapping;
    exports.EquirectangularRefractionMapping = EquirectangularRefractionMapping;
    exports.SphericalReflectionMapping = SphericalReflectionMapping;
    exports.CubeUVReflectionMapping = CubeUVReflectionMapping;
    exports.CubeUVRefractionMapping = CubeUVRefractionMapping;
    exports.TextureMapping = TextureMapping;
    exports.RepeatWrapping = RepeatWrapping;
    exports.ClampToEdgeWrapping = ClampToEdgeWrapping;
    exports.MirroredRepeatWrapping = MirroredRepeatWrapping;
    exports.TextureWrapping = TextureWrapping;
    exports.NearestFilter = NearestFilter;
    exports.NearestMipMapNearestFilter = NearestMipMapNearestFilter;
    exports.NearestMipMapLinearFilter = NearestMipMapLinearFilter;
    exports.LinearFilter = LinearFilter;
    exports.LinearMipMapNearestFilter = LinearMipMapNearestFilter;
    exports.LinearMipMapLinearFilter = LinearMipMapLinearFilter;
    exports.TextureFilter = TextureFilter;
    exports.UnsignedByteType = UnsignedByteType;
    exports.ByteType = ByteType;
    exports.ShortType = ShortType;
    exports.UnsignedShortType = UnsignedShortType;
    exports.IntType = IntType;
    exports.UnsignedIntType = UnsignedIntType;
    exports.FloatType = FloatType;
    exports.HalfFloatType = HalfFloatType;
    exports.UnsignedShort4444Type = UnsignedShort4444Type;
    exports.UnsignedShort5551Type = UnsignedShort5551Type;
    exports.UnsignedShort565Type = UnsignedShort565Type;
    exports.UnsignedInt248Type = UnsignedInt248Type;
    exports.AlphaFormat = AlphaFormat;
    exports.RGBFormat = RGBFormat;
    exports.RGBAFormat = RGBAFormat;
    exports.LuminanceFormat = LuminanceFormat;
    exports.LuminanceAlphaFormat = LuminanceAlphaFormat;
    exports.RGBEFormat = RGBEFormat;
    exports.DepthFormat = DepthFormat;
    exports.DepthStencilFormat = DepthStencilFormat;
    exports.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format;
    exports.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format;
    exports.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format;
    exports.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format;
    exports.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format;
    exports.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format;
    exports.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format;
    exports.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format;
    exports.RGB_ETC1_Format = RGB_ETC1_Format;
    exports.LoopOnce = LoopOnce;
    exports.LoopRepeat = LoopRepeat;
    exports.LoopPingPong = LoopPingPong;
    exports.InterpolateDiscrete = InterpolateDiscrete;
    exports.InterpolateLinear = InterpolateLinear;
    exports.InterpolateSmooth = InterpolateSmooth;
    exports.ZeroCurvatureEnding = ZeroCurvatureEnding;
    exports.ZeroSlopeEnding = ZeroSlopeEnding;
    exports.WrapAroundEnding = WrapAroundEnding;
    exports.TrianglesDrawMode = TrianglesDrawMode;
    exports.TriangleStripDrawMode = TriangleStripDrawMode;
    exports.TriangleFanDrawMode = TriangleFanDrawMode;
    exports.LinearEncoding = LinearEncoding;
    exports.sRGBEncoding = sRGBEncoding;
    exports.GammaEncoding = GammaEncoding;
    exports.RGBEEncoding = RGBEEncoding;
    exports.LogLuvEncoding = LogLuvEncoding;
    exports.RGBM7Encoding = RGBM7Encoding;
    exports.RGBM16Encoding = RGBM16Encoding;
    exports.RGBDEncoding = RGBDEncoding;
    exports.BasicDepthPacking = BasicDepthPacking;
    exports.RGBADepthPacking = RGBADepthPacking;
    exports.CubeGeometry = BoxGeometry;
    exports.Face4 = Face4;
    exports.LineStrip = LineStrip;
    exports.LinePieces = LinePieces;
    exports.MeshFaceMaterial = MultiMaterial;
    exports.PointCloud = PointCloud;
    exports.Particle = Sprite;
    exports.ParticleSystem = ParticleSystem;
    exports.PointCloudMaterial = PointCloudMaterial;
    exports.ParticleBasicMaterial = ParticleBasicMaterial;
    exports.ParticleSystemMaterial = ParticleSystemMaterial;
    exports.Vertex = Vertex;
    exports.EdgesHelper = EdgesHelper;
    exports.WireframeHelper = WireframeHelper;
    exports.GeometryUtils = GeometryUtils;
    exports.ImageUtils = ImageUtils;
    exports.Projector = Projector;
    exports.CanvasRenderer = CanvasRenderer;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
},{}],3:[function(require,module,exports){
'use strict';

/**
 * @author James Baicoianu / http://www.baicoianu.com/
 */
module.exports = function (THREE) {
	THREE.FlyControls = function (object, domElement) {

		this.object = object;

		this.domElement = domElement !== undefined ? domElement : document;
		if (domElement) this.domElement.setAttribute('tabindex', -1);

		// API

		this.movementSpeed = 1.0;
		this.rollSpeed = 0.005;

		this.dragToLook = false;
		this.autoForward = false;

		// disable default target object behavior

		// internals

		this.tmpQuaternion = new THREE.Quaternion();

		this.mouseStatus = 0;

		this.moveState = { up: 0, down: 0, left: 0, right: 0, forward: 0, back: 0, pitchUp: 0, pitchDown: 0, yawLeft: 0, yawRight: 0, rollLeft: 0, rollRight: 0 };
		this.moveVector = new THREE.Vector3(0, 0, 0);
		this.rotationVector = new THREE.Vector3(0, 0, 0);

		this.handleEvent = function (event) {

			if (typeof this[event.type] == 'function') {

				this[event.type](event);
			}
		};

		this.keydown = function (event) {

			if (event.altKey) {

				return;
			}

			//event.preventDefault();

			switch (event.keyCode) {

				case 16:
					/* shift */this.movementSpeedMultiplier = .1;break;

				case 87:
					/*W*/this.moveState.forward = 1;break;
				case 83:
					/*S*/this.moveState.back = 1;break;

				case 65:
					/*A*/this.moveState.left = 1;break;
				case 68:
					/*D*/this.moveState.right = 1;break;

				case 82:
					/*R*/this.moveState.up = 1;break;
				case 70:
					/*F*/this.moveState.down = 1;break;

				case 38:
					/*up*/this.moveState.pitchUp = 1;break;
				case 40:
					/*down*/this.moveState.pitchDown = 1;break;

				case 37:
					/*left*/this.moveState.yawLeft = 1;break;
				case 39:
					/*right*/this.moveState.yawRight = 1;break;

				case 81:
					/*Q*/this.moveState.rollLeft = 1;break;
				case 69:
					/*E*/this.moveState.rollRight = 1;break;

			}

			this.updateMovementVector();
			this.updateRotationVector();
		};

		this.keyup = function (event) {

			switch (event.keyCode) {

				case 16:
					/* shift */this.movementSpeedMultiplier = 1;break;

				case 87:
					/*W*/this.moveState.forward = 0;break;
				case 83:
					/*S*/this.moveState.back = 0;break;

				case 65:
					/*A*/this.moveState.left = 0;break;
				case 68:
					/*D*/this.moveState.right = 0;break;

				case 82:
					/*R*/this.moveState.up = 0;break;
				case 70:
					/*F*/this.moveState.down = 0;break;

				case 38:
					/*up*/this.moveState.pitchUp = 0;break;
				case 40:
					/*down*/this.moveState.pitchDown = 0;break;

				case 37:
					/*left*/this.moveState.yawLeft = 0;break;
				case 39:
					/*right*/this.moveState.yawRight = 0;break;

				case 81:
					/*Q*/this.moveState.rollLeft = 0;break;
				case 69:
					/*E*/this.moveState.rollRight = 0;break;

			}

			this.updateMovementVector();
			this.updateRotationVector();
		};

		this.mousedown = function (event) {

			if (this.domElement !== document) {

				this.domElement.focus();
			}

			event.preventDefault();
			event.stopPropagation();

			if (this.dragToLook) {

				this.mouseStatus++;
			} else {

				switch (event.button) {

					case 0:
						this.moveState.forward = 1;break;
					case 2:
						this.moveState.back = 1;break;

				}

				this.updateMovementVector();
			}
		};

		this.mousemove = function (event) {

			if (!this.dragToLook || this.mouseStatus > 0) {

				var container = this.getContainerDimensions();
				var halfWidth = container.size[0] / 2;
				var halfHeight = container.size[1] / 2;

				this.moveState.yawLeft = -(event.pageX - container.offset[0] - halfWidth) / halfWidth;
				this.moveState.pitchDown = (event.pageY - container.offset[1] - halfHeight) / halfHeight;

				this.updateRotationVector();
			}
		};

		this.mouseup = function (event) {

			event.preventDefault();
			event.stopPropagation();

			if (this.dragToLook) {

				this.mouseStatus--;

				this.moveState.yawLeft = this.moveState.pitchDown = 0;
			} else {

				switch (event.button) {

					case 0:
						this.moveState.forward = 0;break;
					case 2:
						this.moveState.back = 0;break;

				}

				this.updateMovementVector();
			}

			this.updateRotationVector();
		};

		this.update = function (delta) {

			var moveMult = delta * this.movementSpeed;
			var rotMult = delta * this.rollSpeed;

			this.object.translateX(this.moveVector.x * moveMult);
			this.object.translateY(this.moveVector.y * moveMult);
			this.object.translateZ(this.moveVector.z * moveMult);

			this.tmpQuaternion.set(this.rotationVector.x * rotMult, this.rotationVector.y * rotMult, this.rotationVector.z * rotMult, 1).normalize();
			this.object.quaternion.multiply(this.tmpQuaternion);

			// expose the rotation vector for convenience
			this.object.rotation.setFromQuaternion(this.object.quaternion, this.object.rotation.order);
		};

		this.updateMovementVector = function () {

			var forward = this.moveState.forward || this.autoForward && !this.moveState.back ? 1 : 0;

			this.moveVector.x = -this.moveState.left + this.moveState.right;
			this.moveVector.y = -this.moveState.down + this.moveState.up;
			this.moveVector.z = -forward + this.moveState.back;

			//console.log( 'move:', [ this.moveVector.x, this.moveVector.y, this.moveVector.z ] );
		};

		this.updateRotationVector = function () {

			this.rotationVector.x = -this.moveState.pitchDown + this.moveState.pitchUp;
			this.rotationVector.y = -this.moveState.yawRight + this.moveState.yawLeft;
			this.rotationVector.z = -this.moveState.rollRight + this.moveState.rollLeft;

			//console.log( 'rotate:', [ this.rotationVector.x, this.rotationVector.y, this.rotationVector.z ] );
		};

		this.getContainerDimensions = function () {

			if (this.domElement != document) {

				return {
					size: [this.domElement.offsetWidth, this.domElement.offsetHeight],
					offset: [this.domElement.offsetLeft, this.domElement.offsetTop]
				};
			} else {

				return {
					size: [window.innerWidth, window.innerHeight],
					offset: [0, 0]
				};
			}
		};

		function bind(scope, fn) {

			return function () {

				fn.apply(scope, arguments);
			};
		}

		function contextmenu(event) {

			event.preventDefault();
		}

		this.dispose = function () {

			this.domElement.removeEventListener('contextmenu', contextmenu, false);
			this.domElement.removeEventListener('mousedown', _mousedown, false);
			this.domElement.removeEventListener('mousemove', _mousemove, false);
			this.domElement.removeEventListener('mouseup', _mouseup, false);

			window.removeEventListener('keydown', _keydown, false);
			window.removeEventListener('keyup', _keyup, false);
		};

		var _mousemove = bind(this, this.mousemove);
		var _mousedown = bind(this, this.mousedown);
		var _mouseup = bind(this, this.mouseup);
		var _keydown = bind(this, this.keydown);
		var _keyup = bind(this, this.keyup);

		this.domElement.addEventListener('contextmenu', contextmenu, false);

		this.domElement.addEventListener('mousemove', _mousemove, false);
		this.domElement.addEventListener('mousedown', _mousedown, false);
		this.domElement.addEventListener('mouseup', _mouseup, false);

		window.addEventListener('keydown', _keydown, false);
		window.addEventListener('keyup', _keyup, false);

		this.updateMovementVector();
		this.updateRotationVector();
	};
};

},{}],4:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _three = require('three');

var THREE = _interopRequireWildcard(_three);

var _colors = require('./colors');

var _colors2 = _interopRequireDefault(_colors);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var AirPlane = function AirPlane(color) {
  _classCallCheck(this, AirPlane);

  this.mesh = new THREE.Object3D();

  // Create the cabin
  var geomCockpitTail = new THREE.BoxGeometry(130, 40, 40, 1, 1, 1);
  var matCockpitTail = new THREE.MeshPhongMaterial({ color: color, flatShading: THREE.FlatShading });

  // we can access a specific vertex of a shape through
  // the vertices array, and then move its x, y and z property:
  geomCockpitTail.vertices[4].y -= 10;
  geomCockpitTail.vertices[4].z += 20;
  geomCockpitTail.vertices[5].y -= 10;
  geomCockpitTail.vertices[5].z -= 20;
  geomCockpitTail.vertices[6].y += 30;
  geomCockpitTail.vertices[6].z += 20;
  geomCockpitTail.vertices[7].y += 30;
  geomCockpitTail.vertices[7].z -= 20;

  var cockpitTail = new THREE.Mesh(geomCockpitTail, matCockpitTail);
  cockpitTail.castShadow = true;
  cockpitTail.receiveShadow = true;
  cockpitTail.position.set(-75, 0, 0);
  this.mesh.add(cockpitTail);

  var geomCockpit = new THREE.BoxGeometry(40, 40, 40, 1, 1, 1);
  var matCockpit = new THREE.MeshPhongMaterial({ color: color, flatShading: THREE.FlatShading });
  var cockpit = new THREE.Mesh(geomCockpit, matCockpit);
  cockpit.castShadow = true;
  cockpit.receiveShadow = true;
  cockpit.position.set(10, 0, 0);
  this.mesh.add(cockpit);

  // Create the engine
  var geomEngine = new THREE.BoxGeometry(20, 40, 40, 1, 1, 1);
  var matEngine = new THREE.MeshPhongMaterial({ color: _colors2.default.white, flatShading: THREE.FlatShading });
  var engine = new THREE.Mesh(geomEngine, matEngine);
  engine.position.x = 40;
  engine.castShadow = true;
  engine.receiveShadow = true;
  this.mesh.add(engine);

  // Create top wing
  // var geomTopWing = new THREE.BoxGeometry(40, 2, 200, 1, 1, 1)
  // var matTopWing = new THREE.MeshPhongMaterial({color: color, shading: THREE.FlatShading})
  // var topWing = new THREE.Mesh(geomTopWing, matTopWing)
  // topWing.castShadow = true
  // topWing.receiveShadow = true
  // topWing.position.set(20, 50, 0)
  // this.mesh.add(topWing)

  // Create bottom wing
  var geomBottomWing = new THREE.BoxGeometry(40, 2, 200, 1, 1, 1);
  var matBottomWing = new THREE.MeshPhongMaterial({ color: color, flatShading: THREE.FlatShading });
  var bottomWing = new THREE.Mesh(geomBottomWing, matBottomWing);
  bottomWing.castShadow = true;
  bottomWing.receiveShadow = true;
  bottomWing.position.set(10, -10, 0);
  this.mesh.add(bottomWing);

  // Wing support
  // var geomWingSupport = new THREE.BoxGeometry(2, 60, 2, 1, 1, 1)
  // var matWingSupport = new THREE.MeshPhongMaterial({color: color, shading: THREE.FlatShading})
  // var wingSupportLeft = new THREE.Mesh(geomWingSupport, matWingSupport)
  // wingSupportLeft.castShadow = true
  // wingSupportLeft.receiveShadow = true
  // wingSupportLeft.position.set(15, 20, -80)
  // this.mesh.add(wingSupportLeft)
  // var wingSupportRight = new THREE.Mesh(geomWingSupport, matWingSupport)
  // wingSupportRight.castShadow = true
  // wingSupportRight.receiveShadow = true
  // wingSupportRight.position.set(15, 20, 80)
  // this.mesh.add(wingSupportRight)

  // Create the tail
  var geomTailPlane = new THREE.BoxGeometry(30, 25, 2, 1, 1, 1);
  var matTailPlane = new THREE.MeshPhongMaterial({ color: color, flatShading: THREE.FlatShading });
  var tailPlane = new THREE.Mesh(geomTailPlane, matTailPlane);
  tailPlane.position.set(-115, 20, 0);
  tailPlane.castShadow = true;
  tailPlane.receiveShadow = true;
  this.mesh.add(tailPlane);

  // Create the tail wing
  var geomTailWing = new THREE.BoxGeometry(20, 2, 60, 1, 1, 1);
  var matTailWing = new THREE.MeshPhongMaterial({ color: color, flatShading: THREE.FlatShading });
  var tailWing = new THREE.Mesh(geomTailWing, matTailWing);
  tailWing.castShadow = true;
  tailWing.receiveShadow = true;
  tailWing.position.set(-110, 11, 0);
  this.mesh.add(tailWing);

  // propeller
  var geomPropeller = new THREE.BoxGeometry(20, 10, 10, 1, 1, 1);
  geomPropeller.vertices[4].y -= 5;
  geomPropeller.vertices[4].z += 5;
  geomPropeller.vertices[5].y -= 5;
  geomPropeller.vertices[5].z -= 5;
  geomPropeller.vertices[6].y += 5;
  geomPropeller.vertices[6].z += 5;
  geomPropeller.vertices[7].y += 5;
  geomPropeller.vertices[7].z -= 5;
  var matPropeller = new THREE.MeshPhongMaterial({ color: _colors2.default.brown, flatShading: THREE.FlatShading });
  this.propeller = new THREE.Mesh(geomPropeller, matPropeller);

  this.propeller.castShadow = true;
  this.propeller.receiveShadow = true;

  var geomBlade = new THREE.BoxGeometry(1, 80, 10, 1, 1, 1);
  var matBlade = new THREE.MeshPhongMaterial({ color: _colors2.default.brownDark, flatShading: THREE.FlatShading });
  var blade1 = new THREE.Mesh(geomBlade, matBlade);
  blade1.position.set(8, 0, 0);

  blade1.castShadow = true;
  blade1.receiveShadow = true;

  var blade2 = blade1.clone();
  blade2.rotation.x = Math.PI / 2;

  blade2.castShadow = true;
  blade2.receiveShadow = true;

  this.propeller.add(blade1);
  this.propeller.add(blade2);
  this.propeller.position.set(50, 0, 0);
  this.mesh.add(this.propeller);

  // rotate the geometry on the Y axis away from the camera
  //this.mesh.applyMatrix(new THREE.Matrix4().makeRotationY(Math.PI / 2))

  // change rotation order to avoid gimbal lock
  // this.mesh.rotation.order = 'ZXY'
};

exports.default = AirPlane;

},{"./colors":5,"three":2}],5:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var randomColor = '0x' + (0x1000000 + Math.random() * 0xffffff).toString(16).substr(1, 6);

var Colors = {
  airplane: randomColor,
  white: 0xe8e0e1,
  brown: 0x59332e,
  brownDark: 0x23190f,
  water: 0x006457
};

exports.default = Colors;

},{}],6:[function(require,module,exports){
'use strict';

var _scene = require('./scene');

var _scene2 = _interopRequireDefault(_scene);

var _airplane = require('./airplane');

var _airplane2 = _interopRequireDefault(_airplane);

var _colors = require('./colors');

var _colors2 = _interopRequireDefault(_colors);

var _three = require('three');

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var randomColor = function randomColor() {
  return '#' + (0x1000000 + Math.random() * 0xffffff).toString(16).substr(1, 6);
};

//A socket.io instance
var socket = io();

//One WebGL context to rule them all !
var glScene = new _scene2.default();
var id = void 0;
var instances = [];
var clients = new Object();

glScene.on('userMoved', function () {
  var newPosition = [glScene.camera.position.x, glScene.camera.position.y, glScene.camera.position.z];
  var newRotation = [glScene.camera.rotation.x, glScene.camera.rotation.y, glScene.camera.rotation.z];
  console.log(newRotation);
  socket.emit('move', newPosition, newRotation);
});

//On connection server sends the client his ID
socket.on('introduction', function (_id, _clientNum, _ids) {
  // Create airplanes for other connected clients
  for (var i = 0; i < _ids.length; i++) {
    // if(_ids[i] != _id) {
    // const planeStartY = 200
    // const planeStartZ = 0
    var airplane = new _airplane2.default(randomColor());
    airplane.mesh.scale.set(0.01, 0.01, 0.01);

    airplane.mesh.rotation.y = 1.5;

    clients[_ids[i]] = {
      airplane: airplane.mesh

      //Add initial users to the scene
    };glScene.scene.add(clients[_ids[i]].airplane);
    console.log('ap X: ' + airplane.mesh.rotation.x + ' ap Y: ' + airplane.mesh.rotation.y + ' ap Z: ' + airplane.mesh.rotation.z);
    // }
  }

  console.log(clients);

  id = _id;
  console.log('My ID is: ' + id);
  //airplane.propeller.rotation.x += 0.3;
});

socket.on('newUserConnected', function (clientCount, _id, _ids) {
  console.log(clientCount + ' clients connected');
  var alreadyHasUser = false;
  for (var i = 0; i < Object.keys(clients).length; i++) {
    if (Object.keys(clients)[i] == _id) {
      alreadyHasUser = true;
      break;
    }
  }
  if (_id != id && !alreadyHasUser) {
    console.log('A new user connected with the id: ' + _id);
    // const planeStartY = 200
    // const planeStartZ = 0
    var airplane = new _airplane2.default(randomColor());
    airplane.mesh.scale.set(0.01, 0.01, 0.01);
    // airplane.mesh.position.y = 2000 + planeStartY
    clients[_id] = {
      airplane: airplane.mesh

      //Add initial users to the scene
    };glScene.scene.add(clients[_id].airplane);
    console.log('ap X: ' + airplane.mesh.rotation.x + ' ap Y: ' + airplane.mesh.rotation.y + ' ap Z: ' + airplane.mesh.rotation.z);
  }
  //airplane.propeller.rotation.x += 0.3
});

socket.on('userDisconnected', function (clientCount, _id, _ids) {
  //Update the data from the server
  // document.getElementById('numUsers').textContent = clientCount;

  if (_id != id) {
    console.log('A user disconnected with the id: ' + _id);
    glScene.scene.remove(clients[_id].airplane);
    delete clients[_id];
  }
});

socket.on('connect', function () {});

//Update when one of the users moves in space
// props sent contain position and rotation of the other users' camera
socket.on('userPositions', function (_clientProps) {
  for (var i = 0; i < Object.keys(_clientProps).length; i++) {
    if (Object.keys(_clientProps)[i] != id) {

      var currentProps = Object.keys(_clientProps)[i];

      //Store the values
      var oldPos = clients[currentProps].airplane.position;
      var oldRot = clients[currentProps].airplane.rotation;
      var newPos = _clientProps[currentProps].position;
      var newRot = _clientProps[currentProps].rotation;

      //Create a vector 3 and lerp the new values with the old values
      var lerpedPos = new THREE.Vector3();
      lerpedPos.x = THREE.Math.lerp(oldPos.x, newPos[0], 0.3);
      lerpedPos.y = THREE.Math.lerp(oldPos.y, newPos[1], 0.3);
      lerpedPos.z = THREE.Math.lerp(oldPos.z, newPos[2], 0.3);

      var lerpedRot = new THREE.Vector3();
      lerpedRot.x = THREE.Math.lerp(oldRot.x, newRot[0], 0.3);
      lerpedRot.y = THREE.Math.lerp(oldRot.y, newRot[1], 0.3);
      lerpedRot.z = THREE.Math.lerp(oldRot.z, newRot[2], 0.3);

      //Set the position and rotation
      clients[currentProps].airplane.position.set(lerpedPos.x, lerpedPos.y, lerpedPos.z);
      clients[currentProps].airplane.rotation.set(lerpedRot.x, lerpedRot.y, lerpedRot.z);
    }
  }
});

},{"./airplane":4,"./colors":5,"./scene":7,"three":2}],7:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _three = require('three');

var THREE = _interopRequireWildcard(_three);

var _FlyControls = require('./FlyControls');

var _FlyControls2 = _interopRequireDefault(_FlyControls);

var _eventEmitterEs = require('event-emitter-es6');

var _eventEmitterEs2 = _interopRequireDefault(_eventEmitterEs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } //Three.js

//import Airplane from './airplane';
// import ProceduralCity from './proceduralcity';
//import FirstPersonControls from './fpscontrols';


//FirstPersonControls(THREE);
(0, _FlyControls2.default)(THREE);
// ProceduralCity(THREE);

// Event emitter implementation for ES6

var Scene = function (_EventEmitter) {
  _inherits(Scene, _EventEmitter);

  function Scene() {
    var domElement = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document.getElementById('gl_context');

    var _width = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window.innerWidth;

    var _height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : window.innerHeight;

    var hasControls = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
    var clearColor = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'black';

    _classCallCheck(this, Scene);

    //THREE scene
    var _this = _possibleConstructorReturn(this, (Scene.__proto__ || Object.getPrototypeOf(Scene)).call(this));

    //Since we extend EventEmitter we need to instance it from here


    _this.scene = new THREE.Scene();

    //Utility
    _this.width = _width;
    _this.height = _height;

    //THREE Camera
    _this.camera = new THREE.PerspectiveCamera(50, _this.width / _this.height, 0.1, 1000);

    //THREE WebGL renderer
    _this.renderer = new THREE.WebGLRenderer({
      antialiasing: true
    });

    _this.renderer.setClearColor(new THREE.Color(clearColor));

    _this.renderer.setSize(_this.width, _this.height);

    //Push the canvas to the DOM
    domElement.append(_this.renderer.domElement);

    if (hasControls) {
      // this.controls = new THREE.FirstPersonControls(this.camera, this.renderer.domElement);
      _this.controls = new THREE.FlyControls(_this.camera, _this.renderer.domElement);
      //this.controls.lookSpeed = 0.15;
      _this.controls.dragToLook = true;
      _this.controls.movementSpeed = 5;
      _this.controls.rollSpeed = 0.5;
      _this.autoForward = false;
    }

    //Setup event listeners for events and handle the states
    window.addEventListener('resize', function (e) {
      return _this.onWindowResize(e);
    }, false);
    domElement.addEventListener('mouseenter', function (e) {
      return _this.onEnterCanvas(e);
    }, false);
    domElement.addEventListener('mouseleave', function (e) {
      return _this.onLeaveCanvas(e);
    }, false);
    window.addEventListener('keydown', function (e) {
      return _this.onKeyDown(e);
    }, false);

    _this.helperGrid = new THREE.GridHelper(50, 50);
    _this.helperGrid.position.y = -0.5;
    _this.scene.add(_this.helperGrid);
    _this.clock = new THREE.Clock();

    // var light = new THREE.AmbientLight( 0xFFFFFF ); // soft white light
    // this.scene.add( light );
    // const spotlight = new THREE.SpotLight( 0xFFFFFF );
    // spotlight.position.set( -10, 60, 10 );
    // this.scene.add(spotlight);
    // LIGHTS
    _this.scene.background = new THREE.Color().setHSL(0.6, 0, 1);
    _this.scene.fog = new THREE.Fog(_this.scene.background, 1, 5000);

    var hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 0.6);
    hemiLight.color.setHSL(0.6, 1, 0.6);
    hemiLight.groundColor.setHSL(0.095, 1, 0.75);
    hemiLight.position.set(0, 50, 0);
    _this.scene.add(hemiLight);
    var hemiLightHelper = new THREE.HemisphereLightHelper(hemiLight, 10);
    _this.scene.add(hemiLightHelper);
    //
    var dirLight = new THREE.DirectionalLight(0xffffff, 1);
    dirLight.color.setHSL(0.1, 1, 0.95);
    dirLight.position.set(-1, 1.75, 1);
    dirLight.position.multiplyScalar(30);
    _this.scene.add(dirLight);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.width = 2048;
    dirLight.shadow.mapSize.height = 2048;
    var d = 50;
    dirLight.shadow.camera.left = -d;
    dirLight.shadow.camera.right = d;
    dirLight.shadow.camera.top = d;
    dirLight.shadow.camera.bottom = -d;
    dirLight.shadow.camera.far = 3500;
    dirLight.shadow.bias = -0.0001;
    var dirLightHeper = new THREE.DirectionalLightHelper(dirLight, 10);
    _this.scene.add(dirLightHeper);
    // GROUND
    var groundGeo = new THREE.PlaneBufferGeometry(10000, 10000);
    var groundMat = new THREE.MeshPhongMaterial({ color: 0xffffff, specular: 0x050505 });
    groundMat.color.setHSL(0.095, 1, 0.75);
    var ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = -33;
    _this.scene.add(ground);
    ground.receiveShadow = true;
    // SKYDOME
    var vertexShader = document.getElementById('vertexShader').textContent;
    var fragmentShader = document.getElementById('fragmentShader').textContent;
    var uniforms = {
      topColor: { value: new THREE.Color(0x0077ff) },
      bottomColor: { value: new THREE.Color(0xffffff) },
      offset: { value: 33 },
      exponent: { value: 0.6 }
    };
    uniforms.topColor.value.copy(hemiLight.color);
    _this.scene.fog.color.copy(uniforms.bottomColor.value);
    var skyGeo = new THREE.SphereGeometry(4000, 32, 15);
    var skyMat = new THREE.ShaderMaterial({ vertexShader: vertexShader, fragmentShader: fragmentShader, uniforms: uniforms, side: THREE.BackSide });
    var sky = new THREE.Mesh(skyGeo, skyMat);
    _this.scene.add(sky);

    // var city  = ProceduralCity();
    // this.scene.add(city);

    _this.update();

    return _this;
  }

  _createClass(Scene, [{
    key: 'drawUsers',
    value: function drawUsers(positions, id) {
      for (var i = 0; i < Object.keys(positions).length; i++) {
        if (Object.keys(positions)[i] != id) {
          this.users[i].position.set(positions[Object.keys(positions)[i]].position[0], positions[Object.keys(positions)[i]].position[1], positions[Object.keys(positions)[i]].position[2]);
        }
      }
    }
  }, {
    key: 'update',
    value: function update() {
      var _this2 = this;

      requestAnimationFrame(function () {
        return _this2.update();
      });

      this.controls.update(this.clock.getDelta());
      this.controls.target = new THREE.Vector3(0, 0, 0);
      this.render();
    }
  }, {
    key: 'render',
    value: function render() {
      this.renderer.render(this.scene, this.camera);
    }
  }, {
    key: 'onWindowResize',
    value: function onWindowResize(e) {
      this.width = window.innerWidth;
      this.height = Math.floor(window.innerHeight - window.innerHeight * 0.3);
      this.camera.aspect = this.width / this.height;
      this.camera.updateProjectionMatrix();
      this.renderer.setSize(this.width, this.height);
    }
  }, {
    key: 'onLeaveCanvas',
    value: function onLeaveCanvas(e) {
      this.controls.enabled = false;
    }
  }, {
    key: 'onEnterCanvas',
    value: function onEnterCanvas(e) {
      this.controls.enabled = true;
    }
  }, {
    key: 'onKeyDown',
    value: function onKeyDown(e) {
      this.emit('userMoved');
    }
  }]);

  return Scene;
}(_eventEmitterEs2.default);

exports.default = Scene;

},{"./FlyControls":3,"event-emitter-es6":1,"three":2}]},{},[6])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvZXZlbnQtZW1pdHRlci1lczYvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdGhyZWUvYnVpbGQvdGhyZWUuanMiLCJzcmMvRmx5Q29udHJvbHMuanMiLCJzcmMvYWlycGxhbmUuanMiLCJzcmMvY29sb3JzLmpzIiwic3JjL2luZGV4LmpzIiwic3JjL3NjZW5lLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDelBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMvenhDQTs7O0FBR0EsT0FBTyxPQUFQLEdBQWlCLFVBQUMsS0FBRCxFQUFVO0FBQzFCLE9BQU0sV0FBTixHQUFvQixVQUFXLE1BQVgsRUFBbUIsVUFBbkIsRUFBZ0M7O0FBRW5ELE9BQUssTUFBTCxHQUFjLE1BQWQ7O0FBRUEsT0FBSyxVQUFMLEdBQW9CLGVBQWUsU0FBakIsR0FBK0IsVUFBL0IsR0FBNEMsUUFBOUQ7QUFDQSxNQUFLLFVBQUwsRUFBa0IsS0FBSyxVQUFMLENBQWdCLFlBQWhCLENBQThCLFVBQTlCLEVBQTBDLENBQUUsQ0FBNUM7O0FBRWxCOztBQUVBLE9BQUssYUFBTCxHQUFxQixHQUFyQjtBQUNBLE9BQUssU0FBTCxHQUFpQixLQUFqQjs7QUFFQSxPQUFLLFVBQUwsR0FBa0IsS0FBbEI7QUFDQSxPQUFLLFdBQUwsR0FBbUIsS0FBbkI7O0FBRUE7O0FBRUE7O0FBRUEsT0FBSyxhQUFMLEdBQXFCLElBQUksTUFBTSxVQUFWLEVBQXJCOztBQUVBLE9BQUssV0FBTCxHQUFtQixDQUFuQjs7QUFFQSxPQUFLLFNBQUwsR0FBaUIsRUFBRSxJQUFJLENBQU4sRUFBUyxNQUFNLENBQWYsRUFBa0IsTUFBTSxDQUF4QixFQUEyQixPQUFPLENBQWxDLEVBQXFDLFNBQVMsQ0FBOUMsRUFBaUQsTUFBTSxDQUF2RCxFQUEwRCxTQUFTLENBQW5FLEVBQXNFLFdBQVcsQ0FBakYsRUFBb0YsU0FBUyxDQUE3RixFQUFnRyxVQUFVLENBQTFHLEVBQTZHLFVBQVUsQ0FBdkgsRUFBMEgsV0FBVyxDQUFySSxFQUFqQjtBQUNBLE9BQUssVUFBTCxHQUFrQixJQUFJLE1BQU0sT0FBVixDQUFtQixDQUFuQixFQUFzQixDQUF0QixFQUF5QixDQUF6QixDQUFsQjtBQUNBLE9BQUssY0FBTCxHQUFzQixJQUFJLE1BQU0sT0FBVixDQUFtQixDQUFuQixFQUFzQixDQUF0QixFQUF5QixDQUF6QixDQUF0Qjs7QUFFQSxPQUFLLFdBQUwsR0FBbUIsVUFBVyxLQUFYLEVBQW1COztBQUVyQyxPQUFLLE9BQU8sS0FBTSxNQUFNLElBQVosQ0FBUCxJQUE2QixVQUFsQyxFQUErQzs7QUFFOUMsU0FBTSxNQUFNLElBQVosRUFBb0IsS0FBcEI7QUFFQTtBQUVELEdBUkQ7O0FBVUEsT0FBSyxPQUFMLEdBQWUsVUFBVSxLQUFWLEVBQWtCOztBQUVoQyxPQUFLLE1BQU0sTUFBWCxFQUFvQjs7QUFFbkI7QUFFQTs7QUFFRDs7QUFFQSxXQUFTLE1BQU0sT0FBZjs7QUFFQyxTQUFLLEVBQUw7QUFBUyxnQkFBWSxLQUFLLHVCQUFMLEdBQStCLEVBQS9CLENBQW1DOztBQUV4RCxTQUFLLEVBQUw7QUFBUyxVQUFNLEtBQUssU0FBTCxDQUFlLE9BQWYsR0FBeUIsQ0FBekIsQ0FBNEI7QUFDM0MsU0FBSyxFQUFMO0FBQVMsVUFBTSxLQUFLLFNBQUwsQ0FBZSxJQUFmLEdBQXNCLENBQXRCLENBQXlCOztBQUV4QyxTQUFLLEVBQUw7QUFBUyxVQUFNLEtBQUssU0FBTCxDQUFlLElBQWYsR0FBc0IsQ0FBdEIsQ0FBeUI7QUFDeEMsU0FBSyxFQUFMO0FBQVMsVUFBTSxLQUFLLFNBQUwsQ0FBZSxLQUFmLEdBQXVCLENBQXZCLENBQTBCOztBQUV6QyxTQUFLLEVBQUw7QUFBUyxVQUFNLEtBQUssU0FBTCxDQUFlLEVBQWYsR0FBb0IsQ0FBcEIsQ0FBdUI7QUFDdEMsU0FBSyxFQUFMO0FBQVMsVUFBTSxLQUFLLFNBQUwsQ0FBZSxJQUFmLEdBQXNCLENBQXRCLENBQXlCOztBQUV4QyxTQUFLLEVBQUw7QUFBUyxXQUFPLEtBQUssU0FBTCxDQUFlLE9BQWYsR0FBeUIsQ0FBekIsQ0FBNEI7QUFDNUMsU0FBSyxFQUFMO0FBQVMsYUFBUyxLQUFLLFNBQUwsQ0FBZSxTQUFmLEdBQTJCLENBQTNCLENBQThCOztBQUVoRCxTQUFLLEVBQUw7QUFBUyxhQUFTLEtBQUssU0FBTCxDQUFlLE9BQWYsR0FBeUIsQ0FBekIsQ0FBNEI7QUFDOUMsU0FBSyxFQUFMO0FBQVMsY0FBVSxLQUFLLFNBQUwsQ0FBZSxRQUFmLEdBQTBCLENBQTFCLENBQTZCOztBQUVoRCxTQUFLLEVBQUw7QUFBUyxVQUFNLEtBQUssU0FBTCxDQUFlLFFBQWYsR0FBMEIsQ0FBMUIsQ0FBNkI7QUFDNUMsU0FBSyxFQUFMO0FBQVMsVUFBTSxLQUFLLFNBQUwsQ0FBZSxTQUFmLEdBQTJCLENBQTNCLENBQThCOztBQXBCOUM7O0FBd0JBLFFBQUssb0JBQUw7QUFDQSxRQUFLLG9CQUFMO0FBRUEsR0FyQ0Q7O0FBdUNBLE9BQUssS0FBTCxHQUFhLFVBQVUsS0FBVixFQUFrQjs7QUFFOUIsV0FBUyxNQUFNLE9BQWY7O0FBRUMsU0FBSyxFQUFMO0FBQVMsZ0JBQVksS0FBSyx1QkFBTCxHQUErQixDQUEvQixDQUFrQzs7QUFFdkQsU0FBSyxFQUFMO0FBQVMsVUFBTSxLQUFLLFNBQUwsQ0FBZSxPQUFmLEdBQXlCLENBQXpCLENBQTRCO0FBQzNDLFNBQUssRUFBTDtBQUFTLFVBQU0sS0FBSyxTQUFMLENBQWUsSUFBZixHQUFzQixDQUF0QixDQUF5Qjs7QUFFeEMsU0FBSyxFQUFMO0FBQVMsVUFBTSxLQUFLLFNBQUwsQ0FBZSxJQUFmLEdBQXNCLENBQXRCLENBQXlCO0FBQ3hDLFNBQUssRUFBTDtBQUFTLFVBQU0sS0FBSyxTQUFMLENBQWUsS0FBZixHQUF1QixDQUF2QixDQUEwQjs7QUFFekMsU0FBSyxFQUFMO0FBQVMsVUFBTSxLQUFLLFNBQUwsQ0FBZSxFQUFmLEdBQW9CLENBQXBCLENBQXVCO0FBQ3RDLFNBQUssRUFBTDtBQUFTLFVBQU0sS0FBSyxTQUFMLENBQWUsSUFBZixHQUFzQixDQUF0QixDQUF5Qjs7QUFFeEMsU0FBSyxFQUFMO0FBQVMsV0FBTyxLQUFLLFNBQUwsQ0FBZSxPQUFmLEdBQXlCLENBQXpCLENBQTRCO0FBQzVDLFNBQUssRUFBTDtBQUFTLGFBQVMsS0FBSyxTQUFMLENBQWUsU0FBZixHQUEyQixDQUEzQixDQUE4Qjs7QUFFaEQsU0FBSyxFQUFMO0FBQVMsYUFBUyxLQUFLLFNBQUwsQ0FBZSxPQUFmLEdBQXlCLENBQXpCLENBQTRCO0FBQzlDLFNBQUssRUFBTDtBQUFTLGNBQVUsS0FBSyxTQUFMLENBQWUsUUFBZixHQUEwQixDQUExQixDQUE2Qjs7QUFFaEQsU0FBSyxFQUFMO0FBQVMsVUFBTSxLQUFLLFNBQUwsQ0FBZSxRQUFmLEdBQTBCLENBQTFCLENBQTZCO0FBQzVDLFNBQUssRUFBTDtBQUFTLFVBQU0sS0FBSyxTQUFMLENBQWUsU0FBZixHQUEyQixDQUEzQixDQUE4Qjs7QUFwQjlDOztBQXdCQSxRQUFLLG9CQUFMO0FBQ0EsUUFBSyxvQkFBTDtBQUVBLEdBN0JEOztBQStCQSxPQUFLLFNBQUwsR0FBaUIsVUFBVSxLQUFWLEVBQWtCOztBQUVsQyxPQUFLLEtBQUssVUFBTCxLQUFvQixRQUF6QixFQUFvQzs7QUFFbkMsU0FBSyxVQUFMLENBQWdCLEtBQWhCO0FBRUE7O0FBRUQsU0FBTSxjQUFOO0FBQ0EsU0FBTSxlQUFOOztBQUVBLE9BQUssS0FBSyxVQUFWLEVBQXVCOztBQUV0QixTQUFLLFdBQUw7QUFFQSxJQUpELE1BSU87O0FBRU4sWUFBUyxNQUFNLE1BQWY7O0FBRUMsVUFBSyxDQUFMO0FBQVEsV0FBSyxTQUFMLENBQWUsT0FBZixHQUF5QixDQUF6QixDQUE0QjtBQUNwQyxVQUFLLENBQUw7QUFBUSxXQUFLLFNBQUwsQ0FBZSxJQUFmLEdBQXNCLENBQXRCLENBQXlCOztBQUhsQzs7QUFPQSxTQUFLLG9CQUFMO0FBRUE7QUFFRCxHQTVCRDs7QUE4QkEsT0FBSyxTQUFMLEdBQWlCLFVBQVUsS0FBVixFQUFrQjs7QUFFbEMsT0FBSyxDQUFFLEtBQUssVUFBUCxJQUFxQixLQUFLLFdBQUwsR0FBbUIsQ0FBN0MsRUFBaUQ7O0FBRWhELFFBQUksWUFBWSxLQUFLLHNCQUFMLEVBQWhCO0FBQ0EsUUFBSSxZQUFhLFVBQVUsSUFBVixDQUFnQixDQUFoQixJQUFzQixDQUF2QztBQUNBLFFBQUksYUFBYSxVQUFVLElBQVYsQ0FBZ0IsQ0FBaEIsSUFBc0IsQ0FBdkM7O0FBRUEsU0FBSyxTQUFMLENBQWUsT0FBZixHQUEyQixFQUFNLE1BQU0sS0FBTixHQUFjLFVBQVUsTUFBVixDQUFrQixDQUFsQixDQUFoQixHQUEwQyxTQUE5QyxJQUE2RCxTQUF4RjtBQUNBLFNBQUssU0FBTCxDQUFlLFNBQWYsR0FBNkIsQ0FBSSxNQUFNLEtBQU4sR0FBYyxVQUFVLE1BQVYsQ0FBa0IsQ0FBbEIsQ0FBaEIsR0FBMEMsVUFBNUMsSUFBMkQsVUFBeEY7O0FBRUEsU0FBSyxvQkFBTDtBQUVBO0FBRUQsR0FmRDs7QUFpQkEsT0FBSyxPQUFMLEdBQWUsVUFBVSxLQUFWLEVBQWtCOztBQUVoQyxTQUFNLGNBQU47QUFDQSxTQUFNLGVBQU47O0FBRUEsT0FBSyxLQUFLLFVBQVYsRUFBdUI7O0FBRXRCLFNBQUssV0FBTDs7QUFFQSxTQUFLLFNBQUwsQ0FBZSxPQUFmLEdBQXlCLEtBQUssU0FBTCxDQUFlLFNBQWYsR0FBMkIsQ0FBcEQ7QUFFQSxJQU5ELE1BTU87O0FBRU4sWUFBUyxNQUFNLE1BQWY7O0FBRUMsVUFBSyxDQUFMO0FBQVEsV0FBSyxTQUFMLENBQWUsT0FBZixHQUF5QixDQUF6QixDQUE0QjtBQUNwQyxVQUFLLENBQUw7QUFBUSxXQUFLLFNBQUwsQ0FBZSxJQUFmLEdBQXNCLENBQXRCLENBQXlCOztBQUhsQzs7QUFPQSxTQUFLLG9CQUFMO0FBRUE7O0FBRUQsUUFBSyxvQkFBTDtBQUVBLEdBMUJEOztBQTRCQSxPQUFLLE1BQUwsR0FBYyxVQUFVLEtBQVYsRUFBa0I7O0FBRS9CLE9BQUksV0FBVyxRQUFRLEtBQUssYUFBNUI7QUFDQSxPQUFJLFVBQVUsUUFBUSxLQUFLLFNBQTNCOztBQUVBLFFBQUssTUFBTCxDQUFZLFVBQVosQ0FBd0IsS0FBSyxVQUFMLENBQWdCLENBQWhCLEdBQW9CLFFBQTVDO0FBQ0EsUUFBSyxNQUFMLENBQVksVUFBWixDQUF3QixLQUFLLFVBQUwsQ0FBZ0IsQ0FBaEIsR0FBb0IsUUFBNUM7QUFDQSxRQUFLLE1BQUwsQ0FBWSxVQUFaLENBQXdCLEtBQUssVUFBTCxDQUFnQixDQUFoQixHQUFvQixRQUE1Qzs7QUFFQSxRQUFLLGFBQUwsQ0FBbUIsR0FBbkIsQ0FBd0IsS0FBSyxjQUFMLENBQW9CLENBQXBCLEdBQXdCLE9BQWhELEVBQXlELEtBQUssY0FBTCxDQUFvQixDQUFwQixHQUF3QixPQUFqRixFQUEwRixLQUFLLGNBQUwsQ0FBb0IsQ0FBcEIsR0FBd0IsT0FBbEgsRUFBMkgsQ0FBM0gsRUFBK0gsU0FBL0g7QUFDQSxRQUFLLE1BQUwsQ0FBWSxVQUFaLENBQXVCLFFBQXZCLENBQWlDLEtBQUssYUFBdEM7O0FBRUE7QUFDQSxRQUFLLE1BQUwsQ0FBWSxRQUFaLENBQXFCLGlCQUFyQixDQUF3QyxLQUFLLE1BQUwsQ0FBWSxVQUFwRCxFQUFnRSxLQUFLLE1BQUwsQ0FBWSxRQUFaLENBQXFCLEtBQXJGO0FBR0EsR0FoQkQ7O0FBa0JBLE9BQUssb0JBQUwsR0FBNEIsWUFBVzs7QUFFdEMsT0FBSSxVQUFZLEtBQUssU0FBTCxDQUFlLE9BQWYsSUFBNEIsS0FBSyxXQUFMLElBQW9CLENBQUUsS0FBSyxTQUFMLENBQWUsSUFBbkUsR0FBOEUsQ0FBOUUsR0FBa0YsQ0FBaEc7O0FBRUEsUUFBSyxVQUFMLENBQWdCLENBQWhCLEdBQXNCLENBQUUsS0FBSyxTQUFMLENBQWUsSUFBakIsR0FBMkIsS0FBSyxTQUFMLENBQWUsS0FBaEU7QUFDQSxRQUFLLFVBQUwsQ0FBZ0IsQ0FBaEIsR0FBc0IsQ0FBRSxLQUFLLFNBQUwsQ0FBZSxJQUFqQixHQUEyQixLQUFLLFNBQUwsQ0FBZSxFQUFoRTtBQUNBLFFBQUssVUFBTCxDQUFnQixDQUFoQixHQUFzQixDQUFFLE9BQUYsR0FBWSxLQUFLLFNBQUwsQ0FBZSxJQUFqRDs7QUFFQTtBQUVBLEdBVkQ7O0FBWUEsT0FBSyxvQkFBTCxHQUE0QixZQUFXOztBQUV0QyxRQUFLLGNBQUwsQ0FBb0IsQ0FBcEIsR0FBMEIsQ0FBRSxLQUFLLFNBQUwsQ0FBZSxTQUFqQixHQUE2QixLQUFLLFNBQUwsQ0FBZSxPQUF0RTtBQUNBLFFBQUssY0FBTCxDQUFvQixDQUFwQixHQUEwQixDQUFFLEtBQUssU0FBTCxDQUFlLFFBQWpCLEdBQTZCLEtBQUssU0FBTCxDQUFlLE9BQXRFO0FBQ0EsUUFBSyxjQUFMLENBQW9CLENBQXBCLEdBQTBCLENBQUUsS0FBSyxTQUFMLENBQWUsU0FBakIsR0FBNkIsS0FBSyxTQUFMLENBQWUsUUFBdEU7O0FBRUE7QUFFQSxHQVJEOztBQVVBLE9BQUssc0JBQUwsR0FBOEIsWUFBVzs7QUFFeEMsT0FBSyxLQUFLLFVBQUwsSUFBbUIsUUFBeEIsRUFBbUM7O0FBRWxDLFdBQU87QUFDTixXQUFPLENBQUUsS0FBSyxVQUFMLENBQWdCLFdBQWxCLEVBQStCLEtBQUssVUFBTCxDQUFnQixZQUEvQyxDQUREO0FBRU4sYUFBUyxDQUFFLEtBQUssVUFBTCxDQUFnQixVQUFsQixFQUErQixLQUFLLFVBQUwsQ0FBZ0IsU0FBL0M7QUFGSCxLQUFQO0FBS0EsSUFQRCxNQU9POztBQUVOLFdBQU87QUFDTixXQUFPLENBQUUsT0FBTyxVQUFULEVBQXFCLE9BQU8sV0FBNUIsQ0FERDtBQUVOLGFBQVMsQ0FBRSxDQUFGLEVBQUssQ0FBTDtBQUZILEtBQVA7QUFLQTtBQUVELEdBbEJEOztBQW9CQSxXQUFTLElBQVQsQ0FBZSxLQUFmLEVBQXNCLEVBQXRCLEVBQTJCOztBQUUxQixVQUFPLFlBQVk7O0FBRWxCLE9BQUcsS0FBSCxDQUFVLEtBQVYsRUFBaUIsU0FBakI7QUFFQSxJQUpEO0FBTUE7O0FBRUQsV0FBUyxXQUFULENBQXNCLEtBQXRCLEVBQThCOztBQUU3QixTQUFNLGNBQU47QUFFQTs7QUFFRCxPQUFLLE9BQUwsR0FBZSxZQUFXOztBQUV6QixRQUFLLFVBQUwsQ0FBZ0IsbUJBQWhCLENBQXFDLGFBQXJDLEVBQW9ELFdBQXBELEVBQWlFLEtBQWpFO0FBQ0EsUUFBSyxVQUFMLENBQWdCLG1CQUFoQixDQUFxQyxXQUFyQyxFQUFrRCxVQUFsRCxFQUE4RCxLQUE5RDtBQUNBLFFBQUssVUFBTCxDQUFnQixtQkFBaEIsQ0FBcUMsV0FBckMsRUFBa0QsVUFBbEQsRUFBOEQsS0FBOUQ7QUFDQSxRQUFLLFVBQUwsQ0FBZ0IsbUJBQWhCLENBQXFDLFNBQXJDLEVBQWdELFFBQWhELEVBQTBELEtBQTFEOztBQUVBLFVBQU8sbUJBQVAsQ0FBNEIsU0FBNUIsRUFBdUMsUUFBdkMsRUFBaUQsS0FBakQ7QUFDQSxVQUFPLG1CQUFQLENBQTRCLE9BQTVCLEVBQXFDLE1BQXJDLEVBQTZDLEtBQTdDO0FBRUEsR0FWRDs7QUFZQSxNQUFJLGFBQWEsS0FBTSxJQUFOLEVBQVksS0FBSyxTQUFqQixDQUFqQjtBQUNBLE1BQUksYUFBYSxLQUFNLElBQU4sRUFBWSxLQUFLLFNBQWpCLENBQWpCO0FBQ0EsTUFBSSxXQUFXLEtBQU0sSUFBTixFQUFZLEtBQUssT0FBakIsQ0FBZjtBQUNBLE1BQUksV0FBVyxLQUFNLElBQU4sRUFBWSxLQUFLLE9BQWpCLENBQWY7QUFDQSxNQUFJLFNBQVMsS0FBTSxJQUFOLEVBQVksS0FBSyxLQUFqQixDQUFiOztBQUVBLE9BQUssVUFBTCxDQUFnQixnQkFBaEIsQ0FBa0MsYUFBbEMsRUFBaUQsV0FBakQsRUFBOEQsS0FBOUQ7O0FBRUEsT0FBSyxVQUFMLENBQWdCLGdCQUFoQixDQUFrQyxXQUFsQyxFQUErQyxVQUEvQyxFQUEyRCxLQUEzRDtBQUNBLE9BQUssVUFBTCxDQUFnQixnQkFBaEIsQ0FBa0MsV0FBbEMsRUFBK0MsVUFBL0MsRUFBMkQsS0FBM0Q7QUFDQSxPQUFLLFVBQUwsQ0FBZ0IsZ0JBQWhCLENBQWtDLFNBQWxDLEVBQStDLFFBQS9DLEVBQXlELEtBQXpEOztBQUVBLFNBQU8sZ0JBQVAsQ0FBeUIsU0FBekIsRUFBb0MsUUFBcEMsRUFBOEMsS0FBOUM7QUFDQSxTQUFPLGdCQUFQLENBQXlCLE9BQXpCLEVBQW9DLE1BQXBDLEVBQTRDLEtBQTVDOztBQUVBLE9BQUssb0JBQUw7QUFDQSxPQUFLLG9CQUFMO0FBRUEsRUFoU0Q7QUFpU0EsQ0FsU0Q7Ozs7Ozs7OztBQ0hBOztJQUFZLEs7O0FBQ1o7Ozs7Ozs7Ozs7SUFFTSxRLEdBQ0osa0JBQWEsS0FBYixFQUFvQjtBQUFBOztBQUNsQixPQUFLLElBQUwsR0FBWSxJQUFJLE1BQU0sUUFBVixFQUFaOztBQUVBO0FBQ0EsTUFBSSxrQkFBa0IsSUFBSSxNQUFNLFdBQVYsQ0FBc0IsR0FBdEIsRUFBMkIsRUFBM0IsRUFBK0IsRUFBL0IsRUFBbUMsQ0FBbkMsRUFBc0MsQ0FBdEMsRUFBeUMsQ0FBekMsQ0FBdEI7QUFDQSxNQUFJLGlCQUFpQixJQUFJLE1BQU0saUJBQVYsQ0FBNEIsRUFBQyxPQUFPLEtBQVIsRUFBZSxhQUFhLE1BQU0sV0FBbEMsRUFBNUIsQ0FBckI7O0FBRUE7QUFDQTtBQUNBLGtCQUFnQixRQUFoQixDQUF5QixDQUF6QixFQUE0QixDQUE1QixJQUFpQyxFQUFqQztBQUNBLGtCQUFnQixRQUFoQixDQUF5QixDQUF6QixFQUE0QixDQUE1QixJQUFpQyxFQUFqQztBQUNBLGtCQUFnQixRQUFoQixDQUF5QixDQUF6QixFQUE0QixDQUE1QixJQUFpQyxFQUFqQztBQUNBLGtCQUFnQixRQUFoQixDQUF5QixDQUF6QixFQUE0QixDQUE1QixJQUFpQyxFQUFqQztBQUNBLGtCQUFnQixRQUFoQixDQUF5QixDQUF6QixFQUE0QixDQUE1QixJQUFpQyxFQUFqQztBQUNBLGtCQUFnQixRQUFoQixDQUF5QixDQUF6QixFQUE0QixDQUE1QixJQUFpQyxFQUFqQztBQUNBLGtCQUFnQixRQUFoQixDQUF5QixDQUF6QixFQUE0QixDQUE1QixJQUFpQyxFQUFqQztBQUNBLGtCQUFnQixRQUFoQixDQUF5QixDQUF6QixFQUE0QixDQUE1QixJQUFpQyxFQUFqQzs7QUFFQSxNQUFJLGNBQWMsSUFBSSxNQUFNLElBQVYsQ0FBZSxlQUFmLEVBQWdDLGNBQWhDLENBQWxCO0FBQ0EsY0FBWSxVQUFaLEdBQXlCLElBQXpCO0FBQ0EsY0FBWSxhQUFaLEdBQTRCLElBQTVCO0FBQ0EsY0FBWSxRQUFaLENBQXFCLEdBQXJCLENBQXlCLENBQUMsRUFBMUIsRUFBOEIsQ0FBOUIsRUFBaUMsQ0FBakM7QUFDQSxPQUFLLElBQUwsQ0FBVSxHQUFWLENBQWMsV0FBZDs7QUFFQSxNQUFJLGNBQWMsSUFBSSxNQUFNLFdBQVYsQ0FBc0IsRUFBdEIsRUFBMEIsRUFBMUIsRUFBOEIsRUFBOUIsRUFBa0MsQ0FBbEMsRUFBcUMsQ0FBckMsRUFBd0MsQ0FBeEMsQ0FBbEI7QUFDQSxNQUFJLGFBQWEsSUFBSSxNQUFNLGlCQUFWLENBQTRCLEVBQUMsT0FBTyxLQUFSLEVBQWUsYUFBYSxNQUFNLFdBQWxDLEVBQTVCLENBQWpCO0FBQ0EsTUFBSSxVQUFVLElBQUksTUFBTSxJQUFWLENBQWUsV0FBZixFQUE0QixVQUE1QixDQUFkO0FBQ0EsVUFBUSxVQUFSLEdBQXFCLElBQXJCO0FBQ0EsVUFBUSxhQUFSLEdBQXdCLElBQXhCO0FBQ0EsVUFBUSxRQUFSLENBQWlCLEdBQWpCLENBQXFCLEVBQXJCLEVBQXlCLENBQXpCLEVBQTRCLENBQTVCO0FBQ0EsT0FBSyxJQUFMLENBQVUsR0FBVixDQUFjLE9BQWQ7O0FBRUE7QUFDQSxNQUFJLGFBQWEsSUFBSSxNQUFNLFdBQVYsQ0FBc0IsRUFBdEIsRUFBMEIsRUFBMUIsRUFBOEIsRUFBOUIsRUFBa0MsQ0FBbEMsRUFBcUMsQ0FBckMsRUFBd0MsQ0FBeEMsQ0FBakI7QUFDQSxNQUFJLFlBQVksSUFBSSxNQUFNLGlCQUFWLENBQTRCLEVBQUMsT0FBTyxpQkFBTyxLQUFmLEVBQXNCLGFBQWEsTUFBTSxXQUF6QyxFQUE1QixDQUFoQjtBQUNBLE1BQUksU0FBUyxJQUFJLE1BQU0sSUFBVixDQUFlLFVBQWYsRUFBMkIsU0FBM0IsQ0FBYjtBQUNBLFNBQU8sUUFBUCxDQUFnQixDQUFoQixHQUFvQixFQUFwQjtBQUNBLFNBQU8sVUFBUCxHQUFvQixJQUFwQjtBQUNBLFNBQU8sYUFBUCxHQUF1QixJQUF2QjtBQUNBLE9BQUssSUFBTCxDQUFVLEdBQVYsQ0FBYyxNQUFkOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFJLGlCQUFpQixJQUFJLE1BQU0sV0FBVixDQUFzQixFQUF0QixFQUEwQixDQUExQixFQUE2QixHQUE3QixFQUFrQyxDQUFsQyxFQUFxQyxDQUFyQyxFQUF3QyxDQUF4QyxDQUFyQjtBQUNBLE1BQUksZ0JBQWdCLElBQUksTUFBTSxpQkFBVixDQUE0QixFQUFDLE9BQU8sS0FBUixFQUFlLGFBQWEsTUFBTSxXQUFsQyxFQUE1QixDQUFwQjtBQUNBLE1BQUksYUFBYSxJQUFJLE1BQU0sSUFBVixDQUFlLGNBQWYsRUFBK0IsYUFBL0IsQ0FBakI7QUFDQSxhQUFXLFVBQVgsR0FBd0IsSUFBeEI7QUFDQSxhQUFXLGFBQVgsR0FBMkIsSUFBM0I7QUFDQSxhQUFXLFFBQVgsQ0FBb0IsR0FBcEIsQ0FBd0IsRUFBeEIsRUFBNEIsQ0FBQyxFQUE3QixFQUFpQyxDQUFqQztBQUNBLE9BQUssSUFBTCxDQUFVLEdBQVYsQ0FBYyxVQUFkOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBSSxnQkFBZ0IsSUFBSSxNQUFNLFdBQVYsQ0FBc0IsRUFBdEIsRUFBMEIsRUFBMUIsRUFBOEIsQ0FBOUIsRUFBaUMsQ0FBakMsRUFBb0MsQ0FBcEMsRUFBdUMsQ0FBdkMsQ0FBcEI7QUFDQSxNQUFJLGVBQWUsSUFBSSxNQUFNLGlCQUFWLENBQTRCLEVBQUMsT0FBTyxLQUFSLEVBQWUsYUFBYSxNQUFNLFdBQWxDLEVBQTVCLENBQW5CO0FBQ0EsTUFBSSxZQUFZLElBQUksTUFBTSxJQUFWLENBQWUsYUFBZixFQUE4QixZQUE5QixDQUFoQjtBQUNBLFlBQVUsUUFBVixDQUFtQixHQUFuQixDQUF1QixDQUFDLEdBQXhCLEVBQTZCLEVBQTdCLEVBQWlDLENBQWpDO0FBQ0EsWUFBVSxVQUFWLEdBQXVCLElBQXZCO0FBQ0EsWUFBVSxhQUFWLEdBQTBCLElBQTFCO0FBQ0EsT0FBSyxJQUFMLENBQVUsR0FBVixDQUFjLFNBQWQ7O0FBRUE7QUFDQSxNQUFJLGVBQWUsSUFBSSxNQUFNLFdBQVYsQ0FBc0IsRUFBdEIsRUFBMEIsQ0FBMUIsRUFBNkIsRUFBN0IsRUFBaUMsQ0FBakMsRUFBb0MsQ0FBcEMsRUFBdUMsQ0FBdkMsQ0FBbkI7QUFDQSxNQUFJLGNBQWMsSUFBSSxNQUFNLGlCQUFWLENBQTRCLEVBQUMsT0FBTyxLQUFSLEVBQWUsYUFBYSxNQUFNLFdBQWxDLEVBQTVCLENBQWxCO0FBQ0EsTUFBSSxXQUFXLElBQUksTUFBTSxJQUFWLENBQWUsWUFBZixFQUE2QixXQUE3QixDQUFmO0FBQ0EsV0FBUyxVQUFULEdBQXNCLElBQXRCO0FBQ0EsV0FBUyxhQUFULEdBQXlCLElBQXpCO0FBQ0EsV0FBUyxRQUFULENBQWtCLEdBQWxCLENBQXNCLENBQUMsR0FBdkIsRUFBNEIsRUFBNUIsRUFBZ0MsQ0FBaEM7QUFDQSxPQUFLLElBQUwsQ0FBVSxHQUFWLENBQWMsUUFBZDs7QUFFQTtBQUNBLE1BQUksZ0JBQWdCLElBQUksTUFBTSxXQUFWLENBQXNCLEVBQXRCLEVBQTBCLEVBQTFCLEVBQThCLEVBQTlCLEVBQWtDLENBQWxDLEVBQXFDLENBQXJDLEVBQXdDLENBQXhDLENBQXBCO0FBQ0EsZ0JBQWMsUUFBZCxDQUF1QixDQUF2QixFQUEwQixDQUExQixJQUErQixDQUEvQjtBQUNBLGdCQUFjLFFBQWQsQ0FBdUIsQ0FBdkIsRUFBMEIsQ0FBMUIsSUFBK0IsQ0FBL0I7QUFDQSxnQkFBYyxRQUFkLENBQXVCLENBQXZCLEVBQTBCLENBQTFCLElBQStCLENBQS9CO0FBQ0EsZ0JBQWMsUUFBZCxDQUF1QixDQUF2QixFQUEwQixDQUExQixJQUErQixDQUEvQjtBQUNBLGdCQUFjLFFBQWQsQ0FBdUIsQ0FBdkIsRUFBMEIsQ0FBMUIsSUFBK0IsQ0FBL0I7QUFDQSxnQkFBYyxRQUFkLENBQXVCLENBQXZCLEVBQTBCLENBQTFCLElBQStCLENBQS9CO0FBQ0EsZ0JBQWMsUUFBZCxDQUF1QixDQUF2QixFQUEwQixDQUExQixJQUErQixDQUEvQjtBQUNBLGdCQUFjLFFBQWQsQ0FBdUIsQ0FBdkIsRUFBMEIsQ0FBMUIsSUFBK0IsQ0FBL0I7QUFDQSxNQUFJLGVBQWUsSUFBSSxNQUFNLGlCQUFWLENBQTRCLEVBQUMsT0FBTyxpQkFBTyxLQUFmLEVBQXNCLGFBQWEsTUFBTSxXQUF6QyxFQUE1QixDQUFuQjtBQUNBLE9BQUssU0FBTCxHQUFpQixJQUFJLE1BQU0sSUFBVixDQUFlLGFBQWYsRUFBOEIsWUFBOUIsQ0FBakI7O0FBRUEsT0FBSyxTQUFMLENBQWUsVUFBZixHQUE0QixJQUE1QjtBQUNBLE9BQUssU0FBTCxDQUFlLGFBQWYsR0FBK0IsSUFBL0I7O0FBRUEsTUFBSSxZQUFZLElBQUksTUFBTSxXQUFWLENBQXNCLENBQXRCLEVBQXlCLEVBQXpCLEVBQTZCLEVBQTdCLEVBQWlDLENBQWpDLEVBQW9DLENBQXBDLEVBQXVDLENBQXZDLENBQWhCO0FBQ0EsTUFBSSxXQUFXLElBQUksTUFBTSxpQkFBVixDQUE0QixFQUFDLE9BQU8saUJBQU8sU0FBZixFQUEwQixhQUFhLE1BQU0sV0FBN0MsRUFBNUIsQ0FBZjtBQUNBLE1BQUksU0FBUyxJQUFJLE1BQU0sSUFBVixDQUFlLFNBQWYsRUFBMEIsUUFBMUIsQ0FBYjtBQUNBLFNBQU8sUUFBUCxDQUFnQixHQUFoQixDQUFvQixDQUFwQixFQUF1QixDQUF2QixFQUEwQixDQUExQjs7QUFFQSxTQUFPLFVBQVAsR0FBb0IsSUFBcEI7QUFDQSxTQUFPLGFBQVAsR0FBdUIsSUFBdkI7O0FBRUEsTUFBSSxTQUFTLE9BQU8sS0FBUCxFQUFiO0FBQ0EsU0FBTyxRQUFQLENBQWdCLENBQWhCLEdBQW9CLEtBQUssRUFBTCxHQUFVLENBQTlCOztBQUVBLFNBQU8sVUFBUCxHQUFvQixJQUFwQjtBQUNBLFNBQU8sYUFBUCxHQUF1QixJQUF2Qjs7QUFFQSxPQUFLLFNBQUwsQ0FBZSxHQUFmLENBQW1CLE1BQW5CO0FBQ0EsT0FBSyxTQUFMLENBQWUsR0FBZixDQUFtQixNQUFuQjtBQUNBLE9BQUssU0FBTCxDQUFlLFFBQWYsQ0FBd0IsR0FBeEIsQ0FBNEIsRUFBNUIsRUFBZ0MsQ0FBaEMsRUFBbUMsQ0FBbkM7QUFDQSxPQUFLLElBQUwsQ0FBVSxHQUFWLENBQWMsS0FBSyxTQUFuQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDRCxDOztrQkFHWSxROzs7Ozs7OztBQzFJZixJQUFJLGNBQWMsT0FBSyxDQUFDLFlBQVcsS0FBSyxNQUFMLEVBQUQsR0FBZ0IsUUFBM0IsRUFBcUMsUUFBckMsQ0FBOEMsRUFBOUMsRUFBa0QsTUFBbEQsQ0FBeUQsQ0FBekQsRUFBMkQsQ0FBM0QsQ0FBdkI7O0FBRUEsSUFBTSxTQUFTO0FBQ2IsWUFBVSxXQURHO0FBRWIsU0FBTyxRQUZNO0FBR2IsU0FBTyxRQUhNO0FBSWIsYUFBVyxRQUpFO0FBS2IsU0FBTztBQUxNLENBQWY7O2tCQVFlLE07Ozs7O0FDVmY7Ozs7QUFDQTs7OztBQUNBOzs7O0FBRUE7O0lBQVksSzs7Ozs7O0FBRVosSUFBTSxjQUFjLFNBQWQsV0FBYyxHQUFZO0FBQzlCLFNBQU8sTUFBSSxDQUFDLFlBQVcsS0FBSyxNQUFMLEVBQUQsR0FBZ0IsUUFBM0IsRUFBcUMsUUFBckMsQ0FBOEMsRUFBOUMsRUFBa0QsTUFBbEQsQ0FBeUQsQ0FBekQsRUFBMkQsQ0FBM0QsQ0FBWDtBQUNELENBRkQ7O0FBSUE7QUFDQSxJQUFNLFNBQVMsSUFBZjs7QUFFQTtBQUNBLElBQUksVUFBVSxxQkFBZDtBQUNBLElBQUksV0FBSjtBQUNBLElBQUksWUFBWSxFQUFoQjtBQUNBLElBQUksVUFBVSxJQUFJLE1BQUosRUFBZDs7QUFFQSxRQUFRLEVBQVIsQ0FBVyxXQUFYLEVBQXdCLFlBQU07QUFDNUIsTUFBTSxjQUFjLENBQ2xCLFFBQVEsTUFBUixDQUFlLFFBQWYsQ0FBd0IsQ0FETixFQUVsQixRQUFRLE1BQVIsQ0FBZSxRQUFmLENBQXdCLENBRk4sRUFHbEIsUUFBUSxNQUFSLENBQWUsUUFBZixDQUF3QixDQUhOLENBQXBCO0FBS0EsTUFBTSxjQUFjLENBQ2xCLFFBQVEsTUFBUixDQUFlLFFBQWYsQ0FBd0IsQ0FETixFQUVsQixRQUFRLE1BQVIsQ0FBZSxRQUFmLENBQXdCLENBRk4sRUFHbEIsUUFBUSxNQUFSLENBQWUsUUFBZixDQUF3QixDQUhOLENBQXBCO0FBS0EsVUFBUSxHQUFSLENBQVksV0FBWjtBQUNBLFNBQU8sSUFBUCxDQUFZLE1BQVosRUFBb0IsV0FBcEIsRUFBaUMsV0FBakM7QUFDRCxDQWJEOztBQWVBO0FBQ0EsT0FBTyxFQUFQLENBQVUsY0FBVixFQUEwQixVQUFDLEdBQUQsRUFBTSxVQUFOLEVBQWtCLElBQWxCLEVBQTJCO0FBQ25EO0FBQ0EsT0FBSSxJQUFJLElBQUksQ0FBWixFQUFlLElBQUksS0FBSyxNQUF4QixFQUFnQyxHQUFoQyxFQUFxQztBQUNuQztBQUNFO0FBQ0E7QUFDQSxRQUFJLFdBQVcsdUJBQWEsYUFBYixDQUFmO0FBQ0EsYUFBUyxJQUFULENBQWMsS0FBZCxDQUFvQixHQUFwQixDQUF3QixJQUF4QixFQUE4QixJQUE5QixFQUFvQyxJQUFwQzs7QUFFQSxhQUFTLElBQVQsQ0FBYyxRQUFkLENBQXVCLENBQXZCLEdBQTJCLEdBQTNCOztBQUdBLFlBQVEsS0FBSyxDQUFMLENBQVIsSUFBbUI7QUFDakIsZ0JBQVUsU0FBUzs7QUFHckI7QUFKbUIsS0FBbkIsQ0FLQSxRQUFRLEtBQVIsQ0FBYyxHQUFkLENBQWtCLFFBQVEsS0FBSyxDQUFMLENBQVIsRUFBaUIsUUFBbkM7QUFDQSxZQUFRLEdBQVIsWUFBcUIsU0FBUyxJQUFULENBQWMsUUFBZCxDQUF1QixDQUE1QyxlQUF1RCxTQUFTLElBQVQsQ0FBYyxRQUFkLENBQXVCLENBQTlFLGVBQXlGLFNBQVMsSUFBVCxDQUFjLFFBQWQsQ0FBdUIsQ0FBaEg7QUFDRjtBQUNEOztBQUVELFVBQVEsR0FBUixDQUFZLE9BQVo7O0FBRUEsT0FBSyxHQUFMO0FBQ0EsVUFBUSxHQUFSLENBQVksZUFBZSxFQUEzQjtBQUNBO0FBQ0QsQ0EzQkQ7O0FBNkJBLE9BQU8sRUFBUCxDQUFVLGtCQUFWLEVBQThCLFVBQUMsV0FBRCxFQUFjLEdBQWQsRUFBbUIsSUFBbkIsRUFBNEI7QUFDeEQsVUFBUSxHQUFSLENBQVksY0FBYyxvQkFBMUI7QUFDQSxNQUFJLGlCQUFpQixLQUFyQjtBQUNBLE9BQUksSUFBSSxJQUFJLENBQVosRUFBZSxJQUFJLE9BQU8sSUFBUCxDQUFZLE9BQVosRUFBcUIsTUFBeEMsRUFBZ0QsR0FBaEQsRUFBb0Q7QUFDbEQsUUFBRyxPQUFPLElBQVAsQ0FBWSxPQUFaLEVBQXFCLENBQXJCLEtBQTJCLEdBQTlCLEVBQWtDO0FBQ2hDLHVCQUFpQixJQUFqQjtBQUNBO0FBQ0Q7QUFDRjtBQUNELE1BQUcsT0FBTyxFQUFQLElBQWEsQ0FBQyxjQUFqQixFQUFpQztBQUMvQixZQUFRLEdBQVIsQ0FBWSx1Q0FBdUMsR0FBbkQ7QUFDQTtBQUNBO0FBQ0EsUUFBSSxXQUFXLHVCQUFhLGFBQWIsQ0FBZjtBQUNBLGFBQVMsSUFBVCxDQUFjLEtBQWQsQ0FBb0IsR0FBcEIsQ0FBd0IsSUFBeEIsRUFBOEIsSUFBOUIsRUFBb0MsSUFBcEM7QUFDQTtBQUNBLFlBQVEsR0FBUixJQUFlO0FBQ2IsZ0JBQVUsU0FBUzs7QUFHckI7QUFKZSxLQUFmLENBS0EsUUFBUSxLQUFSLENBQWMsR0FBZCxDQUFrQixRQUFRLEdBQVIsRUFBYSxRQUEvQjtBQUNBLFlBQVEsR0FBUixZQUFxQixTQUFTLElBQVQsQ0FBYyxRQUFkLENBQXVCLENBQTVDLGVBQXVELFNBQVMsSUFBVCxDQUFjLFFBQWQsQ0FBdUIsQ0FBOUUsZUFBeUYsU0FBUyxJQUFULENBQWMsUUFBZCxDQUF1QixDQUFoSDtBQUNEO0FBQ0Q7QUFDRCxDQXpCRDs7QUEyQkEsT0FBTyxFQUFQLENBQVUsa0JBQVYsRUFBOEIsVUFBQyxXQUFELEVBQWMsR0FBZCxFQUFtQixJQUFuQixFQUE0QjtBQUN4RDtBQUNBOztBQUVBLE1BQUcsT0FBTyxFQUFWLEVBQWM7QUFDWixZQUFRLEdBQVIsQ0FBWSxzQ0FBc0MsR0FBbEQ7QUFDQSxZQUFRLEtBQVIsQ0FBYyxNQUFkLENBQXFCLFFBQVEsR0FBUixFQUFhLFFBQWxDO0FBQ0EsV0FBTyxRQUFRLEdBQVIsQ0FBUDtBQUNEO0FBQ0YsQ0FURDs7QUFXQSxPQUFPLEVBQVAsQ0FBVSxTQUFWLEVBQXFCLFlBQUksQ0FBRSxDQUEzQjs7QUFFQTtBQUNBO0FBQ0EsT0FBTyxFQUFQLENBQVUsZUFBVixFQUEyQix3QkFBZ0I7QUFDekMsT0FBSSxJQUFJLElBQUksQ0FBWixFQUFlLElBQUksT0FBTyxJQUFQLENBQVksWUFBWixFQUEwQixNQUE3QyxFQUFxRCxHQUFyRCxFQUEwRDtBQUN4RCxRQUFHLE9BQU8sSUFBUCxDQUFZLFlBQVosRUFBMEIsQ0FBMUIsS0FBZ0MsRUFBbkMsRUFBdUM7O0FBRXJDLFVBQU0sZUFBZSxPQUFPLElBQVAsQ0FBWSxZQUFaLEVBQTBCLENBQTFCLENBQXJCOztBQUVBO0FBQ0EsVUFBSSxTQUFTLFFBQVEsWUFBUixFQUFzQixRQUF0QixDQUErQixRQUE1QztBQUNBLFVBQUksU0FBUyxRQUFRLFlBQVIsRUFBc0IsUUFBdEIsQ0FBK0IsUUFBNUM7QUFDQSxVQUFJLFNBQVMsYUFBYSxZQUFiLEVBQTJCLFFBQXhDO0FBQ0EsVUFBSSxTQUFTLGFBQWEsWUFBYixFQUEyQixRQUF4Qzs7QUFFQTtBQUNBLFVBQUksWUFBWSxJQUFJLE1BQU0sT0FBVixFQUFoQjtBQUNBLGdCQUFVLENBQVYsR0FBYyxNQUFNLElBQU4sQ0FBVyxJQUFYLENBQWdCLE9BQU8sQ0FBdkIsRUFBMEIsT0FBTyxDQUFQLENBQTFCLEVBQXFDLEdBQXJDLENBQWQ7QUFDQSxnQkFBVSxDQUFWLEdBQWMsTUFBTSxJQUFOLENBQVcsSUFBWCxDQUFnQixPQUFPLENBQXZCLEVBQTBCLE9BQU8sQ0FBUCxDQUExQixFQUFxQyxHQUFyQyxDQUFkO0FBQ0EsZ0JBQVUsQ0FBVixHQUFjLE1BQU0sSUFBTixDQUFXLElBQVgsQ0FBZ0IsT0FBTyxDQUF2QixFQUEwQixPQUFPLENBQVAsQ0FBMUIsRUFBcUMsR0FBckMsQ0FBZDs7QUFFQSxVQUFJLFlBQVksSUFBSSxNQUFNLE9BQVYsRUFBaEI7QUFDQSxnQkFBVSxDQUFWLEdBQWMsTUFBTSxJQUFOLENBQVcsSUFBWCxDQUFnQixPQUFPLENBQXZCLEVBQTBCLE9BQU8sQ0FBUCxDQUExQixFQUFxQyxHQUFyQyxDQUFkO0FBQ0EsZ0JBQVUsQ0FBVixHQUFjLE1BQU0sSUFBTixDQUFXLElBQVgsQ0FBZ0IsT0FBTyxDQUF2QixFQUEwQixPQUFPLENBQVAsQ0FBMUIsRUFBcUMsR0FBckMsQ0FBZDtBQUNBLGdCQUFVLENBQVYsR0FBYyxNQUFNLElBQU4sQ0FBVyxJQUFYLENBQWdCLE9BQU8sQ0FBdkIsRUFBMEIsT0FBTyxDQUFQLENBQTFCLEVBQXFDLEdBQXJDLENBQWQ7O0FBRUE7QUFDQSxjQUFRLFlBQVIsRUFBc0IsUUFBdEIsQ0FBK0IsUUFBL0IsQ0FBd0MsR0FBeEMsQ0FBNEMsVUFBVSxDQUF0RCxFQUF5RCxVQUFVLENBQW5FLEVBQXNFLFVBQVUsQ0FBaEY7QUFDQSxjQUFRLFlBQVIsRUFBc0IsUUFBdEIsQ0FBK0IsUUFBL0IsQ0FBd0MsR0FBeEMsQ0FBNEMsVUFBVSxDQUF0RCxFQUF5RCxVQUFVLENBQW5FLEVBQXNFLFVBQVUsQ0FBaEY7QUFDRDtBQUNGO0FBQ0YsQ0E1QkQ7Ozs7Ozs7Ozs7O0FDekdBOztJQUFZLEs7O0FBSVo7Ozs7QUFNQTs7Ozs7Ozs7Ozs7OytlQVhBOztBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQSwyQkFBWSxLQUFaO0FBQ0E7O0FBRUE7O0lBR00sSzs7O0FBQ0osbUJBSWlDO0FBQUEsUUFKckIsVUFJcUIsdUVBSlIsU0FBUyxjQUFULENBQXdCLFlBQXhCLENBSVE7O0FBQUEsUUFIckIsTUFHcUIsdUVBSFosT0FBTyxVQUdLOztBQUFBLFFBRnJCLE9BRXFCLHVFQUZYLE9BQU8sV0FFSTs7QUFBQSxRQURyQixXQUNxQix1RUFEUCxJQUNPO0FBQUEsUUFBckIsVUFBcUIsdUVBQVIsT0FBUTs7QUFBQTs7QUFLL0I7QUFMK0I7O0FBRS9COzs7QUFJQSxVQUFLLEtBQUwsR0FBYSxJQUFJLE1BQU0sS0FBVixFQUFiOztBQUVBO0FBQ0EsVUFBSyxLQUFMLEdBQWEsTUFBYjtBQUNBLFVBQUssTUFBTCxHQUFjLE9BQWQ7O0FBRUE7QUFDQSxVQUFLLE1BQUwsR0FBYyxJQUFJLE1BQU0saUJBQVYsQ0FBNEIsRUFBNUIsRUFBZ0MsTUFBSyxLQUFMLEdBQWEsTUFBSyxNQUFsRCxFQUEwRCxHQUExRCxFQUErRCxJQUEvRCxDQUFkOztBQUVBO0FBQ0EsVUFBSyxRQUFMLEdBQWdCLElBQUksTUFBTSxhQUFWLENBQXdCO0FBQ3RDLG9CQUFjO0FBRHdCLEtBQXhCLENBQWhCOztBQUlBLFVBQUssUUFBTCxDQUFjLGFBQWQsQ0FBNEIsSUFBSSxNQUFNLEtBQVYsQ0FBZ0IsVUFBaEIsQ0FBNUI7O0FBRUEsVUFBSyxRQUFMLENBQWMsT0FBZCxDQUFzQixNQUFLLEtBQTNCLEVBQWtDLE1BQUssTUFBdkM7O0FBRUE7QUFDQSxlQUFXLE1BQVgsQ0FBa0IsTUFBSyxRQUFMLENBQWMsVUFBaEM7O0FBRUEsUUFBRyxXQUFILEVBQWU7QUFDYjtBQUNBLFlBQUssUUFBTCxHQUFnQixJQUFJLE1BQU0sV0FBVixDQUFzQixNQUFLLE1BQTNCLEVBQW1DLE1BQUssUUFBTCxDQUFjLFVBQWpELENBQWhCO0FBQ0E7QUFDQSxZQUFLLFFBQUwsQ0FBYyxVQUFkLEdBQTJCLElBQTNCO0FBQ0EsWUFBSyxRQUFMLENBQWMsYUFBZCxHQUE4QixDQUE5QjtBQUNBLFlBQUssUUFBTCxDQUFjLFNBQWQsR0FBMEIsR0FBMUI7QUFDQSxZQUFLLFdBQUwsR0FBbUIsS0FBbkI7QUFDRDs7QUFFRDtBQUNBLFdBQU8sZ0JBQVAsQ0FBd0IsUUFBeEIsRUFBa0M7QUFBQSxhQUFLLE1BQUssY0FBTCxDQUFvQixDQUFwQixDQUFMO0FBQUEsS0FBbEMsRUFBK0QsS0FBL0Q7QUFDQSxlQUFXLGdCQUFYLENBQTRCLFlBQTVCLEVBQTBDO0FBQUEsYUFBSyxNQUFLLGFBQUwsQ0FBbUIsQ0FBbkIsQ0FBTDtBQUFBLEtBQTFDLEVBQXNFLEtBQXRFO0FBQ0EsZUFBVyxnQkFBWCxDQUE0QixZQUE1QixFQUEwQztBQUFBLGFBQUssTUFBSyxhQUFMLENBQW1CLENBQW5CLENBQUw7QUFBQSxLQUExQyxFQUFzRSxLQUF0RTtBQUNBLFdBQU8sZ0JBQVAsQ0FBd0IsU0FBeEIsRUFBbUM7QUFBQSxhQUFLLE1BQUssU0FBTCxDQUFlLENBQWYsQ0FBTDtBQUFBLEtBQW5DLEVBQTJELEtBQTNEOztBQUVBLFVBQUssVUFBTCxHQUFrQixJQUFJLE1BQU0sVUFBVixDQUFzQixFQUF0QixFQUEwQixFQUExQixDQUFsQjtBQUNBLFVBQUssVUFBTCxDQUFnQixRQUFoQixDQUF5QixDQUF6QixHQUE2QixDQUFDLEdBQTlCO0FBQ0EsVUFBSyxLQUFMLENBQVcsR0FBWCxDQUFlLE1BQUssVUFBcEI7QUFDQSxVQUFLLEtBQUwsR0FBYSxJQUFJLE1BQU0sS0FBVixFQUFiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFLFVBQUssS0FBTCxDQUFXLFVBQVgsR0FBd0IsSUFBSSxNQUFNLEtBQVYsR0FBa0IsTUFBbEIsQ0FBMEIsR0FBMUIsRUFBK0IsQ0FBL0IsRUFBa0MsQ0FBbEMsQ0FBeEI7QUFDSCxVQUFLLEtBQUwsQ0FBVyxHQUFYLEdBQWlCLElBQUksTUFBTSxHQUFWLENBQWUsTUFBSyxLQUFMLENBQVcsVUFBMUIsRUFBc0MsQ0FBdEMsRUFBeUMsSUFBekMsQ0FBakI7O0FBRUEsUUFBSSxZQUFZLElBQUksTUFBTSxlQUFWLENBQTJCLFFBQTNCLEVBQXFDLFFBQXJDLEVBQStDLEdBQS9DLENBQWhCO0FBQ0MsY0FBVSxLQUFWLENBQWdCLE1BQWhCLENBQXdCLEdBQXhCLEVBQTZCLENBQTdCLEVBQWdDLEdBQWhDO0FBQ0EsY0FBVSxXQUFWLENBQXNCLE1BQXRCLENBQThCLEtBQTlCLEVBQXFDLENBQXJDLEVBQXdDLElBQXhDO0FBQ0EsY0FBVSxRQUFWLENBQW1CLEdBQW5CLENBQXdCLENBQXhCLEVBQTJCLEVBQTNCLEVBQStCLENBQS9CO0FBQ0EsVUFBSyxLQUFMLENBQVcsR0FBWCxDQUFnQixTQUFoQjtBQUNBLFFBQUksa0JBQWtCLElBQUksTUFBTSxxQkFBVixDQUFpQyxTQUFqQyxFQUE0QyxFQUE1QyxDQUF0QjtBQUNBLFVBQUssS0FBTCxDQUFXLEdBQVgsQ0FBZ0IsZUFBaEI7QUFDQTtBQUNBLFFBQUksV0FBVyxJQUFJLE1BQU0sZ0JBQVYsQ0FBNEIsUUFBNUIsRUFBc0MsQ0FBdEMsQ0FBZjtBQUNBLGFBQVMsS0FBVCxDQUFlLE1BQWYsQ0FBdUIsR0FBdkIsRUFBNEIsQ0FBNUIsRUFBK0IsSUFBL0I7QUFDQSxhQUFTLFFBQVQsQ0FBa0IsR0FBbEIsQ0FBdUIsQ0FBQyxDQUF4QixFQUEyQixJQUEzQixFQUFpQyxDQUFqQztBQUNBLGFBQVMsUUFBVCxDQUFrQixjQUFsQixDQUFrQyxFQUFsQztBQUNBLFVBQUssS0FBTCxDQUFXLEdBQVgsQ0FBZ0IsUUFBaEI7QUFDQSxhQUFTLFVBQVQsR0FBc0IsSUFBdEI7QUFDQSxhQUFTLE1BQVQsQ0FBZ0IsT0FBaEIsQ0FBd0IsS0FBeEIsR0FBZ0MsSUFBaEM7QUFDQSxhQUFTLE1BQVQsQ0FBZ0IsT0FBaEIsQ0FBd0IsTUFBeEIsR0FBaUMsSUFBakM7QUFDQSxRQUFJLElBQUksRUFBUjtBQUNBLGFBQVMsTUFBVCxDQUFnQixNQUFoQixDQUF1QixJQUF2QixHQUE4QixDQUFDLENBQS9CO0FBQ0EsYUFBUyxNQUFULENBQWdCLE1BQWhCLENBQXVCLEtBQXZCLEdBQStCLENBQS9CO0FBQ0EsYUFBUyxNQUFULENBQWdCLE1BQWhCLENBQXVCLEdBQXZCLEdBQTZCLENBQTdCO0FBQ0EsYUFBUyxNQUFULENBQWdCLE1BQWhCLENBQXVCLE1BQXZCLEdBQWdDLENBQUMsQ0FBakM7QUFDQSxhQUFTLE1BQVQsQ0FBZ0IsTUFBaEIsQ0FBdUIsR0FBdkIsR0FBNkIsSUFBN0I7QUFDQSxhQUFTLE1BQVQsQ0FBZ0IsSUFBaEIsR0FBdUIsQ0FBQyxNQUF4QjtBQUNBLFFBQUksZ0JBQWdCLElBQUksTUFBTSxzQkFBVixDQUFrQyxRQUFsQyxFQUE0QyxFQUE1QyxDQUFwQjtBQUNBLFVBQUssS0FBTCxDQUFXLEdBQVgsQ0FBZ0IsYUFBaEI7QUFDQTtBQUNBLFFBQUksWUFBWSxJQUFJLE1BQU0sbUJBQVYsQ0FBK0IsS0FBL0IsRUFBc0MsS0FBdEMsQ0FBaEI7QUFDQSxRQUFJLFlBQVksSUFBSSxNQUFNLGlCQUFWLENBQTZCLEVBQUUsT0FBTyxRQUFULEVBQW1CLFVBQVUsUUFBN0IsRUFBN0IsQ0FBaEI7QUFDQSxjQUFVLEtBQVYsQ0FBZ0IsTUFBaEIsQ0FBd0IsS0FBeEIsRUFBK0IsQ0FBL0IsRUFBa0MsSUFBbEM7QUFDQSxRQUFJLFNBQVMsSUFBSSxNQUFNLElBQVYsQ0FBZ0IsU0FBaEIsRUFBMkIsU0FBM0IsQ0FBYjtBQUNBLFdBQU8sUUFBUCxDQUFnQixDQUFoQixHQUFvQixDQUFDLEtBQUssRUFBTixHQUFTLENBQTdCO0FBQ0EsV0FBTyxRQUFQLENBQWdCLENBQWhCLEdBQW9CLENBQUMsRUFBckI7QUFDQSxVQUFLLEtBQUwsQ0FBVyxHQUFYLENBQWdCLE1BQWhCO0FBQ0EsV0FBTyxhQUFQLEdBQXVCLElBQXZCO0FBQ0E7QUFDQSxRQUFJLGVBQWUsU0FBUyxjQUFULENBQXlCLGNBQXpCLEVBQTBDLFdBQTdEO0FBQ0EsUUFBSSxpQkFBaUIsU0FBUyxjQUFULENBQXlCLGdCQUF6QixFQUE0QyxXQUFqRTtBQUNBLFFBQUksV0FBVztBQUNkLGdCQUFhLEVBQUUsT0FBTyxJQUFJLE1BQU0sS0FBVixDQUFpQixRQUFqQixDQUFULEVBREM7QUFFZCxtQkFBYSxFQUFFLE9BQU8sSUFBSSxNQUFNLEtBQVYsQ0FBaUIsUUFBakIsQ0FBVCxFQUZDO0FBR2QsY0FBYSxFQUFFLE9BQU8sRUFBVCxFQUhDO0FBSWQsZ0JBQWEsRUFBRSxPQUFPLEdBQVQ7QUFKQyxLQUFmO0FBTUEsYUFBUyxRQUFULENBQWtCLEtBQWxCLENBQXdCLElBQXhCLENBQThCLFVBQVUsS0FBeEM7QUFDQSxVQUFLLEtBQUwsQ0FBVyxHQUFYLENBQWUsS0FBZixDQUFxQixJQUFyQixDQUEyQixTQUFTLFdBQVQsQ0FBcUIsS0FBaEQ7QUFDQSxRQUFJLFNBQVMsSUFBSSxNQUFNLGNBQVYsQ0FBMEIsSUFBMUIsRUFBZ0MsRUFBaEMsRUFBb0MsRUFBcEMsQ0FBYjtBQUNBLFFBQUksU0FBUyxJQUFJLE1BQU0sY0FBVixDQUEwQixFQUFFLGNBQWMsWUFBaEIsRUFBOEIsZ0JBQWdCLGNBQTlDLEVBQThELFVBQVUsUUFBeEUsRUFBa0YsTUFBTSxNQUFNLFFBQTlGLEVBQTFCLENBQWI7QUFDQSxRQUFJLE1BQU0sSUFBSSxNQUFNLElBQVYsQ0FBZ0IsTUFBaEIsRUFBd0IsTUFBeEIsQ0FBVjtBQUNBLFVBQUssS0FBTCxDQUFXLEdBQVgsQ0FBZ0IsR0FBaEI7O0FBRUk7QUFDQTs7QUFFSixVQUFLLE1BQUw7O0FBOUcrQjtBQWdIaEM7Ozs7OEJBRVMsUyxFQUFXLEUsRUFBRztBQUN0QixXQUFJLElBQUksSUFBSSxDQUFaLEVBQWUsSUFBSSxPQUFPLElBQVAsQ0FBWSxTQUFaLEVBQXVCLE1BQTFDLEVBQWtELEdBQWxELEVBQXNEO0FBQ3BELFlBQUcsT0FBTyxJQUFQLENBQVksU0FBWixFQUF1QixDQUF2QixLQUE2QixFQUFoQyxFQUFtQztBQUNqQyxlQUFLLEtBQUwsQ0FBVyxDQUFYLEVBQWMsUUFBZCxDQUF1QixHQUF2QixDQUEyQixVQUFVLE9BQU8sSUFBUCxDQUFZLFNBQVosRUFBdUIsQ0FBdkIsQ0FBVixFQUFxQyxRQUFyQyxDQUE4QyxDQUE5QyxDQUEzQixFQUMyQixVQUFVLE9BQU8sSUFBUCxDQUFZLFNBQVosRUFBdUIsQ0FBdkIsQ0FBVixFQUFxQyxRQUFyQyxDQUE4QyxDQUE5QyxDQUQzQixFQUUyQixVQUFVLE9BQU8sSUFBUCxDQUFZLFNBQVosRUFBdUIsQ0FBdkIsQ0FBVixFQUFxQyxRQUFyQyxDQUE4QyxDQUE5QyxDQUYzQjtBQUdEO0FBQ0Y7QUFDRjs7OzZCQUVPO0FBQUE7O0FBQ04sNEJBQXNCO0FBQUEsZUFBTSxPQUFLLE1BQUwsRUFBTjtBQUFBLE9BQXRCOztBQUdBLFdBQUssUUFBTCxDQUFjLE1BQWQsQ0FBcUIsS0FBSyxLQUFMLENBQVcsUUFBWCxFQUFyQjtBQUNBLFdBQUssUUFBTCxDQUFjLE1BQWQsR0FBdUIsSUFBSSxNQUFNLE9BQVYsQ0FBa0IsQ0FBbEIsRUFBb0IsQ0FBcEIsRUFBc0IsQ0FBdEIsQ0FBdkI7QUFDQSxXQUFLLE1BQUw7QUFDRDs7OzZCQUVRO0FBQ1AsV0FBSyxRQUFMLENBQWMsTUFBZCxDQUFxQixLQUFLLEtBQTFCLEVBQWlDLEtBQUssTUFBdEM7QUFDRDs7O21DQUVjLEMsRUFBRztBQUNoQixXQUFLLEtBQUwsR0FBYSxPQUFPLFVBQXBCO0FBQ0EsV0FBSyxNQUFMLEdBQWMsS0FBSyxLQUFMLENBQVcsT0FBTyxXQUFQLEdBQXNCLE9BQU8sV0FBUCxHQUFxQixHQUF0RCxDQUFkO0FBQ0EsV0FBSyxNQUFMLENBQVksTUFBWixHQUFxQixLQUFLLEtBQUwsR0FBYSxLQUFLLE1BQXZDO0FBQ0EsV0FBSyxNQUFMLENBQVksc0JBQVo7QUFDQSxXQUFLLFFBQUwsQ0FBYyxPQUFkLENBQXNCLEtBQUssS0FBM0IsRUFBa0MsS0FBSyxNQUF2QztBQUNEOzs7a0NBRWEsQyxFQUFFO0FBQ2QsV0FBSyxRQUFMLENBQWMsT0FBZCxHQUF3QixLQUF4QjtBQUNEOzs7a0NBQ2EsQyxFQUFFO0FBQ2QsV0FBSyxRQUFMLENBQWMsT0FBZCxHQUF3QixJQUF4QjtBQUNEOzs7OEJBQ1MsQyxFQUFFO0FBQ1YsV0FBSyxJQUFMLENBQVUsV0FBVjtBQUNEOzs7Ozs7a0JBR1ksSyIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9cmV0dXJuIGV9KSgpIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgREVGQVVMVF9WQUxVRVMgPSB7XG4gICAgZW1pdERlbGF5OiAxMCxcbiAgICBzdHJpY3RNb2RlOiBmYWxzZVxufTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBFdmVudEVtaXR0ZXJMaXN0ZW5lckZ1bmNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gb25jZVxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gZm5cbiAqL1xuXG4vKipcbiAqIEBjbGFzcyBFdmVudEVtaXR0ZXJcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHByb3BlcnR5IHtPYmplY3QuPHN0cmluZywgRXZlbnRFbWl0dGVyTGlzdGVuZXJGdW5jW10+fSBfbGlzdGVuZXJzXG4gKiBAcHJvcGVydHkge3N0cmluZ1tdfSBldmVudHNcbiAqL1xuXG52YXIgRXZlbnRFbWl0dGVyID0gZnVuY3Rpb24gKCkge1xuXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHt7fX0gICAgICBbb3B0c11cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gIFtvcHRzLmVtaXREZWxheSA9IDEwXSAtIE51bWJlciBpbiBtcy4gU3BlY2lmaWVzIHdoZXRoZXIgZW1pdCB3aWxsIGJlIHN5bmMgb3IgYXN5bmMuIEJ5IGRlZmF1bHQgLSAxMG1zLiBJZiAwIC0gZmlyZXMgc3luY1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc3RyaWN0TW9kZSA9IGZhbHNlXSAtIGlzIHRydWUsIEVtaXR0ZXIgdGhyb3dzIGVycm9yIG9uIGVtaXQgZXJyb3Igd2l0aCBubyBsaXN0ZW5lcnNcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgICAgICAgdmFyIG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyBERUZBVUxUX1ZBTFVFUyA6IGFyZ3VtZW50c1swXTtcblxuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRXZlbnRFbWl0dGVyKTtcblxuICAgICAgICB2YXIgZW1pdERlbGF5ID0gdm9pZCAwLFxuICAgICAgICAgICAgc3RyaWN0TW9kZSA9IHZvaWQgMDtcblxuICAgICAgICBpZiAob3B0cy5oYXNPd25Qcm9wZXJ0eSgnZW1pdERlbGF5JykpIHtcbiAgICAgICAgICAgIGVtaXREZWxheSA9IG9wdHMuZW1pdERlbGF5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZW1pdERlbGF5ID0gREVGQVVMVF9WQUxVRVMuZW1pdERlbGF5O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2VtaXREZWxheSA9IGVtaXREZWxheTtcblxuICAgICAgICBpZiAob3B0cy5oYXNPd25Qcm9wZXJ0eSgnc3RyaWN0TW9kZScpKSB7XG4gICAgICAgICAgICBzdHJpY3RNb2RlID0gb3B0cy5zdHJpY3RNb2RlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RyaWN0TW9kZSA9IERFRkFVTFRfVkFMVUVTLnN0cmljdE1vZGU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3RyaWN0TW9kZSA9IHN0cmljdE1vZGU7XG5cbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0ge307XG4gICAgICAgIHRoaXMuZXZlbnRzID0gW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gbGlzdGVuZXJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvbmNlID0gZmFsc2VdXG4gICAgICovXG5cblxuICAgIF9jcmVhdGVDbGFzcyhFdmVudEVtaXR0ZXIsIFt7XG4gICAgICAgIGtleTogJ19hZGRMaXN0ZW5uZXInLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2FkZExpc3Rlbm5lcih0eXBlLCBsaXN0ZW5lciwgb25jZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmV2ZW50cy5pbmRleE9mKHR5cGUpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xpc3RlbmVyc1t0eXBlXSA9IFt7XG4gICAgICAgICAgICAgICAgICAgIG9uY2U6IG9uY2UsXG4gICAgICAgICAgICAgICAgICAgIGZuOiBsaXN0ZW5lclxuICAgICAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLnB1c2godHlwZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xpc3RlbmVyc1t0eXBlXS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgb25jZTogb25jZSxcbiAgICAgICAgICAgICAgICAgICAgZm46IGxpc3RlbmVyXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogU3Vic2NyaWJlcyBvbiBldmVudCB0eXBlIHNwZWNpZmllZCBmdW5jdGlvblxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBsaXN0ZW5lclxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnb24nLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2FkZExpc3Rlbm5lcih0eXBlLCBsaXN0ZW5lciwgZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN1YnNjcmliZXMgb24gZXZlbnQgdHlwZSBzcGVjaWZpZWQgZnVuY3Rpb24gdG8gZmlyZSBvbmx5IG9uY2VcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbn0gbGlzdGVuZXJcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ29uY2UnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb25jZSh0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgICAgICAgdGhpcy5fYWRkTGlzdGVubmVyKHR5cGUsIGxpc3RlbmVyLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmVzIGV2ZW50IHdpdGggc3BlY2lmaWVkIHR5cGUuIElmIHNwZWNpZmllZCBsaXN0ZW5lckZ1bmMgLSBkZWxldGVzIG9ubHkgb25lIGxpc3RlbmVyIG9mIHNwZWNpZmllZCB0eXBlXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGVcbiAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2xpc3RlbmVyRnVuY11cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ29mZicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvZmYoZXZlbnRUeXBlLCBsaXN0ZW5lckZ1bmMpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgICAgIHZhciB0eXBlSW5kZXggPSB0aGlzLmV2ZW50cy5pbmRleE9mKGV2ZW50VHlwZSk7XG4gICAgICAgICAgICB2YXIgaGFzVHlwZSA9IGV2ZW50VHlwZSAmJiB0eXBlSW5kZXggIT09IC0xO1xuXG4gICAgICAgICAgICBpZiAoaGFzVHlwZSkge1xuICAgICAgICAgICAgICAgIGlmICghbGlzdGVuZXJGdW5jKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9saXN0ZW5lcnNbZXZlbnRUeXBlXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudHMuc3BsaWNlKHR5cGVJbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZW1vdmVkRXZlbnRzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZUxpc3RlbmVycyA9IF90aGlzLl9saXN0ZW5lcnNbZXZlbnRUeXBlXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZUxpc3RlbmVycy5mb3JFYWNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0V2ZW50RW1pdHRlckxpc3RlbmVyRnVuY30gZm5cbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZHhcbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGZuLCBpZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZm4uZm4gPT09IGxpc3RlbmVyRnVuYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVkRXZlbnRzLnVuc2hpZnQoaWR4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZEV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlTGlzdGVuZXJzLnNwbGljZShpZHgsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdHlwZUxpc3RlbmVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5ldmVudHMuc3BsaWNlKHR5cGVJbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIF90aGlzLl9saXN0ZW5lcnNbZXZlbnRUeXBlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQXBwbGllcyBhcmd1bWVudHMgdG8gc3BlY2lmaWVkIGV2ZW50IHR5cGVcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZVxuICAgICAgICAgKiBAcGFyYW0geypbXX0gZXZlbnRBcmd1bWVudHNcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnX2FwcGx5RXZlbnRzJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9hcHBseUV2ZW50cyhldmVudFR5cGUsIGV2ZW50QXJndW1lbnRzKSB7XG4gICAgICAgICAgICB2YXIgdHlwZUxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVyc1tldmVudFR5cGVdO1xuXG4gICAgICAgICAgICBpZiAoIXR5cGVMaXN0ZW5lcnMgfHwgIXR5cGVMaXN0ZW5lcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3N0cmljdE1vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ05vIGxpc3RlbmVycyBzcGVjaWZpZWQgZm9yIGV2ZW50OiAnICsgZXZlbnRUeXBlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByZW1vdmFibGVMaXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgICAgIHR5cGVMaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAoZWVMaXN0ZW5lciwgaWR4KSB7XG4gICAgICAgICAgICAgICAgZWVMaXN0ZW5lci5mbi5hcHBseShudWxsLCBldmVudEFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgaWYgKGVlTGlzdGVuZXIub25jZSkge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmFibGVMaXN0ZW5lcnMudW5zaGlmdChpZHgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZW1vdmFibGVMaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgICAgICAgICAgdHlwZUxpc3RlbmVycy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVtaXRzIGV2ZW50IHdpdGggc3BlY2lmaWVkIHR5cGUgYW5kIHBhcmFtcy5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICAgICAgICogQHBhcmFtIGV2ZW50QXJnc1xuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZW1pdCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBlbWl0KHR5cGUpIHtcbiAgICAgICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgZXZlbnRBcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICAgICAgICAgIGV2ZW50QXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9lbWl0RGVsYXkpIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMyLl9hcHBseUV2ZW50cy5jYWxsKF90aGlzMiwgdHlwZSwgZXZlbnRBcmdzKTtcbiAgICAgICAgICAgICAgICB9LCB0aGlzLl9lbWl0RGVsYXkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hcHBseUV2ZW50cyh0eXBlLCBldmVudEFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVtaXRzIGV2ZW50IHdpdGggc3BlY2lmaWVkIHR5cGUgYW5kIHBhcmFtcyBzeW5jaHJvbm91c2x5LlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgICAgICAgKiBAcGFyYW0gZXZlbnRBcmdzXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdlbWl0U3luYycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBlbWl0U3luYyh0eXBlKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGV2ZW50QXJncyA9IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgICAgICAgICBldmVudEFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2FwcGx5RXZlbnRzKHR5cGUsIGV2ZW50QXJncyk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVzdHJveXMgRXZlbnRFbWl0dGVyXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdkZXN0cm95JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzID0gW107XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gRXZlbnRFbWl0dGVyO1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcbiIsIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG4gICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4gICAgKGZhY3RvcnkoKGdsb2JhbC5USFJFRSA9IGdsb2JhbC5USFJFRSB8fCB7fSkpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuICAgIC8vIFBvbHlmaWxsc1xuXG4gICAgaWYgKCBOdW1iZXIuRVBTSUxPTiA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHROdW1iZXIuRVBTSUxPTiA9IE1hdGgucG93KCAyLCAtIDUyICk7XG5cbiAgICB9XG5cbiAgICAvL1xuXG4gICAgaWYgKCBNYXRoLnNpZ24gPT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0Ly8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9zaWduXG5cbiAgICBcdE1hdGguc2lnbiA9IGZ1bmN0aW9uICggeCApIHtcblxuICAgIFx0XHRyZXR1cm4gKCB4IDwgMCApID8gLSAxIDogKCB4ID4gMCApID8gMSA6ICsgeDtcblxuICAgIFx0fTtcblxuICAgIH1cblxuICAgIGlmICggRnVuY3Rpb24ucHJvdG90eXBlLm5hbWUgPT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0Ly8gTWlzc2luZyBpbiBJRTktMTEuXG4gICAgXHQvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GdW5jdGlvbi9uYW1lXG5cbiAgICBcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggRnVuY3Rpb24ucHJvdG90eXBlLCAnbmFtZScsIHtcblxuICAgIFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHRcdHJldHVybiB0aGlzLnRvU3RyaW5nKCkubWF0Y2goIC9eXFxzKmZ1bmN0aW9uXFxzKihcXFMqKVxccypcXCgvIClbIDEgXTtcblxuICAgIFx0XHR9XG5cbiAgICBcdH0gKTtcblxuICAgIH1cblxuICAgIGlmICggT2JqZWN0LmFzc2lnbiA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHQvLyBNaXNzaW5nIGluIElFLlxuICAgIFx0Ly8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2Fzc2lnblxuXG4gICAgXHQoIGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHRPYmplY3QuYXNzaWduID0gZnVuY3Rpb24gKCB0YXJnZXQgKSB7XG5cbiAgICBcdFx0XHQndXNlIHN0cmljdCc7XG5cbiAgICBcdFx0XHRpZiAoIHRhcmdldCA9PT0gdW5kZWZpbmVkIHx8IHRhcmdldCA9PT0gbnVsbCApIHtcblxuICAgIFx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvciggJ0Nhbm5vdCBjb252ZXJ0IHVuZGVmaW5lZCBvciBudWxsIHRvIG9iamVjdCcgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdHZhciBvdXRwdXQgPSBPYmplY3QoIHRhcmdldCApO1xuXG4gICAgXHRcdFx0Zm9yICggdmFyIGluZGV4ID0gMTsgaW5kZXggPCBhcmd1bWVudHMubGVuZ3RoOyBpbmRleCArKyApIHtcblxuICAgIFx0XHRcdFx0dmFyIHNvdXJjZSA9IGFyZ3VtZW50c1sgaW5kZXggXTtcblxuICAgIFx0XHRcdFx0aWYgKCBzb3VyY2UgIT09IHVuZGVmaW5lZCAmJiBzb3VyY2UgIT09IG51bGwgKSB7XG5cbiAgICBcdFx0XHRcdFx0Zm9yICggdmFyIG5leHRLZXkgaW4gc291cmNlICkge1xuXG4gICAgXHRcdFx0XHRcdFx0aWYgKCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoIHNvdXJjZSwgbmV4dEtleSApICkge1xuXG4gICAgXHRcdFx0XHRcdFx0XHRvdXRwdXRbIG5leHRLZXkgXSA9IHNvdXJjZVsgbmV4dEtleSBdO1xuXG4gICAgXHRcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0cmV0dXJuIG91dHB1dDtcblxuICAgIFx0XHR9O1xuXG4gICAgXHR9ICkoKTtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvZXZlbnRkaXNwYXRjaGVyLmpzL1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gRXZlbnREaXNwYXRjaGVyKCkge31cblxuICAgIE9iamVjdC5hc3NpZ24oIEV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUsIHtcblxuICAgIFx0YWRkRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gKCB0eXBlLCBsaXN0ZW5lciApIHtcblxuICAgIFx0XHRpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICkgdGhpcy5fbGlzdGVuZXJzID0ge307XG5cbiAgICBcdFx0dmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcblxuICAgIFx0XHRpZiAoIGxpc3RlbmVyc1sgdHlwZSBdID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRsaXN0ZW5lcnNbIHR5cGUgXSA9IFtdO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoIGxpc3RlbmVyc1sgdHlwZSBdLmluZGV4T2YoIGxpc3RlbmVyICkgPT09IC0gMSApIHtcblxuICAgIFx0XHRcdGxpc3RlbmVyc1sgdHlwZSBdLnB1c2goIGxpc3RlbmVyICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9LFxuXG4gICAgXHRoYXNFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAoIHR5cGUsIGxpc3RlbmVyICkge1xuXG4gICAgXHRcdGlmICggdGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQgKSByZXR1cm4gZmFsc2U7XG5cbiAgICBcdFx0dmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcblxuICAgIFx0XHRpZiAoIGxpc3RlbmVyc1sgdHlwZSBdICE9PSB1bmRlZmluZWQgJiYgbGlzdGVuZXJzWyB0eXBlIF0uaW5kZXhPZiggbGlzdGVuZXIgKSAhPT0gLSAxICkge1xuXG4gICAgXHRcdFx0cmV0dXJuIHRydWU7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiBmYWxzZTtcblxuICAgIFx0fSxcblxuICAgIFx0cmVtb3ZlRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gKCB0eXBlLCBsaXN0ZW5lciApIHtcblxuICAgIFx0XHRpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xuXG4gICAgXHRcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG4gICAgXHRcdHZhciBsaXN0ZW5lckFycmF5ID0gbGlzdGVuZXJzWyB0eXBlIF07XG5cbiAgICBcdFx0aWYgKCBsaXN0ZW5lckFycmF5ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHR2YXIgaW5kZXggPSBsaXN0ZW5lckFycmF5LmluZGV4T2YoIGxpc3RlbmVyICk7XG5cbiAgICBcdFx0XHRpZiAoIGluZGV4ICE9PSAtIDEgKSB7XG5cbiAgICBcdFx0XHRcdGxpc3RlbmVyQXJyYXkuc3BsaWNlKCBpbmRleCwgMSApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0fSxcblxuICAgIFx0ZGlzcGF0Y2hFdmVudDogZnVuY3Rpb24gKCBldmVudCApIHtcblxuICAgIFx0XHRpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xuXG4gICAgXHRcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG4gICAgXHRcdHZhciBsaXN0ZW5lckFycmF5ID0gbGlzdGVuZXJzWyBldmVudC50eXBlIF07XG5cbiAgICBcdFx0aWYgKCBsaXN0ZW5lckFycmF5ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRldmVudC50YXJnZXQgPSB0aGlzO1xuXG4gICAgXHRcdFx0dmFyIGFycmF5ID0gW10sIGkgPSAwO1xuICAgIFx0XHRcdHZhciBsZW5ndGggPSBsaXN0ZW5lckFycmF5Lmxlbmd0aDtcblxuICAgIFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICsrICkge1xuXG4gICAgXHRcdFx0XHRhcnJheVsgaSBdID0gbGlzdGVuZXJBcnJheVsgaSBdO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW5ndGg7IGkgKysgKSB7XG5cbiAgICBcdFx0XHRcdGFycmF5WyBpIF0uY2FsbCggdGhpcywgZXZlbnQgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdH1cblxuICAgIH0gKTtcblxuICAgIHZhciBSRVZJU0lPTiA9ICc4MSc7XG4gICAgdmFyIE1PVVNFID0geyBMRUZUOiAwLCBNSURETEU6IDEsIFJJR0hUOiAyIH07XG4gICAgdmFyIEN1bGxGYWNlTm9uZSA9IDA7XG4gICAgdmFyIEN1bGxGYWNlQmFjayA9IDE7XG4gICAgdmFyIEN1bGxGYWNlRnJvbnQgPSAyO1xuICAgIHZhciBDdWxsRmFjZUZyb250QmFjayA9IDM7XG4gICAgdmFyIEZyb250RmFjZURpcmVjdGlvbkNXID0gMDtcbiAgICB2YXIgRnJvbnRGYWNlRGlyZWN0aW9uQ0NXID0gMTtcbiAgICB2YXIgQmFzaWNTaGFkb3dNYXAgPSAwO1xuICAgIHZhciBQQ0ZTaGFkb3dNYXAgPSAxO1xuICAgIHZhciBQQ0ZTb2Z0U2hhZG93TWFwID0gMjtcbiAgICB2YXIgRnJvbnRTaWRlID0gMDtcbiAgICB2YXIgQmFja1NpZGUgPSAxO1xuICAgIHZhciBEb3VibGVTaWRlID0gMjtcbiAgICB2YXIgRmxhdFNoYWRpbmcgPSAxO1xuICAgIHZhciBTbW9vdGhTaGFkaW5nID0gMjtcbiAgICB2YXIgTm9Db2xvcnMgPSAwO1xuICAgIHZhciBGYWNlQ29sb3JzID0gMTtcbiAgICB2YXIgVmVydGV4Q29sb3JzID0gMjtcbiAgICB2YXIgTm9CbGVuZGluZyA9IDA7XG4gICAgdmFyIE5vcm1hbEJsZW5kaW5nID0gMTtcbiAgICB2YXIgQWRkaXRpdmVCbGVuZGluZyA9IDI7XG4gICAgdmFyIFN1YnRyYWN0aXZlQmxlbmRpbmcgPSAzO1xuICAgIHZhciBNdWx0aXBseUJsZW5kaW5nID0gNDtcbiAgICB2YXIgQ3VzdG9tQmxlbmRpbmcgPSA1O1xuICAgIHZhciBCbGVuZGluZ01vZGUgPSB7XG4gICAgICAgIE5vQmxlbmRpbmc6IE5vQmxlbmRpbmcsXG4gICAgICAgIE5vcm1hbEJsZW5kaW5nOiBOb3JtYWxCbGVuZGluZyxcbiAgICAgICAgQWRkaXRpdmVCbGVuZGluZzogQWRkaXRpdmVCbGVuZGluZyxcbiAgICAgICAgU3VidHJhY3RpdmVCbGVuZGluZzogU3VidHJhY3RpdmVCbGVuZGluZyxcbiAgICAgICAgTXVsdGlwbHlCbGVuZGluZzogTXVsdGlwbHlCbGVuZGluZyxcbiAgICAgICAgQ3VzdG9tQmxlbmRpbmc6IEN1c3RvbUJsZW5kaW5nXG4gICAgfTtcbiAgICB2YXIgQWRkRXF1YXRpb24gPSAxMDA7XG4gICAgdmFyIFN1YnRyYWN0RXF1YXRpb24gPSAxMDE7XG4gICAgdmFyIFJldmVyc2VTdWJ0cmFjdEVxdWF0aW9uID0gMTAyO1xuICAgIHZhciBNaW5FcXVhdGlvbiA9IDEwMztcbiAgICB2YXIgTWF4RXF1YXRpb24gPSAxMDQ7XG4gICAgdmFyIFplcm9GYWN0b3IgPSAyMDA7XG4gICAgdmFyIE9uZUZhY3RvciA9IDIwMTtcbiAgICB2YXIgU3JjQ29sb3JGYWN0b3IgPSAyMDI7XG4gICAgdmFyIE9uZU1pbnVzU3JjQ29sb3JGYWN0b3IgPSAyMDM7XG4gICAgdmFyIFNyY0FscGhhRmFjdG9yID0gMjA0O1xuICAgIHZhciBPbmVNaW51c1NyY0FscGhhRmFjdG9yID0gMjA1O1xuICAgIHZhciBEc3RBbHBoYUZhY3RvciA9IDIwNjtcbiAgICB2YXIgT25lTWludXNEc3RBbHBoYUZhY3RvciA9IDIwNztcbiAgICB2YXIgRHN0Q29sb3JGYWN0b3IgPSAyMDg7XG4gICAgdmFyIE9uZU1pbnVzRHN0Q29sb3JGYWN0b3IgPSAyMDk7XG4gICAgdmFyIFNyY0FscGhhU2F0dXJhdGVGYWN0b3IgPSAyMTA7XG4gICAgdmFyIE5ldmVyRGVwdGggPSAwO1xuICAgIHZhciBBbHdheXNEZXB0aCA9IDE7XG4gICAgdmFyIExlc3NEZXB0aCA9IDI7XG4gICAgdmFyIExlc3NFcXVhbERlcHRoID0gMztcbiAgICB2YXIgRXF1YWxEZXB0aCA9IDQ7XG4gICAgdmFyIEdyZWF0ZXJFcXVhbERlcHRoID0gNTtcbiAgICB2YXIgR3JlYXRlckRlcHRoID0gNjtcbiAgICB2YXIgTm90RXF1YWxEZXB0aCA9IDc7XG4gICAgdmFyIE11bHRpcGx5T3BlcmF0aW9uID0gMDtcbiAgICB2YXIgTWl4T3BlcmF0aW9uID0gMTtcbiAgICB2YXIgQWRkT3BlcmF0aW9uID0gMjtcbiAgICB2YXIgTm9Ub25lTWFwcGluZyA9IDA7XG4gICAgdmFyIExpbmVhclRvbmVNYXBwaW5nID0gMTtcbiAgICB2YXIgUmVpbmhhcmRUb25lTWFwcGluZyA9IDI7XG4gICAgdmFyIFVuY2hhcnRlZDJUb25lTWFwcGluZyA9IDM7XG4gICAgdmFyIENpbmVvblRvbmVNYXBwaW5nID0gNDtcbiAgICB2YXIgVVZNYXBwaW5nID0gMzAwO1xuICAgIHZhciBDdWJlUmVmbGVjdGlvbk1hcHBpbmcgPSAzMDE7XG4gICAgdmFyIEN1YmVSZWZyYWN0aW9uTWFwcGluZyA9IDMwMjtcbiAgICB2YXIgRXF1aXJlY3Rhbmd1bGFyUmVmbGVjdGlvbk1hcHBpbmcgPSAzMDM7XG4gICAgdmFyIEVxdWlyZWN0YW5ndWxhclJlZnJhY3Rpb25NYXBwaW5nID0gMzA0O1xuICAgIHZhciBTcGhlcmljYWxSZWZsZWN0aW9uTWFwcGluZyA9IDMwNTtcbiAgICB2YXIgQ3ViZVVWUmVmbGVjdGlvbk1hcHBpbmcgPSAzMDY7XG4gICAgdmFyIEN1YmVVVlJlZnJhY3Rpb25NYXBwaW5nID0gMzA3O1xuICAgIHZhciBUZXh0dXJlTWFwcGluZyA9IHtcbiAgICAgICAgVVZNYXBwaW5nOiBVVk1hcHBpbmcsXG4gICAgICAgIEN1YmVSZWZsZWN0aW9uTWFwcGluZzogQ3ViZVJlZmxlY3Rpb25NYXBwaW5nLFxuICAgICAgICBDdWJlUmVmcmFjdGlvbk1hcHBpbmc6IEN1YmVSZWZyYWN0aW9uTWFwcGluZyxcbiAgICAgICAgRXF1aXJlY3Rhbmd1bGFyUmVmbGVjdGlvbk1hcHBpbmc6IEVxdWlyZWN0YW5ndWxhclJlZmxlY3Rpb25NYXBwaW5nLFxuICAgICAgICBFcXVpcmVjdGFuZ3VsYXJSZWZyYWN0aW9uTWFwcGluZzogRXF1aXJlY3Rhbmd1bGFyUmVmcmFjdGlvbk1hcHBpbmcsXG4gICAgICAgIFNwaGVyaWNhbFJlZmxlY3Rpb25NYXBwaW5nOiBTcGhlcmljYWxSZWZsZWN0aW9uTWFwcGluZyxcbiAgICAgICAgQ3ViZVVWUmVmbGVjdGlvbk1hcHBpbmc6IEN1YmVVVlJlZmxlY3Rpb25NYXBwaW5nLFxuICAgICAgICBDdWJlVVZSZWZyYWN0aW9uTWFwcGluZzogQ3ViZVVWUmVmcmFjdGlvbk1hcHBpbmdcbiAgICB9O1xuICAgIHZhciBSZXBlYXRXcmFwcGluZyA9IDEwMDA7XG4gICAgdmFyIENsYW1wVG9FZGdlV3JhcHBpbmcgPSAxMDAxO1xuICAgIHZhciBNaXJyb3JlZFJlcGVhdFdyYXBwaW5nID0gMTAwMjtcbiAgICB2YXIgVGV4dHVyZVdyYXBwaW5nID0ge1xuICAgICAgICBSZXBlYXRXcmFwcGluZzogUmVwZWF0V3JhcHBpbmcsXG4gICAgICAgIENsYW1wVG9FZGdlV3JhcHBpbmc6IENsYW1wVG9FZGdlV3JhcHBpbmcsXG4gICAgICAgIE1pcnJvcmVkUmVwZWF0V3JhcHBpbmc6IE1pcnJvcmVkUmVwZWF0V3JhcHBpbmdcbiAgICB9O1xuICAgIHZhciBOZWFyZXN0RmlsdGVyID0gMTAwMztcbiAgICB2YXIgTmVhcmVzdE1pcE1hcE5lYXJlc3RGaWx0ZXIgPSAxMDA0O1xuICAgIHZhciBOZWFyZXN0TWlwTWFwTGluZWFyRmlsdGVyID0gMTAwNTtcbiAgICB2YXIgTGluZWFyRmlsdGVyID0gMTAwNjtcbiAgICB2YXIgTGluZWFyTWlwTWFwTmVhcmVzdEZpbHRlciA9IDEwMDc7XG4gICAgdmFyIExpbmVhck1pcE1hcExpbmVhckZpbHRlciA9IDEwMDg7XG4gICAgdmFyIFRleHR1cmVGaWx0ZXIgPSB7XG4gICAgICAgIE5lYXJlc3RGaWx0ZXI6IE5lYXJlc3RGaWx0ZXIsXG4gICAgICAgIE5lYXJlc3RNaXBNYXBOZWFyZXN0RmlsdGVyOiBOZWFyZXN0TWlwTWFwTmVhcmVzdEZpbHRlcixcbiAgICAgICAgTmVhcmVzdE1pcE1hcExpbmVhckZpbHRlcjogTmVhcmVzdE1pcE1hcExpbmVhckZpbHRlcixcbiAgICAgICAgTGluZWFyRmlsdGVyOiBMaW5lYXJGaWx0ZXIsXG4gICAgICAgIExpbmVhck1pcE1hcE5lYXJlc3RGaWx0ZXI6IExpbmVhck1pcE1hcE5lYXJlc3RGaWx0ZXIsXG4gICAgICAgIExpbmVhck1pcE1hcExpbmVhckZpbHRlcjogTGluZWFyTWlwTWFwTGluZWFyRmlsdGVyXG4gICAgfTtcbiAgICB2YXIgVW5zaWduZWRCeXRlVHlwZSA9IDEwMDk7XG4gICAgdmFyIEJ5dGVUeXBlID0gMTAxMDtcbiAgICB2YXIgU2hvcnRUeXBlID0gMTAxMTtcbiAgICB2YXIgVW5zaWduZWRTaG9ydFR5cGUgPSAxMDEyO1xuICAgIHZhciBJbnRUeXBlID0gMTAxMztcbiAgICB2YXIgVW5zaWduZWRJbnRUeXBlID0gMTAxNDtcbiAgICB2YXIgRmxvYXRUeXBlID0gMTAxNTtcbiAgICB2YXIgSGFsZkZsb2F0VHlwZSA9IDEwMTY7XG4gICAgdmFyIFVuc2lnbmVkU2hvcnQ0NDQ0VHlwZSA9IDEwMTc7XG4gICAgdmFyIFVuc2lnbmVkU2hvcnQ1NTUxVHlwZSA9IDEwMTg7XG4gICAgdmFyIFVuc2lnbmVkU2hvcnQ1NjVUeXBlID0gMTAxOTtcbiAgICB2YXIgVW5zaWduZWRJbnQyNDhUeXBlID0gMTAyMDtcbiAgICB2YXIgQWxwaGFGb3JtYXQgPSAxMDIxO1xuICAgIHZhciBSR0JGb3JtYXQgPSAxMDIyO1xuICAgIHZhciBSR0JBRm9ybWF0ID0gMTAyMztcbiAgICB2YXIgTHVtaW5hbmNlRm9ybWF0ID0gMTAyNDtcbiAgICB2YXIgTHVtaW5hbmNlQWxwaGFGb3JtYXQgPSAxMDI1O1xuICAgIHZhciBSR0JFRm9ybWF0ID0gUkdCQUZvcm1hdDtcbiAgICB2YXIgRGVwdGhGb3JtYXQgPSAxMDI2O1xuICAgIHZhciBEZXB0aFN0ZW5jaWxGb3JtYXQgPSAxMDI3O1xuICAgIHZhciBSR0JfUzNUQ19EWFQxX0Zvcm1hdCA9IDIwMDE7XG4gICAgdmFyIFJHQkFfUzNUQ19EWFQxX0Zvcm1hdCA9IDIwMDI7XG4gICAgdmFyIFJHQkFfUzNUQ19EWFQzX0Zvcm1hdCA9IDIwMDM7XG4gICAgdmFyIFJHQkFfUzNUQ19EWFQ1X0Zvcm1hdCA9IDIwMDQ7XG4gICAgdmFyIFJHQl9QVlJUQ180QlBQVjFfRm9ybWF0ID0gMjEwMDtcbiAgICB2YXIgUkdCX1BWUlRDXzJCUFBWMV9Gb3JtYXQgPSAyMTAxO1xuICAgIHZhciBSR0JBX1BWUlRDXzRCUFBWMV9Gb3JtYXQgPSAyMTAyO1xuICAgIHZhciBSR0JBX1BWUlRDXzJCUFBWMV9Gb3JtYXQgPSAyMTAzO1xuICAgIHZhciBSR0JfRVRDMV9Gb3JtYXQgPSAyMTUxO1xuICAgIHZhciBMb29wT25jZSA9IDIyMDA7XG4gICAgdmFyIExvb3BSZXBlYXQgPSAyMjAxO1xuICAgIHZhciBMb29wUGluZ1BvbmcgPSAyMjAyO1xuICAgIHZhciBJbnRlcnBvbGF0ZURpc2NyZXRlID0gMjMwMDtcbiAgICB2YXIgSW50ZXJwb2xhdGVMaW5lYXIgPSAyMzAxO1xuICAgIHZhciBJbnRlcnBvbGF0ZVNtb290aCA9IDIzMDI7XG4gICAgdmFyIFplcm9DdXJ2YXR1cmVFbmRpbmcgPSAyNDAwO1xuICAgIHZhciBaZXJvU2xvcGVFbmRpbmcgPSAyNDAxO1xuICAgIHZhciBXcmFwQXJvdW5kRW5kaW5nID0gMjQwMjtcbiAgICB2YXIgVHJpYW5nbGVzRHJhd01vZGUgPSAwO1xuICAgIHZhciBUcmlhbmdsZVN0cmlwRHJhd01vZGUgPSAxO1xuICAgIHZhciBUcmlhbmdsZUZhbkRyYXdNb2RlID0gMjtcbiAgICB2YXIgTGluZWFyRW5jb2RpbmcgPSAzMDAwO1xuICAgIHZhciBzUkdCRW5jb2RpbmcgPSAzMDAxO1xuICAgIHZhciBHYW1tYUVuY29kaW5nID0gMzAwNztcbiAgICB2YXIgUkdCRUVuY29kaW5nID0gMzAwMjtcbiAgICB2YXIgTG9nTHV2RW5jb2RpbmcgPSAzMDAzO1xuICAgIHZhciBSR0JNN0VuY29kaW5nID0gMzAwNDtcbiAgICB2YXIgUkdCTTE2RW5jb2RpbmcgPSAzMDA1O1xuICAgIHZhciBSR0JERW5jb2RpbmcgPSAzMDA2O1xuICAgIHZhciBCYXNpY0RlcHRoUGFja2luZyA9IDMyMDA7XG4gICAgdmFyIFJHQkFEZXB0aFBhY2tpbmcgPSAzMjAxO1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAgICAgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICAgICAqL1xuXG4gICAgZXhwb3J0cy5NYXRoID0ge1xuXG4gICAgXHRERUcyUkFEOiBNYXRoLlBJIC8gMTgwLFxuICAgIFx0UkFEMkRFRzogMTgwIC8gTWF0aC5QSSxcblxuICAgIFx0Z2VuZXJhdGVVVUlEOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0Ly8gaHR0cDovL3d3dy5icm9vZmEuY29tL1Rvb2xzL01hdGgudXVpZC5odG1cblxuICAgIFx0XHR2YXIgY2hhcnMgPSAnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXonLnNwbGl0KCAnJyApO1xuICAgIFx0XHR2YXIgdXVpZCA9IG5ldyBBcnJheSggMzYgKTtcbiAgICBcdFx0dmFyIHJuZCA9IDAsIHI7XG5cbiAgICBcdFx0cmV0dXJuIGZ1bmN0aW9uIGdlbmVyYXRlVVVJRCgpIHtcblxuICAgIFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IDM2OyBpICsrICkge1xuXG4gICAgXHRcdFx0XHRpZiAoIGkgPT09IDggfHwgaSA9PT0gMTMgfHwgaSA9PT0gMTggfHwgaSA9PT0gMjMgKSB7XG5cbiAgICBcdFx0XHRcdFx0dXVpZFsgaSBdID0gJy0nO1xuXG4gICAgXHRcdFx0XHR9IGVsc2UgaWYgKCBpID09PSAxNCApIHtcblxuICAgIFx0XHRcdFx0XHR1dWlkWyBpIF0gPSAnNCc7XG5cbiAgICBcdFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdFx0aWYgKCBybmQgPD0gMHgwMiApIHJuZCA9IDB4MjAwMDAwMCArICggTWF0aC5yYW5kb20oKSAqIDB4MTAwMDAwMCApIHwgMDtcbiAgICBcdFx0XHRcdFx0ciA9IHJuZCAmIDB4ZjtcbiAgICBcdFx0XHRcdFx0cm5kID0gcm5kID4+IDQ7XG4gICAgXHRcdFx0XHRcdHV1aWRbIGkgXSA9IGNoYXJzWyAoIGkgPT09IDE5ICkgPyAoIHIgJiAweDMgKSB8IDB4OCA6IHIgXTtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0cmV0dXJuIHV1aWQuam9pbiggJycgKTtcblxuICAgIFx0XHR9O1xuXG4gICAgXHR9KCksXG5cbiAgICBcdGNsYW1wOiBmdW5jdGlvbiAoIHZhbHVlLCBtaW4sIG1heCApIHtcblxuICAgIFx0XHRyZXR1cm4gTWF0aC5tYXgoIG1pbiwgTWF0aC5taW4oIG1heCwgdmFsdWUgKSApO1xuXG4gICAgXHR9LFxuXG4gICAgXHQvLyBjb21wdXRlIGV1Y2xpZGlhbiBtb2R1bG8gb2YgbSAlIG5cbiAgICBcdC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01vZHVsb19vcGVyYXRpb25cblxuICAgIFx0ZXVjbGlkZWFuTW9kdWxvOiBmdW5jdGlvbiAoIG4sIG0gKSB7XG5cbiAgICBcdFx0cmV0dXJuICggKCBuICUgbSApICsgbSApICUgbTtcblxuICAgIFx0fSxcblxuICAgIFx0Ly8gTGluZWFyIG1hcHBpbmcgZnJvbSByYW5nZSA8YTEsIGEyPiB0byByYW5nZSA8YjEsIGIyPlxuXG4gICAgXHRtYXBMaW5lYXI6IGZ1bmN0aW9uICggeCwgYTEsIGEyLCBiMSwgYjIgKSB7XG5cbiAgICBcdFx0cmV0dXJuIGIxICsgKCB4IC0gYTEgKSAqICggYjIgLSBiMSApIC8gKCBhMiAtIGExICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU21vb3Roc3RlcFxuXG4gICAgXHRzbW9vdGhzdGVwOiBmdW5jdGlvbiAoIHgsIG1pbiwgbWF4ICkge1xuXG4gICAgXHRcdGlmICggeCA8PSBtaW4gKSByZXR1cm4gMDtcbiAgICBcdFx0aWYgKCB4ID49IG1heCApIHJldHVybiAxO1xuXG4gICAgXHRcdHggPSAoIHggLSBtaW4gKSAvICggbWF4IC0gbWluICk7XG5cbiAgICBcdFx0cmV0dXJuIHggKiB4ICogKCAzIC0gMiAqIHggKTtcblxuICAgIFx0fSxcblxuICAgIFx0c21vb3RoZXJzdGVwOiBmdW5jdGlvbiAoIHgsIG1pbiwgbWF4ICkge1xuXG4gICAgXHRcdGlmICggeCA8PSBtaW4gKSByZXR1cm4gMDtcbiAgICBcdFx0aWYgKCB4ID49IG1heCApIHJldHVybiAxO1xuXG4gICAgXHRcdHggPSAoIHggLSBtaW4gKSAvICggbWF4IC0gbWluICk7XG5cbiAgICBcdFx0cmV0dXJuIHggKiB4ICogeCAqICggeCAqICggeCAqIDYgLSAxNSApICsgMTAgKTtcblxuICAgIFx0fSxcblxuICAgIFx0cmFuZG9tMTY6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRoLnJhbmRvbTE2KCkgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIE1hdGgucmFuZG9tKCkgaW5zdGVhZC4nICk7XG4gICAgXHRcdHJldHVybiBNYXRoLnJhbmRvbSgpO1xuXG4gICAgXHR9LFxuXG4gICAgXHQvLyBSYW5kb20gaW50ZWdlciBmcm9tIDxsb3csIGhpZ2g+IGludGVydmFsXG5cbiAgICBcdHJhbmRJbnQ6IGZ1bmN0aW9uICggbG93LCBoaWdoICkge1xuXG4gICAgXHRcdHJldHVybiBsb3cgKyBNYXRoLmZsb29yKCBNYXRoLnJhbmRvbSgpICogKCBoaWdoIC0gbG93ICsgMSApICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdC8vIFJhbmRvbSBmbG9hdCBmcm9tIDxsb3csIGhpZ2g+IGludGVydmFsXG5cbiAgICBcdHJhbmRGbG9hdDogZnVuY3Rpb24gKCBsb3csIGhpZ2ggKSB7XG5cbiAgICBcdFx0cmV0dXJuIGxvdyArIE1hdGgucmFuZG9tKCkgKiAoIGhpZ2ggLSBsb3cgKTtcblxuICAgIFx0fSxcblxuICAgIFx0Ly8gUmFuZG9tIGZsb2F0IGZyb20gPC1yYW5nZS8yLCByYW5nZS8yPiBpbnRlcnZhbFxuXG4gICAgXHRyYW5kRmxvYXRTcHJlYWQ6IGZ1bmN0aW9uICggcmFuZ2UgKSB7XG5cbiAgICBcdFx0cmV0dXJuIHJhbmdlICogKCAwLjUgLSBNYXRoLnJhbmRvbSgpICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGRlZ1RvUmFkOiBmdW5jdGlvbiAoIGRlZ3JlZXMgKSB7XG5cbiAgICBcdFx0cmV0dXJuIGRlZ3JlZXMgKiBleHBvcnRzLk1hdGguREVHMlJBRDtcblxuICAgIFx0fSxcblxuICAgIFx0cmFkVG9EZWc6IGZ1bmN0aW9uICggcmFkaWFucyApIHtcblxuICAgIFx0XHRyZXR1cm4gcmFkaWFucyAqIGV4cG9ydHMuTWF0aC5SQUQyREVHO1xuXG4gICAgXHR9LFxuXG4gICAgXHRpc1Bvd2VyT2ZUd286IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cbiAgICBcdFx0cmV0dXJuICggdmFsdWUgJiAoIHZhbHVlIC0gMSApICkgPT09IDAgJiYgdmFsdWUgIT09IDA7XG5cbiAgICBcdH0sXG5cbiAgICBcdG5lYXJlc3RQb3dlck9mVHdvOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG4gICAgXHRcdHJldHVybiBNYXRoLnBvdyggMiwgTWF0aC5yb3VuZCggTWF0aC5sb2coIHZhbHVlICkgLyBNYXRoLkxOMiApICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdG5leHRQb3dlck9mVHdvOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG4gICAgXHRcdHZhbHVlIC0tO1xuICAgIFx0XHR2YWx1ZSB8PSB2YWx1ZSA+PiAxO1xuICAgIFx0XHR2YWx1ZSB8PSB2YWx1ZSA+PiAyO1xuICAgIFx0XHR2YWx1ZSB8PSB2YWx1ZSA+PiA0O1xuICAgIFx0XHR2YWx1ZSB8PSB2YWx1ZSA+PiA4O1xuICAgIFx0XHR2YWx1ZSB8PSB2YWx1ZSA+PiAxNjtcbiAgICBcdFx0dmFsdWUgKys7XG5cbiAgICBcdFx0cmV0dXJuIHZhbHVlO1xuXG4gICAgXHR9XG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAgICAgKiBAYXV0aG9yIHBoaWxvZ2IgLyBodHRwOi8vYmxvZy50aGVqaXQub3JnL1xuICAgICAqIEBhdXRob3IgZWdyYWV0aGVyIC8gaHR0cDovL2VncmFldGhlci5jb20vXG4gICAgICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gVmVjdG9yMiggeCwgeSApIHtcblxuICAgIFx0dGhpcy54ID0geCB8fCAwO1xuICAgIFx0dGhpcy55ID0geSB8fCAwO1xuXG4gICAgfVxuXG4gICAgVmVjdG9yMi5wcm90b3R5cGUgPSB7XG5cbiAgICBcdGNvbnN0cnVjdG9yOiBWZWN0b3IyLFxuXG4gICAgXHRpc1ZlY3RvcjI6IHRydWUsXG5cbiAgICBcdGdldCB3aWR0aCgpIHtcblxuICAgIFx0XHRyZXR1cm4gdGhpcy54O1xuXG4gICAgXHR9LFxuXG4gICAgXHRzZXQgd2lkdGgoIHZhbHVlICkge1xuXG4gICAgXHRcdHRoaXMueCA9IHZhbHVlO1xuXG4gICAgXHR9LFxuXG4gICAgXHRnZXQgaGVpZ2h0KCkge1xuXG4gICAgXHRcdHJldHVybiB0aGlzLnk7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldCBoZWlnaHQoIHZhbHVlICkge1xuXG4gICAgXHRcdHRoaXMueSA9IHZhbHVlO1xuXG4gICAgXHR9LFxuXG4gICAgXHQvL1xuXG4gICAgXHRzZXQ6IGZ1bmN0aW9uICggeCwgeSApIHtcblxuICAgIFx0XHR0aGlzLnggPSB4O1xuICAgIFx0XHR0aGlzLnkgPSB5O1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzZXRTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xuXG4gICAgXHRcdHRoaXMueCA9IHNjYWxhcjtcbiAgICBcdFx0dGhpcy55ID0gc2NhbGFyO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzZXRYOiBmdW5jdGlvbiAoIHggKSB7XG5cbiAgICBcdFx0dGhpcy54ID0geDtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0c2V0WTogZnVuY3Rpb24gKCB5ICkge1xuXG4gICAgXHRcdHRoaXMueSA9IHk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldENvbXBvbmVudDogZnVuY3Rpb24gKCBpbmRleCwgdmFsdWUgKSB7XG5cbiAgICBcdFx0c3dpdGNoICggaW5kZXggKSB7XG5cbiAgICBcdFx0XHRjYXNlIDA6IHRoaXMueCA9IHZhbHVlOyBicmVhaztcbiAgICBcdFx0XHRjYXNlIDE6IHRoaXMueSA9IHZhbHVlOyBicmVhaztcbiAgICBcdFx0XHRkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0fSxcblxuICAgIFx0Z2V0Q29tcG9uZW50OiBmdW5jdGlvbiAoIGluZGV4ICkge1xuXG4gICAgXHRcdHN3aXRjaCAoIGluZGV4ICkge1xuXG4gICAgXHRcdFx0Y2FzZSAwOiByZXR1cm4gdGhpcy54O1xuICAgIFx0XHRcdGNhc2UgMTogcmV0dXJuIHRoaXMueTtcbiAgICBcdFx0XHRkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0fSxcblxuICAgIFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMueCwgdGhpcy55ICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGNvcHk6IGZ1bmN0aW9uICggdiApIHtcblxuICAgIFx0XHR0aGlzLnggPSB2Lng7XG4gICAgXHRcdHRoaXMueSA9IHYueTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0YWRkOiBmdW5jdGlvbiAoIHYsIHcgKSB7XG5cbiAgICBcdFx0aWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IyOiAuYWRkKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuYWRkVmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyApO1xuICAgIFx0XHRcdHJldHVybiB0aGlzLmFkZFZlY3RvcnMoIHYsIHcgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0dGhpcy54ICs9IHYueDtcbiAgICBcdFx0dGhpcy55ICs9IHYueTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0YWRkU2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XG5cbiAgICBcdFx0dGhpcy54ICs9IHM7XG4gICAgXHRcdHRoaXMueSArPSBzO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRhZGRWZWN0b3JzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XG5cbiAgICBcdFx0dGhpcy54ID0gYS54ICsgYi54O1xuICAgIFx0XHR0aGlzLnkgPSBhLnkgKyBiLnk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGFkZFNjYWxlZFZlY3RvcjogZnVuY3Rpb24gKCB2LCBzICkge1xuXG4gICAgXHRcdHRoaXMueCArPSB2LnggKiBzO1xuICAgIFx0XHR0aGlzLnkgKz0gdi55ICogcztcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0c3ViOiBmdW5jdGlvbiAoIHYsIHcgKSB7XG5cbiAgICBcdFx0aWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IyOiAuc3ViKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuc3ViVmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyApO1xuICAgIFx0XHRcdHJldHVybiB0aGlzLnN1YlZlY3RvcnMoIHYsIHcgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0dGhpcy54IC09IHYueDtcbiAgICBcdFx0dGhpcy55IC09IHYueTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0c3ViU2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XG5cbiAgICBcdFx0dGhpcy54IC09IHM7XG4gICAgXHRcdHRoaXMueSAtPSBzO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzdWJWZWN0b3JzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XG5cbiAgICBcdFx0dGhpcy54ID0gYS54IC0gYi54O1xuICAgIFx0XHR0aGlzLnkgPSBhLnkgLSBiLnk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdG11bHRpcGx5OiBmdW5jdGlvbiAoIHYgKSB7XG5cbiAgICBcdFx0dGhpcy54ICo9IHYueDtcbiAgICBcdFx0dGhpcy55ICo9IHYueTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0bXVsdGlwbHlTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xuXG4gICAgXHRcdGlmICggaXNGaW5pdGUoIHNjYWxhciApICkge1xuXG4gICAgXHRcdFx0dGhpcy54ICo9IHNjYWxhcjtcbiAgICBcdFx0XHR0aGlzLnkgKj0gc2NhbGFyO1xuXG4gICAgXHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHR0aGlzLnggPSAwO1xuICAgIFx0XHRcdHRoaXMueSA9IDA7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRkaXZpZGU6IGZ1bmN0aW9uICggdiApIHtcblxuICAgIFx0XHR0aGlzLnggLz0gdi54O1xuICAgIFx0XHR0aGlzLnkgLz0gdi55O1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRkaXZpZGVTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xuXG4gICAgXHRcdHJldHVybiB0aGlzLm11bHRpcGx5U2NhbGFyKCAxIC8gc2NhbGFyICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdG1pbjogZnVuY3Rpb24gKCB2ICkge1xuXG4gICAgXHRcdHRoaXMueCA9IE1hdGgubWluKCB0aGlzLngsIHYueCApO1xuICAgIFx0XHR0aGlzLnkgPSBNYXRoLm1pbiggdGhpcy55LCB2LnkgKTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0bWF4OiBmdW5jdGlvbiAoIHYgKSB7XG5cbiAgICBcdFx0dGhpcy54ID0gTWF0aC5tYXgoIHRoaXMueCwgdi54ICk7XG4gICAgXHRcdHRoaXMueSA9IE1hdGgubWF4KCB0aGlzLnksIHYueSApO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRjbGFtcDogZnVuY3Rpb24gKCBtaW4sIG1heCApIHtcblxuICAgIFx0XHQvLyBUaGlzIGZ1bmN0aW9uIGFzc3VtZXMgbWluIDwgbWF4LCBpZiB0aGlzIGFzc3VtcHRpb24gaXNuJ3QgdHJ1ZSBpdCB3aWxsIG5vdCBvcGVyYXRlIGNvcnJlY3RseVxuXG4gICAgXHRcdHRoaXMueCA9IE1hdGgubWF4KCBtaW4ueCwgTWF0aC5taW4oIG1heC54LCB0aGlzLnggKSApO1xuICAgIFx0XHR0aGlzLnkgPSBNYXRoLm1heCggbWluLnksIE1hdGgubWluKCBtYXgueSwgdGhpcy55ICkgKTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0Y2xhbXBTY2FsYXI6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR2YXIgbWluLCBtYXg7XG5cbiAgICBcdFx0cmV0dXJuIGZ1bmN0aW9uIGNsYW1wU2NhbGFyKCBtaW5WYWwsIG1heFZhbCApIHtcblxuICAgIFx0XHRcdGlmICggbWluID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRcdG1pbiA9IG5ldyBWZWN0b3IyKCk7XG4gICAgXHRcdFx0XHRtYXggPSBuZXcgVmVjdG9yMigpO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0bWluLnNldCggbWluVmFsLCBtaW5WYWwgKTtcbiAgICBcdFx0XHRtYXguc2V0KCBtYXhWYWwsIG1heFZhbCApO1xuXG4gICAgXHRcdFx0cmV0dXJuIHRoaXMuY2xhbXAoIG1pbiwgbWF4ICk7XG5cbiAgICBcdFx0fTtcblxuICAgIFx0fSgpLFxuXG4gICAgXHRjbGFtcExlbmd0aDogZnVuY3Rpb24gKCBtaW4sIG1heCApIHtcblxuICAgIFx0XHR2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGgoKTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseVNjYWxhciggTWF0aC5tYXgoIG1pbiwgTWF0aC5taW4oIG1heCwgbGVuZ3RoICkgKSAvIGxlbmd0aCApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRmbG9vcjogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHRoaXMueCA9IE1hdGguZmxvb3IoIHRoaXMueCApO1xuICAgIFx0XHR0aGlzLnkgPSBNYXRoLmZsb29yKCB0aGlzLnkgKTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0Y2VpbDogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHRoaXMueCA9IE1hdGguY2VpbCggdGhpcy54ICk7XG4gICAgXHRcdHRoaXMueSA9IE1hdGguY2VpbCggdGhpcy55ICk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdHJvdW5kOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dGhpcy54ID0gTWF0aC5yb3VuZCggdGhpcy54ICk7XG4gICAgXHRcdHRoaXMueSA9IE1hdGgucm91bmQoIHRoaXMueSApO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRyb3VuZFRvWmVybzogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHRoaXMueCA9ICggdGhpcy54IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnggKSA6IE1hdGguZmxvb3IoIHRoaXMueCApO1xuICAgIFx0XHR0aGlzLnkgPSAoIHRoaXMueSA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy55ICkgOiBNYXRoLmZsb29yKCB0aGlzLnkgKTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0bmVnYXRlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dGhpcy54ID0gLSB0aGlzLng7XG4gICAgXHRcdHRoaXMueSA9IC0gdGhpcy55O1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRkb3Q6IGZ1bmN0aW9uICggdiApIHtcblxuICAgIFx0XHRyZXR1cm4gdGhpcy54ICogdi54ICsgdGhpcy55ICogdi55O1xuXG4gICAgXHR9LFxuXG4gICAgXHRsZW5ndGhTcTogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHJldHVybiB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGxlbmd0aDogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRsZW5ndGhNYW5oYXR0YW46IGZ1bmN0aW9uKCkge1xuXG4gICAgXHRcdHJldHVybiBNYXRoLmFicyggdGhpcy54ICkgKyBNYXRoLmFicyggdGhpcy55ICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdG5vcm1hbGl6ZTogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHJldHVybiB0aGlzLmRpdmlkZVNjYWxhciggdGhpcy5sZW5ndGgoKSApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRhbmdsZTogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdC8vIGNvbXB1dGVzIHRoZSBhbmdsZSBpbiByYWRpYW5zIHdpdGggcmVzcGVjdCB0byB0aGUgcG9zaXRpdmUgeC1heGlzXG5cbiAgICBcdFx0dmFyIGFuZ2xlID0gTWF0aC5hdGFuMiggdGhpcy55LCB0aGlzLnggKTtcblxuICAgIFx0XHRpZiAoIGFuZ2xlIDwgMCApIGFuZ2xlICs9IDIgKiBNYXRoLlBJO1xuXG4gICAgXHRcdHJldHVybiBhbmdsZTtcblxuICAgIFx0fSxcblxuICAgIFx0ZGlzdGFuY2VUbzogZnVuY3Rpb24gKCB2ICkge1xuXG4gICAgXHRcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMuZGlzdGFuY2VUb1NxdWFyZWQoIHYgKSApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRkaXN0YW5jZVRvU3F1YXJlZDogZnVuY3Rpb24gKCB2ICkge1xuXG4gICAgXHRcdHZhciBkeCA9IHRoaXMueCAtIHYueCwgZHkgPSB0aGlzLnkgLSB2Lnk7XG4gICAgXHRcdHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcblxuICAgIFx0fSxcblxuICAgIFx0ZGlzdGFuY2VUb01hbmhhdHRhbjogZnVuY3Rpb24gKCB2ICkge1xuXG4gICAgXHRcdHJldHVybiBNYXRoLmFicyggdGhpcy54IC0gdi54ICkgKyBNYXRoLmFicyggdGhpcy55IC0gdi55ICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldExlbmd0aDogZnVuY3Rpb24gKCBsZW5ndGggKSB7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoIGxlbmd0aCAvIHRoaXMubGVuZ3RoKCkgKTtcblxuICAgIFx0fSxcblxuICAgIFx0bGVycDogZnVuY3Rpb24gKCB2LCBhbHBoYSApIHtcblxuICAgIFx0XHR0aGlzLnggKz0gKCB2LnggLSB0aGlzLnggKSAqIGFscGhhO1xuICAgIFx0XHR0aGlzLnkgKz0gKCB2LnkgLSB0aGlzLnkgKSAqIGFscGhhO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRsZXJwVmVjdG9yczogZnVuY3Rpb24gKCB2MSwgdjIsIGFscGhhICkge1xuXG4gICAgXHRcdHJldHVybiB0aGlzLnN1YlZlY3RvcnMoIHYyLCB2MSApLm11bHRpcGx5U2NhbGFyKCBhbHBoYSApLmFkZCggdjEgKTtcblxuICAgIFx0fSxcblxuICAgIFx0ZXF1YWxzOiBmdW5jdGlvbiAoIHYgKSB7XG5cbiAgICBcdFx0cmV0dXJuICggKCB2LnggPT09IHRoaXMueCApICYmICggdi55ID09PSB0aGlzLnkgKSApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRmcm9tQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcblxuICAgIFx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuICAgIFx0XHR0aGlzLnggPSBhcnJheVsgb2Zmc2V0IF07XG4gICAgXHRcdHRoaXMueSA9IGFycmF5WyBvZmZzZXQgKyAxIF07XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdHRvQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcblxuICAgIFx0XHRpZiAoIGFycmF5ID09PSB1bmRlZmluZWQgKSBhcnJheSA9IFtdO1xuICAgIFx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuICAgIFx0XHRhcnJheVsgb2Zmc2V0IF0gPSB0aGlzLng7XG4gICAgXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLnk7XG5cbiAgICBcdFx0cmV0dXJuIGFycmF5O1xuXG4gICAgXHR9LFxuXG4gICAgXHRmcm9tQXR0cmlidXRlOiBmdW5jdGlvbiAoIGF0dHJpYnV0ZSwgaW5kZXgsIG9mZnNldCApIHtcblxuICAgIFx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuICAgIFx0XHRpbmRleCA9IGluZGV4ICogYXR0cmlidXRlLml0ZW1TaXplICsgb2Zmc2V0O1xuXG4gICAgXHRcdHRoaXMueCA9IGF0dHJpYnV0ZS5hcnJheVsgaW5kZXggXTtcbiAgICBcdFx0dGhpcy55ID0gYXR0cmlidXRlLmFycmF5WyBpbmRleCArIDEgXTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0cm90YXRlQXJvdW5kOiBmdW5jdGlvbiAoIGNlbnRlciwgYW5nbGUgKSB7XG5cbiAgICBcdFx0dmFyIGMgPSBNYXRoLmNvcyggYW5nbGUgKSwgcyA9IE1hdGguc2luKCBhbmdsZSApO1xuXG4gICAgXHRcdHZhciB4ID0gdGhpcy54IC0gY2VudGVyLng7XG4gICAgXHRcdHZhciB5ID0gdGhpcy55IC0gY2VudGVyLnk7XG5cbiAgICBcdFx0dGhpcy54ID0geCAqIGMgLSB5ICogcyArIGNlbnRlci54O1xuICAgIFx0XHR0aGlzLnkgPSB4ICogcyArIHkgKiBjICsgY2VudGVyLnk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH1cblxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICAgICAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gICAgICogQGF1dGhvciBzemltZWsgLyBodHRwczovL2dpdGh1Yi5jb20vc3ppbWVrL1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gVGV4dHVyZSggaW1hZ2UsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSwgZW5jb2RpbmcgKSB7XG5cbiAgICBcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgJ2lkJywgeyB2YWx1ZTogVGV4dHVyZUlkQ291bnQoKSB9ICk7XG5cbiAgICBcdHRoaXMudXVpZCA9IGV4cG9ydHMuTWF0aC5nZW5lcmF0ZVVVSUQoKTtcblxuICAgIFx0dGhpcy5uYW1lID0gJyc7XG4gICAgXHR0aGlzLnNvdXJjZUZpbGUgPSAnJztcblxuICAgIFx0dGhpcy5pbWFnZSA9IGltYWdlICE9PSB1bmRlZmluZWQgPyBpbWFnZSA6IFRleHR1cmUuREVGQVVMVF9JTUFHRTtcbiAgICBcdHRoaXMubWlwbWFwcyA9IFtdO1xuXG4gICAgXHR0aGlzLm1hcHBpbmcgPSBtYXBwaW5nICE9PSB1bmRlZmluZWQgPyBtYXBwaW5nIDogVGV4dHVyZS5ERUZBVUxUX01BUFBJTkc7XG5cbiAgICBcdHRoaXMud3JhcFMgPSB3cmFwUyAhPT0gdW5kZWZpbmVkID8gd3JhcFMgOiBDbGFtcFRvRWRnZVdyYXBwaW5nO1xuICAgIFx0dGhpcy53cmFwVCA9IHdyYXBUICE9PSB1bmRlZmluZWQgPyB3cmFwVCA6IENsYW1wVG9FZGdlV3JhcHBpbmc7XG5cbiAgICBcdHRoaXMubWFnRmlsdGVyID0gbWFnRmlsdGVyICE9PSB1bmRlZmluZWQgPyBtYWdGaWx0ZXIgOiBMaW5lYXJGaWx0ZXI7XG4gICAgXHR0aGlzLm1pbkZpbHRlciA9IG1pbkZpbHRlciAhPT0gdW5kZWZpbmVkID8gbWluRmlsdGVyIDogTGluZWFyTWlwTWFwTGluZWFyRmlsdGVyO1xuXG4gICAgXHR0aGlzLmFuaXNvdHJvcHkgPSBhbmlzb3Ryb3B5ICE9PSB1bmRlZmluZWQgPyBhbmlzb3Ryb3B5IDogMTtcblxuICAgIFx0dGhpcy5mb3JtYXQgPSBmb3JtYXQgIT09IHVuZGVmaW5lZCA/IGZvcm1hdCA6IFJHQkFGb3JtYXQ7XG4gICAgXHR0aGlzLnR5cGUgPSB0eXBlICE9PSB1bmRlZmluZWQgPyB0eXBlIDogVW5zaWduZWRCeXRlVHlwZTtcblxuICAgIFx0dGhpcy5vZmZzZXQgPSBuZXcgVmVjdG9yMiggMCwgMCApO1xuICAgIFx0dGhpcy5yZXBlYXQgPSBuZXcgVmVjdG9yMiggMSwgMSApO1xuXG4gICAgXHR0aGlzLmdlbmVyYXRlTWlwbWFwcyA9IHRydWU7XG4gICAgXHR0aGlzLnByZW11bHRpcGx5QWxwaGEgPSBmYWxzZTtcbiAgICBcdHRoaXMuZmxpcFkgPSB0cnVlO1xuICAgIFx0dGhpcy51bnBhY2tBbGlnbm1lbnQgPSA0O1x0Ly8gdmFsaWQgdmFsdWVzOiAxLCAyLCA0LCA4IChzZWUgaHR0cDovL3d3dy5raHJvbm9zLm9yZy9vcGVuZ2xlcy9zZGsvZG9jcy9tYW4veGh0bWwvZ2xQaXhlbFN0b3JlaS54bWwpXG5cblxuICAgIFx0Ly8gVmFsdWVzIG9mIGVuY29kaW5nICE9PSBUSFJFRS5MaW5lYXJFbmNvZGluZyBvbmx5IHN1cHBvcnRlZCBvbiBtYXAsIGVudk1hcCBhbmQgZW1pc3NpdmVNYXAuXG4gICAgXHQvL1xuICAgIFx0Ly8gQWxzbyBjaGFuZ2luZyB0aGUgZW5jb2RpbmcgYWZ0ZXIgYWxyZWFkeSB1c2VkIGJ5IGEgTWF0ZXJpYWwgd2lsbCBub3QgYXV0b21hdGljYWxseSBtYWtlIHRoZSBNYXRlcmlhbFxuICAgIFx0Ly8gdXBkYXRlLiAgWW91IG5lZWQgdG8gZXhwbGljaXRseSBjYWxsIE1hdGVyaWFsLm5lZWRzVXBkYXRlIHRvIHRyaWdnZXIgaXQgdG8gcmVjb21waWxlLlxuICAgIFx0dGhpcy5lbmNvZGluZyA9IGVuY29kaW5nICE9PSB1bmRlZmluZWQgPyBlbmNvZGluZyA6ICBMaW5lYXJFbmNvZGluZztcblxuICAgIFx0dGhpcy52ZXJzaW9uID0gMDtcbiAgICBcdHRoaXMub25VcGRhdGUgPSBudWxsO1xuXG4gICAgfVxuXG4gICAgVGV4dHVyZS5ERUZBVUxUX0lNQUdFID0gdW5kZWZpbmVkO1xuICAgIFRleHR1cmUuREVGQVVMVF9NQVBQSU5HID0gVVZNYXBwaW5nO1xuXG4gICAgVGV4dHVyZS5wcm90b3R5cGUgPSB7XG5cbiAgICBcdGNvbnN0cnVjdG9yOiBUZXh0dXJlLFxuXG4gICAgXHRpc1RleHR1cmU6IHRydWUsXG5cbiAgICBcdHNldCBuZWVkc1VwZGF0ZSggdmFsdWUgKSB7XG5cbiAgICBcdFx0aWYgKCB2YWx1ZSA9PT0gdHJ1ZSApIHRoaXMudmVyc2lvbiArKztcblxuICAgIFx0fSxcblxuICAgIFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xuXG4gICAgXHRcdHRoaXMuaW1hZ2UgPSBzb3VyY2UuaW1hZ2U7XG4gICAgXHRcdHRoaXMubWlwbWFwcyA9IHNvdXJjZS5taXBtYXBzLnNsaWNlKCAwICk7XG5cbiAgICBcdFx0dGhpcy5tYXBwaW5nID0gc291cmNlLm1hcHBpbmc7XG5cbiAgICBcdFx0dGhpcy53cmFwUyA9IHNvdXJjZS53cmFwUztcbiAgICBcdFx0dGhpcy53cmFwVCA9IHNvdXJjZS53cmFwVDtcblxuICAgIFx0XHR0aGlzLm1hZ0ZpbHRlciA9IHNvdXJjZS5tYWdGaWx0ZXI7XG4gICAgXHRcdHRoaXMubWluRmlsdGVyID0gc291cmNlLm1pbkZpbHRlcjtcblxuICAgIFx0XHR0aGlzLmFuaXNvdHJvcHkgPSBzb3VyY2UuYW5pc290cm9weTtcblxuICAgIFx0XHR0aGlzLmZvcm1hdCA9IHNvdXJjZS5mb3JtYXQ7XG4gICAgXHRcdHRoaXMudHlwZSA9IHNvdXJjZS50eXBlO1xuXG4gICAgXHRcdHRoaXMub2Zmc2V0LmNvcHkoIHNvdXJjZS5vZmZzZXQgKTtcbiAgICBcdFx0dGhpcy5yZXBlYXQuY29weSggc291cmNlLnJlcGVhdCApO1xuXG4gICAgXHRcdHRoaXMuZ2VuZXJhdGVNaXBtYXBzID0gc291cmNlLmdlbmVyYXRlTWlwbWFwcztcbiAgICBcdFx0dGhpcy5wcmVtdWx0aXBseUFscGhhID0gc291cmNlLnByZW11bHRpcGx5QWxwaGE7XG4gICAgXHRcdHRoaXMuZmxpcFkgPSBzb3VyY2UuZmxpcFk7XG4gICAgXHRcdHRoaXMudW5wYWNrQWxpZ25tZW50ID0gc291cmNlLnVucGFja0FsaWdubWVudDtcbiAgICBcdFx0dGhpcy5lbmNvZGluZyA9IHNvdXJjZS5lbmNvZGluZztcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0dG9KU09OOiBmdW5jdGlvbiAoIG1ldGEgKSB7XG5cbiAgICBcdFx0aWYgKCBtZXRhLnRleHR1cmVzWyB0aGlzLnV1aWQgXSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0cmV0dXJuIG1ldGEudGV4dHVyZXNbIHRoaXMudXVpZCBdO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRmdW5jdGlvbiBnZXREYXRhVVJMKCBpbWFnZSApIHtcblxuICAgIFx0XHRcdHZhciBjYW52YXM7XG5cbiAgICBcdFx0XHRpZiAoIGltYWdlLnRvRGF0YVVSTCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0XHRjYW52YXMgPSBpbWFnZTtcblxuICAgIFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyggJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnLCAnY2FudmFzJyApO1xuICAgIFx0XHRcdFx0Y2FudmFzLndpZHRoID0gaW1hZ2Uud2lkdGg7XG4gICAgXHRcdFx0XHRjYW52YXMuaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xuXG4gICAgXHRcdFx0XHRjYW52YXMuZ2V0Q29udGV4dCggJzJkJyApLmRyYXdJbWFnZSggaW1hZ2UsIDAsIDAsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGlmICggY2FudmFzLndpZHRoID4gMjA0OCB8fCBjYW52YXMuaGVpZ2h0ID4gMjA0OCApIHtcblxuICAgIFx0XHRcdFx0cmV0dXJuIGNhbnZhcy50b0RhdGFVUkwoICdpbWFnZS9qcGVnJywgMC42ICk7XG5cbiAgICBcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRyZXR1cm4gY2FudmFzLnRvRGF0YVVSTCggJ2ltYWdlL3BuZycgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdFx0dmFyIG91dHB1dCA9IHtcbiAgICBcdFx0XHRtZXRhZGF0YToge1xuICAgIFx0XHRcdFx0dmVyc2lvbjogNC40LFxuICAgIFx0XHRcdFx0dHlwZTogJ1RleHR1cmUnLFxuICAgIFx0XHRcdFx0Z2VuZXJhdG9yOiAnVGV4dHVyZS50b0pTT04nXG4gICAgXHRcdFx0fSxcblxuICAgIFx0XHRcdHV1aWQ6IHRoaXMudXVpZCxcbiAgICBcdFx0XHRuYW1lOiB0aGlzLm5hbWUsXG5cbiAgICBcdFx0XHRtYXBwaW5nOiB0aGlzLm1hcHBpbmcsXG5cbiAgICBcdFx0XHRyZXBlYXQ6IFsgdGhpcy5yZXBlYXQueCwgdGhpcy5yZXBlYXQueSBdLFxuICAgIFx0XHRcdG9mZnNldDogWyB0aGlzLm9mZnNldC54LCB0aGlzLm9mZnNldC55IF0sXG4gICAgXHRcdFx0d3JhcDogWyB0aGlzLndyYXBTLCB0aGlzLndyYXBUIF0sXG5cbiAgICBcdFx0XHRtaW5GaWx0ZXI6IHRoaXMubWluRmlsdGVyLFxuICAgIFx0XHRcdG1hZ0ZpbHRlcjogdGhpcy5tYWdGaWx0ZXIsXG4gICAgXHRcdFx0YW5pc290cm9weTogdGhpcy5hbmlzb3Ryb3B5LFxuXG4gICAgXHRcdFx0ZmxpcFk6IHRoaXMuZmxpcFlcbiAgICBcdFx0fTtcblxuICAgIFx0XHRpZiAoIHRoaXMuaW1hZ2UgIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdC8vIFRPRE86IE1vdmUgdG8gVEhSRUUuSW1hZ2VcblxuICAgIFx0XHRcdHZhciBpbWFnZSA9IHRoaXMuaW1hZ2U7XG5cbiAgICBcdFx0XHRpZiAoIGltYWdlLnV1aWQgPT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0aW1hZ2UudXVpZCA9IGV4cG9ydHMuTWF0aC5nZW5lcmF0ZVVVSUQoKTsgLy8gVUdIXG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRpZiAoIG1ldGEuaW1hZ2VzWyBpbWFnZS51dWlkIF0gPT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0bWV0YS5pbWFnZXNbIGltYWdlLnV1aWQgXSA9IHtcbiAgICBcdFx0XHRcdFx0dXVpZDogaW1hZ2UudXVpZCxcbiAgICBcdFx0XHRcdFx0dXJsOiBnZXREYXRhVVJMKCBpbWFnZSApXG4gICAgXHRcdFx0XHR9O1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0b3V0cHV0LmltYWdlID0gaW1hZ2UudXVpZDtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0bWV0YS50ZXh0dXJlc1sgdGhpcy51dWlkIF0gPSBvdXRwdXQ7XG5cbiAgICBcdFx0cmV0dXJuIG91dHB1dDtcblxuICAgIFx0fSxcblxuICAgIFx0ZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHRoaXMuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAnZGlzcG9zZScgfSApO1xuXG4gICAgXHR9LFxuXG4gICAgXHR0cmFuc2Zvcm1VdjogZnVuY3Rpb24gKCB1diApIHtcblxuICAgIFx0XHRpZiAoIHRoaXMubWFwcGluZyAhPT0gVVZNYXBwaW5nICkgIHJldHVybjtcblxuICAgIFx0XHR1di5tdWx0aXBseSggdGhpcy5yZXBlYXQgKTtcbiAgICBcdFx0dXYuYWRkKCB0aGlzLm9mZnNldCApO1xuXG4gICAgXHRcdGlmICggdXYueCA8IDAgfHwgdXYueCA+IDEgKSB7XG5cbiAgICBcdFx0XHRzd2l0Y2ggKCB0aGlzLndyYXBTICkge1xuXG4gICAgXHRcdFx0XHRjYXNlIFJlcGVhdFdyYXBwaW5nOlxuXG4gICAgXHRcdFx0XHRcdHV2LnggPSB1di54IC0gTWF0aC5mbG9vciggdXYueCApO1xuICAgIFx0XHRcdFx0XHRicmVhaztcblxuICAgIFx0XHRcdFx0Y2FzZSBDbGFtcFRvRWRnZVdyYXBwaW5nOlxuXG4gICAgXHRcdFx0XHRcdHV2LnggPSB1di54IDwgMCA/IDAgOiAxO1xuICAgIFx0XHRcdFx0XHRicmVhaztcblxuICAgIFx0XHRcdFx0Y2FzZSBNaXJyb3JlZFJlcGVhdFdyYXBwaW5nOlxuXG4gICAgXHRcdFx0XHRcdGlmICggTWF0aC5hYnMoIE1hdGguZmxvb3IoIHV2LnggKSAlIDIgKSA9PT0gMSApIHtcblxuICAgIFx0XHRcdFx0XHRcdHV2LnggPSBNYXRoLmNlaWwoIHV2LnggKSAtIHV2Lng7XG5cbiAgICBcdFx0XHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0XHRcdHV2LnggPSB1di54IC0gTWF0aC5mbG9vciggdXYueCApO1xuXG4gICAgXHRcdFx0XHRcdH1cbiAgICBcdFx0XHRcdFx0YnJlYWs7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGlmICggdXYueSA8IDAgfHwgdXYueSA+IDEgKSB7XG5cbiAgICBcdFx0XHRzd2l0Y2ggKCB0aGlzLndyYXBUICkge1xuXG4gICAgXHRcdFx0XHRjYXNlIFJlcGVhdFdyYXBwaW5nOlxuXG4gICAgXHRcdFx0XHRcdHV2LnkgPSB1di55IC0gTWF0aC5mbG9vciggdXYueSApO1xuICAgIFx0XHRcdFx0XHRicmVhaztcblxuICAgIFx0XHRcdFx0Y2FzZSBDbGFtcFRvRWRnZVdyYXBwaW5nOlxuXG4gICAgXHRcdFx0XHRcdHV2LnkgPSB1di55IDwgMCA/IDAgOiAxO1xuICAgIFx0XHRcdFx0XHRicmVhaztcblxuICAgIFx0XHRcdFx0Y2FzZSBNaXJyb3JlZFJlcGVhdFdyYXBwaW5nOlxuXG4gICAgXHRcdFx0XHRcdGlmICggTWF0aC5hYnMoIE1hdGguZmxvb3IoIHV2LnkgKSAlIDIgKSA9PT0gMSApIHtcblxuICAgIFx0XHRcdFx0XHRcdHV2LnkgPSBNYXRoLmNlaWwoIHV2LnkgKSAtIHV2Lnk7XG5cbiAgICBcdFx0XHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0XHRcdHV2LnkgPSB1di55IC0gTWF0aC5mbG9vciggdXYueSApO1xuXG4gICAgXHRcdFx0XHRcdH1cbiAgICBcdFx0XHRcdFx0YnJlYWs7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGlmICggdGhpcy5mbGlwWSApIHtcblxuICAgIFx0XHRcdHV2LnkgPSAxIC0gdXYueTtcblxuICAgIFx0XHR9XG5cbiAgICBcdH1cblxuICAgIH07XG5cbiAgICBPYmplY3QuYXNzaWduKCBUZXh0dXJlLnByb3RvdHlwZSwgRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZSApO1xuXG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICBmdW5jdGlvbiBUZXh0dXJlSWRDb3VudCgpIHsgcmV0dXJuIGNvdW50Kys7IH07XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIHN1cGVyZWdnYmVydCAvIGh0dHA6Ly93d3cucGF1bGJydW50LmNvLnVrL1xuICAgICAqIEBhdXRob3IgcGhpbG9nYiAvIGh0dHA6Ly9ibG9nLnRoZWppdC5vcmcvXG4gICAgICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAgICAgKiBAYXV0aG9yIGVncmFldGhlciAvIGh0dHA6Ly9lZ3JhZXRoZXIuY29tL1xuICAgICAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gVmVjdG9yNCggeCwgeSwgeiwgdyApIHtcblxuICAgIFx0dGhpcy54ID0geCB8fCAwO1xuICAgIFx0dGhpcy55ID0geSB8fCAwO1xuICAgIFx0dGhpcy56ID0geiB8fCAwO1xuICAgIFx0dGhpcy53ID0gKCB3ICE9PSB1bmRlZmluZWQgKSA/IHcgOiAxO1xuXG4gICAgfVxuXG4gICAgVmVjdG9yNC5wcm90b3R5cGUgPSB7XG5cbiAgICBcdGNvbnN0cnVjdG9yOiBWZWN0b3I0LFxuXG4gICAgXHRpc1ZlY3RvcjQ6IHRydWUsXG5cbiAgICBcdHNldDogZnVuY3Rpb24gKCB4LCB5LCB6LCB3ICkge1xuXG4gICAgXHRcdHRoaXMueCA9IHg7XG4gICAgXHRcdHRoaXMueSA9IHk7XG4gICAgXHRcdHRoaXMueiA9IHo7XG4gICAgXHRcdHRoaXMudyA9IHc7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldFNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XG5cbiAgICBcdFx0dGhpcy54ID0gc2NhbGFyO1xuICAgIFx0XHR0aGlzLnkgPSBzY2FsYXI7XG4gICAgXHRcdHRoaXMueiA9IHNjYWxhcjtcbiAgICBcdFx0dGhpcy53ID0gc2NhbGFyO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzZXRYOiBmdW5jdGlvbiAoIHggKSB7XG5cbiAgICBcdFx0dGhpcy54ID0geDtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0c2V0WTogZnVuY3Rpb24gKCB5ICkge1xuXG4gICAgXHRcdHRoaXMueSA9IHk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldFo6IGZ1bmN0aW9uICggeiApIHtcblxuICAgIFx0XHR0aGlzLnogPSB6O1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzZXRXOiBmdW5jdGlvbiAoIHcgKSB7XG5cbiAgICBcdFx0dGhpcy53ID0gdztcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0c2V0Q29tcG9uZW50OiBmdW5jdGlvbiAoIGluZGV4LCB2YWx1ZSApIHtcblxuICAgIFx0XHRzd2l0Y2ggKCBpbmRleCApIHtcblxuICAgIFx0XHRcdGNhc2UgMDogdGhpcy54ID0gdmFsdWU7IGJyZWFrO1xuICAgIFx0XHRcdGNhc2UgMTogdGhpcy55ID0gdmFsdWU7IGJyZWFrO1xuICAgIFx0XHRcdGNhc2UgMjogdGhpcy56ID0gdmFsdWU7IGJyZWFrO1xuICAgIFx0XHRcdGNhc2UgMzogdGhpcy53ID0gdmFsdWU7IGJyZWFrO1xuICAgIFx0XHRcdGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvciggJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4ICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9LFxuXG4gICAgXHRnZXRDb21wb25lbnQ6IGZ1bmN0aW9uICggaW5kZXggKSB7XG5cbiAgICBcdFx0c3dpdGNoICggaW5kZXggKSB7XG5cbiAgICBcdFx0XHRjYXNlIDA6IHJldHVybiB0aGlzLng7XG4gICAgXHRcdFx0Y2FzZSAxOiByZXR1cm4gdGhpcy55O1xuICAgIFx0XHRcdGNhc2UgMjogcmV0dXJuIHRoaXMuejtcbiAgICBcdFx0XHRjYXNlIDM6IHJldHVybiB0aGlzLnc7XG4gICAgXHRcdFx0ZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCAnaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAnICsgaW5kZXggKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdH0sXG5cbiAgICBcdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLngsIHRoaXMueSwgdGhpcy56LCB0aGlzLncgKTtcblxuICAgIFx0fSxcblxuICAgIFx0Y29weTogZnVuY3Rpb24gKCB2ICkge1xuXG4gICAgXHRcdHRoaXMueCA9IHYueDtcbiAgICBcdFx0dGhpcy55ID0gdi55O1xuICAgIFx0XHR0aGlzLnogPSB2Lno7XG4gICAgXHRcdHRoaXMudyA9ICggdi53ICE9PSB1bmRlZmluZWQgKSA/IHYudyA6IDE7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGFkZDogZnVuY3Rpb24gKCB2LCB3ICkge1xuXG4gICAgXHRcdGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yNDogLmFkZCgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLmFkZFZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcbiAgICBcdFx0XHRyZXR1cm4gdGhpcy5hZGRWZWN0b3JzKCB2LCB3ICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHRoaXMueCArPSB2Lng7XG4gICAgXHRcdHRoaXMueSArPSB2Lnk7XG4gICAgXHRcdHRoaXMueiArPSB2Lno7XG4gICAgXHRcdHRoaXMudyArPSB2Lnc7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGFkZFNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xuXG4gICAgXHRcdHRoaXMueCArPSBzO1xuICAgIFx0XHR0aGlzLnkgKz0gcztcbiAgICBcdFx0dGhpcy56ICs9IHM7XG4gICAgXHRcdHRoaXMudyArPSBzO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRhZGRWZWN0b3JzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XG5cbiAgICBcdFx0dGhpcy54ID0gYS54ICsgYi54O1xuICAgIFx0XHR0aGlzLnkgPSBhLnkgKyBiLnk7XG4gICAgXHRcdHRoaXMueiA9IGEueiArIGIuejtcbiAgICBcdFx0dGhpcy53ID0gYS53ICsgYi53O1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRhZGRTY2FsZWRWZWN0b3I6IGZ1bmN0aW9uICggdiwgcyApIHtcblxuICAgIFx0XHR0aGlzLnggKz0gdi54ICogcztcbiAgICBcdFx0dGhpcy55ICs9IHYueSAqIHM7XG4gICAgXHRcdHRoaXMueiArPSB2LnogKiBzO1xuICAgIFx0XHR0aGlzLncgKz0gdi53ICogcztcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0c3ViOiBmdW5jdGlvbiAoIHYsIHcgKSB7XG5cbiAgICBcdFx0aWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3I0OiAuc3ViKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuc3ViVmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyApO1xuICAgIFx0XHRcdHJldHVybiB0aGlzLnN1YlZlY3RvcnMoIHYsIHcgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0dGhpcy54IC09IHYueDtcbiAgICBcdFx0dGhpcy55IC09IHYueTtcbiAgICBcdFx0dGhpcy56IC09IHYuejtcbiAgICBcdFx0dGhpcy53IC09IHYudztcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0c3ViU2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XG5cbiAgICBcdFx0dGhpcy54IC09IHM7XG4gICAgXHRcdHRoaXMueSAtPSBzO1xuICAgIFx0XHR0aGlzLnogLT0gcztcbiAgICBcdFx0dGhpcy53IC09IHM7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdHN1YlZlY3RvcnM6IGZ1bmN0aW9uICggYSwgYiApIHtcblxuICAgIFx0XHR0aGlzLnggPSBhLnggLSBiLng7XG4gICAgXHRcdHRoaXMueSA9IGEueSAtIGIueTtcbiAgICBcdFx0dGhpcy56ID0gYS56IC0gYi56O1xuICAgIFx0XHR0aGlzLncgPSBhLncgLSBiLnc7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdG11bHRpcGx5U2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcblxuICAgIFx0XHRpZiAoIGlzRmluaXRlKCBzY2FsYXIgKSApIHtcblxuICAgIFx0XHRcdHRoaXMueCAqPSBzY2FsYXI7XG4gICAgXHRcdFx0dGhpcy55ICo9IHNjYWxhcjtcbiAgICBcdFx0XHR0aGlzLnogKj0gc2NhbGFyO1xuICAgIFx0XHRcdHRoaXMudyAqPSBzY2FsYXI7XG5cbiAgICBcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdHRoaXMueCA9IDA7XG4gICAgXHRcdFx0dGhpcy55ID0gMDtcbiAgICBcdFx0XHR0aGlzLnogPSAwO1xuICAgIFx0XHRcdHRoaXMudyA9IDA7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRhcHBseU1hdHJpeDQ6IGZ1bmN0aW9uICggbSApIHtcblxuICAgIFx0XHR2YXIgeCA9IHRoaXMueCwgeSA9IHRoaXMueSwgeiA9IHRoaXMueiwgdyA9IHRoaXMudztcbiAgICBcdFx0dmFyIGUgPSBtLmVsZW1lbnRzO1xuXG4gICAgXHRcdHRoaXMueCA9IGVbIDAgXSAqIHggKyBlWyA0IF0gKiB5ICsgZVsgOCBdICogeiArIGVbIDEyIF0gKiB3O1xuICAgIFx0XHR0aGlzLnkgPSBlWyAxIF0gKiB4ICsgZVsgNSBdICogeSArIGVbIDkgXSAqIHogKyBlWyAxMyBdICogdztcbiAgICBcdFx0dGhpcy56ID0gZVsgMiBdICogeCArIGVbIDYgXSAqIHkgKyBlWyAxMCBdICogeiArIGVbIDE0IF0gKiB3O1xuICAgIFx0XHR0aGlzLncgPSBlWyAzIF0gKiB4ICsgZVsgNyBdICogeSArIGVbIDExIF0gKiB6ICsgZVsgMTUgXSAqIHc7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGRpdmlkZVNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoIDEgLyBzY2FsYXIgKTtcblxuICAgIFx0fSxcblxuICAgIFx0c2V0QXhpc0FuZ2xlRnJvbVF1YXRlcm5pb246IGZ1bmN0aW9uICggcSApIHtcblxuICAgIFx0XHQvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9nZW9tZXRyeS9yb3RhdGlvbnMvY29udmVyc2lvbnMvcXVhdGVybmlvblRvQW5nbGUvaW5kZXguaHRtXG5cbiAgICBcdFx0Ly8gcSBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWRcblxuICAgIFx0XHR0aGlzLncgPSAyICogTWF0aC5hY29zKCBxLncgKTtcblxuICAgIFx0XHR2YXIgcyA9IE1hdGguc3FydCggMSAtIHEudyAqIHEudyApO1xuXG4gICAgXHRcdGlmICggcyA8IDAuMDAwMSApIHtcblxuICAgIFx0XHRcdCB0aGlzLnggPSAxO1xuICAgIFx0XHRcdCB0aGlzLnkgPSAwO1xuICAgIFx0XHRcdCB0aGlzLnogPSAwO1xuXG4gICAgXHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHQgdGhpcy54ID0gcS54IC8gcztcbiAgICBcdFx0XHQgdGhpcy55ID0gcS55IC8gcztcbiAgICBcdFx0XHQgdGhpcy56ID0gcS56IC8gcztcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldEF4aXNBbmdsZUZyb21Sb3RhdGlvbk1hdHJpeDogZnVuY3Rpb24gKCBtICkge1xuXG4gICAgXHRcdC8vIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2dlb21ldHJ5L3JvdGF0aW9ucy9jb252ZXJzaW9ucy9tYXRyaXhUb0FuZ2xlL2luZGV4Lmh0bVxuXG4gICAgXHRcdC8vIGFzc3VtZXMgdGhlIHVwcGVyIDN4MyBvZiBtIGlzIGEgcHVyZSByb3RhdGlvbiBtYXRyaXggKGkuZSwgdW5zY2FsZWQpXG5cbiAgICBcdFx0dmFyIGFuZ2xlLCB4LCB5LCB6LFx0XHQvLyB2YXJpYWJsZXMgZm9yIHJlc3VsdFxuICAgIFx0XHRcdGVwc2lsb24gPSAwLjAxLFx0XHQvLyBtYXJnaW4gdG8gYWxsb3cgZm9yIHJvdW5kaW5nIGVycm9yc1xuICAgIFx0XHRcdGVwc2lsb24yID0gMC4xLFx0XHQvLyBtYXJnaW4gdG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiAwIGFuZCAxODAgZGVncmVlc1xuXG4gICAgXHRcdFx0dGUgPSBtLmVsZW1lbnRzLFxuXG4gICAgXHRcdFx0bTExID0gdGVbIDAgXSwgbTEyID0gdGVbIDQgXSwgbTEzID0gdGVbIDggXSxcbiAgICBcdFx0XHRtMjEgPSB0ZVsgMSBdLCBtMjIgPSB0ZVsgNSBdLCBtMjMgPSB0ZVsgOSBdLFxuICAgIFx0XHRcdG0zMSA9IHRlWyAyIF0sIG0zMiA9IHRlWyA2IF0sIG0zMyA9IHRlWyAxMCBdO1xuXG4gICAgXHRcdGlmICggKCBNYXRoLmFicyggbTEyIC0gbTIxICkgPCBlcHNpbG9uICkgJiZcbiAgICBcdFx0ICAgICAoIE1hdGguYWJzKCBtMTMgLSBtMzEgKSA8IGVwc2lsb24gKSAmJlxuICAgIFx0XHQgICAgICggTWF0aC5hYnMoIG0yMyAtIG0zMiApIDwgZXBzaWxvbiApICkge1xuXG4gICAgXHRcdFx0Ly8gc2luZ3VsYXJpdHkgZm91bmRcbiAgICBcdFx0XHQvLyBmaXJzdCBjaGVjayBmb3IgaWRlbnRpdHkgbWF0cml4IHdoaWNoIG11c3QgaGF2ZSArMSBmb3IgYWxsIHRlcm1zXG4gICAgXHRcdFx0Ly8gaW4gbGVhZGluZyBkaWFnb25hbCBhbmQgemVybyBpbiBvdGhlciB0ZXJtc1xuXG4gICAgXHRcdFx0aWYgKCAoIE1hdGguYWJzKCBtMTIgKyBtMjEgKSA8IGVwc2lsb24yICkgJiZcbiAgICBcdFx0XHQgICAgICggTWF0aC5hYnMoIG0xMyArIG0zMSApIDwgZXBzaWxvbjIgKSAmJlxuICAgIFx0XHRcdCAgICAgKCBNYXRoLmFicyggbTIzICsgbTMyICkgPCBlcHNpbG9uMiApICYmXG4gICAgXHRcdFx0ICAgICAoIE1hdGguYWJzKCBtMTEgKyBtMjIgKyBtMzMgLSAzICkgPCBlcHNpbG9uMiApICkge1xuXG4gICAgXHRcdFx0XHQvLyB0aGlzIHNpbmd1bGFyaXR5IGlzIGlkZW50aXR5IG1hdHJpeCBzbyBhbmdsZSA9IDBcblxuICAgIFx0XHRcdFx0dGhpcy5zZXQoIDEsIDAsIDAsIDAgKTtcblxuICAgIFx0XHRcdFx0cmV0dXJuIHRoaXM7IC8vIHplcm8gYW5nbGUsIGFyYml0cmFyeSBheGlzXG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHQvLyBvdGhlcndpc2UgdGhpcyBzaW5ndWxhcml0eSBpcyBhbmdsZSA9IDE4MFxuXG4gICAgXHRcdFx0YW5nbGUgPSBNYXRoLlBJO1xuXG4gICAgXHRcdFx0dmFyIHh4ID0gKCBtMTEgKyAxICkgLyAyO1xuICAgIFx0XHRcdHZhciB5eSA9ICggbTIyICsgMSApIC8gMjtcbiAgICBcdFx0XHR2YXIgenogPSAoIG0zMyArIDEgKSAvIDI7XG4gICAgXHRcdFx0dmFyIHh5ID0gKCBtMTIgKyBtMjEgKSAvIDQ7XG4gICAgXHRcdFx0dmFyIHh6ID0gKCBtMTMgKyBtMzEgKSAvIDQ7XG4gICAgXHRcdFx0dmFyIHl6ID0gKCBtMjMgKyBtMzIgKSAvIDQ7XG5cbiAgICBcdFx0XHRpZiAoICggeHggPiB5eSApICYmICggeHggPiB6eiApICkge1xuXG4gICAgXHRcdFx0XHQvLyBtMTEgaXMgdGhlIGxhcmdlc3QgZGlhZ29uYWwgdGVybVxuXG4gICAgXHRcdFx0XHRpZiAoIHh4IDwgZXBzaWxvbiApIHtcblxuICAgIFx0XHRcdFx0XHR4ID0gMDtcbiAgICBcdFx0XHRcdFx0eSA9IDAuNzA3MTA2NzgxO1xuICAgIFx0XHRcdFx0XHR6ID0gMC43MDcxMDY3ODE7XG5cbiAgICBcdFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdFx0eCA9IE1hdGguc3FydCggeHggKTtcbiAgICBcdFx0XHRcdFx0eSA9IHh5IC8geDtcbiAgICBcdFx0XHRcdFx0eiA9IHh6IC8geDtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fSBlbHNlIGlmICggeXkgPiB6eiApIHtcblxuICAgIFx0XHRcdFx0Ly8gbTIyIGlzIHRoZSBsYXJnZXN0IGRpYWdvbmFsIHRlcm1cblxuICAgIFx0XHRcdFx0aWYgKCB5eSA8IGVwc2lsb24gKSB7XG5cbiAgICBcdFx0XHRcdFx0eCA9IDAuNzA3MTA2NzgxO1xuICAgIFx0XHRcdFx0XHR5ID0gMDtcbiAgICBcdFx0XHRcdFx0eiA9IDAuNzA3MTA2NzgxO1xuXG4gICAgXHRcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRcdHkgPSBNYXRoLnNxcnQoIHl5ICk7XG4gICAgXHRcdFx0XHRcdHggPSB4eSAvIHk7XG4gICAgXHRcdFx0XHRcdHogPSB5eiAvIHk7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdC8vIG0zMyBpcyB0aGUgbGFyZ2VzdCBkaWFnb25hbCB0ZXJtIHNvIGJhc2UgcmVzdWx0IG9uIHRoaXNcblxuICAgIFx0XHRcdFx0aWYgKCB6eiA8IGVwc2lsb24gKSB7XG5cbiAgICBcdFx0XHRcdFx0eCA9IDAuNzA3MTA2NzgxO1xuICAgIFx0XHRcdFx0XHR5ID0gMC43MDcxMDY3ODE7XG4gICAgXHRcdFx0XHRcdHogPSAwO1xuXG4gICAgXHRcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRcdHogPSBNYXRoLnNxcnQoIHp6ICk7XG4gICAgXHRcdFx0XHRcdHggPSB4eiAvIHo7XG4gICAgXHRcdFx0XHRcdHkgPSB5eiAvIHo7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdHRoaXMuc2V0KCB4LCB5LCB6LCBhbmdsZSApO1xuXG4gICAgXHRcdFx0cmV0dXJuIHRoaXM7IC8vIHJldHVybiAxODAgZGVnIHJvdGF0aW9uXG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdC8vIGFzIHdlIGhhdmUgcmVhY2hlZCBoZXJlIHRoZXJlIGFyZSBubyBzaW5ndWxhcml0aWVzIHNvIHdlIGNhbiBoYW5kbGUgbm9ybWFsbHlcblxuICAgIFx0XHR2YXIgcyA9IE1hdGguc3FydCggKCBtMzIgLSBtMjMgKSAqICggbTMyIC0gbTIzICkgK1xuICAgIFx0XHQgICAgICAgICAgICAgICAgICAgKCBtMTMgLSBtMzEgKSAqICggbTEzIC0gbTMxICkgK1xuICAgIFx0XHQgICAgICAgICAgICAgICAgICAgKCBtMjEgLSBtMTIgKSAqICggbTIxIC0gbTEyICkgKTsgLy8gdXNlZCB0byBub3JtYWxpemVcblxuICAgIFx0XHRpZiAoIE1hdGguYWJzKCBzICkgPCAwLjAwMSApIHMgPSAxO1xuXG4gICAgXHRcdC8vIHByZXZlbnQgZGl2aWRlIGJ5IHplcm8sIHNob3VsZCBub3QgaGFwcGVuIGlmIG1hdHJpeCBpcyBvcnRob2dvbmFsIGFuZCBzaG91bGQgYmVcbiAgICBcdFx0Ly8gY2F1Z2h0IGJ5IHNpbmd1bGFyaXR5IHRlc3QgYWJvdmUsIGJ1dCBJJ3ZlIGxlZnQgaXQgaW4ganVzdCBpbiBjYXNlXG5cbiAgICBcdFx0dGhpcy54ID0gKCBtMzIgLSBtMjMgKSAvIHM7XG4gICAgXHRcdHRoaXMueSA9ICggbTEzIC0gbTMxICkgLyBzO1xuICAgIFx0XHR0aGlzLnogPSAoIG0yMSAtIG0xMiApIC8gcztcbiAgICBcdFx0dGhpcy53ID0gTWF0aC5hY29zKCAoIG0xMSArIG0yMiArIG0zMyAtIDEgKSAvIDIgKTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0bWluOiBmdW5jdGlvbiAoIHYgKSB7XG5cbiAgICBcdFx0dGhpcy54ID0gTWF0aC5taW4oIHRoaXMueCwgdi54ICk7XG4gICAgXHRcdHRoaXMueSA9IE1hdGgubWluKCB0aGlzLnksIHYueSApO1xuICAgIFx0XHR0aGlzLnogPSBNYXRoLm1pbiggdGhpcy56LCB2LnogKTtcbiAgICBcdFx0dGhpcy53ID0gTWF0aC5taW4oIHRoaXMudywgdi53ICk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdG1heDogZnVuY3Rpb24gKCB2ICkge1xuXG4gICAgXHRcdHRoaXMueCA9IE1hdGgubWF4KCB0aGlzLngsIHYueCApO1xuICAgIFx0XHR0aGlzLnkgPSBNYXRoLm1heCggdGhpcy55LCB2LnkgKTtcbiAgICBcdFx0dGhpcy56ID0gTWF0aC5tYXgoIHRoaXMueiwgdi56ICk7XG4gICAgXHRcdHRoaXMudyA9IE1hdGgubWF4KCB0aGlzLncsIHYudyApO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRjbGFtcDogZnVuY3Rpb24gKCBtaW4sIG1heCApIHtcblxuICAgIFx0XHQvLyBUaGlzIGZ1bmN0aW9uIGFzc3VtZXMgbWluIDwgbWF4LCBpZiB0aGlzIGFzc3VtcHRpb24gaXNuJ3QgdHJ1ZSBpdCB3aWxsIG5vdCBvcGVyYXRlIGNvcnJlY3RseVxuXG4gICAgXHRcdHRoaXMueCA9IE1hdGgubWF4KCBtaW4ueCwgTWF0aC5taW4oIG1heC54LCB0aGlzLnggKSApO1xuICAgIFx0XHR0aGlzLnkgPSBNYXRoLm1heCggbWluLnksIE1hdGgubWluKCBtYXgueSwgdGhpcy55ICkgKTtcbiAgICBcdFx0dGhpcy56ID0gTWF0aC5tYXgoIG1pbi56LCBNYXRoLm1pbiggbWF4LnosIHRoaXMueiApICk7XG4gICAgXHRcdHRoaXMudyA9IE1hdGgubWF4KCBtaW4udywgTWF0aC5taW4oIG1heC53LCB0aGlzLncgKSApO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRjbGFtcFNjYWxhcjogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHZhciBtaW4sIG1heDtcblxuICAgIFx0XHRyZXR1cm4gZnVuY3Rpb24gY2xhbXBTY2FsYXIoIG1pblZhbCwgbWF4VmFsICkge1xuXG4gICAgXHRcdFx0aWYgKCBtaW4gPT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0bWluID0gbmV3IFZlY3RvcjQoKTtcbiAgICBcdFx0XHRcdG1heCA9IG5ldyBWZWN0b3I0KCk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRtaW4uc2V0KCBtaW5WYWwsIG1pblZhbCwgbWluVmFsLCBtaW5WYWwgKTtcbiAgICBcdFx0XHRtYXguc2V0KCBtYXhWYWwsIG1heFZhbCwgbWF4VmFsLCBtYXhWYWwgKTtcblxuICAgIFx0XHRcdHJldHVybiB0aGlzLmNsYW1wKCBtaW4sIG1heCApO1xuXG4gICAgXHRcdH07XG5cbiAgICBcdH0oKSxcblxuICAgIFx0Zmxvb3I6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR0aGlzLnggPSBNYXRoLmZsb29yKCB0aGlzLnggKTtcbiAgICBcdFx0dGhpcy55ID0gTWF0aC5mbG9vciggdGhpcy55ICk7XG4gICAgXHRcdHRoaXMueiA9IE1hdGguZmxvb3IoIHRoaXMueiApO1xuICAgIFx0XHR0aGlzLncgPSBNYXRoLmZsb29yKCB0aGlzLncgKTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0Y2VpbDogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHRoaXMueCA9IE1hdGguY2VpbCggdGhpcy54ICk7XG4gICAgXHRcdHRoaXMueSA9IE1hdGguY2VpbCggdGhpcy55ICk7XG4gICAgXHRcdHRoaXMueiA9IE1hdGguY2VpbCggdGhpcy56ICk7XG4gICAgXHRcdHRoaXMudyA9IE1hdGguY2VpbCggdGhpcy53ICk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdHJvdW5kOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dGhpcy54ID0gTWF0aC5yb3VuZCggdGhpcy54ICk7XG4gICAgXHRcdHRoaXMueSA9IE1hdGgucm91bmQoIHRoaXMueSApO1xuICAgIFx0XHR0aGlzLnogPSBNYXRoLnJvdW5kKCB0aGlzLnogKTtcbiAgICBcdFx0dGhpcy53ID0gTWF0aC5yb3VuZCggdGhpcy53ICk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdHJvdW5kVG9aZXJvOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dGhpcy54ID0gKCB0aGlzLnggPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMueCApIDogTWF0aC5mbG9vciggdGhpcy54ICk7XG4gICAgXHRcdHRoaXMueSA9ICggdGhpcy55IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnkgKSA6IE1hdGguZmxvb3IoIHRoaXMueSApO1xuICAgIFx0XHR0aGlzLnogPSAoIHRoaXMueiA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy56ICkgOiBNYXRoLmZsb29yKCB0aGlzLnogKTtcbiAgICBcdFx0dGhpcy53ID0gKCB0aGlzLncgPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMudyApIDogTWF0aC5mbG9vciggdGhpcy53ICk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdG5lZ2F0ZTogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHRoaXMueCA9IC0gdGhpcy54O1xuICAgIFx0XHR0aGlzLnkgPSAtIHRoaXMueTtcbiAgICBcdFx0dGhpcy56ID0gLSB0aGlzLno7XG4gICAgXHRcdHRoaXMudyA9IC0gdGhpcy53O1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRkb3Q6IGZ1bmN0aW9uICggdiApIHtcblxuICAgIFx0XHRyZXR1cm4gdGhpcy54ICogdi54ICsgdGhpcy55ICogdi55ICsgdGhpcy56ICogdi56ICsgdGhpcy53ICogdi53O1xuXG4gICAgXHR9LFxuXG4gICAgXHRsZW5ndGhTcTogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHJldHVybiB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLnogKyB0aGlzLncgKiB0aGlzLnc7XG5cbiAgICBcdH0sXG5cbiAgICBcdGxlbmd0aDogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMueiArIHRoaXMudyAqIHRoaXMudyApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRsZW5ndGhNYW5oYXR0YW46IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHRyZXR1cm4gTWF0aC5hYnMoIHRoaXMueCApICsgTWF0aC5hYnMoIHRoaXMueSApICsgTWF0aC5hYnMoIHRoaXMueiApICsgTWF0aC5hYnMoIHRoaXMudyApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRub3JtYWxpemU6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHRyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIoIHRoaXMubGVuZ3RoKCkgKTtcblxuICAgIFx0fSxcblxuICAgIFx0c2V0TGVuZ3RoOiBmdW5jdGlvbiAoIGxlbmd0aCApIHtcblxuICAgIFx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseVNjYWxhciggbGVuZ3RoIC8gdGhpcy5sZW5ndGgoKSApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRsZXJwOiBmdW5jdGlvbiAoIHYsIGFscGhhICkge1xuXG4gICAgXHRcdHRoaXMueCArPSAoIHYueCAtIHRoaXMueCApICogYWxwaGE7XG4gICAgXHRcdHRoaXMueSArPSAoIHYueSAtIHRoaXMueSApICogYWxwaGE7XG4gICAgXHRcdHRoaXMueiArPSAoIHYueiAtIHRoaXMueiApICogYWxwaGE7XG4gICAgXHRcdHRoaXMudyArPSAoIHYudyAtIHRoaXMudyApICogYWxwaGE7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGxlcnBWZWN0b3JzOiBmdW5jdGlvbiAoIHYxLCB2MiwgYWxwaGEgKSB7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMuc3ViVmVjdG9ycyggdjIsIHYxICkubXVsdGlwbHlTY2FsYXIoIGFscGhhICkuYWRkKCB2MSApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRlcXVhbHM6IGZ1bmN0aW9uICggdiApIHtcblxuICAgIFx0XHRyZXR1cm4gKCAoIHYueCA9PT0gdGhpcy54ICkgJiYgKCB2LnkgPT09IHRoaXMueSApICYmICggdi56ID09PSB0aGlzLnogKSAmJiAoIHYudyA9PT0gdGhpcy53ICkgKTtcblxuICAgIFx0fSxcblxuICAgIFx0ZnJvbUFycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XG5cbiAgICBcdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cbiAgICBcdFx0dGhpcy54ID0gYXJyYXlbIG9mZnNldCBdO1xuICAgIFx0XHR0aGlzLnkgPSBhcnJheVsgb2Zmc2V0ICsgMSBdO1xuICAgIFx0XHR0aGlzLnogPSBhcnJheVsgb2Zmc2V0ICsgMiBdO1xuICAgIFx0XHR0aGlzLncgPSBhcnJheVsgb2Zmc2V0ICsgMyBdO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHR0b0FycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XG5cbiAgICBcdFx0aWYgKCBhcnJheSA9PT0gdW5kZWZpbmVkICkgYXJyYXkgPSBbXTtcbiAgICBcdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cbiAgICBcdFx0YXJyYXlbIG9mZnNldCBdID0gdGhpcy54O1xuICAgIFx0XHRhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGhpcy55O1xuICAgIFx0XHRhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGhpcy56O1xuICAgIFx0XHRhcnJheVsgb2Zmc2V0ICsgMyBdID0gdGhpcy53O1xuXG4gICAgXHRcdHJldHVybiBhcnJheTtcblxuICAgIFx0fSxcblxuICAgIFx0ZnJvbUF0dHJpYnV0ZTogZnVuY3Rpb24gKCBhdHRyaWJ1dGUsIGluZGV4LCBvZmZzZXQgKSB7XG5cbiAgICBcdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cbiAgICBcdFx0aW5kZXggPSBpbmRleCAqIGF0dHJpYnV0ZS5pdGVtU2l6ZSArIG9mZnNldDtcblxuICAgIFx0XHR0aGlzLnggPSBhdHRyaWJ1dGUuYXJyYXlbIGluZGV4IF07XG4gICAgXHRcdHRoaXMueSA9IGF0dHJpYnV0ZS5hcnJheVsgaW5kZXggKyAxIF07XG4gICAgXHRcdHRoaXMueiA9IGF0dHJpYnV0ZS5hcnJheVsgaW5kZXggKyAyIF07XG4gICAgXHRcdHRoaXMudyA9IGF0dHJpYnV0ZS5hcnJheVsgaW5kZXggKyAzIF07XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH1cblxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIHN6aW1layAvIGh0dHBzOi8vZ2l0aHViLmNvbS9zemltZWsvXG4gICAgICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAgICAgKiBAYXV0aG9yIE1hcml1cyBLaW50ZWwgLyBodHRwczovL2dpdGh1Yi5jb20va2ludGVsXG4gICAgICovXG5cbiAgICAvKlxuICAgICBJbiBvcHRpb25zLCB3ZSBjYW4gc3BlY2lmeTpcbiAgICAgKiBUZXh0dXJlIHBhcmFtZXRlcnMgZm9yIGFuIGF1dG8tZ2VuZXJhdGVkIHRhcmdldCB0ZXh0dXJlXG4gICAgICogZGVwdGhCdWZmZXIvc3RlbmNpbEJ1ZmZlcjogQm9vbGVhbnMgdG8gaW5kaWNhdGUgaWYgd2Ugc2hvdWxkIGdlbmVyYXRlIHRoZXNlIGJ1ZmZlcnNcbiAgICAqL1xuICAgIGZ1bmN0aW9uIFdlYkdMUmVuZGVyVGFyZ2V0KCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zICkge1xuXG4gICAgXHR0aGlzLnV1aWQgPSBleHBvcnRzLk1hdGguZ2VuZXJhdGVVVUlEKCk7XG5cbiAgICBcdHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICBcdHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgXHR0aGlzLnNjaXNzb3IgPSBuZXcgVmVjdG9yNCggMCwgMCwgd2lkdGgsIGhlaWdodCApO1xuICAgIFx0dGhpcy5zY2lzc29yVGVzdCA9IGZhbHNlO1xuXG4gICAgXHR0aGlzLnZpZXdwb3J0ID0gbmV3IFZlY3RvcjQoIDAsIDAsIHdpZHRoLCBoZWlnaHQgKTtcblxuICAgIFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBcdGlmICggb3B0aW9ucy5taW5GaWx0ZXIgPT09IHVuZGVmaW5lZCApIG9wdGlvbnMubWluRmlsdGVyID0gTGluZWFyRmlsdGVyO1xuXG4gICAgXHR0aGlzLnRleHR1cmUgPSBuZXcgVGV4dHVyZSggdW5kZWZpbmVkLCB1bmRlZmluZWQsIG9wdGlvbnMud3JhcFMsIG9wdGlvbnMud3JhcFQsIG9wdGlvbnMubWFnRmlsdGVyLCBvcHRpb25zLm1pbkZpbHRlciwgb3B0aW9ucy5mb3JtYXQsIG9wdGlvbnMudHlwZSwgb3B0aW9ucy5hbmlzb3Ryb3B5LCBvcHRpb25zLmVuY29kaW5nICk7XG5cbiAgICBcdHRoaXMuZGVwdGhCdWZmZXIgPSBvcHRpb25zLmRlcHRoQnVmZmVyICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmRlcHRoQnVmZmVyIDogdHJ1ZTtcbiAgICBcdHRoaXMuc3RlbmNpbEJ1ZmZlciA9IG9wdGlvbnMuc3RlbmNpbEJ1ZmZlciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5zdGVuY2lsQnVmZmVyIDogdHJ1ZTtcbiAgICBcdHRoaXMuZGVwdGhUZXh0dXJlID0gb3B0aW9ucy5kZXB0aFRleHR1cmUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZGVwdGhUZXh0dXJlIDogbnVsbDtcblxuICAgIH1cblxuICAgIE9iamVjdC5hc3NpZ24oIFdlYkdMUmVuZGVyVGFyZ2V0LnByb3RvdHlwZSwgRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZSwge1xuXG4gICAgXHRpc1dlYkdMUmVuZGVyVGFyZ2V0OiB0cnVlLFxuXG4gICAgXHRzZXRTaXplOiBmdW5jdGlvbiAoIHdpZHRoLCBoZWlnaHQgKSB7XG5cbiAgICBcdFx0aWYgKCB0aGlzLndpZHRoICE9PSB3aWR0aCB8fCB0aGlzLmhlaWdodCAhPT0gaGVpZ2h0ICkge1xuXG4gICAgXHRcdFx0dGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIFx0XHRcdHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgXHRcdFx0dGhpcy5kaXNwb3NlKCk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHRoaXMudmlld3BvcnQuc2V0KCAwLCAwLCB3aWR0aCwgaGVpZ2h0ICk7XG4gICAgXHRcdHRoaXMuc2Npc3Nvci5zZXQoIDAsIDAsIHdpZHRoLCBoZWlnaHQgKTtcblxuICAgIFx0fSxcblxuICAgIFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xuXG4gICAgXHRcdHRoaXMud2lkdGggPSBzb3VyY2Uud2lkdGg7XG4gICAgXHRcdHRoaXMuaGVpZ2h0ID0gc291cmNlLmhlaWdodDtcblxuICAgIFx0XHR0aGlzLnZpZXdwb3J0LmNvcHkoIHNvdXJjZS52aWV3cG9ydCApO1xuXG4gICAgXHRcdHRoaXMudGV4dHVyZSA9IHNvdXJjZS50ZXh0dXJlLmNsb25lKCk7XG5cbiAgICBcdFx0dGhpcy5kZXB0aEJ1ZmZlciA9IHNvdXJjZS5kZXB0aEJ1ZmZlcjtcbiAgICBcdFx0dGhpcy5zdGVuY2lsQnVmZmVyID0gc291cmNlLnN0ZW5jaWxCdWZmZXI7XG4gICAgXHRcdHRoaXMuZGVwdGhUZXh0dXJlID0gc291cmNlLmRlcHRoVGV4dHVyZTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0ZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHRoaXMuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAnZGlzcG9zZScgfSApO1xuXG4gICAgXHR9XG5cbiAgICB9ICk7XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBXZWJHTFJlbmRlclRhcmdldEN1YmUoIHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMgKSB7XG5cbiAgICBcdFdlYkdMUmVuZGVyVGFyZ2V0LmNhbGwoIHRoaXMsIHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMgKTtcblxuICAgIFx0dGhpcy5hY3RpdmVDdWJlRmFjZSA9IDA7IC8vIFBYIDAsIE5YIDEsIFBZIDIsIE5ZIDMsIFBaIDQsIE5aIDVcbiAgICBcdHRoaXMuYWN0aXZlTWlwTWFwTGV2ZWwgPSAwO1xuXG4gICAgfVxuXG4gICAgV2ViR0xSZW5kZXJUYXJnZXRDdWJlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFdlYkdMUmVuZGVyVGFyZ2V0LnByb3RvdHlwZSApO1xuICAgIFdlYkdMUmVuZGVyVGFyZ2V0Q3ViZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBXZWJHTFJlbmRlclRhcmdldEN1YmU7XG5cbiAgICBXZWJHTFJlbmRlclRhcmdldEN1YmUucHJvdG90eXBlLmlzV2ViR0xSZW5kZXJUYXJnZXRDdWJlID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gICAgICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAgICAgKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAgICAgKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBRdWF0ZXJuaW9uKCB4LCB5LCB6LCB3ICkge1xuXG4gICAgXHR0aGlzLl94ID0geCB8fCAwO1xuICAgIFx0dGhpcy5feSA9IHkgfHwgMDtcbiAgICBcdHRoaXMuX3ogPSB6IHx8IDA7XG4gICAgXHR0aGlzLl93ID0gKCB3ICE9PSB1bmRlZmluZWQgKSA/IHcgOiAxO1xuXG4gICAgfVxuXG4gICAgUXVhdGVybmlvbi5wcm90b3R5cGUgPSB7XG5cbiAgICBcdGNvbnN0cnVjdG9yOiBRdWF0ZXJuaW9uLFxuXG4gICAgXHRnZXQgeCAoKSB7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMuX3g7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldCB4ICggdmFsdWUgKSB7XG5cbiAgICBcdFx0dGhpcy5feCA9IHZhbHVlO1xuICAgIFx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuICAgIFx0fSxcblxuICAgIFx0Z2V0IHkgKCkge1xuXG4gICAgXHRcdHJldHVybiB0aGlzLl95O1xuXG4gICAgXHR9LFxuXG4gICAgXHRzZXQgeSAoIHZhbHVlICkge1xuXG4gICAgXHRcdHRoaXMuX3kgPSB2YWx1ZTtcbiAgICBcdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGdldCB6ICgpIHtcblxuICAgIFx0XHRyZXR1cm4gdGhpcy5fejtcblxuICAgIFx0fSxcblxuICAgIFx0c2V0IHogKCB2YWx1ZSApIHtcblxuICAgIFx0XHR0aGlzLl96ID0gdmFsdWU7XG4gICAgXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG4gICAgXHR9LFxuXG4gICAgXHRnZXQgdyAoKSB7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMuX3c7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldCB3ICggdmFsdWUgKSB7XG5cbiAgICBcdFx0dGhpcy5fdyA9IHZhbHVlO1xuICAgIFx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuICAgIFx0fSxcblxuICAgIFx0c2V0OiBmdW5jdGlvbiAoIHgsIHksIHosIHcgKSB7XG5cbiAgICBcdFx0dGhpcy5feCA9IHg7XG4gICAgXHRcdHRoaXMuX3kgPSB5O1xuICAgIFx0XHR0aGlzLl96ID0gejtcbiAgICBcdFx0dGhpcy5fdyA9IHc7XG5cbiAgICBcdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLl94LCB0aGlzLl95LCB0aGlzLl96LCB0aGlzLl93ICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGNvcHk6IGZ1bmN0aW9uICggcXVhdGVybmlvbiApIHtcblxuICAgIFx0XHR0aGlzLl94ID0gcXVhdGVybmlvbi54O1xuICAgIFx0XHR0aGlzLl95ID0gcXVhdGVybmlvbi55O1xuICAgIFx0XHR0aGlzLl96ID0gcXVhdGVybmlvbi56O1xuICAgIFx0XHR0aGlzLl93ID0gcXVhdGVybmlvbi53O1xuXG4gICAgXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzZXRGcm9tRXVsZXI6IGZ1bmN0aW9uICggZXVsZXIsIHVwZGF0ZSApIHtcblxuICAgIFx0XHRpZiAoIChldWxlciAmJiBldWxlci5pc0V1bGVyKSA9PT0gZmFsc2UgKSB7XG5cbiAgICBcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5RdWF0ZXJuaW9uOiAuc2V0RnJvbUV1bGVyKCkgbm93IGV4cGVjdHMgYSBFdWxlciByb3RhdGlvbiByYXRoZXIgdGhhbiBhIFZlY3RvcjMgYW5kIG9yZGVyLicgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0Ly8gaHR0cDovL3d3dy5tYXRod29ya3MuY29tL21hdGxhYmNlbnRyYWwvZmlsZWV4Y2hhbmdlL1xuICAgIFx0XHQvLyBcdDIwNjk2LWZ1bmN0aW9uLXRvLWNvbnZlcnQtYmV0d2Vlbi1kY20tZXVsZXItYW5nbGVzLXF1YXRlcm5pb25zLWFuZC1ldWxlci12ZWN0b3JzL1xuICAgIFx0XHQvL1x0Y29udGVudC9TcGluQ2FsYy5tXG5cbiAgICBcdFx0dmFyIGMxID0gTWF0aC5jb3MoIGV1bGVyLl94IC8gMiApO1xuICAgIFx0XHR2YXIgYzIgPSBNYXRoLmNvcyggZXVsZXIuX3kgLyAyICk7XG4gICAgXHRcdHZhciBjMyA9IE1hdGguY29zKCBldWxlci5feiAvIDIgKTtcbiAgICBcdFx0dmFyIHMxID0gTWF0aC5zaW4oIGV1bGVyLl94IC8gMiApO1xuICAgIFx0XHR2YXIgczIgPSBNYXRoLnNpbiggZXVsZXIuX3kgLyAyICk7XG4gICAgXHRcdHZhciBzMyA9IE1hdGguc2luKCBldWxlci5feiAvIDIgKTtcblxuICAgIFx0XHR2YXIgb3JkZXIgPSBldWxlci5vcmRlcjtcblxuICAgIFx0XHRpZiAoIG9yZGVyID09PSAnWFlaJyApIHtcblxuICAgIFx0XHRcdHRoaXMuX3ggPSBzMSAqIGMyICogYzMgKyBjMSAqIHMyICogczM7XG4gICAgXHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyAtIHMxICogYzIgKiBzMztcbiAgICBcdFx0XHR0aGlzLl96ID0gYzEgKiBjMiAqIHMzICsgczEgKiBzMiAqIGMzO1xuICAgIFx0XHRcdHRoaXMuX3cgPSBjMSAqIGMyICogYzMgLSBzMSAqIHMyICogczM7XG5cbiAgICBcdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdZWFonICkge1xuXG4gICAgXHRcdFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyArIGMxICogczIgKiBzMztcbiAgICBcdFx0XHR0aGlzLl95ID0gYzEgKiBzMiAqIGMzIC0gczEgKiBjMiAqIHMzO1xuICAgIFx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7XG4gICAgXHRcdFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyArIHMxICogczIgKiBzMztcblxuICAgIFx0XHR9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1pYWScgKSB7XG5cbiAgICBcdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzIC0gYzEgKiBzMiAqIHMzO1xuICAgIFx0XHRcdHRoaXMuX3kgPSBjMSAqIHMyICogYzMgKyBzMSAqIGMyICogczM7XG4gICAgXHRcdFx0dGhpcy5feiA9IGMxICogYzIgKiBzMyArIHMxICogczIgKiBjMztcbiAgICBcdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzO1xuXG4gICAgXHRcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWllYJyApIHtcblxuICAgIFx0XHRcdHRoaXMuX3ggPSBzMSAqIGMyICogYzMgLSBjMSAqIHMyICogczM7XG4gICAgXHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyArIHMxICogYzIgKiBzMztcbiAgICBcdFx0XHR0aGlzLl96ID0gYzEgKiBjMiAqIHMzIC0gczEgKiBzMiAqIGMzO1xuICAgIFx0XHRcdHRoaXMuX3cgPSBjMSAqIGMyICogYzMgKyBzMSAqIHMyICogczM7XG5cbiAgICBcdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdZWlgnICkge1xuXG4gICAgXHRcdFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyArIGMxICogczIgKiBzMztcbiAgICBcdFx0XHR0aGlzLl95ID0gYzEgKiBzMiAqIGMzICsgczEgKiBjMiAqIHMzO1xuICAgIFx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7XG4gICAgXHRcdFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyAtIHMxICogczIgKiBzMztcblxuICAgIFx0XHR9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1haWScgKSB7XG5cbiAgICBcdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzIC0gYzEgKiBzMiAqIHMzO1xuICAgIFx0XHRcdHRoaXMuX3kgPSBjMSAqIHMyICogYzMgLSBzMSAqIGMyICogczM7XG4gICAgXHRcdFx0dGhpcy5feiA9IGMxICogYzIgKiBzMyArIHMxICogczIgKiBjMztcbiAgICBcdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzICsgczEgKiBzMiAqIHMzO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoIHVwZGF0ZSAhPT0gZmFsc2UgKSB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0c2V0RnJvbUF4aXNBbmdsZTogZnVuY3Rpb24gKCBheGlzLCBhbmdsZSApIHtcblxuICAgIFx0XHQvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9nZW9tZXRyeS9yb3RhdGlvbnMvY29udmVyc2lvbnMvYW5nbGVUb1F1YXRlcm5pb24vaW5kZXguaHRtXG5cbiAgICBcdFx0Ly8gYXNzdW1lcyBheGlzIGlzIG5vcm1hbGl6ZWRcblxuICAgIFx0XHR2YXIgaGFsZkFuZ2xlID0gYW5nbGUgLyAyLCBzID0gTWF0aC5zaW4oIGhhbGZBbmdsZSApO1xuXG4gICAgXHRcdHRoaXMuX3ggPSBheGlzLnggKiBzO1xuICAgIFx0XHR0aGlzLl95ID0gYXhpcy55ICogcztcbiAgICBcdFx0dGhpcy5feiA9IGF4aXMueiAqIHM7XG4gICAgXHRcdHRoaXMuX3cgPSBNYXRoLmNvcyggaGFsZkFuZ2xlICk7XG5cbiAgICBcdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldEZyb21Sb3RhdGlvbk1hdHJpeDogZnVuY3Rpb24gKCBtICkge1xuXG4gICAgXHRcdC8vIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2dlb21ldHJ5L3JvdGF0aW9ucy9jb252ZXJzaW9ucy9tYXRyaXhUb1F1YXRlcm5pb24vaW5kZXguaHRtXG5cbiAgICBcdFx0Ly8gYXNzdW1lcyB0aGUgdXBwZXIgM3gzIG9mIG0gaXMgYSBwdXJlIHJvdGF0aW9uIG1hdHJpeCAoaS5lLCB1bnNjYWxlZClcblxuICAgIFx0XHR2YXIgdGUgPSBtLmVsZW1lbnRzLFxuXG4gICAgXHRcdFx0bTExID0gdGVbIDAgXSwgbTEyID0gdGVbIDQgXSwgbTEzID0gdGVbIDggXSxcbiAgICBcdFx0XHRtMjEgPSB0ZVsgMSBdLCBtMjIgPSB0ZVsgNSBdLCBtMjMgPSB0ZVsgOSBdLFxuICAgIFx0XHRcdG0zMSA9IHRlWyAyIF0sIG0zMiA9IHRlWyA2IF0sIG0zMyA9IHRlWyAxMCBdLFxuXG4gICAgXHRcdFx0dHJhY2UgPSBtMTEgKyBtMjIgKyBtMzMsXG4gICAgXHRcdFx0cztcblxuICAgIFx0XHRpZiAoIHRyYWNlID4gMCApIHtcblxuICAgIFx0XHRcdHMgPSAwLjUgLyBNYXRoLnNxcnQoIHRyYWNlICsgMS4wICk7XG5cbiAgICBcdFx0XHR0aGlzLl93ID0gMC4yNSAvIHM7XG4gICAgXHRcdFx0dGhpcy5feCA9ICggbTMyIC0gbTIzICkgKiBzO1xuICAgIFx0XHRcdHRoaXMuX3kgPSAoIG0xMyAtIG0zMSApICogcztcbiAgICBcdFx0XHR0aGlzLl96ID0gKCBtMjEgLSBtMTIgKSAqIHM7XG5cbiAgICBcdFx0fSBlbHNlIGlmICggbTExID4gbTIyICYmIG0xMSA+IG0zMyApIHtcblxuICAgIFx0XHRcdHMgPSAyLjAgKiBNYXRoLnNxcnQoIDEuMCArIG0xMSAtIG0yMiAtIG0zMyApO1xuXG4gICAgXHRcdFx0dGhpcy5fdyA9ICggbTMyIC0gbTIzICkgLyBzO1xuICAgIFx0XHRcdHRoaXMuX3ggPSAwLjI1ICogcztcbiAgICBcdFx0XHR0aGlzLl95ID0gKCBtMTIgKyBtMjEgKSAvIHM7XG4gICAgXHRcdFx0dGhpcy5feiA9ICggbTEzICsgbTMxICkgLyBzO1xuXG4gICAgXHRcdH0gZWxzZSBpZiAoIG0yMiA+IG0zMyApIHtcblxuICAgIFx0XHRcdHMgPSAyLjAgKiBNYXRoLnNxcnQoIDEuMCArIG0yMiAtIG0xMSAtIG0zMyApO1xuXG4gICAgXHRcdFx0dGhpcy5fdyA9ICggbTEzIC0gbTMxICkgLyBzO1xuICAgIFx0XHRcdHRoaXMuX3ggPSAoIG0xMiArIG0yMSApIC8gcztcbiAgICBcdFx0XHR0aGlzLl95ID0gMC4yNSAqIHM7XG4gICAgXHRcdFx0dGhpcy5feiA9ICggbTIzICsgbTMyICkgLyBzO1xuXG4gICAgXHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRzID0gMi4wICogTWF0aC5zcXJ0KCAxLjAgKyBtMzMgLSBtMTEgLSBtMjIgKTtcblxuICAgIFx0XHRcdHRoaXMuX3cgPSAoIG0yMSAtIG0xMiApIC8gcztcbiAgICBcdFx0XHR0aGlzLl94ID0gKCBtMTMgKyBtMzEgKSAvIHM7XG4gICAgXHRcdFx0dGhpcy5feSA9ICggbTIzICsgbTMyICkgLyBzO1xuICAgIFx0XHRcdHRoaXMuX3ogPSAwLjI1ICogcztcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldEZyb21Vbml0VmVjdG9yczogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdC8vIGh0dHA6Ly9sb2xlbmdpbmUubmV0L2Jsb2cvMjAxNC8wMi8yNC9xdWF0ZXJuaW9uLWZyb20tdHdvLXZlY3RvcnMtZmluYWxcblxuICAgIFx0XHQvLyBhc3N1bWVzIGRpcmVjdGlvbiB2ZWN0b3JzIHZGcm9tIGFuZCB2VG8gYXJlIG5vcm1hbGl6ZWRcblxuICAgIFx0XHR2YXIgdjEsIHI7XG5cbiAgICBcdFx0dmFyIEVQUyA9IDAuMDAwMDAxO1xuXG4gICAgXHRcdHJldHVybiBmdW5jdGlvbiBzZXRGcm9tVW5pdFZlY3RvcnMoIHZGcm9tLCB2VG8gKSB7XG5cbiAgICBcdFx0XHRpZiAoIHYxID09PSB1bmRlZmluZWQgKSB2MSA9IG5ldyBWZWN0b3IzKCk7XG5cbiAgICBcdFx0XHRyID0gdkZyb20uZG90KCB2VG8gKSArIDE7XG5cbiAgICBcdFx0XHRpZiAoIHIgPCBFUFMgKSB7XG5cbiAgICBcdFx0XHRcdHIgPSAwO1xuXG4gICAgXHRcdFx0XHRpZiAoIE1hdGguYWJzKCB2RnJvbS54ICkgPiBNYXRoLmFicyggdkZyb20ueiApICkge1xuXG4gICAgXHRcdFx0XHRcdHYxLnNldCggLSB2RnJvbS55LCB2RnJvbS54LCAwICk7XG5cbiAgICBcdFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdFx0djEuc2V0KCAwLCAtIHZGcm9tLnosIHZGcm9tLnkgKTtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0djEuY3Jvc3NWZWN0b3JzKCB2RnJvbSwgdlRvICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHR0aGlzLl94ID0gdjEueDtcbiAgICBcdFx0XHR0aGlzLl95ID0gdjEueTtcbiAgICBcdFx0XHR0aGlzLl96ID0gdjEuejtcbiAgICBcdFx0XHR0aGlzLl93ID0gcjtcblxuICAgIFx0XHRcdHJldHVybiB0aGlzLm5vcm1hbGl6ZSgpO1xuXG4gICAgXHRcdH07XG5cbiAgICBcdH0oKSxcblxuICAgIFx0aW52ZXJzZTogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHJldHVybiB0aGlzLmNvbmp1Z2F0ZSgpLm5vcm1hbGl6ZSgpO1xuXG4gICAgXHR9LFxuXG4gICAgXHRjb25qdWdhdGU6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR0aGlzLl94ICo9IC0gMTtcbiAgICBcdFx0dGhpcy5feSAqPSAtIDE7XG4gICAgXHRcdHRoaXMuX3ogKj0gLSAxO1xuXG4gICAgXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRkb3Q6IGZ1bmN0aW9uICggdiApIHtcblxuICAgIFx0XHRyZXR1cm4gdGhpcy5feCAqIHYuX3ggKyB0aGlzLl95ICogdi5feSArIHRoaXMuX3ogKiB2Ll96ICsgdGhpcy5fdyAqIHYuX3c7XG5cbiAgICBcdH0sXG5cbiAgICBcdGxlbmd0aFNxOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMuX3ggKiB0aGlzLl94ICsgdGhpcy5feSAqIHRoaXMuX3kgKyB0aGlzLl96ICogdGhpcy5feiArIHRoaXMuX3cgKiB0aGlzLl93O1xuXG4gICAgXHR9LFxuXG4gICAgXHRsZW5ndGg6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHRyZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLl94ICogdGhpcy5feCArIHRoaXMuX3kgKiB0aGlzLl95ICsgdGhpcy5feiAqIHRoaXMuX3ogKyB0aGlzLl93ICogdGhpcy5fdyApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRub3JtYWxpemU6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR2YXIgbCA9IHRoaXMubGVuZ3RoKCk7XG5cbiAgICBcdFx0aWYgKCBsID09PSAwICkge1xuXG4gICAgXHRcdFx0dGhpcy5feCA9IDA7XG4gICAgXHRcdFx0dGhpcy5feSA9IDA7XG4gICAgXHRcdFx0dGhpcy5feiA9IDA7XG4gICAgXHRcdFx0dGhpcy5fdyA9IDE7XG5cbiAgICBcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdGwgPSAxIC8gbDtcblxuICAgIFx0XHRcdHRoaXMuX3ggPSB0aGlzLl94ICogbDtcbiAgICBcdFx0XHR0aGlzLl95ID0gdGhpcy5feSAqIGw7XG4gICAgXHRcdFx0dGhpcy5feiA9IHRoaXMuX3ogKiBsO1xuICAgIFx0XHRcdHRoaXMuX3cgPSB0aGlzLl93ICogbDtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdG11bHRpcGx5OiBmdW5jdGlvbiAoIHEsIHAgKSB7XG5cbiAgICBcdFx0aWYgKCBwICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5RdWF0ZXJuaW9uOiAubXVsdGlwbHkoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5tdWx0aXBseVF1YXRlcm5pb25zKCBhLCBiICkgaW5zdGVhZC4nICk7XG4gICAgXHRcdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlRdWF0ZXJuaW9ucyggcSwgcCApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseVF1YXRlcm5pb25zKCB0aGlzLCBxICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdHByZW11bHRpcGx5OiBmdW5jdGlvbiAoIHEgKSB7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlRdWF0ZXJuaW9ucyggcSwgdGhpcyApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRtdWx0aXBseVF1YXRlcm5pb25zOiBmdW5jdGlvbiAoIGEsIGIgKSB7XG5cbiAgICBcdFx0Ly8gZnJvbSBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9hbGdlYnJhL3JlYWxOb3JtZWRBbGdlYnJhL3F1YXRlcm5pb25zL2NvZGUvaW5kZXguaHRtXG5cbiAgICBcdFx0dmFyIHFheCA9IGEuX3gsIHFheSA9IGEuX3ksIHFheiA9IGEuX3osIHFhdyA9IGEuX3c7XG4gICAgXHRcdHZhciBxYnggPSBiLl94LCBxYnkgPSBiLl95LCBxYnogPSBiLl96LCBxYncgPSBiLl93O1xuXG4gICAgXHRcdHRoaXMuX3ggPSBxYXggKiBxYncgKyBxYXcgKiBxYnggKyBxYXkgKiBxYnogLSBxYXogKiBxYnk7XG4gICAgXHRcdHRoaXMuX3kgPSBxYXkgKiBxYncgKyBxYXcgKiBxYnkgKyBxYXogKiBxYnggLSBxYXggKiBxYno7XG4gICAgXHRcdHRoaXMuX3ogPSBxYXogKiBxYncgKyBxYXcgKiBxYnogKyBxYXggKiBxYnkgLSBxYXkgKiBxYng7XG4gICAgXHRcdHRoaXMuX3cgPSBxYXcgKiBxYncgLSBxYXggKiBxYnggLSBxYXkgKiBxYnkgLSBxYXogKiBxYno7XG5cbiAgICBcdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNsZXJwOiBmdW5jdGlvbiAoIHFiLCB0ICkge1xuXG4gICAgXHRcdGlmICggdCA9PT0gMCApIHJldHVybiB0aGlzO1xuICAgIFx0XHRpZiAoIHQgPT09IDEgKSByZXR1cm4gdGhpcy5jb3B5KCBxYiApO1xuXG4gICAgXHRcdHZhciB4ID0gdGhpcy5feCwgeSA9IHRoaXMuX3ksIHogPSB0aGlzLl96LCB3ID0gdGhpcy5fdztcblxuICAgIFx0XHQvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9hbGdlYnJhL3JlYWxOb3JtZWRBbGdlYnJhL3F1YXRlcm5pb25zL3NsZXJwL1xuXG4gICAgXHRcdHZhciBjb3NIYWxmVGhldGEgPSB3ICogcWIuX3cgKyB4ICogcWIuX3ggKyB5ICogcWIuX3kgKyB6ICogcWIuX3o7XG5cbiAgICBcdFx0aWYgKCBjb3NIYWxmVGhldGEgPCAwICkge1xuXG4gICAgXHRcdFx0dGhpcy5fdyA9IC0gcWIuX3c7XG4gICAgXHRcdFx0dGhpcy5feCA9IC0gcWIuX3g7XG4gICAgXHRcdFx0dGhpcy5feSA9IC0gcWIuX3k7XG4gICAgXHRcdFx0dGhpcy5feiA9IC0gcWIuX3o7XG5cbiAgICBcdFx0XHRjb3NIYWxmVGhldGEgPSAtIGNvc0hhbGZUaGV0YTtcblxuICAgIFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0dGhpcy5jb3B5KCBxYiApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoIGNvc0hhbGZUaGV0YSA+PSAxLjAgKSB7XG5cbiAgICBcdFx0XHR0aGlzLl93ID0gdztcbiAgICBcdFx0XHR0aGlzLl94ID0geDtcbiAgICBcdFx0XHR0aGlzLl95ID0geTtcbiAgICBcdFx0XHR0aGlzLl96ID0gejtcblxuICAgIFx0XHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHR2YXIgc2luSGFsZlRoZXRhID0gTWF0aC5zcXJ0KCAxLjAgLSBjb3NIYWxmVGhldGEgKiBjb3NIYWxmVGhldGEgKTtcblxuICAgIFx0XHRpZiAoIE1hdGguYWJzKCBzaW5IYWxmVGhldGEgKSA8IDAuMDAxICkge1xuXG4gICAgXHRcdFx0dGhpcy5fdyA9IDAuNSAqICggdyArIHRoaXMuX3cgKTtcbiAgICBcdFx0XHR0aGlzLl94ID0gMC41ICogKCB4ICsgdGhpcy5feCApO1xuICAgIFx0XHRcdHRoaXMuX3kgPSAwLjUgKiAoIHkgKyB0aGlzLl95ICk7XG4gICAgXHRcdFx0dGhpcy5feiA9IDAuNSAqICggeiArIHRoaXMuX3ogKTtcblxuICAgIFx0XHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHR2YXIgaGFsZlRoZXRhID0gTWF0aC5hdGFuMiggc2luSGFsZlRoZXRhLCBjb3NIYWxmVGhldGEgKTtcbiAgICBcdFx0dmFyIHJhdGlvQSA9IE1hdGguc2luKCAoIDEgLSB0ICkgKiBoYWxmVGhldGEgKSAvIHNpbkhhbGZUaGV0YSxcbiAgICBcdFx0cmF0aW9CID0gTWF0aC5zaW4oIHQgKiBoYWxmVGhldGEgKSAvIHNpbkhhbGZUaGV0YTtcblxuICAgIFx0XHR0aGlzLl93ID0gKCB3ICogcmF0aW9BICsgdGhpcy5fdyAqIHJhdGlvQiApO1xuICAgIFx0XHR0aGlzLl94ID0gKCB4ICogcmF0aW9BICsgdGhpcy5feCAqIHJhdGlvQiApO1xuICAgIFx0XHR0aGlzLl95ID0gKCB5ICogcmF0aW9BICsgdGhpcy5feSAqIHJhdGlvQiApO1xuICAgIFx0XHR0aGlzLl96ID0gKCB6ICogcmF0aW9BICsgdGhpcy5feiAqIHJhdGlvQiApO1xuXG4gICAgXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRlcXVhbHM6IGZ1bmN0aW9uICggcXVhdGVybmlvbiApIHtcblxuICAgIFx0XHRyZXR1cm4gKCBxdWF0ZXJuaW9uLl94ID09PSB0aGlzLl94ICkgJiYgKCBxdWF0ZXJuaW9uLl95ID09PSB0aGlzLl95ICkgJiYgKCBxdWF0ZXJuaW9uLl96ID09PSB0aGlzLl96ICkgJiYgKCBxdWF0ZXJuaW9uLl93ID09PSB0aGlzLl93ICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGZyb21BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xuXG4gICAgXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG4gICAgXHRcdHRoaXMuX3ggPSBhcnJheVsgb2Zmc2V0IF07XG4gICAgXHRcdHRoaXMuX3kgPSBhcnJheVsgb2Zmc2V0ICsgMSBdO1xuICAgIFx0XHR0aGlzLl96ID0gYXJyYXlbIG9mZnNldCArIDIgXTtcbiAgICBcdFx0dGhpcy5fdyA9IGFycmF5WyBvZmZzZXQgKyAzIF07XG5cbiAgICBcdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdHRvQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcblxuICAgIFx0XHRpZiAoIGFycmF5ID09PSB1bmRlZmluZWQgKSBhcnJheSA9IFtdO1xuICAgIFx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuICAgIFx0XHRhcnJheVsgb2Zmc2V0IF0gPSB0aGlzLl94O1xuICAgIFx0XHRhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGhpcy5feTtcbiAgICBcdFx0YXJyYXlbIG9mZnNldCArIDIgXSA9IHRoaXMuX3o7XG4gICAgXHRcdGFycmF5WyBvZmZzZXQgKyAzIF0gPSB0aGlzLl93O1xuXG4gICAgXHRcdHJldHVybiBhcnJheTtcblxuICAgIFx0fSxcblxuICAgIFx0b25DaGFuZ2U6IGZ1bmN0aW9uICggY2FsbGJhY2sgKSB7XG5cbiAgICBcdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrID0gY2FsbGJhY2s7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdG9uQ2hhbmdlQ2FsbGJhY2s6IGZ1bmN0aW9uICgpIHt9XG5cbiAgICB9O1xuXG4gICAgT2JqZWN0LmFzc2lnbiggUXVhdGVybmlvbiwge1xuXG4gICAgXHRzbGVycDogZnVuY3Rpb24oIHFhLCBxYiwgcW0sIHQgKSB7XG5cbiAgICBcdFx0cmV0dXJuIHFtLmNvcHkoIHFhICkuc2xlcnAoIHFiLCB0ICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNsZXJwRmxhdDogZnVuY3Rpb24oXG4gICAgXHRcdFx0ZHN0LCBkc3RPZmZzZXQsIHNyYzAsIHNyY09mZnNldDAsIHNyYzEsIHNyY09mZnNldDEsIHQgKSB7XG5cbiAgICBcdFx0Ly8gZnV6ei1mcmVlLCBhcnJheS1iYXNlZCBRdWF0ZXJuaW9uIFNMRVJQIG9wZXJhdGlvblxuXG4gICAgXHRcdHZhciB4MCA9IHNyYzBbIHNyY09mZnNldDAgKyAwIF0sXG4gICAgXHRcdFx0eTAgPSBzcmMwWyBzcmNPZmZzZXQwICsgMSBdLFxuICAgIFx0XHRcdHowID0gc3JjMFsgc3JjT2Zmc2V0MCArIDIgXSxcbiAgICBcdFx0XHR3MCA9IHNyYzBbIHNyY09mZnNldDAgKyAzIF0sXG5cbiAgICBcdFx0XHR4MSA9IHNyYzFbIHNyY09mZnNldDEgKyAwIF0sXG4gICAgXHRcdFx0eTEgPSBzcmMxWyBzcmNPZmZzZXQxICsgMSBdLFxuICAgIFx0XHRcdHoxID0gc3JjMVsgc3JjT2Zmc2V0MSArIDIgXSxcbiAgICBcdFx0XHR3MSA9IHNyYzFbIHNyY09mZnNldDEgKyAzIF07XG5cbiAgICBcdFx0aWYgKCB3MCAhPT0gdzEgfHwgeDAgIT09IHgxIHx8IHkwICE9PSB5MSB8fCB6MCAhPT0gejEgKSB7XG5cbiAgICBcdFx0XHR2YXIgcyA9IDEgLSB0LFxuXG4gICAgXHRcdFx0XHRjb3MgPSB4MCAqIHgxICsgeTAgKiB5MSArIHowICogejEgKyB3MCAqIHcxLFxuXG4gICAgXHRcdFx0XHRkaXIgPSAoIGNvcyA+PSAwID8gMSA6IC0gMSApLFxuICAgIFx0XHRcdFx0c3FyU2luID0gMSAtIGNvcyAqIGNvcztcblxuICAgIFx0XHRcdC8vIFNraXAgdGhlIFNsZXJwIGZvciB0aW55IHN0ZXBzIHRvIGF2b2lkIG51bWVyaWMgcHJvYmxlbXM6XG4gICAgXHRcdFx0aWYgKCBzcXJTaW4gPiBOdW1iZXIuRVBTSUxPTiApIHtcblxuICAgIFx0XHRcdFx0dmFyIHNpbiA9IE1hdGguc3FydCggc3FyU2luICksXG4gICAgXHRcdFx0XHRcdGxlbiA9IE1hdGguYXRhbjIoIHNpbiwgY29zICogZGlyICk7XG5cbiAgICBcdFx0XHRcdHMgPSBNYXRoLnNpbiggcyAqIGxlbiApIC8gc2luO1xuICAgIFx0XHRcdFx0dCA9IE1hdGguc2luKCB0ICogbGVuICkgLyBzaW47XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHR2YXIgdERpciA9IHQgKiBkaXI7XG5cbiAgICBcdFx0XHR4MCA9IHgwICogcyArIHgxICogdERpcjtcbiAgICBcdFx0XHR5MCA9IHkwICogcyArIHkxICogdERpcjtcbiAgICBcdFx0XHR6MCA9IHowICogcyArIHoxICogdERpcjtcbiAgICBcdFx0XHR3MCA9IHcwICogcyArIHcxICogdERpcjtcblxuICAgIFx0XHRcdC8vIE5vcm1hbGl6ZSBpbiBjYXNlIHdlIGp1c3QgZGlkIGEgbGVycDpcbiAgICBcdFx0XHRpZiAoIHMgPT09IDEgLSB0ICkge1xuXG4gICAgXHRcdFx0XHR2YXIgZiA9IDEgLyBNYXRoLnNxcnQoIHgwICogeDAgKyB5MCAqIHkwICsgejAgKiB6MCArIHcwICogdzAgKTtcblxuICAgIFx0XHRcdFx0eDAgKj0gZjtcbiAgICBcdFx0XHRcdHkwICo9IGY7XG4gICAgXHRcdFx0XHR6MCAqPSBmO1xuICAgIFx0XHRcdFx0dzAgKj0gZjtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdFx0ZHN0WyBkc3RPZmZzZXQgXSA9IHgwO1xuICAgIFx0XHRkc3RbIGRzdE9mZnNldCArIDEgXSA9IHkwO1xuICAgIFx0XHRkc3RbIGRzdE9mZnNldCArIDIgXSA9IHowO1xuICAgIFx0XHRkc3RbIGRzdE9mZnNldCArIDMgXSA9IHcwO1xuXG4gICAgXHR9XG5cbiAgICB9ICk7XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICAgICAqIEBhdXRob3IgKmtpbGUgLyBodHRwOi8va2lsZS5zdHJhdmFnYW56YS5vcmcvXG4gICAgICogQGF1dGhvciBwaGlsb2diIC8gaHR0cDovL2Jsb2cudGhlaml0Lm9yZy9cbiAgICAgKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICAgICAqIEBhdXRob3IgZWdyYWV0aGVyIC8gaHR0cDovL2VncmFldGhlci5jb20vXG4gICAgICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBWZWN0b3IzKCB4LCB5LCB6ICkge1xuXG4gICAgXHR0aGlzLnggPSB4IHx8IDA7XG4gICAgXHR0aGlzLnkgPSB5IHx8IDA7XG4gICAgXHR0aGlzLnogPSB6IHx8IDA7XG5cbiAgICB9XG5cbiAgICBWZWN0b3IzLnByb3RvdHlwZSA9IHtcblxuICAgIFx0Y29uc3RydWN0b3I6IFZlY3RvcjMsXG5cbiAgICBcdGlzVmVjdG9yMzogdHJ1ZSxcblxuICAgIFx0c2V0OiBmdW5jdGlvbiAoIHgsIHksIHogKSB7XG5cbiAgICBcdFx0dGhpcy54ID0geDtcbiAgICBcdFx0dGhpcy55ID0geTtcbiAgICBcdFx0dGhpcy56ID0gejtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0c2V0U2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcblxuICAgIFx0XHR0aGlzLnggPSBzY2FsYXI7XG4gICAgXHRcdHRoaXMueSA9IHNjYWxhcjtcbiAgICBcdFx0dGhpcy56ID0gc2NhbGFyO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzZXRYOiBmdW5jdGlvbiAoIHggKSB7XG5cbiAgICBcdFx0dGhpcy54ID0geDtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0c2V0WTogZnVuY3Rpb24gKCB5ICkge1xuXG4gICAgXHRcdHRoaXMueSA9IHk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldFo6IGZ1bmN0aW9uICggeiApIHtcblxuICAgIFx0XHR0aGlzLnogPSB6O1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzZXRDb21wb25lbnQ6IGZ1bmN0aW9uICggaW5kZXgsIHZhbHVlICkge1xuXG4gICAgXHRcdHN3aXRjaCAoIGluZGV4ICkge1xuXG4gICAgXHRcdFx0Y2FzZSAwOiB0aGlzLnggPSB2YWx1ZTsgYnJlYWs7XG4gICAgXHRcdFx0Y2FzZSAxOiB0aGlzLnkgPSB2YWx1ZTsgYnJlYWs7XG4gICAgXHRcdFx0Y2FzZSAyOiB0aGlzLnogPSB2YWx1ZTsgYnJlYWs7XG4gICAgXHRcdFx0ZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCAnaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAnICsgaW5kZXggKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdH0sXG5cbiAgICBcdGdldENvbXBvbmVudDogZnVuY3Rpb24gKCBpbmRleCApIHtcblxuICAgIFx0XHRzd2l0Y2ggKCBpbmRleCApIHtcblxuICAgIFx0XHRcdGNhc2UgMDogcmV0dXJuIHRoaXMueDtcbiAgICBcdFx0XHRjYXNlIDE6IHJldHVybiB0aGlzLnk7XG4gICAgXHRcdFx0Y2FzZSAyOiByZXR1cm4gdGhpcy56O1xuICAgIFx0XHRcdGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvciggJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4ICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9LFxuXG4gICAgXHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy54LCB0aGlzLnksIHRoaXMueiApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRjb3B5OiBmdW5jdGlvbiAoIHYgKSB7XG5cbiAgICBcdFx0dGhpcy54ID0gdi54O1xuICAgIFx0XHR0aGlzLnkgPSB2Lnk7XG4gICAgXHRcdHRoaXMueiA9IHYuejtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0YWRkOiBmdW5jdGlvbiAoIHYsIHcgKSB7XG5cbiAgICBcdFx0aWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IzOiAuYWRkKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuYWRkVmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyApO1xuICAgIFx0XHRcdHJldHVybiB0aGlzLmFkZFZlY3RvcnMoIHYsIHcgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0dGhpcy54ICs9IHYueDtcbiAgICBcdFx0dGhpcy55ICs9IHYueTtcbiAgICBcdFx0dGhpcy56ICs9IHYuejtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0YWRkU2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XG5cbiAgICBcdFx0dGhpcy54ICs9IHM7XG4gICAgXHRcdHRoaXMueSArPSBzO1xuICAgIFx0XHR0aGlzLnogKz0gcztcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0YWRkVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xuXG4gICAgXHRcdHRoaXMueCA9IGEueCArIGIueDtcbiAgICBcdFx0dGhpcy55ID0gYS55ICsgYi55O1xuICAgIFx0XHR0aGlzLnogPSBhLnogKyBiLno7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGFkZFNjYWxlZFZlY3RvcjogZnVuY3Rpb24gKCB2LCBzICkge1xuXG4gICAgXHRcdHRoaXMueCArPSB2LnggKiBzO1xuICAgIFx0XHR0aGlzLnkgKz0gdi55ICogcztcbiAgICBcdFx0dGhpcy56ICs9IHYueiAqIHM7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdHN1YjogZnVuY3Rpb24gKCB2LCB3ICkge1xuXG4gICAgXHRcdGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLnN1YigpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLnN1YlZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcbiAgICBcdFx0XHRyZXR1cm4gdGhpcy5zdWJWZWN0b3JzKCB2LCB3ICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHRoaXMueCAtPSB2Lng7XG4gICAgXHRcdHRoaXMueSAtPSB2Lnk7XG4gICAgXHRcdHRoaXMueiAtPSB2Lno7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdHN1YlNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xuXG4gICAgXHRcdHRoaXMueCAtPSBzO1xuICAgIFx0XHR0aGlzLnkgLT0gcztcbiAgICBcdFx0dGhpcy56IC09IHM7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdHN1YlZlY3RvcnM6IGZ1bmN0aW9uICggYSwgYiApIHtcblxuICAgIFx0XHR0aGlzLnggPSBhLnggLSBiLng7XG4gICAgXHRcdHRoaXMueSA9IGEueSAtIGIueTtcbiAgICBcdFx0dGhpcy56ID0gYS56IC0gYi56O1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRtdWx0aXBseTogZnVuY3Rpb24gKCB2LCB3ICkge1xuXG4gICAgXHRcdGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLm11bHRpcGx5KCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAubXVsdGlwbHlWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XG4gICAgXHRcdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlWZWN0b3JzKCB2LCB3ICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHRoaXMueCAqPSB2Lng7XG4gICAgXHRcdHRoaXMueSAqPSB2Lnk7XG4gICAgXHRcdHRoaXMueiAqPSB2Lno7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdG11bHRpcGx5U2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcblxuICAgIFx0XHRpZiAoIGlzRmluaXRlKCBzY2FsYXIgKSApIHtcblxuICAgIFx0XHRcdHRoaXMueCAqPSBzY2FsYXI7XG4gICAgXHRcdFx0dGhpcy55ICo9IHNjYWxhcjtcbiAgICBcdFx0XHR0aGlzLnogKj0gc2NhbGFyO1xuXG4gICAgXHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHR0aGlzLnggPSAwO1xuICAgIFx0XHRcdHRoaXMueSA9IDA7XG4gICAgXHRcdFx0dGhpcy56ID0gMDtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdG11bHRpcGx5VmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xuXG4gICAgXHRcdHRoaXMueCA9IGEueCAqIGIueDtcbiAgICBcdFx0dGhpcy55ID0gYS55ICogYi55O1xuICAgIFx0XHR0aGlzLnogPSBhLnogKiBiLno7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGFwcGx5RXVsZXI6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR2YXIgcXVhdGVybmlvbjtcblxuICAgIFx0XHRyZXR1cm4gZnVuY3Rpb24gYXBwbHlFdWxlciggZXVsZXIgKSB7XG5cbiAgICBcdFx0XHRpZiAoIChldWxlciAmJiBldWxlci5pc0V1bGVyKSA9PT0gZmFsc2UgKSB7XG5cbiAgICBcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5WZWN0b3IzOiAuYXBwbHlFdWxlcigpIG5vdyBleHBlY3RzIGFuIEV1bGVyIHJvdGF0aW9uIHJhdGhlciB0aGFuIGEgVmVjdG9yMyBhbmQgb3JkZXIuJyApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0aWYgKCBxdWF0ZXJuaW9uID09PSB1bmRlZmluZWQgKSBxdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKTtcblxuICAgIFx0XHRcdHJldHVybiB0aGlzLmFwcGx5UXVhdGVybmlvbiggcXVhdGVybmlvbi5zZXRGcm9tRXVsZXIoIGV1bGVyICkgKTtcblxuICAgIFx0XHR9O1xuXG4gICAgXHR9KCksXG5cbiAgICBcdGFwcGx5QXhpc0FuZ2xlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dmFyIHF1YXRlcm5pb247XG5cbiAgICBcdFx0cmV0dXJuIGZ1bmN0aW9uIGFwcGx5QXhpc0FuZ2xlKCBheGlzLCBhbmdsZSApIHtcblxuICAgIFx0XHRcdGlmICggcXVhdGVybmlvbiA9PT0gdW5kZWZpbmVkICkgcXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG5cbiAgICBcdFx0XHRyZXR1cm4gdGhpcy5hcHBseVF1YXRlcm5pb24oIHF1YXRlcm5pb24uc2V0RnJvbUF4aXNBbmdsZSggYXhpcywgYW5nbGUgKSApO1xuXG4gICAgXHRcdH07XG5cbiAgICBcdH0oKSxcblxuICAgIFx0YXBwbHlNYXRyaXgzOiBmdW5jdGlvbiAoIG0gKSB7XG5cbiAgICBcdFx0dmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLno7XG4gICAgXHRcdHZhciBlID0gbS5lbGVtZW50cztcblxuICAgIFx0XHR0aGlzLnggPSBlWyAwIF0gKiB4ICsgZVsgMyBdICogeSArIGVbIDYgXSAqIHo7XG4gICAgXHRcdHRoaXMueSA9IGVbIDEgXSAqIHggKyBlWyA0IF0gKiB5ICsgZVsgNyBdICogejtcbiAgICBcdFx0dGhpcy56ID0gZVsgMiBdICogeCArIGVbIDUgXSAqIHkgKyBlWyA4IF0gKiB6O1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRhcHBseU1hdHJpeDQ6IGZ1bmN0aW9uICggbSApIHtcblxuICAgIFx0XHQvLyBpbnB1dDogVEhSRUUuTWF0cml4NCBhZmZpbmUgbWF0cml4XG5cbiAgICBcdFx0dmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLno7XG4gICAgXHRcdHZhciBlID0gbS5lbGVtZW50cztcblxuICAgIFx0XHR0aGlzLnggPSBlWyAwIF0gKiB4ICsgZVsgNCBdICogeSArIGVbIDggXSAgKiB6ICsgZVsgMTIgXTtcbiAgICBcdFx0dGhpcy55ID0gZVsgMSBdICogeCArIGVbIDUgXSAqIHkgKyBlWyA5IF0gICogeiArIGVbIDEzIF07XG4gICAgXHRcdHRoaXMueiA9IGVbIDIgXSAqIHggKyBlWyA2IF0gKiB5ICsgZVsgMTAgXSAqIHogKyBlWyAxNCBdO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRhcHBseVByb2plY3Rpb246IGZ1bmN0aW9uICggbSApIHtcblxuICAgIFx0XHQvLyBpbnB1dDogVEhSRUUuTWF0cml4NCBwcm9qZWN0aW9uIG1hdHJpeFxuXG4gICAgXHRcdHZhciB4ID0gdGhpcy54LCB5ID0gdGhpcy55LCB6ID0gdGhpcy56O1xuICAgIFx0XHR2YXIgZSA9IG0uZWxlbWVudHM7XG4gICAgXHRcdHZhciBkID0gMSAvICggZVsgMyBdICogeCArIGVbIDcgXSAqIHkgKyBlWyAxMSBdICogeiArIGVbIDE1IF0gKTsgLy8gcGVyc3BlY3RpdmUgZGl2aWRlXG5cbiAgICBcdFx0dGhpcy54ID0gKCBlWyAwIF0gKiB4ICsgZVsgNCBdICogeSArIGVbIDggXSAgKiB6ICsgZVsgMTIgXSApICogZDtcbiAgICBcdFx0dGhpcy55ID0gKCBlWyAxIF0gKiB4ICsgZVsgNSBdICogeSArIGVbIDkgXSAgKiB6ICsgZVsgMTMgXSApICogZDtcbiAgICBcdFx0dGhpcy56ID0gKCBlWyAyIF0gKiB4ICsgZVsgNiBdICogeSArIGVbIDEwIF0gKiB6ICsgZVsgMTQgXSApICogZDtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0YXBwbHlRdWF0ZXJuaW9uOiBmdW5jdGlvbiAoIHEgKSB7XG5cbiAgICBcdFx0dmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLno7XG4gICAgXHRcdHZhciBxeCA9IHEueCwgcXkgPSBxLnksIHF6ID0gcS56LCBxdyA9IHEudztcblxuICAgIFx0XHQvLyBjYWxjdWxhdGUgcXVhdCAqIHZlY3RvclxuXG4gICAgXHRcdHZhciBpeCA9ICBxdyAqIHggKyBxeSAqIHogLSBxeiAqIHk7XG4gICAgXHRcdHZhciBpeSA9ICBxdyAqIHkgKyBxeiAqIHggLSBxeCAqIHo7XG4gICAgXHRcdHZhciBpeiA9ICBxdyAqIHogKyBxeCAqIHkgLSBxeSAqIHg7XG4gICAgXHRcdHZhciBpdyA9IC0gcXggKiB4IC0gcXkgKiB5IC0gcXogKiB6O1xuXG4gICAgXHRcdC8vIGNhbGN1bGF0ZSByZXN1bHQgKiBpbnZlcnNlIHF1YXRcblxuICAgIFx0XHR0aGlzLnggPSBpeCAqIHF3ICsgaXcgKiAtIHF4ICsgaXkgKiAtIHF6IC0gaXogKiAtIHF5O1xuICAgIFx0XHR0aGlzLnkgPSBpeSAqIHF3ICsgaXcgKiAtIHF5ICsgaXogKiAtIHF4IC0gaXggKiAtIHF6O1xuICAgIFx0XHR0aGlzLnogPSBpeiAqIHF3ICsgaXcgKiAtIHF6ICsgaXggKiAtIHF5IC0gaXkgKiAtIHF4O1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRwcm9qZWN0OiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dmFyIG1hdHJpeDtcblxuICAgIFx0XHRyZXR1cm4gZnVuY3Rpb24gcHJvamVjdCggY2FtZXJhICkge1xuXG4gICAgXHRcdFx0aWYgKCBtYXRyaXggPT09IHVuZGVmaW5lZCApIG1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XG5cbiAgICBcdFx0XHRtYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggY2FtZXJhLnByb2plY3Rpb25NYXRyaXgsIG1hdHJpeC5nZXRJbnZlcnNlKCBjYW1lcmEubWF0cml4V29ybGQgKSApO1xuICAgIFx0XHRcdHJldHVybiB0aGlzLmFwcGx5UHJvamVjdGlvbiggbWF0cml4ICk7XG5cbiAgICBcdFx0fTtcblxuICAgIFx0fSgpLFxuXG4gICAgXHR1bnByb2plY3Q6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR2YXIgbWF0cml4O1xuXG4gICAgXHRcdHJldHVybiBmdW5jdGlvbiB1bnByb2plY3QoIGNhbWVyYSApIHtcblxuICAgIFx0XHRcdGlmICggbWF0cml4ID09PSB1bmRlZmluZWQgKSBtYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuXG4gICAgXHRcdFx0bWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIGNhbWVyYS5tYXRyaXhXb3JsZCwgbWF0cml4LmdldEludmVyc2UoIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4ICkgKTtcbiAgICBcdFx0XHRyZXR1cm4gdGhpcy5hcHBseVByb2plY3Rpb24oIG1hdHJpeCApO1xuXG4gICAgXHRcdH07XG5cbiAgICBcdH0oKSxcblxuICAgIFx0dHJhbnNmb3JtRGlyZWN0aW9uOiBmdW5jdGlvbiAoIG0gKSB7XG5cbiAgICBcdFx0Ly8gaW5wdXQ6IFRIUkVFLk1hdHJpeDQgYWZmaW5lIG1hdHJpeFxuICAgIFx0XHQvLyB2ZWN0b3IgaW50ZXJwcmV0ZWQgYXMgYSBkaXJlY3Rpb25cblxuICAgIFx0XHR2YXIgeCA9IHRoaXMueCwgeSA9IHRoaXMueSwgeiA9IHRoaXMuejtcbiAgICBcdFx0dmFyIGUgPSBtLmVsZW1lbnRzO1xuXG4gICAgXHRcdHRoaXMueCA9IGVbIDAgXSAqIHggKyBlWyA0IF0gKiB5ICsgZVsgOCBdICAqIHo7XG4gICAgXHRcdHRoaXMueSA9IGVbIDEgXSAqIHggKyBlWyA1IF0gKiB5ICsgZVsgOSBdICAqIHo7XG4gICAgXHRcdHRoaXMueiA9IGVbIDIgXSAqIHggKyBlWyA2IF0gKiB5ICsgZVsgMTAgXSAqIHo7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMubm9ybWFsaXplKCk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGRpdmlkZTogZnVuY3Rpb24gKCB2ICkge1xuXG4gICAgXHRcdHRoaXMueCAvPSB2Lng7XG4gICAgXHRcdHRoaXMueSAvPSB2Lnk7XG4gICAgXHRcdHRoaXMueiAvPSB2Lno7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGRpdmlkZVNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoIDEgLyBzY2FsYXIgKTtcblxuICAgIFx0fSxcblxuICAgIFx0bWluOiBmdW5jdGlvbiAoIHYgKSB7XG5cbiAgICBcdFx0dGhpcy54ID0gTWF0aC5taW4oIHRoaXMueCwgdi54ICk7XG4gICAgXHRcdHRoaXMueSA9IE1hdGgubWluKCB0aGlzLnksIHYueSApO1xuICAgIFx0XHR0aGlzLnogPSBNYXRoLm1pbiggdGhpcy56LCB2LnogKTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0bWF4OiBmdW5jdGlvbiAoIHYgKSB7XG5cbiAgICBcdFx0dGhpcy54ID0gTWF0aC5tYXgoIHRoaXMueCwgdi54ICk7XG4gICAgXHRcdHRoaXMueSA9IE1hdGgubWF4KCB0aGlzLnksIHYueSApO1xuICAgIFx0XHR0aGlzLnogPSBNYXRoLm1heCggdGhpcy56LCB2LnogKTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0Y2xhbXA6IGZ1bmN0aW9uICggbWluLCBtYXggKSB7XG5cbiAgICBcdFx0Ly8gVGhpcyBmdW5jdGlvbiBhc3N1bWVzIG1pbiA8IG1heCwgaWYgdGhpcyBhc3N1bXB0aW9uIGlzbid0IHRydWUgaXQgd2lsbCBub3Qgb3BlcmF0ZSBjb3JyZWN0bHlcblxuICAgIFx0XHR0aGlzLnggPSBNYXRoLm1heCggbWluLngsIE1hdGgubWluKCBtYXgueCwgdGhpcy54ICkgKTtcbiAgICBcdFx0dGhpcy55ID0gTWF0aC5tYXgoIG1pbi55LCBNYXRoLm1pbiggbWF4LnksIHRoaXMueSApICk7XG4gICAgXHRcdHRoaXMueiA9IE1hdGgubWF4KCBtaW4ueiwgTWF0aC5taW4oIG1heC56LCB0aGlzLnogKSApO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRjbGFtcFNjYWxhcjogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHZhciBtaW4sIG1heDtcblxuICAgIFx0XHRyZXR1cm4gZnVuY3Rpb24gY2xhbXBTY2FsYXIoIG1pblZhbCwgbWF4VmFsICkge1xuXG4gICAgXHRcdFx0aWYgKCBtaW4gPT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0bWluID0gbmV3IFZlY3RvcjMoKTtcbiAgICBcdFx0XHRcdG1heCA9IG5ldyBWZWN0b3IzKCk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRtaW4uc2V0KCBtaW5WYWwsIG1pblZhbCwgbWluVmFsICk7XG4gICAgXHRcdFx0bWF4LnNldCggbWF4VmFsLCBtYXhWYWwsIG1heFZhbCApO1xuXG4gICAgXHRcdFx0cmV0dXJuIHRoaXMuY2xhbXAoIG1pbiwgbWF4ICk7XG5cbiAgICBcdFx0fTtcblxuICAgIFx0fSgpLFxuXG4gICAgXHRjbGFtcExlbmd0aDogZnVuY3Rpb24gKCBtaW4sIG1heCApIHtcblxuICAgIFx0XHR2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGgoKTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseVNjYWxhciggTWF0aC5tYXgoIG1pbiwgTWF0aC5taW4oIG1heCwgbGVuZ3RoICkgKSAvIGxlbmd0aCApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRmbG9vcjogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHRoaXMueCA9IE1hdGguZmxvb3IoIHRoaXMueCApO1xuICAgIFx0XHR0aGlzLnkgPSBNYXRoLmZsb29yKCB0aGlzLnkgKTtcbiAgICBcdFx0dGhpcy56ID0gTWF0aC5mbG9vciggdGhpcy56ICk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGNlaWw6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR0aGlzLnggPSBNYXRoLmNlaWwoIHRoaXMueCApO1xuICAgIFx0XHR0aGlzLnkgPSBNYXRoLmNlaWwoIHRoaXMueSApO1xuICAgIFx0XHR0aGlzLnogPSBNYXRoLmNlaWwoIHRoaXMueiApO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRyb3VuZDogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHRoaXMueCA9IE1hdGgucm91bmQoIHRoaXMueCApO1xuICAgIFx0XHR0aGlzLnkgPSBNYXRoLnJvdW5kKCB0aGlzLnkgKTtcbiAgICBcdFx0dGhpcy56ID0gTWF0aC5yb3VuZCggdGhpcy56ICk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdHJvdW5kVG9aZXJvOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dGhpcy54ID0gKCB0aGlzLnggPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMueCApIDogTWF0aC5mbG9vciggdGhpcy54ICk7XG4gICAgXHRcdHRoaXMueSA9ICggdGhpcy55IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnkgKSA6IE1hdGguZmxvb3IoIHRoaXMueSApO1xuICAgIFx0XHR0aGlzLnogPSAoIHRoaXMueiA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy56ICkgOiBNYXRoLmZsb29yKCB0aGlzLnogKTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0bmVnYXRlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dGhpcy54ID0gLSB0aGlzLng7XG4gICAgXHRcdHRoaXMueSA9IC0gdGhpcy55O1xuICAgIFx0XHR0aGlzLnogPSAtIHRoaXMuejtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0ZG90OiBmdW5jdGlvbiAoIHYgKSB7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMueCAqIHYueCArIHRoaXMueSAqIHYueSArIHRoaXMueiAqIHYuejtcblxuICAgIFx0fSxcblxuICAgIFx0bGVuZ3RoU3E6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHRyZXR1cm4gdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56O1xuXG4gICAgXHR9LFxuXG4gICAgXHRsZW5ndGg6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHRyZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLnogKTtcblxuICAgIFx0fSxcblxuICAgIFx0bGVuZ3RoTWFuaGF0dGFuOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0cmV0dXJuIE1hdGguYWJzKCB0aGlzLnggKSArIE1hdGguYWJzKCB0aGlzLnkgKSArIE1hdGguYWJzKCB0aGlzLnogKTtcblxuICAgIFx0fSxcblxuICAgIFx0bm9ybWFsaXplOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKCB0aGlzLmxlbmd0aCgpICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldExlbmd0aDogZnVuY3Rpb24gKCBsZW5ndGggKSB7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoIGxlbmd0aCAvIHRoaXMubGVuZ3RoKCkgKTtcblxuICAgIFx0fSxcblxuICAgIFx0bGVycDogZnVuY3Rpb24gKCB2LCBhbHBoYSApIHtcblxuICAgIFx0XHR0aGlzLnggKz0gKCB2LnggLSB0aGlzLnggKSAqIGFscGhhO1xuICAgIFx0XHR0aGlzLnkgKz0gKCB2LnkgLSB0aGlzLnkgKSAqIGFscGhhO1xuICAgIFx0XHR0aGlzLnogKz0gKCB2LnogLSB0aGlzLnogKSAqIGFscGhhO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRsZXJwVmVjdG9yczogZnVuY3Rpb24gKCB2MSwgdjIsIGFscGhhICkge1xuXG4gICAgXHRcdHJldHVybiB0aGlzLnN1YlZlY3RvcnMoIHYyLCB2MSApLm11bHRpcGx5U2NhbGFyKCBhbHBoYSApLmFkZCggdjEgKTtcblxuICAgIFx0fSxcblxuICAgIFx0Y3Jvc3M6IGZ1bmN0aW9uICggdiwgdyApIHtcblxuICAgIFx0XHRpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjM6IC5jcm9zcygpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLmNyb3NzVmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyApO1xuICAgIFx0XHRcdHJldHVybiB0aGlzLmNyb3NzVmVjdG9ycyggdiwgdyApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHR2YXIgeCA9IHRoaXMueCwgeSA9IHRoaXMueSwgeiA9IHRoaXMuejtcblxuICAgIFx0XHR0aGlzLnggPSB5ICogdi56IC0geiAqIHYueTtcbiAgICBcdFx0dGhpcy55ID0geiAqIHYueCAtIHggKiB2Lno7XG4gICAgXHRcdHRoaXMueiA9IHggKiB2LnkgLSB5ICogdi54O1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRjcm9zc1ZlY3RvcnM6IGZ1bmN0aW9uICggYSwgYiApIHtcblxuICAgIFx0XHR2YXIgYXggPSBhLngsIGF5ID0gYS55LCBheiA9IGEuejtcbiAgICBcdFx0dmFyIGJ4ID0gYi54LCBieSA9IGIueSwgYnogPSBiLno7XG5cbiAgICBcdFx0dGhpcy54ID0gYXkgKiBieiAtIGF6ICogYnk7XG4gICAgXHRcdHRoaXMueSA9IGF6ICogYnggLSBheCAqIGJ6O1xuICAgIFx0XHR0aGlzLnogPSBheCAqIGJ5IC0gYXkgKiBieDtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0cHJvamVjdE9uVmVjdG9yOiBmdW5jdGlvbiAoIHZlY3RvciApIHtcblxuICAgIFx0XHR2YXIgc2NhbGFyID0gdmVjdG9yLmRvdCggdGhpcyApIC8gdmVjdG9yLmxlbmd0aFNxKCk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMuY29weSggdmVjdG9yICkubXVsdGlwbHlTY2FsYXIoIHNjYWxhciApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRwcm9qZWN0T25QbGFuZTogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHZhciB2MTtcblxuICAgIFx0XHRyZXR1cm4gZnVuY3Rpb24gcHJvamVjdE9uUGxhbmUoIHBsYW5lTm9ybWFsICkge1xuXG4gICAgXHRcdFx0aWYgKCB2MSA9PT0gdW5kZWZpbmVkICkgdjEgPSBuZXcgVmVjdG9yMygpO1xuXG4gICAgXHRcdFx0djEuY29weSggdGhpcyApLnByb2plY3RPblZlY3RvciggcGxhbmVOb3JtYWwgKTtcblxuICAgIFx0XHRcdHJldHVybiB0aGlzLnN1YiggdjEgKTtcblxuICAgIFx0XHR9O1xuXG4gICAgXHR9KCksXG5cbiAgICBcdHJlZmxlY3Q6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHQvLyByZWZsZWN0IGluY2lkZW50IHZlY3RvciBvZmYgcGxhbmUgb3J0aG9nb25hbCB0byBub3JtYWxcbiAgICBcdFx0Ly8gbm9ybWFsIGlzIGFzc3VtZWQgdG8gaGF2ZSB1bml0IGxlbmd0aFxuXG4gICAgXHRcdHZhciB2MTtcblxuICAgIFx0XHRyZXR1cm4gZnVuY3Rpb24gcmVmbGVjdCggbm9ybWFsICkge1xuXG4gICAgXHRcdFx0aWYgKCB2MSA9PT0gdW5kZWZpbmVkICkgdjEgPSBuZXcgVmVjdG9yMygpO1xuXG4gICAgXHRcdFx0cmV0dXJuIHRoaXMuc3ViKCB2MS5jb3B5KCBub3JtYWwgKS5tdWx0aXBseVNjYWxhciggMiAqIHRoaXMuZG90KCBub3JtYWwgKSApICk7XG5cbiAgICBcdFx0fTtcblxuICAgIFx0fSgpLFxuXG4gICAgXHRhbmdsZVRvOiBmdW5jdGlvbiAoIHYgKSB7XG5cbiAgICBcdFx0dmFyIHRoZXRhID0gdGhpcy5kb3QoIHYgKSAvICggTWF0aC5zcXJ0KCB0aGlzLmxlbmd0aFNxKCkgKiB2Lmxlbmd0aFNxKCkgKSApO1xuXG4gICAgXHRcdC8vIGNsYW1wLCB0byBoYW5kbGUgbnVtZXJpY2FsIHByb2JsZW1zXG5cbiAgICBcdFx0cmV0dXJuIE1hdGguYWNvcyggZXhwb3J0cy5NYXRoLmNsYW1wKCB0aGV0YSwgLSAxLCAxICkgKTtcblxuICAgIFx0fSxcblxuICAgIFx0ZGlzdGFuY2VUbzogZnVuY3Rpb24gKCB2ICkge1xuXG4gICAgXHRcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMuZGlzdGFuY2VUb1NxdWFyZWQoIHYgKSApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRkaXN0YW5jZVRvU3F1YXJlZDogZnVuY3Rpb24gKCB2ICkge1xuXG4gICAgXHRcdHZhciBkeCA9IHRoaXMueCAtIHYueCwgZHkgPSB0aGlzLnkgLSB2LnksIGR6ID0gdGhpcy56IC0gdi56O1xuXG4gICAgXHRcdHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeSArIGR6ICogZHo7XG5cbiAgICBcdH0sXG5cbiAgICBcdGRpc3RhbmNlVG9NYW5oYXR0YW46IGZ1bmN0aW9uICggdiApIHtcblxuICAgIFx0XHRyZXR1cm4gTWF0aC5hYnMoIHRoaXMueCAtIHYueCApICsgTWF0aC5hYnMoIHRoaXMueSAtIHYueSApICsgTWF0aC5hYnMoIHRoaXMueiAtIHYueiApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzZXRGcm9tU3BoZXJpY2FsOiBmdW5jdGlvbiggcyApIHtcblxuICAgIFx0XHR2YXIgc2luUGhpUmFkaXVzID0gTWF0aC5zaW4oIHMucGhpICkgKiBzLnJhZGl1cztcblxuICAgIFx0XHR0aGlzLnggPSBzaW5QaGlSYWRpdXMgKiBNYXRoLnNpbiggcy50aGV0YSApO1xuICAgIFx0XHR0aGlzLnkgPSBNYXRoLmNvcyggcy5waGkgKSAqIHMucmFkaXVzO1xuICAgIFx0XHR0aGlzLnogPSBzaW5QaGlSYWRpdXMgKiBNYXRoLmNvcyggcy50aGV0YSApO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzZXRGcm9tTWF0cml4UG9zaXRpb246IGZ1bmN0aW9uICggbSApIHtcblxuICAgIFx0XHRyZXR1cm4gdGhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKCBtLCAzICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldEZyb21NYXRyaXhTY2FsZTogZnVuY3Rpb24gKCBtICkge1xuXG4gICAgXHRcdHZhciBzeCA9IHRoaXMuc2V0RnJvbU1hdHJpeENvbHVtbiggbSwgMCApLmxlbmd0aCgpO1xuICAgIFx0XHR2YXIgc3kgPSB0aGlzLnNldEZyb21NYXRyaXhDb2x1bW4oIG0sIDEgKS5sZW5ndGgoKTtcbiAgICBcdFx0dmFyIHN6ID0gdGhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKCBtLCAyICkubGVuZ3RoKCk7XG5cbiAgICBcdFx0dGhpcy54ID0gc3g7XG4gICAgXHRcdHRoaXMueSA9IHN5O1xuICAgIFx0XHR0aGlzLnogPSBzejtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0c2V0RnJvbU1hdHJpeENvbHVtbjogZnVuY3Rpb24gKCBtLCBpbmRleCApIHtcblxuICAgIFx0XHRpZiAoIHR5cGVvZiBtID09PSAnbnVtYmVyJyApIHtcblxuICAgIFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjM6IHNldEZyb21NYXRyaXhDb2x1bW4gbm93IGV4cGVjdHMgKCBtYXRyaXgsIGluZGV4ICkuJyApO1xuICAgIFx0XHRcdHZhciB0ZW1wID0gbVxuICAgIFx0XHRcdG0gPSBpbmRleDtcbiAgICBcdFx0XHRpbmRleCA9IHRlbXA7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiB0aGlzLmZyb21BcnJheSggbS5lbGVtZW50cywgaW5kZXggKiA0ICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGVxdWFsczogZnVuY3Rpb24gKCB2ICkge1xuXG4gICAgXHRcdHJldHVybiAoICggdi54ID09PSB0aGlzLnggKSAmJiAoIHYueSA9PT0gdGhpcy55ICkgJiYgKCB2LnogPT09IHRoaXMueiApICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGZyb21BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xuXG4gICAgXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG4gICAgXHRcdHRoaXMueCA9IGFycmF5WyBvZmZzZXQgXTtcbiAgICBcdFx0dGhpcy55ID0gYXJyYXlbIG9mZnNldCArIDEgXTtcbiAgICBcdFx0dGhpcy56ID0gYXJyYXlbIG9mZnNldCArIDIgXTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0dG9BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xuXG4gICAgXHRcdGlmICggYXJyYXkgPT09IHVuZGVmaW5lZCApIGFycmF5ID0gW107XG4gICAgXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG4gICAgXHRcdGFycmF5WyBvZmZzZXQgXSA9IHRoaXMueDtcbiAgICBcdFx0YXJyYXlbIG9mZnNldCArIDEgXSA9IHRoaXMueTtcbiAgICBcdFx0YXJyYXlbIG9mZnNldCArIDIgXSA9IHRoaXMuejtcblxuICAgIFx0XHRyZXR1cm4gYXJyYXk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGZyb21BdHRyaWJ1dGU6IGZ1bmN0aW9uICggYXR0cmlidXRlLCBpbmRleCwgb2Zmc2V0ICkge1xuXG4gICAgXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG4gICAgXHRcdGluZGV4ID0gaW5kZXggKiBhdHRyaWJ1dGUuaXRlbVNpemUgKyBvZmZzZXQ7XG5cbiAgICBcdFx0dGhpcy54ID0gYXR0cmlidXRlLmFycmF5WyBpbmRleCBdO1xuICAgIFx0XHR0aGlzLnkgPSBhdHRyaWJ1dGUuYXJyYXlbIGluZGV4ICsgMSBdO1xuICAgIFx0XHR0aGlzLnogPSBhdHRyaWJ1dGUuYXJyYXlbIGluZGV4ICsgMiBdO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9XG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAgICAgKiBAYXV0aG9yIHN1cGVyZWdnYmVydCAvIGh0dHA6Ly93d3cucGF1bGJydW50LmNvLnVrL1xuICAgICAqIEBhdXRob3IgcGhpbG9nYiAvIGh0dHA6Ly9ibG9nLnRoZWppdC5vcmcvXG4gICAgICogQGF1dGhvciBqb3JkaV9yb3MgLyBodHRwOi8vcGxhdHRzb2Z0LmNvbVxuICAgICAqIEBhdXRob3IgRDFwbG8xZCAvIGh0dHA6Ly9naXRodWIuY29tL0QxcGxvMWRcbiAgICAgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICAgICAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gICAgICogQGF1dGhvciB0aW1rbmlwIC8gaHR0cDovL3d3dy5mbG9vcnBsYW5uZXIuY29tL1xuICAgICAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cbiAgICAgKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIE1hdHJpeDQoKSB7XG5cbiAgICBcdHRoaXMuZWxlbWVudHMgPSBuZXcgRmxvYXQzMkFycmF5KCBbXG5cbiAgICBcdFx0MSwgMCwgMCwgMCxcbiAgICBcdFx0MCwgMSwgMCwgMCxcbiAgICBcdFx0MCwgMCwgMSwgMCxcbiAgICBcdFx0MCwgMCwgMCwgMVxuXG4gICAgXHRdICk7XG5cbiAgICBcdGlmICggYXJndW1lbnRzLmxlbmd0aCA+IDAgKSB7XG5cbiAgICBcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLk1hdHJpeDQ6IHRoZSBjb25zdHJ1Y3RvciBubyBsb25nZXIgcmVhZHMgYXJndW1lbnRzLiB1c2UgLnNldCgpIGluc3RlYWQuJyApO1xuXG4gICAgXHR9XG5cbiAgICB9XG5cbiAgICBNYXRyaXg0LnByb3RvdHlwZSA9IHtcblxuICAgIFx0Y29uc3RydWN0b3I6IE1hdHJpeDQsXG5cbiAgICBcdGlzTWF0cml4NDogdHJ1ZSxcblxuICAgIFx0c2V0OiBmdW5jdGlvbiAoIG4xMSwgbjEyLCBuMTMsIG4xNCwgbjIxLCBuMjIsIG4yMywgbjI0LCBuMzEsIG4zMiwgbjMzLCBuMzQsIG40MSwgbjQyLCBuNDMsIG40NCApIHtcblxuICAgIFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG4gICAgXHRcdHRlWyAwIF0gPSBuMTE7IHRlWyA0IF0gPSBuMTI7IHRlWyA4IF0gPSBuMTM7IHRlWyAxMiBdID0gbjE0O1xuICAgIFx0XHR0ZVsgMSBdID0gbjIxOyB0ZVsgNSBdID0gbjIyOyB0ZVsgOSBdID0gbjIzOyB0ZVsgMTMgXSA9IG4yNDtcbiAgICBcdFx0dGVbIDIgXSA9IG4zMTsgdGVbIDYgXSA9IG4zMjsgdGVbIDEwIF0gPSBuMzM7IHRlWyAxNCBdID0gbjM0O1xuICAgIFx0XHR0ZVsgMyBdID0gbjQxOyB0ZVsgNyBdID0gbjQyOyB0ZVsgMTEgXSA9IG40MzsgdGVbIDE1IF0gPSBuNDQ7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGlkZW50aXR5OiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dGhpcy5zZXQoXG5cbiAgICBcdFx0XHQxLCAwLCAwLCAwLFxuICAgIFx0XHRcdDAsIDEsIDAsIDAsXG4gICAgXHRcdFx0MCwgMCwgMSwgMCxcbiAgICBcdFx0XHQwLCAwLCAwLCAxXG5cbiAgICBcdFx0KTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHRyZXR1cm4gbmV3IE1hdHJpeDQoKS5mcm9tQXJyYXkoIHRoaXMuZWxlbWVudHMgKTtcblxuICAgIFx0fSxcblxuICAgIFx0Y29weTogZnVuY3Rpb24gKCBtICkge1xuXG4gICAgXHRcdHRoaXMuZWxlbWVudHMuc2V0KCBtLmVsZW1lbnRzICk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGNvcHlQb3NpdGlvbjogZnVuY3Rpb24gKCBtICkge1xuXG4gICAgXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG4gICAgXHRcdHZhciBtZSA9IG0uZWxlbWVudHM7XG5cbiAgICBcdFx0dGVbIDEyIF0gPSBtZVsgMTIgXTtcbiAgICBcdFx0dGVbIDEzIF0gPSBtZVsgMTMgXTtcbiAgICBcdFx0dGVbIDE0IF0gPSBtZVsgMTQgXTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0ZXh0cmFjdEJhc2lzOiBmdW5jdGlvbiAoIHhBeGlzLCB5QXhpcywgekF4aXMgKSB7XG5cbiAgICBcdFx0eEF4aXMuc2V0RnJvbU1hdHJpeENvbHVtbiggdGhpcywgMCApO1xuICAgIFx0XHR5QXhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKCB0aGlzLCAxICk7XG4gICAgXHRcdHpBeGlzLnNldEZyb21NYXRyaXhDb2x1bW4oIHRoaXMsIDIgKTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0bWFrZUJhc2lzOiBmdW5jdGlvbiAoIHhBeGlzLCB5QXhpcywgekF4aXMgKSB7XG5cbiAgICBcdFx0dGhpcy5zZXQoXG4gICAgXHRcdFx0eEF4aXMueCwgeUF4aXMueCwgekF4aXMueCwgMCxcbiAgICBcdFx0XHR4QXhpcy55LCB5QXhpcy55LCB6QXhpcy55LCAwLFxuICAgIFx0XHRcdHhBeGlzLnosIHlBeGlzLnosIHpBeGlzLnosIDAsXG4gICAgXHRcdFx0MCwgICAgICAgMCwgICAgICAgMCwgICAgICAgMVxuICAgIFx0XHQpO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRleHRyYWN0Um90YXRpb246IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR2YXIgdjE7XG5cbiAgICBcdFx0cmV0dXJuIGZ1bmN0aW9uIGV4dHJhY3RSb3RhdGlvbiggbSApIHtcblxuICAgIFx0XHRcdGlmICggdjEgPT09IHVuZGVmaW5lZCApIHYxID0gbmV3IFZlY3RvcjMoKTtcblxuICAgIFx0XHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG4gICAgXHRcdFx0dmFyIG1lID0gbS5lbGVtZW50cztcblxuICAgIFx0XHRcdHZhciBzY2FsZVggPSAxIC8gdjEuc2V0RnJvbU1hdHJpeENvbHVtbiggbSwgMCApLmxlbmd0aCgpO1xuICAgIFx0XHRcdHZhciBzY2FsZVkgPSAxIC8gdjEuc2V0RnJvbU1hdHJpeENvbHVtbiggbSwgMSApLmxlbmd0aCgpO1xuICAgIFx0XHRcdHZhciBzY2FsZVogPSAxIC8gdjEuc2V0RnJvbU1hdHJpeENvbHVtbiggbSwgMiApLmxlbmd0aCgpO1xuXG4gICAgXHRcdFx0dGVbIDAgXSA9IG1lWyAwIF0gKiBzY2FsZVg7XG4gICAgXHRcdFx0dGVbIDEgXSA9IG1lWyAxIF0gKiBzY2FsZVg7XG4gICAgXHRcdFx0dGVbIDIgXSA9IG1lWyAyIF0gKiBzY2FsZVg7XG5cbiAgICBcdFx0XHR0ZVsgNCBdID0gbWVbIDQgXSAqIHNjYWxlWTtcbiAgICBcdFx0XHR0ZVsgNSBdID0gbWVbIDUgXSAqIHNjYWxlWTtcbiAgICBcdFx0XHR0ZVsgNiBdID0gbWVbIDYgXSAqIHNjYWxlWTtcblxuICAgIFx0XHRcdHRlWyA4IF0gPSBtZVsgOCBdICogc2NhbGVaO1xuICAgIFx0XHRcdHRlWyA5IF0gPSBtZVsgOSBdICogc2NhbGVaO1xuICAgIFx0XHRcdHRlWyAxMCBdID0gbWVbIDEwIF0gKiBzY2FsZVo7XG5cbiAgICBcdFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0XHR9O1xuXG4gICAgXHR9KCksXG5cbiAgICBcdG1ha2VSb3RhdGlvbkZyb21FdWxlcjogZnVuY3Rpb24gKCBldWxlciApIHtcblxuICAgIFx0XHRpZiAoIChldWxlciAmJiBldWxlci5pc0V1bGVyKSA9PT0gZmFsc2UgKSB7XG5cbiAgICBcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuTWF0cml4OiAubWFrZVJvdGF0aW9uRnJvbUV1bGVyKCkgbm93IGV4cGVjdHMgYSBFdWxlciByb3RhdGlvbiByYXRoZXIgdGhhbiBhIFZlY3RvcjMgYW5kIG9yZGVyLicgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuICAgIFx0XHR2YXIgeCA9IGV1bGVyLngsIHkgPSBldWxlci55LCB6ID0gZXVsZXIuejtcbiAgICBcdFx0dmFyIGEgPSBNYXRoLmNvcyggeCApLCBiID0gTWF0aC5zaW4oIHggKTtcbiAgICBcdFx0dmFyIGMgPSBNYXRoLmNvcyggeSApLCBkID0gTWF0aC5zaW4oIHkgKTtcbiAgICBcdFx0dmFyIGUgPSBNYXRoLmNvcyggeiApLCBmID0gTWF0aC5zaW4oIHogKTtcblxuICAgIFx0XHRpZiAoIGV1bGVyLm9yZGVyID09PSAnWFlaJyApIHtcblxuICAgIFx0XHRcdHZhciBhZSA9IGEgKiBlLCBhZiA9IGEgKiBmLCBiZSA9IGIgKiBlLCBiZiA9IGIgKiBmO1xuXG4gICAgXHRcdFx0dGVbIDAgXSA9IGMgKiBlO1xuICAgIFx0XHRcdHRlWyA0IF0gPSAtIGMgKiBmO1xuICAgIFx0XHRcdHRlWyA4IF0gPSBkO1xuXG4gICAgXHRcdFx0dGVbIDEgXSA9IGFmICsgYmUgKiBkO1xuICAgIFx0XHRcdHRlWyA1IF0gPSBhZSAtIGJmICogZDtcbiAgICBcdFx0XHR0ZVsgOSBdID0gLSBiICogYztcblxuICAgIFx0XHRcdHRlWyAyIF0gPSBiZiAtIGFlICogZDtcbiAgICBcdFx0XHR0ZVsgNiBdID0gYmUgKyBhZiAqIGQ7XG4gICAgXHRcdFx0dGVbIDEwIF0gPSBhICogYztcblxuICAgIFx0XHR9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1lYWicgKSB7XG5cbiAgICBcdFx0XHR2YXIgY2UgPSBjICogZSwgY2YgPSBjICogZiwgZGUgPSBkICogZSwgZGYgPSBkICogZjtcblxuICAgIFx0XHRcdHRlWyAwIF0gPSBjZSArIGRmICogYjtcbiAgICBcdFx0XHR0ZVsgNCBdID0gZGUgKiBiIC0gY2Y7XG4gICAgXHRcdFx0dGVbIDggXSA9IGEgKiBkO1xuXG4gICAgXHRcdFx0dGVbIDEgXSA9IGEgKiBmO1xuICAgIFx0XHRcdHRlWyA1IF0gPSBhICogZTtcbiAgICBcdFx0XHR0ZVsgOSBdID0gLSBiO1xuXG4gICAgXHRcdFx0dGVbIDIgXSA9IGNmICogYiAtIGRlO1xuICAgIFx0XHRcdHRlWyA2IF0gPSBkZiArIGNlICogYjtcbiAgICBcdFx0XHR0ZVsgMTAgXSA9IGEgKiBjO1xuXG4gICAgXHRcdH0gZWxzZSBpZiAoIGV1bGVyLm9yZGVyID09PSAnWlhZJyApIHtcblxuICAgIFx0XHRcdHZhciBjZSA9IGMgKiBlLCBjZiA9IGMgKiBmLCBkZSA9IGQgKiBlLCBkZiA9IGQgKiBmO1xuXG4gICAgXHRcdFx0dGVbIDAgXSA9IGNlIC0gZGYgKiBiO1xuICAgIFx0XHRcdHRlWyA0IF0gPSAtIGEgKiBmO1xuICAgIFx0XHRcdHRlWyA4IF0gPSBkZSArIGNmICogYjtcblxuICAgIFx0XHRcdHRlWyAxIF0gPSBjZiArIGRlICogYjtcbiAgICBcdFx0XHR0ZVsgNSBdID0gYSAqIGU7XG4gICAgXHRcdFx0dGVbIDkgXSA9IGRmIC0gY2UgKiBiO1xuXG4gICAgXHRcdFx0dGVbIDIgXSA9IC0gYSAqIGQ7XG4gICAgXHRcdFx0dGVbIDYgXSA9IGI7XG4gICAgXHRcdFx0dGVbIDEwIF0gPSBhICogYztcblxuICAgIFx0XHR9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1pZWCcgKSB7XG5cbiAgICBcdFx0XHR2YXIgYWUgPSBhICogZSwgYWYgPSBhICogZiwgYmUgPSBiICogZSwgYmYgPSBiICogZjtcblxuICAgIFx0XHRcdHRlWyAwIF0gPSBjICogZTtcbiAgICBcdFx0XHR0ZVsgNCBdID0gYmUgKiBkIC0gYWY7XG4gICAgXHRcdFx0dGVbIDggXSA9IGFlICogZCArIGJmO1xuXG4gICAgXHRcdFx0dGVbIDEgXSA9IGMgKiBmO1xuICAgIFx0XHRcdHRlWyA1IF0gPSBiZiAqIGQgKyBhZTtcbiAgICBcdFx0XHR0ZVsgOSBdID0gYWYgKiBkIC0gYmU7XG5cbiAgICBcdFx0XHR0ZVsgMiBdID0gLSBkO1xuICAgIFx0XHRcdHRlWyA2IF0gPSBiICogYztcbiAgICBcdFx0XHR0ZVsgMTAgXSA9IGEgKiBjO1xuXG4gICAgXHRcdH0gZWxzZSBpZiAoIGV1bGVyLm9yZGVyID09PSAnWVpYJyApIHtcblxuICAgIFx0XHRcdHZhciBhYyA9IGEgKiBjLCBhZCA9IGEgKiBkLCBiYyA9IGIgKiBjLCBiZCA9IGIgKiBkO1xuXG4gICAgXHRcdFx0dGVbIDAgXSA9IGMgKiBlO1xuICAgIFx0XHRcdHRlWyA0IF0gPSBiZCAtIGFjICogZjtcbiAgICBcdFx0XHR0ZVsgOCBdID0gYmMgKiBmICsgYWQ7XG5cbiAgICBcdFx0XHR0ZVsgMSBdID0gZjtcbiAgICBcdFx0XHR0ZVsgNSBdID0gYSAqIGU7XG4gICAgXHRcdFx0dGVbIDkgXSA9IC0gYiAqIGU7XG5cbiAgICBcdFx0XHR0ZVsgMiBdID0gLSBkICogZTtcbiAgICBcdFx0XHR0ZVsgNiBdID0gYWQgKiBmICsgYmM7XG4gICAgXHRcdFx0dGVbIDEwIF0gPSBhYyAtIGJkICogZjtcblxuICAgIFx0XHR9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1haWScgKSB7XG5cbiAgICBcdFx0XHR2YXIgYWMgPSBhICogYywgYWQgPSBhICogZCwgYmMgPSBiICogYywgYmQgPSBiICogZDtcblxuICAgIFx0XHRcdHRlWyAwIF0gPSBjICogZTtcbiAgICBcdFx0XHR0ZVsgNCBdID0gLSBmO1xuICAgIFx0XHRcdHRlWyA4IF0gPSBkICogZTtcblxuICAgIFx0XHRcdHRlWyAxIF0gPSBhYyAqIGYgKyBiZDtcbiAgICBcdFx0XHR0ZVsgNSBdID0gYSAqIGU7XG4gICAgXHRcdFx0dGVbIDkgXSA9IGFkICogZiAtIGJjO1xuXG4gICAgXHRcdFx0dGVbIDIgXSA9IGJjICogZiAtIGFkO1xuICAgIFx0XHRcdHRlWyA2IF0gPSBiICogZTtcbiAgICBcdFx0XHR0ZVsgMTAgXSA9IGJkICogZiArIGFjO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHQvLyBsYXN0IGNvbHVtblxuICAgIFx0XHR0ZVsgMyBdID0gMDtcbiAgICBcdFx0dGVbIDcgXSA9IDA7XG4gICAgXHRcdHRlWyAxMSBdID0gMDtcblxuICAgIFx0XHQvLyBib3R0b20gcm93XG4gICAgXHRcdHRlWyAxMiBdID0gMDtcbiAgICBcdFx0dGVbIDEzIF0gPSAwO1xuICAgIFx0XHR0ZVsgMTQgXSA9IDA7XG4gICAgXHRcdHRlWyAxNSBdID0gMTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0bWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb246IGZ1bmN0aW9uICggcSApIHtcblxuICAgIFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG4gICAgXHRcdHZhciB4ID0gcS54LCB5ID0gcS55LCB6ID0gcS56LCB3ID0gcS53O1xuICAgIFx0XHR2YXIgeDIgPSB4ICsgeCwgeTIgPSB5ICsgeSwgejIgPSB6ICsgejtcbiAgICBcdFx0dmFyIHh4ID0geCAqIHgyLCB4eSA9IHggKiB5MiwgeHogPSB4ICogejI7XG4gICAgXHRcdHZhciB5eSA9IHkgKiB5MiwgeXogPSB5ICogejIsIHp6ID0geiAqIHoyO1xuICAgIFx0XHR2YXIgd3ggPSB3ICogeDIsIHd5ID0gdyAqIHkyLCB3eiA9IHcgKiB6MjtcblxuICAgIFx0XHR0ZVsgMCBdID0gMSAtICggeXkgKyB6eiApO1xuICAgIFx0XHR0ZVsgNCBdID0geHkgLSB3ejtcbiAgICBcdFx0dGVbIDggXSA9IHh6ICsgd3k7XG5cbiAgICBcdFx0dGVbIDEgXSA9IHh5ICsgd3o7XG4gICAgXHRcdHRlWyA1IF0gPSAxIC0gKCB4eCArIHp6ICk7XG4gICAgXHRcdHRlWyA5IF0gPSB5eiAtIHd4O1xuXG4gICAgXHRcdHRlWyAyIF0gPSB4eiAtIHd5O1xuICAgIFx0XHR0ZVsgNiBdID0geXogKyB3eDtcbiAgICBcdFx0dGVbIDEwIF0gPSAxIC0gKCB4eCArIHl5ICk7XG5cbiAgICBcdFx0Ly8gbGFzdCBjb2x1bW5cbiAgICBcdFx0dGVbIDMgXSA9IDA7XG4gICAgXHRcdHRlWyA3IF0gPSAwO1xuICAgIFx0XHR0ZVsgMTEgXSA9IDA7XG5cbiAgICBcdFx0Ly8gYm90dG9tIHJvd1xuICAgIFx0XHR0ZVsgMTIgXSA9IDA7XG4gICAgXHRcdHRlWyAxMyBdID0gMDtcbiAgICBcdFx0dGVbIDE0IF0gPSAwO1xuICAgIFx0XHR0ZVsgMTUgXSA9IDE7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGxvb2tBdDogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHZhciB4LCB5LCB6O1xuXG4gICAgXHRcdHJldHVybiBmdW5jdGlvbiBsb29rQXQoIGV5ZSwgdGFyZ2V0LCB1cCApIHtcblxuICAgIFx0XHRcdGlmICggeCA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0XHR4ID0gbmV3IFZlY3RvcjMoKTtcbiAgICBcdFx0XHRcdHkgPSBuZXcgVmVjdG9yMygpO1xuICAgIFx0XHRcdFx0eiA9IG5ldyBWZWN0b3IzKCk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG4gICAgXHRcdFx0ei5zdWJWZWN0b3JzKCBleWUsIHRhcmdldCApLm5vcm1hbGl6ZSgpO1xuXG4gICAgXHRcdFx0aWYgKCB6Lmxlbmd0aFNxKCkgPT09IDAgKSB7XG5cbiAgICBcdFx0XHRcdHoueiA9IDE7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHR4LmNyb3NzVmVjdG9ycyggdXAsIHogKS5ub3JtYWxpemUoKTtcblxuICAgIFx0XHRcdGlmICggeC5sZW5ndGhTcSgpID09PSAwICkge1xuXG4gICAgXHRcdFx0XHR6LnogKz0gMC4wMDAxO1xuICAgIFx0XHRcdFx0eC5jcm9zc1ZlY3RvcnMoIHVwLCB6ICkubm9ybWFsaXplKCk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHR5LmNyb3NzVmVjdG9ycyggeiwgeCApO1xuXG5cbiAgICBcdFx0XHR0ZVsgMCBdID0geC54OyB0ZVsgNCBdID0geS54OyB0ZVsgOCBdID0gei54O1xuICAgIFx0XHRcdHRlWyAxIF0gPSB4Lnk7IHRlWyA1IF0gPSB5Lnk7IHRlWyA5IF0gPSB6Lnk7XG4gICAgXHRcdFx0dGVbIDIgXSA9IHguejsgdGVbIDYgXSA9IHkuejsgdGVbIDEwIF0gPSB6Lno7XG5cbiAgICBcdFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0XHR9O1xuXG4gICAgXHR9KCksXG5cbiAgICBcdG11bHRpcGx5OiBmdW5jdGlvbiAoIG0sIG4gKSB7XG5cbiAgICBcdFx0aWYgKCBuICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAubXVsdGlwbHkoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5tdWx0aXBseU1hdHJpY2VzKCBhLCBiICkgaW5zdGVhZC4nICk7XG4gICAgXHRcdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlNYXRyaWNlcyggbSwgbiApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseU1hdHJpY2VzKCB0aGlzLCBtICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdHByZW11bHRpcGx5OiBmdW5jdGlvbiAoIG0gKSB7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlNYXRyaWNlcyggbSwgdGhpcyApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRtdWx0aXBseU1hdHJpY2VzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XG5cbiAgICBcdFx0dmFyIGFlID0gYS5lbGVtZW50cztcbiAgICBcdFx0dmFyIGJlID0gYi5lbGVtZW50cztcbiAgICBcdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuICAgIFx0XHR2YXIgYTExID0gYWVbIDAgXSwgYTEyID0gYWVbIDQgXSwgYTEzID0gYWVbIDggXSwgYTE0ID0gYWVbIDEyIF07XG4gICAgXHRcdHZhciBhMjEgPSBhZVsgMSBdLCBhMjIgPSBhZVsgNSBdLCBhMjMgPSBhZVsgOSBdLCBhMjQgPSBhZVsgMTMgXTtcbiAgICBcdFx0dmFyIGEzMSA9IGFlWyAyIF0sIGEzMiA9IGFlWyA2IF0sIGEzMyA9IGFlWyAxMCBdLCBhMzQgPSBhZVsgMTQgXTtcbiAgICBcdFx0dmFyIGE0MSA9IGFlWyAzIF0sIGE0MiA9IGFlWyA3IF0sIGE0MyA9IGFlWyAxMSBdLCBhNDQgPSBhZVsgMTUgXTtcblxuICAgIFx0XHR2YXIgYjExID0gYmVbIDAgXSwgYjEyID0gYmVbIDQgXSwgYjEzID0gYmVbIDggXSwgYjE0ID0gYmVbIDEyIF07XG4gICAgXHRcdHZhciBiMjEgPSBiZVsgMSBdLCBiMjIgPSBiZVsgNSBdLCBiMjMgPSBiZVsgOSBdLCBiMjQgPSBiZVsgMTMgXTtcbiAgICBcdFx0dmFyIGIzMSA9IGJlWyAyIF0sIGIzMiA9IGJlWyA2IF0sIGIzMyA9IGJlWyAxMCBdLCBiMzQgPSBiZVsgMTQgXTtcbiAgICBcdFx0dmFyIGI0MSA9IGJlWyAzIF0sIGI0MiA9IGJlWyA3IF0sIGI0MyA9IGJlWyAxMSBdLCBiNDQgPSBiZVsgMTUgXTtcblxuICAgIFx0XHR0ZVsgMCBdID0gYTExICogYjExICsgYTEyICogYjIxICsgYTEzICogYjMxICsgYTE0ICogYjQxO1xuICAgIFx0XHR0ZVsgNCBdID0gYTExICogYjEyICsgYTEyICogYjIyICsgYTEzICogYjMyICsgYTE0ICogYjQyO1xuICAgIFx0XHR0ZVsgOCBdID0gYTExICogYjEzICsgYTEyICogYjIzICsgYTEzICogYjMzICsgYTE0ICogYjQzO1xuICAgIFx0XHR0ZVsgMTIgXSA9IGExMSAqIGIxNCArIGExMiAqIGIyNCArIGExMyAqIGIzNCArIGExNCAqIGI0NDtcblxuICAgIFx0XHR0ZVsgMSBdID0gYTIxICogYjExICsgYTIyICogYjIxICsgYTIzICogYjMxICsgYTI0ICogYjQxO1xuICAgIFx0XHR0ZVsgNSBdID0gYTIxICogYjEyICsgYTIyICogYjIyICsgYTIzICogYjMyICsgYTI0ICogYjQyO1xuICAgIFx0XHR0ZVsgOSBdID0gYTIxICogYjEzICsgYTIyICogYjIzICsgYTIzICogYjMzICsgYTI0ICogYjQzO1xuICAgIFx0XHR0ZVsgMTMgXSA9IGEyMSAqIGIxNCArIGEyMiAqIGIyNCArIGEyMyAqIGIzNCArIGEyNCAqIGI0NDtcblxuICAgIFx0XHR0ZVsgMiBdID0gYTMxICogYjExICsgYTMyICogYjIxICsgYTMzICogYjMxICsgYTM0ICogYjQxO1xuICAgIFx0XHR0ZVsgNiBdID0gYTMxICogYjEyICsgYTMyICogYjIyICsgYTMzICogYjMyICsgYTM0ICogYjQyO1xuICAgIFx0XHR0ZVsgMTAgXSA9IGEzMSAqIGIxMyArIGEzMiAqIGIyMyArIGEzMyAqIGIzMyArIGEzNCAqIGI0MztcbiAgICBcdFx0dGVbIDE0IF0gPSBhMzEgKiBiMTQgKyBhMzIgKiBiMjQgKyBhMzMgKiBiMzQgKyBhMzQgKiBiNDQ7XG5cbiAgICBcdFx0dGVbIDMgXSA9IGE0MSAqIGIxMSArIGE0MiAqIGIyMSArIGE0MyAqIGIzMSArIGE0NCAqIGI0MTtcbiAgICBcdFx0dGVbIDcgXSA9IGE0MSAqIGIxMiArIGE0MiAqIGIyMiArIGE0MyAqIGIzMiArIGE0NCAqIGI0MjtcbiAgICBcdFx0dGVbIDExIF0gPSBhNDEgKiBiMTMgKyBhNDIgKiBiMjMgKyBhNDMgKiBiMzMgKyBhNDQgKiBiNDM7XG4gICAgXHRcdHRlWyAxNSBdID0gYTQxICogYjE0ICsgYTQyICogYjI0ICsgYTQzICogYjM0ICsgYTQ0ICogYjQ0O1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRtdWx0aXBseVRvQXJyYXk6IGZ1bmN0aW9uICggYSwgYiwgciApIHtcblxuICAgIFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG4gICAgXHRcdHRoaXMubXVsdGlwbHlNYXRyaWNlcyggYSwgYiApO1xuXG4gICAgXHRcdHJbIDAgXSA9IHRlWyAwIF07IHJbIDEgXSA9IHRlWyAxIF07IHJbIDIgXSA9IHRlWyAyIF07IHJbIDMgXSA9IHRlWyAzIF07XG4gICAgXHRcdHJbIDQgXSA9IHRlWyA0IF07IHJbIDUgXSA9IHRlWyA1IF07IHJbIDYgXSA9IHRlWyA2IF07IHJbIDcgXSA9IHRlWyA3IF07XG4gICAgXHRcdHJbIDggXSAgPSB0ZVsgOCBdOyByWyA5IF0gID0gdGVbIDkgXTsgclsgMTAgXSA9IHRlWyAxMCBdOyByWyAxMSBdID0gdGVbIDExIF07XG4gICAgXHRcdHJbIDEyIF0gPSB0ZVsgMTIgXTsgclsgMTMgXSA9IHRlWyAxMyBdOyByWyAxNCBdID0gdGVbIDE0IF07IHJbIDE1IF0gPSB0ZVsgMTUgXTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0bXVsdGlwbHlTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcblxuICAgIFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG4gICAgXHRcdHRlWyAwIF0gKj0gczsgdGVbIDQgXSAqPSBzOyB0ZVsgOCBdICo9IHM7IHRlWyAxMiBdICo9IHM7XG4gICAgXHRcdHRlWyAxIF0gKj0gczsgdGVbIDUgXSAqPSBzOyB0ZVsgOSBdICo9IHM7IHRlWyAxMyBdICo9IHM7XG4gICAgXHRcdHRlWyAyIF0gKj0gczsgdGVbIDYgXSAqPSBzOyB0ZVsgMTAgXSAqPSBzOyB0ZVsgMTQgXSAqPSBzO1xuICAgIFx0XHR0ZVsgMyBdICo9IHM7IHRlWyA3IF0gKj0gczsgdGVbIDExIF0gKj0gczsgdGVbIDE1IF0gKj0gcztcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0YXBwbHlUb1ZlY3RvcjNBcnJheTogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHZhciB2MTtcblxuICAgIFx0XHRyZXR1cm4gZnVuY3Rpb24gYXBwbHlUb1ZlY3RvcjNBcnJheSggYXJyYXksIG9mZnNldCwgbGVuZ3RoICkge1xuXG4gICAgXHRcdFx0aWYgKCB2MSA9PT0gdW5kZWZpbmVkICkgdjEgPSBuZXcgVmVjdG9yMygpO1xuICAgIFx0XHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuICAgIFx0XHRcdGlmICggbGVuZ3RoID09PSB1bmRlZmluZWQgKSBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICBcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGogPSBvZmZzZXQ7IGkgPCBsZW5ndGg7IGkgKz0gMywgaiArPSAzICkge1xuXG4gICAgXHRcdFx0XHR2MS5mcm9tQXJyYXkoIGFycmF5LCBqICk7XG4gICAgXHRcdFx0XHR2MS5hcHBseU1hdHJpeDQoIHRoaXMgKTtcbiAgICBcdFx0XHRcdHYxLnRvQXJyYXkoIGFycmF5LCBqICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRyZXR1cm4gYXJyYXk7XG5cbiAgICBcdFx0fTtcblxuICAgIFx0fSgpLFxuXG4gICAgXHRhcHBseVRvQnVmZmVyOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dmFyIHYxO1xuXG4gICAgXHRcdHJldHVybiBmdW5jdGlvbiBhcHBseVRvQnVmZmVyKCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoICkge1xuXG4gICAgXHRcdFx0aWYgKCB2MSA9PT0gdW5kZWZpbmVkICkgdjEgPSBuZXcgVmVjdG9yMygpO1xuICAgIFx0XHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuICAgIFx0XHRcdGlmICggbGVuZ3RoID09PSB1bmRlZmluZWQgKSBsZW5ndGggPSBidWZmZXIubGVuZ3RoIC8gYnVmZmVyLml0ZW1TaXplO1xuXG4gICAgXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBqID0gb2Zmc2V0OyBpIDwgbGVuZ3RoOyBpICsrLCBqICsrICkge1xuXG4gICAgXHRcdFx0XHR2MS54ID0gYnVmZmVyLmdldFgoIGogKTtcbiAgICBcdFx0XHRcdHYxLnkgPSBidWZmZXIuZ2V0WSggaiApO1xuICAgIFx0XHRcdFx0djEueiA9IGJ1ZmZlci5nZXRaKCBqICk7XG5cbiAgICBcdFx0XHRcdHYxLmFwcGx5TWF0cml4NCggdGhpcyApO1xuXG4gICAgXHRcdFx0XHRidWZmZXIuc2V0WFlaKCB2MS54LCB2MS55LCB2MS56ICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRyZXR1cm4gYnVmZmVyO1xuXG4gICAgXHRcdH07XG5cbiAgICBcdH0oKSxcblxuICAgIFx0ZGV0ZXJtaW5hbnQ6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG4gICAgXHRcdHZhciBuMTEgPSB0ZVsgMCBdLCBuMTIgPSB0ZVsgNCBdLCBuMTMgPSB0ZVsgOCBdLCBuMTQgPSB0ZVsgMTIgXTtcbiAgICBcdFx0dmFyIG4yMSA9IHRlWyAxIF0sIG4yMiA9IHRlWyA1IF0sIG4yMyA9IHRlWyA5IF0sIG4yNCA9IHRlWyAxMyBdO1xuICAgIFx0XHR2YXIgbjMxID0gdGVbIDIgXSwgbjMyID0gdGVbIDYgXSwgbjMzID0gdGVbIDEwIF0sIG4zNCA9IHRlWyAxNCBdO1xuICAgIFx0XHR2YXIgbjQxID0gdGVbIDMgXSwgbjQyID0gdGVbIDcgXSwgbjQzID0gdGVbIDExIF0sIG40NCA9IHRlWyAxNSBdO1xuXG4gICAgXHRcdC8vVE9ETzogbWFrZSB0aGlzIG1vcmUgZWZmaWNpZW50XG4gICAgXHRcdC8vKCBiYXNlZCBvbiBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9hbGdlYnJhL21hdHJpeC9mdW5jdGlvbnMvaW52ZXJzZS9mb3VyRC9pbmRleC5odG0gKVxuXG4gICAgXHRcdHJldHVybiAoXG4gICAgXHRcdFx0bjQxICogKFxuICAgIFx0XHRcdFx0KyBuMTQgKiBuMjMgKiBuMzJcbiAgICBcdFx0XHRcdCAtIG4xMyAqIG4yNCAqIG4zMlxuICAgIFx0XHRcdFx0IC0gbjE0ICogbjIyICogbjMzXG4gICAgXHRcdFx0XHQgKyBuMTIgKiBuMjQgKiBuMzNcbiAgICBcdFx0XHRcdCArIG4xMyAqIG4yMiAqIG4zNFxuICAgIFx0XHRcdFx0IC0gbjEyICogbjIzICogbjM0XG4gICAgXHRcdFx0KSArXG4gICAgXHRcdFx0bjQyICogKFxuICAgIFx0XHRcdFx0KyBuMTEgKiBuMjMgKiBuMzRcbiAgICBcdFx0XHRcdCAtIG4xMSAqIG4yNCAqIG4zM1xuICAgIFx0XHRcdFx0ICsgbjE0ICogbjIxICogbjMzXG4gICAgXHRcdFx0XHQgLSBuMTMgKiBuMjEgKiBuMzRcbiAgICBcdFx0XHRcdCArIG4xMyAqIG4yNCAqIG4zMVxuICAgIFx0XHRcdFx0IC0gbjE0ICogbjIzICogbjMxXG4gICAgXHRcdFx0KSArXG4gICAgXHRcdFx0bjQzICogKFxuICAgIFx0XHRcdFx0KyBuMTEgKiBuMjQgKiBuMzJcbiAgICBcdFx0XHRcdCAtIG4xMSAqIG4yMiAqIG4zNFxuICAgIFx0XHRcdFx0IC0gbjE0ICogbjIxICogbjMyXG4gICAgXHRcdFx0XHQgKyBuMTIgKiBuMjEgKiBuMzRcbiAgICBcdFx0XHRcdCArIG4xNCAqIG4yMiAqIG4zMVxuICAgIFx0XHRcdFx0IC0gbjEyICogbjI0ICogbjMxXG4gICAgXHRcdFx0KSArXG4gICAgXHRcdFx0bjQ0ICogKFxuICAgIFx0XHRcdFx0LSBuMTMgKiBuMjIgKiBuMzFcbiAgICBcdFx0XHRcdCAtIG4xMSAqIG4yMyAqIG4zMlxuICAgIFx0XHRcdFx0ICsgbjExICogbjIyICogbjMzXG4gICAgXHRcdFx0XHQgKyBuMTMgKiBuMjEgKiBuMzJcbiAgICBcdFx0XHRcdCAtIG4xMiAqIG4yMSAqIG4zM1xuICAgIFx0XHRcdFx0ICsgbjEyICogbjIzICogbjMxXG4gICAgXHRcdFx0KVxuXG4gICAgXHRcdCk7XG5cbiAgICBcdH0sXG5cbiAgICBcdHRyYW5zcG9zZTogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG4gICAgXHRcdHZhciB0bXA7XG5cbiAgICBcdFx0dG1wID0gdGVbIDEgXTsgdGVbIDEgXSA9IHRlWyA0IF07IHRlWyA0IF0gPSB0bXA7XG4gICAgXHRcdHRtcCA9IHRlWyAyIF07IHRlWyAyIF0gPSB0ZVsgOCBdOyB0ZVsgOCBdID0gdG1wO1xuICAgIFx0XHR0bXAgPSB0ZVsgNiBdOyB0ZVsgNiBdID0gdGVbIDkgXTsgdGVbIDkgXSA9IHRtcDtcblxuICAgIFx0XHR0bXAgPSB0ZVsgMyBdOyB0ZVsgMyBdID0gdGVbIDEyIF07IHRlWyAxMiBdID0gdG1wO1xuICAgIFx0XHR0bXAgPSB0ZVsgNyBdOyB0ZVsgNyBdID0gdGVbIDEzIF07IHRlWyAxMyBdID0gdG1wO1xuICAgIFx0XHR0bXAgPSB0ZVsgMTEgXTsgdGVbIDExIF0gPSB0ZVsgMTQgXTsgdGVbIDE0IF0gPSB0bXA7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGZsYXR0ZW5Ub0FycmF5T2Zmc2V0OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XG5cbiAgICBcdFx0Y29uc29sZS53YXJuKCBcIlRIUkVFLk1hdHJpeDM6IC5mbGF0dGVuVG9BcnJheU9mZnNldCBpcyBkZXByZWNhdGVkIFwiICtcbiAgICBcdFx0XHRcdFwiLSBqdXN0IHVzZSAudG9BcnJheSBpbnN0ZWFkLlwiICk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMudG9BcnJheSggYXJyYXksIG9mZnNldCApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRnZXRQb3NpdGlvbjogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHZhciB2MTtcblxuICAgIFx0XHRyZXR1cm4gZnVuY3Rpb24gZ2V0UG9zaXRpb24oKSB7XG5cbiAgICBcdFx0XHRpZiAoIHYxID09PSB1bmRlZmluZWQgKSB2MSA9IG5ldyBWZWN0b3IzKCk7XG4gICAgXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLmdldFBvc2l0aW9uKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFZlY3RvcjMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBtYXRyaXggKSBpbnN0ZWFkLicgKTtcblxuICAgIFx0XHRcdHJldHVybiB2MS5zZXRGcm9tTWF0cml4Q29sdW1uKCB0aGlzLCAzICk7XG5cbiAgICBcdFx0fTtcblxuICAgIFx0fSgpLFxuXG4gICAgXHRzZXRQb3NpdGlvbjogZnVuY3Rpb24gKCB2ICkge1xuXG4gICAgXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cbiAgICBcdFx0dGVbIDEyIF0gPSB2Lng7XG4gICAgXHRcdHRlWyAxMyBdID0gdi55O1xuICAgIFx0XHR0ZVsgMTQgXSA9IHYuejtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0Z2V0SW52ZXJzZTogZnVuY3Rpb24gKCBtLCB0aHJvd09uRGVnZW5lcmF0ZSApIHtcblxuICAgIFx0XHQvLyBiYXNlZCBvbiBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9hbGdlYnJhL21hdHJpeC9mdW5jdGlvbnMvaW52ZXJzZS9mb3VyRC9pbmRleC5odG1cbiAgICBcdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cyxcbiAgICBcdFx0XHRtZSA9IG0uZWxlbWVudHMsXG5cbiAgICBcdFx0XHRuMTEgPSBtZVsgMCBdLCBuMjEgPSBtZVsgMSBdLCBuMzEgPSBtZVsgMiBdLCBuNDEgPSBtZVsgMyBdLFxuICAgIFx0XHRcdG4xMiA9IG1lWyA0IF0sIG4yMiA9IG1lWyA1IF0sIG4zMiA9IG1lWyA2IF0sIG40MiA9IG1lWyA3IF0sXG4gICAgXHRcdFx0bjEzID0gbWVbIDggXSwgbjIzID0gbWVbIDkgXSwgbjMzID0gbWVbIDEwIF0sIG40MyA9IG1lWyAxMSBdLFxuICAgIFx0XHRcdG4xNCA9IG1lWyAxMiBdLCBuMjQgPSBtZVsgMTMgXSwgbjM0ID0gbWVbIDE0IF0sIG40NCA9IG1lWyAxNSBdLFxuXG4gICAgXHRcdFx0dDExID0gbjIzICogbjM0ICogbjQyIC0gbjI0ICogbjMzICogbjQyICsgbjI0ICogbjMyICogbjQzIC0gbjIyICogbjM0ICogbjQzIC0gbjIzICogbjMyICogbjQ0ICsgbjIyICogbjMzICogbjQ0LFxuICAgIFx0XHRcdHQxMiA9IG4xNCAqIG4zMyAqIG40MiAtIG4xMyAqIG4zNCAqIG40MiAtIG4xNCAqIG4zMiAqIG40MyArIG4xMiAqIG4zNCAqIG40MyArIG4xMyAqIG4zMiAqIG40NCAtIG4xMiAqIG4zMyAqIG40NCxcbiAgICBcdFx0XHR0MTMgPSBuMTMgKiBuMjQgKiBuNDIgLSBuMTQgKiBuMjMgKiBuNDIgKyBuMTQgKiBuMjIgKiBuNDMgLSBuMTIgKiBuMjQgKiBuNDMgLSBuMTMgKiBuMjIgKiBuNDQgKyBuMTIgKiBuMjMgKiBuNDQsXG4gICAgXHRcdFx0dDE0ID0gbjE0ICogbjIzICogbjMyIC0gbjEzICogbjI0ICogbjMyIC0gbjE0ICogbjIyICogbjMzICsgbjEyICogbjI0ICogbjMzICsgbjEzICogbjIyICogbjM0IC0gbjEyICogbjIzICogbjM0O1xuXG4gICAgXHRcdHZhciBkZXQgPSBuMTEgKiB0MTEgKyBuMjEgKiB0MTIgKyBuMzEgKiB0MTMgKyBuNDEgKiB0MTQ7XG5cbiAgICBcdFx0aWYgKCBkZXQgPT09IDAgKSB7XG5cbiAgICBcdFx0XHR2YXIgbXNnID0gXCJUSFJFRS5NYXRyaXg0LmdldEludmVyc2UoKTogY2FuJ3QgaW52ZXJ0IG1hdHJpeCwgZGV0ZXJtaW5hbnQgaXMgMFwiO1xuXG4gICAgXHRcdFx0aWYgKCB0aHJvd09uRGVnZW5lcmF0ZSA9PT0gdHJ1ZSApIHtcblxuICAgIFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBtc2cgKTtcblxuICAgIFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdGNvbnNvbGUud2FybiggbXNnICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRyZXR1cm4gdGhpcy5pZGVudGl0eSgpO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHR2YXIgZGV0SW52ID0gMSAvIGRldDtcblxuICAgIFx0XHR0ZVsgMCBdID0gdDExICogZGV0SW52O1xuICAgIFx0XHR0ZVsgMSBdID0gKCBuMjQgKiBuMzMgKiBuNDEgLSBuMjMgKiBuMzQgKiBuNDEgLSBuMjQgKiBuMzEgKiBuNDMgKyBuMjEgKiBuMzQgKiBuNDMgKyBuMjMgKiBuMzEgKiBuNDQgLSBuMjEgKiBuMzMgKiBuNDQgKSAqIGRldEludjtcbiAgICBcdFx0dGVbIDIgXSA9ICggbjIyICogbjM0ICogbjQxIC0gbjI0ICogbjMyICogbjQxICsgbjI0ICogbjMxICogbjQyIC0gbjIxICogbjM0ICogbjQyIC0gbjIyICogbjMxICogbjQ0ICsgbjIxICogbjMyICogbjQ0ICkgKiBkZXRJbnY7XG4gICAgXHRcdHRlWyAzIF0gPSAoIG4yMyAqIG4zMiAqIG40MSAtIG4yMiAqIG4zMyAqIG40MSAtIG4yMyAqIG4zMSAqIG40MiArIG4yMSAqIG4zMyAqIG40MiArIG4yMiAqIG4zMSAqIG40MyAtIG4yMSAqIG4zMiAqIG40MyApICogZGV0SW52O1xuXG4gICAgXHRcdHRlWyA0IF0gPSB0MTIgKiBkZXRJbnY7XG4gICAgXHRcdHRlWyA1IF0gPSAoIG4xMyAqIG4zNCAqIG40MSAtIG4xNCAqIG4zMyAqIG40MSArIG4xNCAqIG4zMSAqIG40MyAtIG4xMSAqIG4zNCAqIG40MyAtIG4xMyAqIG4zMSAqIG40NCArIG4xMSAqIG4zMyAqIG40NCApICogZGV0SW52O1xuICAgIFx0XHR0ZVsgNiBdID0gKCBuMTQgKiBuMzIgKiBuNDEgLSBuMTIgKiBuMzQgKiBuNDEgLSBuMTQgKiBuMzEgKiBuNDIgKyBuMTEgKiBuMzQgKiBuNDIgKyBuMTIgKiBuMzEgKiBuNDQgLSBuMTEgKiBuMzIgKiBuNDQgKSAqIGRldEludjtcbiAgICBcdFx0dGVbIDcgXSA9ICggbjEyICogbjMzICogbjQxIC0gbjEzICogbjMyICogbjQxICsgbjEzICogbjMxICogbjQyIC0gbjExICogbjMzICogbjQyIC0gbjEyICogbjMxICogbjQzICsgbjExICogbjMyICogbjQzICkgKiBkZXRJbnY7XG5cbiAgICBcdFx0dGVbIDggXSA9IHQxMyAqIGRldEludjtcbiAgICBcdFx0dGVbIDkgXSA9ICggbjE0ICogbjIzICogbjQxIC0gbjEzICogbjI0ICogbjQxIC0gbjE0ICogbjIxICogbjQzICsgbjExICogbjI0ICogbjQzICsgbjEzICogbjIxICogbjQ0IC0gbjExICogbjIzICogbjQ0ICkgKiBkZXRJbnY7XG4gICAgXHRcdHRlWyAxMCBdID0gKCBuMTIgKiBuMjQgKiBuNDEgLSBuMTQgKiBuMjIgKiBuNDEgKyBuMTQgKiBuMjEgKiBuNDIgLSBuMTEgKiBuMjQgKiBuNDIgLSBuMTIgKiBuMjEgKiBuNDQgKyBuMTEgKiBuMjIgKiBuNDQgKSAqIGRldEludjtcbiAgICBcdFx0dGVbIDExIF0gPSAoIG4xMyAqIG4yMiAqIG40MSAtIG4xMiAqIG4yMyAqIG40MSAtIG4xMyAqIG4yMSAqIG40MiArIG4xMSAqIG4yMyAqIG40MiArIG4xMiAqIG4yMSAqIG40MyAtIG4xMSAqIG4yMiAqIG40MyApICogZGV0SW52O1xuXG4gICAgXHRcdHRlWyAxMiBdID0gdDE0ICogZGV0SW52O1xuICAgIFx0XHR0ZVsgMTMgXSA9ICggbjEzICogbjI0ICogbjMxIC0gbjE0ICogbjIzICogbjMxICsgbjE0ICogbjIxICogbjMzIC0gbjExICogbjI0ICogbjMzIC0gbjEzICogbjIxICogbjM0ICsgbjExICogbjIzICogbjM0ICkgKiBkZXRJbnY7XG4gICAgXHRcdHRlWyAxNCBdID0gKCBuMTQgKiBuMjIgKiBuMzEgLSBuMTIgKiBuMjQgKiBuMzEgLSBuMTQgKiBuMjEgKiBuMzIgKyBuMTEgKiBuMjQgKiBuMzIgKyBuMTIgKiBuMjEgKiBuMzQgLSBuMTEgKiBuMjIgKiBuMzQgKSAqIGRldEludjtcbiAgICBcdFx0dGVbIDE1IF0gPSAoIG4xMiAqIG4yMyAqIG4zMSAtIG4xMyAqIG4yMiAqIG4zMSArIG4xMyAqIG4yMSAqIG4zMiAtIG4xMSAqIG4yMyAqIG4zMiAtIG4xMiAqIG4yMSAqIG4zMyArIG4xMSAqIG4yMiAqIG4zMyApICogZGV0SW52O1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzY2FsZTogZnVuY3Rpb24gKCB2ICkge1xuXG4gICAgXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG4gICAgXHRcdHZhciB4ID0gdi54LCB5ID0gdi55LCB6ID0gdi56O1xuXG4gICAgXHRcdHRlWyAwIF0gKj0geDsgdGVbIDQgXSAqPSB5OyB0ZVsgOCBdICo9IHo7XG4gICAgXHRcdHRlWyAxIF0gKj0geDsgdGVbIDUgXSAqPSB5OyB0ZVsgOSBdICo9IHo7XG4gICAgXHRcdHRlWyAyIF0gKj0geDsgdGVbIDYgXSAqPSB5OyB0ZVsgMTAgXSAqPSB6O1xuICAgIFx0XHR0ZVsgMyBdICo9IHg7IHRlWyA3IF0gKj0geTsgdGVbIDExIF0gKj0gejtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0Z2V0TWF4U2NhbGVPbkF4aXM6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG4gICAgXHRcdHZhciBzY2FsZVhTcSA9IHRlWyAwIF0gKiB0ZVsgMCBdICsgdGVbIDEgXSAqIHRlWyAxIF0gKyB0ZVsgMiBdICogdGVbIDIgXTtcbiAgICBcdFx0dmFyIHNjYWxlWVNxID0gdGVbIDQgXSAqIHRlWyA0IF0gKyB0ZVsgNSBdICogdGVbIDUgXSArIHRlWyA2IF0gKiB0ZVsgNiBdO1xuICAgIFx0XHR2YXIgc2NhbGVaU3EgPSB0ZVsgOCBdICogdGVbIDggXSArIHRlWyA5IF0gKiB0ZVsgOSBdICsgdGVbIDEwIF0gKiB0ZVsgMTAgXTtcblxuICAgIFx0XHRyZXR1cm4gTWF0aC5zcXJ0KCBNYXRoLm1heCggc2NhbGVYU3EsIHNjYWxlWVNxLCBzY2FsZVpTcSApICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdG1ha2VUcmFuc2xhdGlvbjogZnVuY3Rpb24gKCB4LCB5LCB6ICkge1xuXG4gICAgXHRcdHRoaXMuc2V0KFxuXG4gICAgXHRcdFx0MSwgMCwgMCwgeCxcbiAgICBcdFx0XHQwLCAxLCAwLCB5LFxuICAgIFx0XHRcdDAsIDAsIDEsIHosXG4gICAgXHRcdFx0MCwgMCwgMCwgMVxuXG4gICAgXHRcdCk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdG1ha2VSb3RhdGlvblg6IGZ1bmN0aW9uICggdGhldGEgKSB7XG5cbiAgICBcdFx0dmFyIGMgPSBNYXRoLmNvcyggdGhldGEgKSwgcyA9IE1hdGguc2luKCB0aGV0YSApO1xuXG4gICAgXHRcdHRoaXMuc2V0KFxuXG4gICAgXHRcdFx0MSwgMCwgIDAsIDAsXG4gICAgXHRcdFx0MCwgYywgLSBzLCAwLFxuICAgIFx0XHRcdDAsIHMsICBjLCAwLFxuICAgIFx0XHRcdDAsIDAsICAwLCAxXG5cbiAgICBcdFx0KTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0bWFrZVJvdGF0aW9uWTogZnVuY3Rpb24gKCB0aGV0YSApIHtcblxuICAgIFx0XHR2YXIgYyA9IE1hdGguY29zKCB0aGV0YSApLCBzID0gTWF0aC5zaW4oIHRoZXRhICk7XG5cbiAgICBcdFx0dGhpcy5zZXQoXG5cbiAgICBcdFx0XHQgYywgMCwgcywgMCxcbiAgICBcdFx0XHQgMCwgMSwgMCwgMCxcbiAgICBcdFx0XHQtIHMsIDAsIGMsIDAsXG4gICAgXHRcdFx0IDAsIDAsIDAsIDFcblxuICAgIFx0XHQpO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRtYWtlUm90YXRpb25aOiBmdW5jdGlvbiAoIHRoZXRhICkge1xuXG4gICAgXHRcdHZhciBjID0gTWF0aC5jb3MoIHRoZXRhICksIHMgPSBNYXRoLnNpbiggdGhldGEgKTtcblxuICAgIFx0XHR0aGlzLnNldChcblxuICAgIFx0XHRcdGMsIC0gcywgMCwgMCxcbiAgICBcdFx0XHRzLCAgYywgMCwgMCxcbiAgICBcdFx0XHQwLCAgMCwgMSwgMCxcbiAgICBcdFx0XHQwLCAgMCwgMCwgMVxuXG4gICAgXHRcdCk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdG1ha2VSb3RhdGlvbkF4aXM6IGZ1bmN0aW9uICggYXhpcywgYW5nbGUgKSB7XG5cbiAgICBcdFx0Ly8gQmFzZWQgb24gaHR0cDovL3d3dy5nYW1lZGV2Lm5ldC9yZWZlcmVuY2UvYXJ0aWNsZXMvYXJ0aWNsZTExOTkuYXNwXG5cbiAgICBcdFx0dmFyIGMgPSBNYXRoLmNvcyggYW5nbGUgKTtcbiAgICBcdFx0dmFyIHMgPSBNYXRoLnNpbiggYW5nbGUgKTtcbiAgICBcdFx0dmFyIHQgPSAxIC0gYztcbiAgICBcdFx0dmFyIHggPSBheGlzLngsIHkgPSBheGlzLnksIHogPSBheGlzLno7XG4gICAgXHRcdHZhciB0eCA9IHQgKiB4LCB0eSA9IHQgKiB5O1xuXG4gICAgXHRcdHRoaXMuc2V0KFxuXG4gICAgXHRcdFx0dHggKiB4ICsgYywgdHggKiB5IC0gcyAqIHosIHR4ICogeiArIHMgKiB5LCAwLFxuICAgIFx0XHRcdHR4ICogeSArIHMgKiB6LCB0eSAqIHkgKyBjLCB0eSAqIHogLSBzICogeCwgMCxcbiAgICBcdFx0XHR0eCAqIHogLSBzICogeSwgdHkgKiB6ICsgcyAqIHgsIHQgKiB6ICogeiArIGMsIDAsXG4gICAgXHRcdFx0MCwgMCwgMCwgMVxuXG4gICAgXHRcdCk7XG5cbiAgICBcdFx0IHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRtYWtlU2NhbGU6IGZ1bmN0aW9uICggeCwgeSwgeiApIHtcblxuICAgIFx0XHR0aGlzLnNldChcblxuICAgIFx0XHRcdHgsIDAsIDAsIDAsXG4gICAgXHRcdFx0MCwgeSwgMCwgMCxcbiAgICBcdFx0XHQwLCAwLCB6LCAwLFxuICAgIFx0XHRcdDAsIDAsIDAsIDFcblxuICAgIFx0XHQpO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRjb21wb3NlOiBmdW5jdGlvbiAoIHBvc2l0aW9uLCBxdWF0ZXJuaW9uLCBzY2FsZSApIHtcblxuICAgIFx0XHR0aGlzLm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICk7XG4gICAgXHRcdHRoaXMuc2NhbGUoIHNjYWxlICk7XG4gICAgXHRcdHRoaXMuc2V0UG9zaXRpb24oIHBvc2l0aW9uICk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGRlY29tcG9zZTogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHZhciB2ZWN0b3IsIG1hdHJpeDtcblxuICAgIFx0XHRyZXR1cm4gZnVuY3Rpb24gZGVjb21wb3NlKCBwb3NpdGlvbiwgcXVhdGVybmlvbiwgc2NhbGUgKSB7XG5cbiAgICBcdFx0XHRpZiAoIHZlY3RvciA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0XHR2ZWN0b3IgPSBuZXcgVmVjdG9yMygpO1xuICAgIFx0XHRcdFx0bWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cbiAgICBcdFx0XHR2YXIgc3ggPSB2ZWN0b3Iuc2V0KCB0ZVsgMCBdLCB0ZVsgMSBdLCB0ZVsgMiBdICkubGVuZ3RoKCk7XG4gICAgXHRcdFx0dmFyIHN5ID0gdmVjdG9yLnNldCggdGVbIDQgXSwgdGVbIDUgXSwgdGVbIDYgXSApLmxlbmd0aCgpO1xuICAgIFx0XHRcdHZhciBzeiA9IHZlY3Rvci5zZXQoIHRlWyA4IF0sIHRlWyA5IF0sIHRlWyAxMCBdICkubGVuZ3RoKCk7XG5cbiAgICBcdFx0XHQvLyBpZiBkZXRlcm1pbmUgaXMgbmVnYXRpdmUsIHdlIG5lZWQgdG8gaW52ZXJ0IG9uZSBzY2FsZVxuICAgIFx0XHRcdHZhciBkZXQgPSB0aGlzLmRldGVybWluYW50KCk7XG4gICAgXHRcdFx0aWYgKCBkZXQgPCAwICkge1xuXG4gICAgXHRcdFx0XHRzeCA9IC0gc3g7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRwb3NpdGlvbi54ID0gdGVbIDEyIF07XG4gICAgXHRcdFx0cG9zaXRpb24ueSA9IHRlWyAxMyBdO1xuICAgIFx0XHRcdHBvc2l0aW9uLnogPSB0ZVsgMTQgXTtcblxuICAgIFx0XHRcdC8vIHNjYWxlIHRoZSByb3RhdGlvbiBwYXJ0XG5cbiAgICBcdFx0XHRtYXRyaXguZWxlbWVudHMuc2V0KCB0aGlzLmVsZW1lbnRzICk7IC8vIGF0IHRoaXMgcG9pbnQgbWF0cml4IGlzIGluY29tcGxldGUgc28gd2UgY2FuJ3QgdXNlIC5jb3B5KClcblxuICAgIFx0XHRcdHZhciBpbnZTWCA9IDEgLyBzeDtcbiAgICBcdFx0XHR2YXIgaW52U1kgPSAxIC8gc3k7XG4gICAgXHRcdFx0dmFyIGludlNaID0gMSAvIHN6O1xuXG4gICAgXHRcdFx0bWF0cml4LmVsZW1lbnRzWyAwIF0gKj0gaW52U1g7XG4gICAgXHRcdFx0bWF0cml4LmVsZW1lbnRzWyAxIF0gKj0gaW52U1g7XG4gICAgXHRcdFx0bWF0cml4LmVsZW1lbnRzWyAyIF0gKj0gaW52U1g7XG5cbiAgICBcdFx0XHRtYXRyaXguZWxlbWVudHNbIDQgXSAqPSBpbnZTWTtcbiAgICBcdFx0XHRtYXRyaXguZWxlbWVudHNbIDUgXSAqPSBpbnZTWTtcbiAgICBcdFx0XHRtYXRyaXguZWxlbWVudHNbIDYgXSAqPSBpbnZTWTtcblxuICAgIFx0XHRcdG1hdHJpeC5lbGVtZW50c1sgOCBdICo9IGludlNaO1xuICAgIFx0XHRcdG1hdHJpeC5lbGVtZW50c1sgOSBdICo9IGludlNaO1xuICAgIFx0XHRcdG1hdHJpeC5lbGVtZW50c1sgMTAgXSAqPSBpbnZTWjtcblxuICAgIFx0XHRcdHF1YXRlcm5pb24uc2V0RnJvbVJvdGF0aW9uTWF0cml4KCBtYXRyaXggKTtcblxuICAgIFx0XHRcdHNjYWxlLnggPSBzeDtcbiAgICBcdFx0XHRzY2FsZS55ID0gc3k7XG4gICAgXHRcdFx0c2NhbGUueiA9IHN6O1xuXG4gICAgXHRcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdFx0fTtcblxuICAgIFx0fSgpLFxuXG4gICAgXHRtYWtlRnJ1c3R1bTogZnVuY3Rpb24gKCBsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhciApIHtcblxuICAgIFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuICAgIFx0XHR2YXIgeCA9IDIgKiBuZWFyIC8gKCByaWdodCAtIGxlZnQgKTtcbiAgICBcdFx0dmFyIHkgPSAyICogbmVhciAvICggdG9wIC0gYm90dG9tICk7XG5cbiAgICBcdFx0dmFyIGEgPSAoIHJpZ2h0ICsgbGVmdCApIC8gKCByaWdodCAtIGxlZnQgKTtcbiAgICBcdFx0dmFyIGIgPSAoIHRvcCArIGJvdHRvbSApIC8gKCB0b3AgLSBib3R0b20gKTtcbiAgICBcdFx0dmFyIGMgPSAtICggZmFyICsgbmVhciApIC8gKCBmYXIgLSBuZWFyICk7XG4gICAgXHRcdHZhciBkID0gLSAyICogZmFyICogbmVhciAvICggZmFyIC0gbmVhciApO1xuXG4gICAgXHRcdHRlWyAwIF0gPSB4O1x0dGVbIDQgXSA9IDA7XHR0ZVsgOCBdID0gYTtcdHRlWyAxMiBdID0gMDtcbiAgICBcdFx0dGVbIDEgXSA9IDA7XHR0ZVsgNSBdID0geTtcdHRlWyA5IF0gPSBiO1x0dGVbIDEzIF0gPSAwO1xuICAgIFx0XHR0ZVsgMiBdID0gMDtcdHRlWyA2IF0gPSAwO1x0dGVbIDEwIF0gPSBjO1x0dGVbIDE0IF0gPSBkO1xuICAgIFx0XHR0ZVsgMyBdID0gMDtcdHRlWyA3IF0gPSAwO1x0dGVbIDExIF0gPSAtIDE7XHR0ZVsgMTUgXSA9IDA7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdG1ha2VQZXJzcGVjdGl2ZTogZnVuY3Rpb24gKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICkge1xuXG4gICAgXHRcdHZhciB5bWF4ID0gbmVhciAqIE1hdGgudGFuKCBleHBvcnRzLk1hdGguREVHMlJBRCAqIGZvdiAqIDAuNSApO1xuICAgIFx0XHR2YXIgeW1pbiA9IC0geW1heDtcbiAgICBcdFx0dmFyIHhtaW4gPSB5bWluICogYXNwZWN0O1xuICAgIFx0XHR2YXIgeG1heCA9IHltYXggKiBhc3BlY3Q7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMubWFrZUZydXN0dW0oIHhtaW4sIHhtYXgsIHltaW4sIHltYXgsIG5lYXIsIGZhciApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRtYWtlT3J0aG9ncmFwaGljOiBmdW5jdGlvbiAoIGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSwgbmVhciwgZmFyICkge1xuXG4gICAgXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG4gICAgXHRcdHZhciB3ID0gMS4wIC8gKCByaWdodCAtIGxlZnQgKTtcbiAgICBcdFx0dmFyIGggPSAxLjAgLyAoIHRvcCAtIGJvdHRvbSApO1xuICAgIFx0XHR2YXIgcCA9IDEuMCAvICggZmFyIC0gbmVhciApO1xuXG4gICAgXHRcdHZhciB4ID0gKCByaWdodCArIGxlZnQgKSAqIHc7XG4gICAgXHRcdHZhciB5ID0gKCB0b3AgKyBib3R0b20gKSAqIGg7XG4gICAgXHRcdHZhciB6ID0gKCBmYXIgKyBuZWFyICkgKiBwO1xuXG4gICAgXHRcdHRlWyAwIF0gPSAyICogdztcdHRlWyA0IF0gPSAwO1x0dGVbIDggXSA9IDA7XHR0ZVsgMTIgXSA9IC0geDtcbiAgICBcdFx0dGVbIDEgXSA9IDA7XHR0ZVsgNSBdID0gMiAqIGg7XHR0ZVsgOSBdID0gMDtcdHRlWyAxMyBdID0gLSB5O1xuICAgIFx0XHR0ZVsgMiBdID0gMDtcdHRlWyA2IF0gPSAwO1x0dGVbIDEwIF0gPSAtIDIgKiBwO1x0dGVbIDE0IF0gPSAtIHo7XG4gICAgXHRcdHRlWyAzIF0gPSAwO1x0dGVbIDcgXSA9IDA7XHR0ZVsgMTEgXSA9IDA7XHR0ZVsgMTUgXSA9IDE7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGVxdWFsczogZnVuY3Rpb24gKCBtYXRyaXggKSB7XG5cbiAgICBcdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcbiAgICBcdFx0dmFyIG1lID0gbWF0cml4LmVsZW1lbnRzO1xuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IDE2OyBpICsrICkge1xuXG4gICAgXHRcdFx0aWYgKCB0ZVsgaSBdICE9PSBtZVsgaSBdICkgcmV0dXJuIGZhbHNlO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gdHJ1ZTtcblxuICAgIFx0fSxcblxuICAgIFx0ZnJvbUFycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XG5cbiAgICBcdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cbiAgICBcdFx0Zm9yKCB2YXIgaSA9IDA7IGkgPCAxNjsgaSArKyApIHtcblxuICAgIFx0XHRcdHRoaXMuZWxlbWVudHNbIGkgXSA9IGFycmF5WyBpICsgb2Zmc2V0IF07XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHR0b0FycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XG5cbiAgICBcdFx0aWYgKCBhcnJheSA9PT0gdW5kZWZpbmVkICkgYXJyYXkgPSBbXTtcbiAgICBcdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cbiAgICBcdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuICAgIFx0XHRhcnJheVsgb2Zmc2V0IF0gPSB0ZVsgMCBdO1xuICAgIFx0XHRhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGVbIDEgXTtcbiAgICBcdFx0YXJyYXlbIG9mZnNldCArIDIgXSA9IHRlWyAyIF07XG4gICAgXHRcdGFycmF5WyBvZmZzZXQgKyAzIF0gPSB0ZVsgMyBdO1xuXG4gICAgXHRcdGFycmF5WyBvZmZzZXQgKyA0IF0gPSB0ZVsgNCBdO1xuICAgIFx0XHRhcnJheVsgb2Zmc2V0ICsgNSBdID0gdGVbIDUgXTtcbiAgICBcdFx0YXJyYXlbIG9mZnNldCArIDYgXSA9IHRlWyA2IF07XG4gICAgXHRcdGFycmF5WyBvZmZzZXQgKyA3IF0gPSB0ZVsgNyBdO1xuXG4gICAgXHRcdGFycmF5WyBvZmZzZXQgKyA4IF0gID0gdGVbIDggXTtcbiAgICBcdFx0YXJyYXlbIG9mZnNldCArIDkgXSAgPSB0ZVsgOSBdO1xuICAgIFx0XHRhcnJheVsgb2Zmc2V0ICsgMTAgXSA9IHRlWyAxMCBdO1xuICAgIFx0XHRhcnJheVsgb2Zmc2V0ICsgMTEgXSA9IHRlWyAxMSBdO1xuXG4gICAgXHRcdGFycmF5WyBvZmZzZXQgKyAxMiBdID0gdGVbIDEyIF07XG4gICAgXHRcdGFycmF5WyBvZmZzZXQgKyAxMyBdID0gdGVbIDEzIF07XG4gICAgXHRcdGFycmF5WyBvZmZzZXQgKyAxNCBdID0gdGVbIDE0IF07XG4gICAgXHRcdGFycmF5WyBvZmZzZXQgKyAxNSBdID0gdGVbIDE1IF07XG5cbiAgICBcdFx0cmV0dXJuIGFycmF5O1xuXG4gICAgXHR9XG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIEN1YmVUZXh0dXJlKCBpbWFnZXMsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSwgZW5jb2RpbmcgKSB7XG5cbiAgICBcdGltYWdlcyA9IGltYWdlcyAhPT0gdW5kZWZpbmVkID8gaW1hZ2VzIDogW107XG4gICAgXHRtYXBwaW5nID0gbWFwcGluZyAhPT0gdW5kZWZpbmVkID8gbWFwcGluZyA6IEN1YmVSZWZsZWN0aW9uTWFwcGluZztcblxuICAgIFx0VGV4dHVyZS5jYWxsKCB0aGlzLCBpbWFnZXMsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSwgZW5jb2RpbmcgKTtcblxuICAgIFx0dGhpcy5mbGlwWSA9IGZhbHNlO1xuXG4gICAgfVxuXG4gICAgQ3ViZVRleHR1cmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVGV4dHVyZS5wcm90b3R5cGUgKTtcbiAgICBDdWJlVGV4dHVyZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDdWJlVGV4dHVyZTtcblxuICAgIEN1YmVUZXh0dXJlLnByb3RvdHlwZS5pc0N1YmVUZXh0dXJlID0gdHJ1ZTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggQ3ViZVRleHR1cmUucHJvdG90eXBlLCAnaW1hZ2VzJywge1xuXG4gICAgXHRnZXQ6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHRyZXR1cm4gdGhpcy5pbWFnZTtcblxuICAgIFx0fSxcblxuICAgIFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG4gICAgXHRcdHRoaXMuaW1hZ2UgPSB2YWx1ZTtcblxuICAgIFx0fVxuXG4gICAgfSApO1xuXG4gICAgdmFyIGVtcHR5VGV4dHVyZSA9IG5ldyBUZXh0dXJlKCk7XG4gICAgdmFyIGVtcHR5Q3ViZVRleHR1cmUgPSBuZXcgQ3ViZVRleHR1cmUoKTtcblxuICAgIC8vIC0tLSBCYXNlIGZvciBpbm5lciBub2RlcyAoaW5jbHVkaW5nIHRoZSByb290KSAtLS1cblxuICAgIGZ1bmN0aW9uIFVuaWZvcm1Db250YWluZXIoKSB7XG5cbiAgICBcdHRoaXMuc2VxID0gW107XG4gICAgXHR0aGlzLm1hcCA9IHt9O1xuXG4gICAgfVxuXG4gICAgLy8gLS0tIFV0aWxpdGllcyAtLS1cblxuICAgIC8vIEFycmF5IENhY2hlcyAocHJvdmlkZSB0eXBlZCBhcnJheXMgZm9yIHRlbXBvcmFyeSBieSBzaXplKVxuXG4gICAgdmFyIGFycmF5Q2FjaGVGMzIgPSBbXTtcbiAgICB2YXIgYXJyYXlDYWNoZUkzMiA9IFtdO1xuXG4gICAgLy8gRmxhdHRlbmluZyBmb3IgYXJyYXlzIG9mIHZlY3RvcnMgYW5kIG1hdHJpY2VzXG5cbiAgICBmdW5jdGlvbiBmbGF0dGVuKCBhcnJheSwgbkJsb2NrcywgYmxvY2tTaXplICkge1xuXG4gICAgXHR2YXIgZmlyc3RFbGVtID0gYXJyYXlbIDAgXTtcblxuICAgIFx0aWYgKCBmaXJzdEVsZW0gPD0gMCB8fCBmaXJzdEVsZW0gPiAwICkgcmV0dXJuIGFycmF5O1xuICAgIFx0Ly8gdW5vcHRpbWl6ZWQ6ICEgaXNOYU4oIGZpcnN0RWxlbSApXG4gICAgXHQvLyBzZWUgaHR0cDovL2phY2tzb25kdW5zdGFuLmNvbS9hcnRpY2xlcy85ODNcblxuICAgIFx0dmFyIG4gPSBuQmxvY2tzICogYmxvY2tTaXplLFxuICAgIFx0XHRyID0gYXJyYXlDYWNoZUYzMlsgbiBdO1xuXG4gICAgXHRpZiAoIHIgPT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRyID0gbmV3IEZsb2F0MzJBcnJheSggbiApO1xuICAgIFx0XHRhcnJheUNhY2hlRjMyWyBuIF0gPSByO1xuXG4gICAgXHR9XG5cbiAgICBcdGlmICggbkJsb2NrcyAhPT0gMCApIHtcblxuICAgIFx0XHRmaXJzdEVsZW0udG9BcnJheSggciwgMCApO1xuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMSwgb2Zmc2V0ID0gMDsgaSAhPT0gbkJsb2NrczsgKysgaSApIHtcblxuICAgIFx0XHRcdG9mZnNldCArPSBibG9ja1NpemU7XG4gICAgXHRcdFx0YXJyYXlbIGkgXS50b0FycmF5KCByLCBvZmZzZXQgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdH1cblxuICAgIFx0cmV0dXJuIHI7XG5cbiAgICB9XG5cbiAgICAvLyBUZXh0dXJlIHVuaXQgYWxsb2NhdGlvblxuXG4gICAgZnVuY3Rpb24gYWxsb2NUZXhVbml0cyggcmVuZGVyZXIsIG4gKSB7XG5cbiAgICBcdHZhciByID0gYXJyYXlDYWNoZUkzMlsgbiBdO1xuXG4gICAgXHRpZiAoIHIgPT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRyID0gbmV3IEludDMyQXJyYXkoIG4gKTtcbiAgICBcdFx0YXJyYXlDYWNoZUkzMlsgbiBdID0gcjtcblxuICAgIFx0fVxuXG4gICAgXHRmb3IgKCB2YXIgaSA9IDA7IGkgIT09IG47ICsrIGkgKVxuICAgIFx0XHRyWyBpIF0gPSByZW5kZXJlci5hbGxvY1RleHR1cmVVbml0KCk7XG5cbiAgICBcdHJldHVybiByO1xuXG4gICAgfVxuXG4gICAgLy8gLS0tIFNldHRlcnMgLS0tXG5cbiAgICAvLyBOb3RlOiBEZWZpbmluZyB0aGVzZSBtZXRob2RzIGV4dGVybmFsbHksIGJlY2F1c2UgdGhleSBjb21lIGluIGEgYnVuY2hcbiAgICAvLyBhbmQgdGhpcyB3YXkgdGhlaXIgbmFtZXMgbWluaWZ5LlxuXG4gICAgLy8gU2luZ2xlIHNjYWxhclxuXG4gICAgZnVuY3Rpb24gc2V0VmFsdWUxZiggZ2wsIHYgKSB7IGdsLnVuaWZvcm0xZiggdGhpcy5hZGRyLCB2ICk7IH1cbiAgICBmdW5jdGlvbiBzZXRWYWx1ZTFpKCBnbCwgdiApIHsgZ2wudW5pZm9ybTFpKCB0aGlzLmFkZHIsIHYgKTsgfVxuXG4gICAgLy8gU2luZ2xlIGZsb2F0IHZlY3RvciAoZnJvbSBmbGF0IGFycmF5IG9yIFRIUkVFLlZlY3Rvck4pXG5cbiAgICBmdW5jdGlvbiBzZXRWYWx1ZTJmdiggZ2wsIHYgKSB7XG5cbiAgICBcdGlmICggdi54ID09PSB1bmRlZmluZWQgKSBnbC51bmlmb3JtMmZ2KCB0aGlzLmFkZHIsIHYgKTtcbiAgICBcdGVsc2UgZ2wudW5pZm9ybTJmKCB0aGlzLmFkZHIsIHYueCwgdi55ICk7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRWYWx1ZTNmdiggZ2wsIHYgKSB7XG5cbiAgICBcdGlmICggdi54ICE9PSB1bmRlZmluZWQgKVxuICAgIFx0XHRnbC51bmlmb3JtM2YoIHRoaXMuYWRkciwgdi54LCB2LnksIHYueiApO1xuICAgIFx0ZWxzZSBpZiAoIHYuciAhPT0gdW5kZWZpbmVkIClcbiAgICBcdFx0Z2wudW5pZm9ybTNmKCB0aGlzLmFkZHIsIHYuciwgdi5nLCB2LmIgKTtcbiAgICBcdGVsc2VcbiAgICBcdFx0Z2wudW5pZm9ybTNmdiggdGhpcy5hZGRyLCB2ICk7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRWYWx1ZTRmdiggZ2wsIHYgKSB7XG5cbiAgICBcdGlmICggdi54ID09PSB1bmRlZmluZWQgKSBnbC51bmlmb3JtNGZ2KCB0aGlzLmFkZHIsIHYgKTtcbiAgICBcdGVsc2UgZ2wudW5pZm9ybTRmKCB0aGlzLmFkZHIsIHYueCwgdi55LCB2LnosIHYudyApO1xuXG4gICAgfVxuXG4gICAgLy8gU2luZ2xlIG1hdHJpeCAoZnJvbSBmbGF0IGFycmF5IG9yIE1hdHJpeE4pXG5cbiAgICBmdW5jdGlvbiBzZXRWYWx1ZTJmbSggZ2wsIHYgKSB7XG5cbiAgICBcdGdsLnVuaWZvcm1NYXRyaXgyZnYoIHRoaXMuYWRkciwgZmFsc2UsIHYuZWxlbWVudHMgfHwgdiApO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0VmFsdWUzZm0oIGdsLCB2ICkge1xuXG4gICAgXHRnbC51bmlmb3JtTWF0cml4M2Z2KCB0aGlzLmFkZHIsIGZhbHNlLCB2LmVsZW1lbnRzIHx8IHYgKTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldFZhbHVlNGZtKCBnbCwgdiApIHtcblxuICAgIFx0Z2wudW5pZm9ybU1hdHJpeDRmdiggdGhpcy5hZGRyLCBmYWxzZSwgdi5lbGVtZW50cyB8fCB2ICk7XG5cbiAgICB9XG5cbiAgICAvLyBTaW5nbGUgdGV4dHVyZSAoMkQgLyBDdWJlKVxuXG4gICAgZnVuY3Rpb24gc2V0VmFsdWVUMSggZ2wsIHYsIHJlbmRlcmVyICkge1xuXG4gICAgXHR2YXIgdW5pdCA9IHJlbmRlcmVyLmFsbG9jVGV4dHVyZVVuaXQoKTtcbiAgICBcdGdsLnVuaWZvcm0xaSggdGhpcy5hZGRyLCB1bml0ICk7XG4gICAgXHRyZW5kZXJlci5zZXRUZXh0dXJlMkQoIHYgfHwgZW1wdHlUZXh0dXJlLCB1bml0ICk7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRWYWx1ZVQ2KCBnbCwgdiwgcmVuZGVyZXIgKSB7XG5cbiAgICBcdHZhciB1bml0ID0gcmVuZGVyZXIuYWxsb2NUZXh0dXJlVW5pdCgpO1xuICAgIFx0Z2wudW5pZm9ybTFpKCB0aGlzLmFkZHIsIHVuaXQgKTtcbiAgICBcdHJlbmRlcmVyLnNldFRleHR1cmVDdWJlKCB2IHx8IGVtcHR5Q3ViZVRleHR1cmUsIHVuaXQgKTtcblxuICAgIH1cblxuICAgIC8vIEludGVnZXIgLyBCb29sZWFuIHZlY3RvcnMgb3IgYXJyYXlzIHRoZXJlb2YgKGFsd2F5cyBmbGF0IGFycmF5cylcblxuICAgIGZ1bmN0aW9uIHNldFZhbHVlMml2KCBnbCwgdiApIHsgZ2wudW5pZm9ybTJpdiggdGhpcy5hZGRyLCB2ICk7IH1cbiAgICBmdW5jdGlvbiBzZXRWYWx1ZTNpdiggZ2wsIHYgKSB7IGdsLnVuaWZvcm0zaXYoIHRoaXMuYWRkciwgdiApOyB9XG4gICAgZnVuY3Rpb24gc2V0VmFsdWU0aXYoIGdsLCB2ICkgeyBnbC51bmlmb3JtNGl2KCB0aGlzLmFkZHIsIHYgKTsgfVxuXG4gICAgLy8gSGVscGVyIHRvIHBpY2sgdGhlIHJpZ2h0IHNldHRlciBmb3IgdGhlIHNpbmd1bGFyIGNhc2VcblxuICAgIGZ1bmN0aW9uIGdldFNpbmd1bGFyU2V0dGVyKCB0eXBlICkge1xuXG4gICAgXHRzd2l0Y2ggKCB0eXBlICkge1xuXG4gICAgXHRcdGNhc2UgMHgxNDA2OiByZXR1cm4gc2V0VmFsdWUxZjsgLy8gRkxPQVRcbiAgICBcdFx0Y2FzZSAweDhiNTA6IHJldHVybiBzZXRWYWx1ZTJmdjsgLy8gX1ZFQzJcbiAgICBcdFx0Y2FzZSAweDhiNTE6IHJldHVybiBzZXRWYWx1ZTNmdjsgLy8gX1ZFQzNcbiAgICBcdFx0Y2FzZSAweDhiNTI6IHJldHVybiBzZXRWYWx1ZTRmdjsgLy8gX1ZFQzRcblxuICAgIFx0XHRjYXNlIDB4OGI1YTogcmV0dXJuIHNldFZhbHVlMmZtOyAvLyBfTUFUMlxuICAgIFx0XHRjYXNlIDB4OGI1YjogcmV0dXJuIHNldFZhbHVlM2ZtOyAvLyBfTUFUM1xuICAgIFx0XHRjYXNlIDB4OGI1YzogcmV0dXJuIHNldFZhbHVlNGZtOyAvLyBfTUFUNFxuXG4gICAgXHRcdGNhc2UgMHg4YjVlOiByZXR1cm4gc2V0VmFsdWVUMTsgLy8gU0FNUExFUl8yRFxuICAgIFx0XHRjYXNlIDB4OGI2MDogcmV0dXJuIHNldFZhbHVlVDY7IC8vIFNBTVBMRVJfQ1VCRVxuXG4gICAgXHRcdGNhc2UgMHgxNDA0OiBjYXNlIDB4OGI1NjogcmV0dXJuIHNldFZhbHVlMWk7IC8vIElOVCwgQk9PTFxuICAgIFx0XHRjYXNlIDB4OGI1MzogY2FzZSAweDhiNTc6IHJldHVybiBzZXRWYWx1ZTJpdjsgLy8gX1ZFQzJcbiAgICBcdFx0Y2FzZSAweDhiNTQ6IGNhc2UgMHg4YjU4OiByZXR1cm4gc2V0VmFsdWUzaXY7IC8vIF9WRUMzXG4gICAgXHRcdGNhc2UgMHg4YjU1OiBjYXNlIDB4OGI1OTogcmV0dXJuIHNldFZhbHVlNGl2OyAvLyBfVkVDNFxuXG4gICAgXHR9XG5cbiAgICB9XG5cbiAgICAvLyBBcnJheSBvZiBzY2FsYXJzXG5cbiAgICBmdW5jdGlvbiBzZXRWYWx1ZTFmdiggZ2wsIHYgKSB7IGdsLnVuaWZvcm0xZnYoIHRoaXMuYWRkciwgdiApOyB9XG4gICAgZnVuY3Rpb24gc2V0VmFsdWUxaXYoIGdsLCB2ICkgeyBnbC51bmlmb3JtMWl2KCB0aGlzLmFkZHIsIHYgKTsgfVxuXG4gICAgLy8gQXJyYXkgb2YgdmVjdG9ycyAoZmxhdCBvciBmcm9tIFRIUkVFIGNsYXNzZXMpXG5cbiAgICBmdW5jdGlvbiBzZXRWYWx1ZVYyYSggZ2wsIHYgKSB7XG5cbiAgICBcdGdsLnVuaWZvcm0yZnYoIHRoaXMuYWRkciwgZmxhdHRlbiggdiwgdGhpcy5zaXplLCAyICkgKTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldFZhbHVlVjNhKCBnbCwgdiApIHtcblxuICAgIFx0Z2wudW5pZm9ybTNmdiggdGhpcy5hZGRyLCBmbGF0dGVuKCB2LCB0aGlzLnNpemUsIDMgKSApO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0VmFsdWVWNGEoIGdsLCB2ICkge1xuXG4gICAgXHRnbC51bmlmb3JtNGZ2KCB0aGlzLmFkZHIsIGZsYXR0ZW4oIHYsIHRoaXMuc2l6ZSwgNCApICk7XG5cbiAgICB9XG5cbiAgICAvLyBBcnJheSBvZiBtYXRyaWNlcyAoZmxhdCBvciBmcm9tIFRIUkVFIGNsYXNlcylcblxuICAgIGZ1bmN0aW9uIHNldFZhbHVlTTJhKCBnbCwgdiApIHtcblxuICAgIFx0Z2wudW5pZm9ybU1hdHJpeDJmdiggdGhpcy5hZGRyLCBmYWxzZSwgZmxhdHRlbiggdiwgdGhpcy5zaXplLCA0ICkgKTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldFZhbHVlTTNhKCBnbCwgdiApIHtcblxuICAgIFx0Z2wudW5pZm9ybU1hdHJpeDNmdiggdGhpcy5hZGRyLCBmYWxzZSwgZmxhdHRlbiggdiwgdGhpcy5zaXplLCA5ICkgKTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldFZhbHVlTTRhKCBnbCwgdiApIHtcblxuICAgIFx0Z2wudW5pZm9ybU1hdHJpeDRmdiggdGhpcy5hZGRyLCBmYWxzZSwgZmxhdHRlbiggdiwgdGhpcy5zaXplLCAxNiApICk7XG5cbiAgICB9XG5cbiAgICAvLyBBcnJheSBvZiB0ZXh0dXJlcyAoMkQgLyBDdWJlKVxuXG4gICAgZnVuY3Rpb24gc2V0VmFsdWVUMWEoIGdsLCB2LCByZW5kZXJlciApIHtcblxuICAgIFx0dmFyIG4gPSB2Lmxlbmd0aCxcbiAgICBcdFx0dW5pdHMgPSBhbGxvY1RleFVuaXRzKCByZW5kZXJlciwgbiApO1xuXG4gICAgXHRnbC51bmlmb3JtMWl2KCB0aGlzLmFkZHIsIHVuaXRzICk7XG5cbiAgICBcdGZvciAoIHZhciBpID0gMDsgaSAhPT0gbjsgKysgaSApIHtcblxuICAgIFx0XHRyZW5kZXJlci5zZXRUZXh0dXJlMkQoIHZbIGkgXSB8fCBlbXB0eVRleHR1cmUsIHVuaXRzWyBpIF0gKTtcblxuICAgIFx0fVxuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0VmFsdWVUNmEoIGdsLCB2LCByZW5kZXJlciApIHtcblxuICAgIFx0dmFyIG4gPSB2Lmxlbmd0aCxcbiAgICBcdFx0dW5pdHMgPSBhbGxvY1RleFVuaXRzKCByZW5kZXJlciwgbiApO1xuXG4gICAgXHRnbC51bmlmb3JtMWl2KCB0aGlzLmFkZHIsIHVuaXRzICk7XG5cbiAgICBcdGZvciAoIHZhciBpID0gMDsgaSAhPT0gbjsgKysgaSApIHtcblxuICAgIFx0XHRyZW5kZXJlci5zZXRUZXh0dXJlQ3ViZSggdlsgaSBdIHx8IGVtcHR5Q3ViZVRleHR1cmUsIHVuaXRzWyBpIF0gKTtcblxuICAgIFx0fVxuXG4gICAgfVxuXG4gICAgLy8gSGVscGVyIHRvIHBpY2sgdGhlIHJpZ2h0IHNldHRlciBmb3IgYSBwdXJlIChib3R0b20tbGV2ZWwpIGFycmF5XG5cbiAgICBmdW5jdGlvbiBnZXRQdXJlQXJyYXlTZXR0ZXIoIHR5cGUgKSB7XG5cbiAgICBcdHN3aXRjaCAoIHR5cGUgKSB7XG5cbiAgICBcdFx0Y2FzZSAweDE0MDY6IHJldHVybiBzZXRWYWx1ZTFmdjsgLy8gRkxPQVRcbiAgICBcdFx0Y2FzZSAweDhiNTA6IHJldHVybiBzZXRWYWx1ZVYyYTsgLy8gX1ZFQzJcbiAgICBcdFx0Y2FzZSAweDhiNTE6IHJldHVybiBzZXRWYWx1ZVYzYTsgLy8gX1ZFQzNcbiAgICBcdFx0Y2FzZSAweDhiNTI6IHJldHVybiBzZXRWYWx1ZVY0YTsgLy8gX1ZFQzRcblxuICAgIFx0XHRjYXNlIDB4OGI1YTogcmV0dXJuIHNldFZhbHVlTTJhOyAvLyBfTUFUMlxuICAgIFx0XHRjYXNlIDB4OGI1YjogcmV0dXJuIHNldFZhbHVlTTNhOyAvLyBfTUFUM1xuICAgIFx0XHRjYXNlIDB4OGI1YzogcmV0dXJuIHNldFZhbHVlTTRhOyAvLyBfTUFUNFxuXG4gICAgXHRcdGNhc2UgMHg4YjVlOiByZXR1cm4gc2V0VmFsdWVUMWE7IC8vIFNBTVBMRVJfMkRcbiAgICBcdFx0Y2FzZSAweDhiNjA6IHJldHVybiBzZXRWYWx1ZVQ2YTsgLy8gU0FNUExFUl9DVUJFXG5cbiAgICBcdFx0Y2FzZSAweDE0MDQ6IGNhc2UgMHg4YjU2OiByZXR1cm4gc2V0VmFsdWUxaXY7IC8vIElOVCwgQk9PTFxuICAgIFx0XHRjYXNlIDB4OGI1MzogY2FzZSAweDhiNTc6IHJldHVybiBzZXRWYWx1ZTJpdjsgLy8gX1ZFQzJcbiAgICBcdFx0Y2FzZSAweDhiNTQ6IGNhc2UgMHg4YjU4OiByZXR1cm4gc2V0VmFsdWUzaXY7IC8vIF9WRUMzXG4gICAgXHRcdGNhc2UgMHg4YjU1OiBjYXNlIDB4OGI1OTogcmV0dXJuIHNldFZhbHVlNGl2OyAvLyBfVkVDNFxuXG4gICAgXHR9XG5cbiAgICB9XG5cbiAgICAvLyAtLS0gVW5pZm9ybSBDbGFzc2VzIC0tLVxuXG4gICAgZnVuY3Rpb24gU2luZ2xlVW5pZm9ybSggaWQsIGFjdGl2ZUluZm8sIGFkZHIgKSB7XG5cbiAgICBcdHRoaXMuaWQgPSBpZDtcbiAgICBcdHRoaXMuYWRkciA9IGFkZHI7XG4gICAgXHR0aGlzLnNldFZhbHVlID0gZ2V0U2luZ3VsYXJTZXR0ZXIoIGFjdGl2ZUluZm8udHlwZSApO1xuXG4gICAgXHQvLyB0aGlzLnBhdGggPSBhY3RpdmVJbmZvLm5hbWU7IC8vIERFQlVHXG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBQdXJlQXJyYXlVbmlmb3JtKCBpZCwgYWN0aXZlSW5mbywgYWRkciApIHtcblxuICAgIFx0dGhpcy5pZCA9IGlkO1xuICAgIFx0dGhpcy5hZGRyID0gYWRkcjtcbiAgICBcdHRoaXMuc2l6ZSA9IGFjdGl2ZUluZm8uc2l6ZTtcbiAgICBcdHRoaXMuc2V0VmFsdWUgPSBnZXRQdXJlQXJyYXlTZXR0ZXIoIGFjdGl2ZUluZm8udHlwZSApO1xuXG4gICAgXHQvLyB0aGlzLnBhdGggPSBhY3RpdmVJbmZvLm5hbWU7IC8vIERFQlVHXG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBTdHJ1Y3R1cmVkVW5pZm9ybSggaWQgKSB7XG5cbiAgICBcdHRoaXMuaWQgPSBpZDtcblxuICAgIFx0VW5pZm9ybUNvbnRhaW5lci5jYWxsKCB0aGlzICk7IC8vIG1peC1pblxuXG4gICAgfVxuXG4gICAgU3RydWN0dXJlZFVuaWZvcm0ucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24oIGdsLCB2YWx1ZSApIHtcblxuICAgIFx0Ly8gTm90ZTogRG9uJ3QgbmVlZCBhbiBleHRyYSAncmVuZGVyZXInIHBhcmFtZXRlciwgc2luY2Ugc2FtcGxlcnNcbiAgICBcdC8vIGFyZSBub3QgYWxsb3dlZCBpbiBzdHJ1Y3R1cmVkIHVuaWZvcm1zLlxuXG4gICAgXHR2YXIgc2VxID0gdGhpcy5zZXE7XG5cbiAgICBcdGZvciAoIHZhciBpID0gMCwgbiA9IHNlcS5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cbiAgICBcdFx0dmFyIHUgPSBzZXFbIGkgXTtcbiAgICBcdFx0dS5zZXRWYWx1ZSggZ2wsIHZhbHVlWyB1LmlkIF0gKTtcblxuICAgIFx0fVxuXG4gICAgfTtcblxuICAgIC8vIC0tLSBUb3AtbGV2ZWwgLS0tXG5cbiAgICAvLyBQYXJzZXIgLSBidWlsZHMgdXAgdGhlIHByb3BlcnR5IHRyZWUgZnJvbSB0aGUgcGF0aCBzdHJpbmdzXG5cbiAgICB2YXIgUmVQYXRoUGFydCA9IC8oW1xcd1xcZF9dKykoXFxdKT8oXFxbfFxcLik/L2c7XG5cbiAgICAvLyBleHRyYWN0c1xuICAgIC8vIFx0LSB0aGUgaWRlbnRpZmllciAobWVtYmVyIG5hbWUgb3IgYXJyYXkgaW5kZXgpXG4gICAgLy8gIC0gZm9sbG93ZWQgYnkgYW4gb3B0aW9uYWwgcmlnaHQgYnJhY2tldCAoZm91bmQgd2hlbiBhcnJheSBpbmRleClcbiAgICAvLyAgLSBmb2xsb3dlZCBieSBhbiBvcHRpb25hbCBsZWZ0IGJyYWNrZXQgb3IgZG90ICh0eXBlIG9mIHN1YnNjcmlwdClcbiAgICAvL1xuICAgIC8vIE5vdGU6IFRoZXNlIHBvcnRpb25zIGNhbiBiZSByZWFkIGluIGEgbm9uLW92ZXJsYXBwaW5nIGZhc2hpb24gYW5kXG4gICAgLy8gYWxsb3cgc3RyYWlnaHRmb3J3YXJkIHBhcnNpbmcgb2YgdGhlIGhpZXJhcmNoeSB0aGF0IFdlYkdMIGVuY29kZXNcbiAgICAvLyBpbiB0aGUgdW5pZm9ybSBuYW1lcy5cblxuICAgIGZ1bmN0aW9uIGFkZFVuaWZvcm0oIGNvbnRhaW5lciwgdW5pZm9ybU9iamVjdCApIHtcblxuICAgIFx0Y29udGFpbmVyLnNlcS5wdXNoKCB1bmlmb3JtT2JqZWN0ICk7XG4gICAgXHRjb250YWluZXIubWFwWyB1bmlmb3JtT2JqZWN0LmlkIF0gPSB1bmlmb3JtT2JqZWN0O1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VVbmlmb3JtKCBhY3RpdmVJbmZvLCBhZGRyLCBjb250YWluZXIgKSB7XG5cbiAgICBcdHZhciBwYXRoID0gYWN0aXZlSW5mby5uYW1lLFxuICAgIFx0XHRwYXRoTGVuZ3RoID0gcGF0aC5sZW5ndGg7XG5cbiAgICBcdC8vIHJlc2V0IFJlZ0V4cCBvYmplY3QsIGJlY2F1c2Ugb2YgdGhlIGVhcmx5IGV4aXQgb2YgYSBwcmV2aW91cyBydW5cbiAgICBcdFJlUGF0aFBhcnQubGFzdEluZGV4ID0gMDtcblxuICAgIFx0Zm9yICg7IDspIHtcblxuICAgIFx0XHR2YXIgbWF0Y2ggPSBSZVBhdGhQYXJ0LmV4ZWMoIHBhdGggKSxcbiAgICBcdFx0XHRtYXRjaEVuZCA9IFJlUGF0aFBhcnQubGFzdEluZGV4LFxuXG4gICAgXHRcdFx0aWQgPSBtYXRjaFsgMSBdLFxuICAgIFx0XHRcdGlkSXNJbmRleCA9IG1hdGNoWyAyIF0gPT09ICddJyxcbiAgICBcdFx0XHRzdWJzY3JpcHQgPSBtYXRjaFsgMyBdO1xuXG4gICAgXHRcdGlmICggaWRJc0luZGV4ICkgaWQgPSBpZCB8IDA7IC8vIGNvbnZlcnQgdG8gaW50ZWdlclxuXG4gICAgXHRcdGlmICggc3Vic2NyaXB0ID09PSB1bmRlZmluZWQgfHxcbiAgICBcdFx0XHRcdHN1YnNjcmlwdCA9PT0gJ1snICYmIG1hdGNoRW5kICsgMiA9PT0gcGF0aExlbmd0aCApIHtcbiAgICBcdFx0XHQvLyBiYXJlIG5hbWUgb3IgXCJwdXJlXCIgYm90dG9tLWxldmVsIGFycmF5IFwiWzBdXCIgc3VmZml4XG5cbiAgICBcdFx0XHRhZGRVbmlmb3JtKCBjb250YWluZXIsIHN1YnNjcmlwdCA9PT0gdW5kZWZpbmVkID9cbiAgICBcdFx0XHRcdFx0bmV3IFNpbmdsZVVuaWZvcm0oIGlkLCBhY3RpdmVJbmZvLCBhZGRyICkgOlxuICAgIFx0XHRcdFx0XHRuZXcgUHVyZUFycmF5VW5pZm9ybSggaWQsIGFjdGl2ZUluZm8sIGFkZHIgKSApO1xuXG4gICAgXHRcdFx0YnJlYWs7XG5cbiAgICBcdFx0fSBlbHNlIHtcbiAgICBcdFx0XHQvLyBzdGVwIGludG8gaW5uZXIgbm9kZSAvIGNyZWF0ZSBpdCBpbiBjYXNlIGl0IGRvZXNuJ3QgZXhpc3RcblxuICAgIFx0XHRcdHZhciBtYXAgPSBjb250YWluZXIubWFwLFxuICAgIFx0XHRcdFx0bmV4dCA9IG1hcFsgaWQgXTtcblxuICAgIFx0XHRcdGlmICggbmV4dCA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0XHRuZXh0ID0gbmV3IFN0cnVjdHVyZWRVbmlmb3JtKCBpZCApO1xuICAgIFx0XHRcdFx0YWRkVW5pZm9ybSggY29udGFpbmVyLCBuZXh0ICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRjb250YWluZXIgPSBuZXh0O1xuXG4gICAgXHRcdH1cblxuICAgIFx0fVxuXG4gICAgfVxuXG4gICAgLy8gUm9vdCBDb250YWluZXJcblxuICAgIGZ1bmN0aW9uIFdlYkdMVW5pZm9ybXMoIGdsLCBwcm9ncmFtLCByZW5kZXJlciApIHtcblxuICAgIFx0VW5pZm9ybUNvbnRhaW5lci5jYWxsKCB0aGlzICk7XG5cbiAgICBcdHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcblxuICAgIFx0dmFyIG4gPSBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKCBwcm9ncmFtLCBnbC5BQ1RJVkVfVU5JRk9STVMgKTtcblxuICAgIFx0Zm9yICggdmFyIGkgPSAwOyBpICE9PSBuOyArKyBpICkge1xuXG4gICAgXHRcdHZhciBpbmZvID0gZ2wuZ2V0QWN0aXZlVW5pZm9ybSggcHJvZ3JhbSwgaSApLFxuICAgIFx0XHRcdHBhdGggPSBpbmZvLm5hbWUsXG4gICAgXHRcdFx0YWRkciA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgcGF0aCApO1xuXG4gICAgXHRcdHBhcnNlVW5pZm9ybSggaW5mbywgYWRkciwgdGhpcyApO1xuXG4gICAgXHR9XG5cbiAgICB9XG5cbiAgICBXZWJHTFVuaWZvcm1zLnByb3RvdHlwZS5zZXRWYWx1ZSA9IGZ1bmN0aW9uKCBnbCwgbmFtZSwgdmFsdWUgKSB7XG5cbiAgICBcdHZhciB1ID0gdGhpcy5tYXBbIG5hbWUgXTtcblxuICAgIFx0aWYgKCB1ICE9PSB1bmRlZmluZWQgKSB1LnNldFZhbHVlKCBnbCwgdmFsdWUsIHRoaXMucmVuZGVyZXIgKTtcblxuICAgIH07XG5cbiAgICBXZWJHTFVuaWZvcm1zLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiggZ2wsIG9iamVjdCwgbmFtZSApIHtcblxuICAgIFx0dmFyIHUgPSB0aGlzLm1hcFsgbmFtZSBdO1xuXG4gICAgXHRpZiAoIHUgIT09IHVuZGVmaW5lZCApIHUuc2V0VmFsdWUoIGdsLCBvYmplY3RbIG5hbWUgXSwgdGhpcy5yZW5kZXJlciApO1xuXG4gICAgfTtcblxuICAgIFdlYkdMVW5pZm9ybXMucHJvdG90eXBlLnNldE9wdGlvbmFsID0gZnVuY3Rpb24oIGdsLCBvYmplY3QsIG5hbWUgKSB7XG5cbiAgICBcdHZhciB2ID0gb2JqZWN0WyBuYW1lIF07XG5cbiAgICBcdGlmICggdiAhPT0gdW5kZWZpbmVkICkgdGhpcy5zZXRWYWx1ZSggZ2wsIG5hbWUsIHYgKTtcblxuICAgIH07XG5cblxuICAgIC8vIFN0YXRpYyBpbnRlcmZhY2VcblxuICAgIFdlYkdMVW5pZm9ybXMudXBsb2FkID0gZnVuY3Rpb24oIGdsLCBzZXEsIHZhbHVlcywgcmVuZGVyZXIgKSB7XG5cbiAgICBcdGZvciAoIHZhciBpID0gMCwgbiA9IHNlcS5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cbiAgICBcdFx0dmFyIHUgPSBzZXFbIGkgXSxcbiAgICBcdFx0XHR2ID0gdmFsdWVzWyB1LmlkIF07XG5cbiAgICBcdFx0aWYgKCB2Lm5lZWRzVXBkYXRlICE9PSBmYWxzZSApIHtcbiAgICBcdFx0XHQvLyBub3RlOiBhbHdheXMgdXBkYXRpbmcgd2hlbiAubmVlZHNVcGRhdGUgaXMgdW5kZWZpbmVkXG5cbiAgICBcdFx0XHR1LnNldFZhbHVlKCBnbCwgdi52YWx1ZSwgcmVuZGVyZXIgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdH1cblxuICAgIH07XG5cbiAgICBXZWJHTFVuaWZvcm1zLnNlcVdpdGhWYWx1ZSA9IGZ1bmN0aW9uKCBzZXEsIHZhbHVlcyApIHtcblxuICAgIFx0dmFyIHIgPSBbXTtcblxuICAgIFx0Zm9yICggdmFyIGkgPSAwLCBuID0gc2VxLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcblxuICAgIFx0XHR2YXIgdSA9IHNlcVsgaSBdO1xuICAgIFx0XHRpZiAoIHUuaWQgaW4gdmFsdWVzICkgci5wdXNoKCB1ICk7XG5cbiAgICBcdH1cblxuICAgIFx0cmV0dXJuIHI7XG5cbiAgICB9O1xuXG4gICAgV2ViR0xVbmlmb3Jtcy5zcGxpdER5bmFtaWMgPSBmdW5jdGlvbiggc2VxLCB2YWx1ZXMgKSB7XG5cbiAgICBcdHZhciByID0gbnVsbCxcbiAgICBcdFx0biA9IHNlcS5sZW5ndGgsXG4gICAgXHRcdHcgPSAwO1xuXG4gICAgXHRmb3IgKCB2YXIgaSA9IDA7IGkgIT09IG47ICsrIGkgKSB7XG5cbiAgICBcdFx0dmFyIHUgPSBzZXFbIGkgXSxcbiAgICBcdFx0XHR2ID0gdmFsdWVzWyB1LmlkIF07XG5cbiAgICBcdFx0aWYgKCB2ICYmIHYuZHluYW1pYyA9PT0gdHJ1ZSApIHtcblxuICAgIFx0XHRcdGlmICggciA9PT0gbnVsbCApIHIgPSBbXTtcbiAgICBcdFx0XHRyLnB1c2goIHUgKTtcblxuICAgIFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0Ly8gaW4tcGxhY2UgY29tcGFjdCAnc2VxJywgcmVtb3ZpbmcgdGhlIG1hdGNoZXNcbiAgICBcdFx0XHRpZiAoIHcgPCBpICkgc2VxWyB3IF0gPSB1O1xuICAgIFx0XHRcdCsrIHc7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9XG5cbiAgICBcdGlmICggdyA8IG4gKSBzZXEubGVuZ3RoID0gdztcblxuICAgIFx0cmV0dXJuIHI7XG5cbiAgICB9O1xuXG4gICAgV2ViR0xVbmlmb3Jtcy5ldmFsRHluYW1pYyA9IGZ1bmN0aW9uKCBzZXEsIHZhbHVlcywgb2JqZWN0LCBtYXRlcmlhbCwgY2FtZXJhICkge1xuXG4gICAgXHRmb3IgKCB2YXIgaSA9IDAsIG4gPSBzZXEubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xuXG4gICAgXHRcdHZhciB2ID0gdmFsdWVzWyBzZXFbIGkgXS5pZCBdLFxuICAgIFx0XHRcdGYgPSB2Lm9uVXBkYXRlQ2FsbGJhY2s7XG5cbiAgICBcdFx0aWYgKCBmICE9PSB1bmRlZmluZWQgKSBmLmNhbGwoIHYsIG9iamVjdCwgbWF0ZXJpYWwsIGNhbWVyYSApO1xuXG4gICAgXHR9XG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVW5pZm9ybSBVdGlsaXRpZXNcbiAgICAgKi9cblxuICAgIGV4cG9ydHMuVW5pZm9ybXNVdGlscyA9IHtcblxuICAgIFx0bWVyZ2U6IGZ1bmN0aW9uICggdW5pZm9ybXMgKSB7XG5cbiAgICBcdFx0dmFyIG1lcmdlZCA9IHt9O1xuXG4gICAgXHRcdGZvciAoIHZhciB1ID0gMDsgdSA8IHVuaWZvcm1zLmxlbmd0aDsgdSArKyApIHtcblxuICAgIFx0XHRcdHZhciB0bXAgPSB0aGlzLmNsb25lKCB1bmlmb3Jtc1sgdSBdICk7XG5cbiAgICBcdFx0XHRmb3IgKCB2YXIgcCBpbiB0bXAgKSB7XG5cbiAgICBcdFx0XHRcdG1lcmdlZFsgcCBdID0gdG1wWyBwIF07XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiBtZXJnZWQ7XG5cbiAgICBcdH0sXG5cbiAgICBcdGNsb25lOiBmdW5jdGlvbiAoIHVuaWZvcm1zX3NyYyApIHtcblxuICAgIFx0XHR2YXIgdW5pZm9ybXNfZHN0ID0ge307XG5cbiAgICBcdFx0Zm9yICggdmFyIHUgaW4gdW5pZm9ybXNfc3JjICkge1xuXG4gICAgXHRcdFx0dW5pZm9ybXNfZHN0WyB1IF0gPSB7fTtcblxuICAgIFx0XHRcdGZvciAoIHZhciBwIGluIHVuaWZvcm1zX3NyY1sgdSBdICkge1xuXG4gICAgXHRcdFx0XHR2YXIgcGFyYW1ldGVyX3NyYyA9IHVuaWZvcm1zX3NyY1sgdSBdWyBwIF07XG5cbiAgICBcdFx0XHRcdGlmICggKHBhcmFtZXRlcl9zcmMgJiYgcGFyYW1ldGVyX3NyYy5pc0NvbG9yKSB8fFxuICAgIFx0XHRcdFx0XHQgKHBhcmFtZXRlcl9zcmMgJiYgcGFyYW1ldGVyX3NyYy5pc1ZlY3RvcjIpIHx8XG4gICAgXHRcdFx0XHRcdCAocGFyYW1ldGVyX3NyYyAmJiBwYXJhbWV0ZXJfc3JjLmlzVmVjdG9yMykgfHxcbiAgICBcdFx0XHRcdFx0IChwYXJhbWV0ZXJfc3JjICYmIHBhcmFtZXRlcl9zcmMuaXNWZWN0b3I0KSB8fFxuICAgIFx0XHRcdFx0XHQgKHBhcmFtZXRlcl9zcmMgJiYgcGFyYW1ldGVyX3NyYy5pc01hdHJpeDMpIHx8XG4gICAgXHRcdFx0XHRcdCAocGFyYW1ldGVyX3NyYyAmJiBwYXJhbWV0ZXJfc3JjLmlzTWF0cml4NCkgfHxcbiAgICBcdFx0XHRcdFx0IChwYXJhbWV0ZXJfc3JjICYmIHBhcmFtZXRlcl9zcmMuaXNUZXh0dXJlKSApIHtcblxuICAgIFx0XHRcdFx0XHR1bmlmb3Jtc19kc3RbIHUgXVsgcCBdID0gcGFyYW1ldGVyX3NyYy5jbG9uZSgpO1xuXG4gICAgXHRcdFx0XHR9IGVsc2UgaWYgKCBBcnJheS5pc0FycmF5KCBwYXJhbWV0ZXJfc3JjICkgKSB7XG5cbiAgICBcdFx0XHRcdFx0dW5pZm9ybXNfZHN0WyB1IF1bIHAgXSA9IHBhcmFtZXRlcl9zcmMuc2xpY2UoKTtcblxuICAgIFx0XHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0XHR1bmlmb3Jtc19kc3RbIHUgXVsgcCBdID0gcGFyYW1ldGVyX3NyYztcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gdW5pZm9ybXNfZHN0O1xuXG4gICAgXHR9XG5cbiAgICB9O1xuXG4gICAgdmFyIGFscGhhbWFwX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX0FMUEhBTUFQXFxuXFx0ZGlmZnVzZUNvbG9yLmEgKj0gdGV4dHVyZTJEKCBhbHBoYU1hcCwgdlV2ICkuZztcXG4jZW5kaWZcXG5cIjtcblxuICAgIHZhciBhbHBoYW1hcF9wYXJzX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX0FMUEhBTUFQXFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgYWxwaGFNYXA7XFxuI2VuZGlmXFxuXCI7XG5cbiAgICB2YXIgYWxwaGF0ZXN0X2ZyYWdtZW50ID0gXCIjaWZkZWYgQUxQSEFURVNUXFxuXFx0aWYgKCBkaWZmdXNlQ29sb3IuYSA8IEFMUEhBVEVTVCApIGRpc2NhcmQ7XFxuI2VuZGlmXFxuXCI7XG5cbiAgICB2YXIgYW9tYXBfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfQU9NQVBcXG5cXHRmbG9hdCBhbWJpZW50T2NjbHVzaW9uID0gKCB0ZXh0dXJlMkQoIGFvTWFwLCB2VXYyICkuciAtIDEuMCApICogYW9NYXBJbnRlbnNpdHkgKyAxLjA7XFxuXFx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICo9IGFtYmllbnRPY2NsdXNpb247XFxuXFx0I2lmIGRlZmluZWQoIFVTRV9FTlZNQVAgKSAmJiBkZWZpbmVkKCBQSFlTSUNBTCApXFxuXFx0XFx0ZmxvYXQgZG90TlYgPSBzYXR1cmF0ZSggZG90KCBnZW9tZXRyeS5ub3JtYWwsIGdlb21ldHJ5LnZpZXdEaXIgKSApO1xcblxcdFxcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0U3BlY3VsYXIgKj0gY29tcHV0ZVNwZWN1bGFyT2NjbHVzaW9uKCBkb3ROViwgYW1iaWVudE9jY2x1c2lvbiwgbWF0ZXJpYWwuc3BlY3VsYXJSb3VnaG5lc3MgKTtcXG5cXHQjZW5kaWZcXG4jZW5kaWZcXG5cIjtcblxuICAgIHZhciBhb21hcF9wYXJzX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX0FPTUFQXFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgYW9NYXA7XFxuXFx0dW5pZm9ybSBmbG9hdCBhb01hcEludGVuc2l0eTtcXG4jZW5kaWZcIjtcblxuICAgIHZhciBiZWdpbl92ZXJ0ZXggPSBcIlxcbnZlYzMgdHJhbnNmb3JtZWQgPSB2ZWMzKCBwb3NpdGlvbiApO1xcblwiO1xuXG4gICAgdmFyIGJlZ2lubm9ybWFsX3ZlcnRleCA9IFwiXFxudmVjMyBvYmplY3ROb3JtYWwgPSB2ZWMzKCBub3JtYWwgKTtcXG5cIjtcblxuICAgIHZhciBic2RmcyA9IFwiYm9vbCB0ZXN0TGlnaHRJblJhbmdlKCBjb25zdCBpbiBmbG9hdCBsaWdodERpc3RhbmNlLCBjb25zdCBpbiBmbG9hdCBjdXRvZmZEaXN0YW5jZSApIHtcXG5cXHRyZXR1cm4gYW55KCBidmVjMiggY3V0b2ZmRGlzdGFuY2UgPT0gMC4wLCBsaWdodERpc3RhbmNlIDwgY3V0b2ZmRGlzdGFuY2UgKSApO1xcbn1cXG5mbG9hdCBwdW5jdHVhbExpZ2h0SW50ZW5zaXR5VG9JcnJhZGlhbmNlRmFjdG9yKCBjb25zdCBpbiBmbG9hdCBsaWdodERpc3RhbmNlLCBjb25zdCBpbiBmbG9hdCBjdXRvZmZEaXN0YW5jZSwgY29uc3QgaW4gZmxvYXQgZGVjYXlFeHBvbmVudCApIHtcXG5cXHRcXHRpZiggZGVjYXlFeHBvbmVudCA+IDAuMCApIHtcXG4jaWYgZGVmaW5lZCAoIFBIWVNJQ0FMTFlfQ09SUkVDVF9MSUdIVFMgKVxcblxcdFxcdFxcdGZsb2F0IGRpc3RhbmNlRmFsbG9mZiA9IDEuMCAvIG1heCggcG93KCBsaWdodERpc3RhbmNlLCBkZWNheUV4cG9uZW50ICksIDAuMDEgKTtcXG5cXHRcXHRcXHRmbG9hdCBtYXhEaXN0YW5jZUN1dG9mZkZhY3RvciA9IHBvdzIoIHNhdHVyYXRlKCAxLjAgLSBwb3c0KCBsaWdodERpc3RhbmNlIC8gY3V0b2ZmRGlzdGFuY2UgKSApICk7XFxuXFx0XFx0XFx0cmV0dXJuIGRpc3RhbmNlRmFsbG9mZiAqIG1heERpc3RhbmNlQ3V0b2ZmRmFjdG9yO1xcbiNlbHNlXFxuXFx0XFx0XFx0cmV0dXJuIHBvdyggc2F0dXJhdGUoIC1saWdodERpc3RhbmNlIC8gY3V0b2ZmRGlzdGFuY2UgKyAxLjAgKSwgZGVjYXlFeHBvbmVudCApO1xcbiNlbmRpZlxcblxcdFxcdH1cXG5cXHRcXHRyZXR1cm4gMS4wO1xcbn1cXG52ZWMzIEJSREZfRGlmZnVzZV9MYW1iZXJ0KCBjb25zdCBpbiB2ZWMzIGRpZmZ1c2VDb2xvciApIHtcXG5cXHRyZXR1cm4gUkVDSVBST0NBTF9QSSAqIGRpZmZ1c2VDb2xvcjtcXG59XFxudmVjMyBGX1NjaGxpY2soIGNvbnN0IGluIHZlYzMgc3BlY3VsYXJDb2xvciwgY29uc3QgaW4gZmxvYXQgZG90TEggKSB7XFxuXFx0ZmxvYXQgZnJlc25lbCA9IGV4cDIoICggLTUuNTU0NzMgKiBkb3RMSCAtIDYuOTgzMTYgKSAqIGRvdExIICk7XFxuXFx0cmV0dXJuICggMS4wIC0gc3BlY3VsYXJDb2xvciApICogZnJlc25lbCArIHNwZWN1bGFyQ29sb3I7XFxufVxcbmZsb2F0IEdfR0dYX1NtaXRoKCBjb25zdCBpbiBmbG9hdCBhbHBoYSwgY29uc3QgaW4gZmxvYXQgZG90TkwsIGNvbnN0IGluIGZsb2F0IGRvdE5WICkge1xcblxcdGZsb2F0IGEyID0gcG93MiggYWxwaGEgKTtcXG5cXHRmbG9hdCBnbCA9IGRvdE5MICsgc3FydCggYTIgKyAoIDEuMCAtIGEyICkgKiBwb3cyKCBkb3ROTCApICk7XFxuXFx0ZmxvYXQgZ3YgPSBkb3ROViArIHNxcnQoIGEyICsgKCAxLjAgLSBhMiApICogcG93MiggZG90TlYgKSApO1xcblxcdHJldHVybiAxLjAgLyAoIGdsICogZ3YgKTtcXG59XFxuZmxvYXQgR19HR1hfU21pdGhDb3JyZWxhdGVkKCBjb25zdCBpbiBmbG9hdCBhbHBoYSwgY29uc3QgaW4gZmxvYXQgZG90TkwsIGNvbnN0IGluIGZsb2F0IGRvdE5WICkge1xcblxcdGZsb2F0IGEyID0gcG93MiggYWxwaGEgKTtcXG5cXHRmbG9hdCBndiA9IGRvdE5MICogc3FydCggYTIgKyAoIDEuMCAtIGEyICkgKiBwb3cyKCBkb3ROViApICk7XFxuXFx0ZmxvYXQgZ2wgPSBkb3ROViAqIHNxcnQoIGEyICsgKCAxLjAgLSBhMiApICogcG93MiggZG90TkwgKSApO1xcblxcdHJldHVybiAwLjUgLyBtYXgoIGd2ICsgZ2wsIEVQU0lMT04gKTtcXG59XFxuZmxvYXQgRF9HR1goIGNvbnN0IGluIGZsb2F0IGFscGhhLCBjb25zdCBpbiBmbG9hdCBkb3ROSCApIHtcXG5cXHRmbG9hdCBhMiA9IHBvdzIoIGFscGhhICk7XFxuXFx0ZmxvYXQgZGVub20gPSBwb3cyKCBkb3ROSCApICogKCBhMiAtIDEuMCApICsgMS4wO1xcblxcdHJldHVybiBSRUNJUFJPQ0FMX1BJICogYTIgLyBwb3cyKCBkZW5vbSApO1xcbn1cXG52ZWMzIEJSREZfU3BlY3VsYXJfR0dYKCBjb25zdCBpbiBJbmNpZGVudExpZ2h0IGluY2lkZW50TGlnaHQsIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIGNvbnN0IGluIHZlYzMgc3BlY3VsYXJDb2xvciwgY29uc3QgaW4gZmxvYXQgcm91Z2huZXNzICkge1xcblxcdGZsb2F0IGFscGhhID0gcG93Miggcm91Z2huZXNzICk7XFxuXFx0dmVjMyBoYWxmRGlyID0gbm9ybWFsaXplKCBpbmNpZGVudExpZ2h0LmRpcmVjdGlvbiArIGdlb21ldHJ5LnZpZXdEaXIgKTtcXG5cXHRmbG9hdCBkb3ROTCA9IHNhdHVyYXRlKCBkb3QoIGdlb21ldHJ5Lm5vcm1hbCwgaW5jaWRlbnRMaWdodC5kaXJlY3Rpb24gKSApO1xcblxcdGZsb2F0IGRvdE5WID0gc2F0dXJhdGUoIGRvdCggZ2VvbWV0cnkubm9ybWFsLCBnZW9tZXRyeS52aWV3RGlyICkgKTtcXG5cXHRmbG9hdCBkb3ROSCA9IHNhdHVyYXRlKCBkb3QoIGdlb21ldHJ5Lm5vcm1hbCwgaGFsZkRpciApICk7XFxuXFx0ZmxvYXQgZG90TEggPSBzYXR1cmF0ZSggZG90KCBpbmNpZGVudExpZ2h0LmRpcmVjdGlvbiwgaGFsZkRpciApICk7XFxuXFx0dmVjMyBGID0gRl9TY2hsaWNrKCBzcGVjdWxhckNvbG9yLCBkb3RMSCApO1xcblxcdGZsb2F0IEcgPSBHX0dHWF9TbWl0aENvcnJlbGF0ZWQoIGFscGhhLCBkb3ROTCwgZG90TlYgKTtcXG5cXHRmbG9hdCBEID0gRF9HR1goIGFscGhhLCBkb3ROSCApO1xcblxcdHJldHVybiBGICogKCBHICogRCApO1xcbn1cXG52ZWMzIEJSREZfU3BlY3VsYXJfR0dYX0Vudmlyb25tZW50KCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBjb25zdCBpbiB2ZWMzIHNwZWN1bGFyQ29sb3IsIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcyApIHtcXG5cXHRmbG9hdCBkb3ROViA9IHNhdHVyYXRlKCBkb3QoIGdlb21ldHJ5Lm5vcm1hbCwgZ2VvbWV0cnkudmlld0RpciApICk7XFxuXFx0Y29uc3QgdmVjNCBjMCA9IHZlYzQoIC0gMSwgLSAwLjAyNzUsIC0gMC41NzIsIDAuMDIyICk7XFxuXFx0Y29uc3QgdmVjNCBjMSA9IHZlYzQoIDEsIDAuMDQyNSwgMS4wNCwgLSAwLjA0ICk7XFxuXFx0dmVjNCByID0gcm91Z2huZXNzICogYzAgKyBjMTtcXG5cXHRmbG9hdCBhMDA0ID0gbWluKCByLnggKiByLngsIGV4cDIoIC0gOS4yOCAqIGRvdE5WICkgKSAqIHIueCArIHIueTtcXG5cXHR2ZWMyIEFCID0gdmVjMiggLTEuMDQsIDEuMDQgKSAqIGEwMDQgKyByLnp3O1xcblxcdHJldHVybiBzcGVjdWxhckNvbG9yICogQUIueCArIEFCLnk7XFxufVxcbmZsb2F0IEdfQmxpbm5QaG9uZ19JbXBsaWNpdCggKSB7XFxuXFx0cmV0dXJuIDAuMjU7XFxufVxcbmZsb2F0IERfQmxpbm5QaG9uZyggY29uc3QgaW4gZmxvYXQgc2hpbmluZXNzLCBjb25zdCBpbiBmbG9hdCBkb3ROSCApIHtcXG5cXHRyZXR1cm4gUkVDSVBST0NBTF9QSSAqICggc2hpbmluZXNzICogMC41ICsgMS4wICkgKiBwb3coIGRvdE5ILCBzaGluaW5lc3MgKTtcXG59XFxudmVjMyBCUkRGX1NwZWN1bGFyX0JsaW5uUGhvbmcoIGNvbnN0IGluIEluY2lkZW50TGlnaHQgaW5jaWRlbnRMaWdodCwgY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgY29uc3QgaW4gdmVjMyBzcGVjdWxhckNvbG9yLCBjb25zdCBpbiBmbG9hdCBzaGluaW5lc3MgKSB7XFxuXFx0dmVjMyBoYWxmRGlyID0gbm9ybWFsaXplKCBpbmNpZGVudExpZ2h0LmRpcmVjdGlvbiArIGdlb21ldHJ5LnZpZXdEaXIgKTtcXG5cXHRmbG9hdCBkb3ROSCA9IHNhdHVyYXRlKCBkb3QoIGdlb21ldHJ5Lm5vcm1hbCwgaGFsZkRpciApICk7XFxuXFx0ZmxvYXQgZG90TEggPSBzYXR1cmF0ZSggZG90KCBpbmNpZGVudExpZ2h0LmRpcmVjdGlvbiwgaGFsZkRpciApICk7XFxuXFx0dmVjMyBGID0gRl9TY2hsaWNrKCBzcGVjdWxhckNvbG9yLCBkb3RMSCApO1xcblxcdGZsb2F0IEcgPSBHX0JsaW5uUGhvbmdfSW1wbGljaXQoICk7XFxuXFx0ZmxvYXQgRCA9IERfQmxpbm5QaG9uZyggc2hpbmluZXNzLCBkb3ROSCApO1xcblxcdHJldHVybiBGICogKCBHICogRCApO1xcbn1cXG5mbG9hdCBHR1hSb3VnaG5lc3NUb0JsaW5uRXhwb25lbnQoIGNvbnN0IGluIGZsb2F0IGdneFJvdWdobmVzcyApIHtcXG5cXHRyZXR1cm4gKCAyLjAgLyBwb3cyKCBnZ3hSb3VnaG5lc3MgKyAwLjAwMDEgKSAtIDIuMCApO1xcbn1cXG5mbG9hdCBCbGlubkV4cG9uZW50VG9HR1hSb3VnaG5lc3MoIGNvbnN0IGluIGZsb2F0IGJsaW5uRXhwb25lbnQgKSB7XFxuXFx0cmV0dXJuIHNxcnQoIDIuMCAvICggYmxpbm5FeHBvbmVudCArIDIuMCApICk7XFxufVxcblwiO1xuXG4gICAgdmFyIGJ1bXBtYXBfcGFyc19mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9CVU1QTUFQXFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgYnVtcE1hcDtcXG5cXHR1bmlmb3JtIGZsb2F0IGJ1bXBTY2FsZTtcXG5cXHR2ZWMyIGRIZHh5X2Z3ZCgpIHtcXG5cXHRcXHR2ZWMyIGRTVGR4ID0gZEZkeCggdlV2ICk7XFxuXFx0XFx0dmVjMiBkU1RkeSA9IGRGZHkoIHZVdiApO1xcblxcdFxcdGZsb2F0IEhsbCA9IGJ1bXBTY2FsZSAqIHRleHR1cmUyRCggYnVtcE1hcCwgdlV2ICkueDtcXG5cXHRcXHRmbG9hdCBkQnggPSBidW1wU2NhbGUgKiB0ZXh0dXJlMkQoIGJ1bXBNYXAsIHZVdiArIGRTVGR4ICkueCAtIEhsbDtcXG5cXHRcXHRmbG9hdCBkQnkgPSBidW1wU2NhbGUgKiB0ZXh0dXJlMkQoIGJ1bXBNYXAsIHZVdiArIGRTVGR5ICkueCAtIEhsbDtcXG5cXHRcXHRyZXR1cm4gdmVjMiggZEJ4LCBkQnkgKTtcXG5cXHR9XFxuXFx0dmVjMyBwZXJ0dXJiTm9ybWFsQXJiKCB2ZWMzIHN1cmZfcG9zLCB2ZWMzIHN1cmZfbm9ybSwgdmVjMiBkSGR4eSApIHtcXG5cXHRcXHR2ZWMzIHZTaWdtYVggPSBkRmR4KCBzdXJmX3BvcyApO1xcblxcdFxcdHZlYzMgdlNpZ21hWSA9IGRGZHkoIHN1cmZfcG9zICk7XFxuXFx0XFx0dmVjMyB2TiA9IHN1cmZfbm9ybTtcXG5cXHRcXHR2ZWMzIFIxID0gY3Jvc3MoIHZTaWdtYVksIHZOICk7XFxuXFx0XFx0dmVjMyBSMiA9IGNyb3NzKCB2TiwgdlNpZ21hWCApO1xcblxcdFxcdGZsb2F0IGZEZXQgPSBkb3QoIHZTaWdtYVgsIFIxICk7XFxuXFx0XFx0dmVjMyB2R3JhZCA9IHNpZ24oIGZEZXQgKSAqICggZEhkeHkueCAqIFIxICsgZEhkeHkueSAqIFIyICk7XFxuXFx0XFx0cmV0dXJuIG5vcm1hbGl6ZSggYWJzKCBmRGV0ICkgKiBzdXJmX25vcm0gLSB2R3JhZCApO1xcblxcdH1cXG4jZW5kaWZcXG5cIjtcblxuICAgIHZhciBjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQgPSBcIiNpZiBOVU1fQ0xJUFBJTkdfUExBTkVTID4gMFxcblxcdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9DTElQUElOR19QTEFORVM7ICsrIGkgKSB7XFxuXFx0XFx0dmVjNCBwbGFuZSA9IGNsaXBwaW5nUGxhbmVzWyBpIF07XFxuXFx0XFx0aWYgKCBkb3QoIHZWaWV3UG9zaXRpb24sIHBsYW5lLnh5eiApID4gcGxhbmUudyApIGRpc2NhcmQ7XFxuXFx0fVxcbiNlbmRpZlxcblwiO1xuXG4gICAgdmFyIGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50ID0gXCIjaWYgTlVNX0NMSVBQSU5HX1BMQU5FUyA+IDBcXG5cXHQjaWYgISBkZWZpbmVkKCBQSFlTSUNBTCApICYmICEgZGVmaW5lZCggUEhPTkcgKVxcblxcdFxcdHZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1xcblxcdCNlbmRpZlxcblxcdHVuaWZvcm0gdmVjNCBjbGlwcGluZ1BsYW5lc1sgTlVNX0NMSVBQSU5HX1BMQU5FUyBdO1xcbiNlbmRpZlxcblwiO1xuXG4gICAgdmFyIGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleCA9IFwiI2lmIE5VTV9DTElQUElOR19QTEFORVMgPiAwICYmICEgZGVmaW5lZCggUEhZU0lDQUwgKSAmJiAhIGRlZmluZWQoIFBIT05HIClcXG5cXHR2YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcXG4jZW5kaWZcXG5cIjtcblxuICAgIHZhciBjbGlwcGluZ19wbGFuZXNfdmVydGV4ID0gXCIjaWYgTlVNX0NMSVBQSU5HX1BMQU5FUyA+IDAgJiYgISBkZWZpbmVkKCBQSFlTSUNBTCApICYmICEgZGVmaW5lZCggUEhPTkcgKVxcblxcdHZWaWV3UG9zaXRpb24gPSAtIG12UG9zaXRpb24ueHl6O1xcbiNlbmRpZlxcblwiO1xuXG4gICAgdmFyIGNvbG9yX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX0NPTE9SXFxuXFx0ZGlmZnVzZUNvbG9yLnJnYiAqPSB2Q29sb3I7XFxuI2VuZGlmXCI7XG5cbiAgICB2YXIgY29sb3JfcGFyc19mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9DT0xPUlxcblxcdHZhcnlpbmcgdmVjMyB2Q29sb3I7XFxuI2VuZGlmXFxuXCI7XG5cbiAgICB2YXIgY29sb3JfcGFyc192ZXJ0ZXggPSBcIiNpZmRlZiBVU0VfQ09MT1JcXG5cXHR2YXJ5aW5nIHZlYzMgdkNvbG9yO1xcbiNlbmRpZlwiO1xuXG4gICAgdmFyIGNvbG9yX3ZlcnRleCA9IFwiI2lmZGVmIFVTRV9DT0xPUlxcblxcdHZDb2xvci54eXogPSBjb2xvci54eXo7XFxuI2VuZGlmXCI7XG5cbiAgICB2YXIgY29tbW9uID0gXCIjZGVmaW5lIFBJIDMuMTQxNTkyNjUzNTlcXG4jZGVmaW5lIFBJMiA2LjI4MzE4NTMwNzE4XFxuI2RlZmluZSBSRUNJUFJPQ0FMX1BJIDAuMzE4MzA5ODg2MThcXG4jZGVmaW5lIFJFQ0lQUk9DQUxfUEkyIDAuMTU5MTU0OTRcXG4jZGVmaW5lIExPRzIgMS40NDI2OTVcXG4jZGVmaW5lIEVQU0lMT04gMWUtNlxcbiNkZWZpbmUgc2F0dXJhdGUoYSkgY2xhbXAoIGEsIDAuMCwgMS4wIClcXG4jZGVmaW5lIHdoaXRlQ29tcGxpbWVudChhKSAoIDEuMCAtIHNhdHVyYXRlKCBhICkgKVxcbmZsb2F0IHBvdzIoIGNvbnN0IGluIGZsb2F0IHggKSB7IHJldHVybiB4Kng7IH1cXG5mbG9hdCBwb3czKCBjb25zdCBpbiBmbG9hdCB4ICkgeyByZXR1cm4geCp4Kng7IH1cXG5mbG9hdCBwb3c0KCBjb25zdCBpbiBmbG9hdCB4ICkgeyBmbG9hdCB4MiA9IHgqeDsgcmV0dXJuIHgyKngyOyB9XFxuZmxvYXQgYXZlcmFnZSggY29uc3QgaW4gdmVjMyBjb2xvciApIHsgcmV0dXJuIGRvdCggY29sb3IsIHZlYzMoIDAuMzMzMyApICk7IH1cXG5oaWdocCBmbG9hdCByYW5kKCBjb25zdCBpbiB2ZWMyIHV2ICkge1xcblxcdGNvbnN0IGhpZ2hwIGZsb2F0IGEgPSAxMi45ODk4LCBiID0gNzguMjMzLCBjID0gNDM3NTguNTQ1MztcXG5cXHRoaWdocCBmbG9hdCBkdCA9IGRvdCggdXYueHksIHZlYzIoIGEsYiApICksIHNuID0gbW9kKCBkdCwgUEkgKTtcXG5cXHRyZXR1cm4gZnJhY3Qoc2luKHNuKSAqIGMpO1xcbn1cXG5zdHJ1Y3QgSW5jaWRlbnRMaWdodCB7XFxuXFx0dmVjMyBjb2xvcjtcXG5cXHR2ZWMzIGRpcmVjdGlvbjtcXG5cXHRib29sIHZpc2libGU7XFxufTtcXG5zdHJ1Y3QgUmVmbGVjdGVkTGlnaHQge1xcblxcdHZlYzMgZGlyZWN0RGlmZnVzZTtcXG5cXHR2ZWMzIGRpcmVjdFNwZWN1bGFyO1xcblxcdHZlYzMgaW5kaXJlY3REaWZmdXNlO1xcblxcdHZlYzMgaW5kaXJlY3RTcGVjdWxhcjtcXG59O1xcbnN0cnVjdCBHZW9tZXRyaWNDb250ZXh0IHtcXG5cXHR2ZWMzIHBvc2l0aW9uO1xcblxcdHZlYzMgbm9ybWFsO1xcblxcdHZlYzMgdmlld0RpcjtcXG59O1xcbnZlYzMgdHJhbnNmb3JtRGlyZWN0aW9uKCBpbiB2ZWMzIGRpciwgaW4gbWF0NCBtYXRyaXggKSB7XFxuXFx0cmV0dXJuIG5vcm1hbGl6ZSggKCBtYXRyaXggKiB2ZWM0KCBkaXIsIDAuMCApICkueHl6ICk7XFxufVxcbnZlYzMgaW52ZXJzZVRyYW5zZm9ybURpcmVjdGlvbiggaW4gdmVjMyBkaXIsIGluIG1hdDQgbWF0cml4ICkge1xcblxcdHJldHVybiBub3JtYWxpemUoICggdmVjNCggZGlyLCAwLjAgKSAqIG1hdHJpeCApLnh5eiApO1xcbn1cXG52ZWMzIHByb2plY3RPblBsYW5lKGluIHZlYzMgcG9pbnQsIGluIHZlYzMgcG9pbnRPblBsYW5lLCBpbiB2ZWMzIHBsYW5lTm9ybWFsICkge1xcblxcdGZsb2F0IGRpc3RhbmNlID0gZG90KCBwbGFuZU5vcm1hbCwgcG9pbnQgLSBwb2ludE9uUGxhbmUgKTtcXG5cXHRyZXR1cm4gLSBkaXN0YW5jZSAqIHBsYW5lTm9ybWFsICsgcG9pbnQ7XFxufVxcbmZsb2F0IHNpZGVPZlBsYW5lKCBpbiB2ZWMzIHBvaW50LCBpbiB2ZWMzIHBvaW50T25QbGFuZSwgaW4gdmVjMyBwbGFuZU5vcm1hbCApIHtcXG5cXHRyZXR1cm4gc2lnbiggZG90KCBwb2ludCAtIHBvaW50T25QbGFuZSwgcGxhbmVOb3JtYWwgKSApO1xcbn1cXG52ZWMzIGxpbmVQbGFuZUludGVyc2VjdCggaW4gdmVjMyBwb2ludE9uTGluZSwgaW4gdmVjMyBsaW5lRGlyZWN0aW9uLCBpbiB2ZWMzIHBvaW50T25QbGFuZSwgaW4gdmVjMyBwbGFuZU5vcm1hbCApIHtcXG5cXHRyZXR1cm4gbGluZURpcmVjdGlvbiAqICggZG90KCBwbGFuZU5vcm1hbCwgcG9pbnRPblBsYW5lIC0gcG9pbnRPbkxpbmUgKSAvIGRvdCggcGxhbmVOb3JtYWwsIGxpbmVEaXJlY3Rpb24gKSApICsgcG9pbnRPbkxpbmU7XFxufVxcblwiO1xuXG4gICAgdmFyIGN1YmVfdXZfcmVmbGVjdGlvbl9mcmFnbWVudCA9IFwiI2lmZGVmIEVOVk1BUF9UWVBFX0NVQkVfVVZcXG4jZGVmaW5lIGN1YmVVVl90ZXh0dXJlU2l6ZSAoMTAyNC4wKVxcbmludCBnZXRGYWNlRnJvbURpcmVjdGlvbih2ZWMzIGRpcmVjdGlvbikge1xcblxcdHZlYzMgYWJzRGlyZWN0aW9uID0gYWJzKGRpcmVjdGlvbik7XFxuXFx0aW50IGZhY2UgPSAtMTtcXG5cXHRpZiggYWJzRGlyZWN0aW9uLnggPiBhYnNEaXJlY3Rpb24ueiApIHtcXG5cXHRcXHRpZihhYnNEaXJlY3Rpb24ueCA+IGFic0RpcmVjdGlvbi55IClcXG5cXHRcXHRcXHRmYWNlID0gZGlyZWN0aW9uLnggPiAwLjAgPyAwIDogMztcXG5cXHRcXHRlbHNlXFxuXFx0XFx0XFx0ZmFjZSA9IGRpcmVjdGlvbi55ID4gMC4wID8gMSA6IDQ7XFxuXFx0fVxcblxcdGVsc2Uge1xcblxcdFxcdGlmKGFic0RpcmVjdGlvbi56ID4gYWJzRGlyZWN0aW9uLnkgKVxcblxcdFxcdFxcdGZhY2UgPSBkaXJlY3Rpb24ueiA+IDAuMCA/IDIgOiA1O1xcblxcdFxcdGVsc2VcXG5cXHRcXHRcXHRmYWNlID0gZGlyZWN0aW9uLnkgPiAwLjAgPyAxIDogNDtcXG5cXHR9XFxuXFx0cmV0dXJuIGZhY2U7XFxufVxcbiNkZWZpbmUgY3ViZVVWX21heExvZHMxICAobG9nMihjdWJlVVZfdGV4dHVyZVNpemUqMC4yNSkgLSAxLjApXFxuI2RlZmluZSBjdWJlVVZfcmFuZ2VDbGFtcCAoZXhwMigoNi4wIC0gMS4wKSAqIDIuMCkpXFxudmVjMiBNaXBMZXZlbEluZm8oIHZlYzMgdmVjLCBmbG9hdCByb3VnaG5lc3NMZXZlbCwgZmxvYXQgcm91Z2huZXNzICkge1xcblxcdGZsb2F0IHNjYWxlID0gZXhwMihjdWJlVVZfbWF4TG9kczEgLSByb3VnaG5lc3NMZXZlbCk7XFxuXFx0ZmxvYXQgZHhSb3VnaG5lc3MgPSBkRmR4KHJvdWdobmVzcyk7XFxuXFx0ZmxvYXQgZHlSb3VnaG5lc3MgPSBkRmR5KHJvdWdobmVzcyk7XFxuXFx0dmVjMyBkeCA9IGRGZHgoIHZlYyAqIHNjYWxlICogZHhSb3VnaG5lc3MgKTtcXG5cXHR2ZWMzIGR5ID0gZEZkeSggdmVjICogc2NhbGUgKiBkeVJvdWdobmVzcyApO1xcblxcdGZsb2F0IGQgPSBtYXgoIGRvdCggZHgsIGR4ICksIGRvdCggZHksIGR5ICkgKTtcXG5cXHRkID0gY2xhbXAoZCwgMS4wLCBjdWJlVVZfcmFuZ2VDbGFtcCk7XFxuXFx0ZmxvYXQgbWlwTGV2ZWwgPSAwLjUgKiBsb2cyKGQpO1xcblxcdHJldHVybiB2ZWMyKGZsb29yKG1pcExldmVsKSwgZnJhY3QobWlwTGV2ZWwpKTtcXG59XFxuI2RlZmluZSBjdWJlVVZfbWF4TG9kczIgKGxvZzIoY3ViZVVWX3RleHR1cmVTaXplKjAuMjUpIC0gMi4wKVxcbiNkZWZpbmUgY3ViZVVWX3JjcFRleHR1cmVTaXplICgxLjAgLyBjdWJlVVZfdGV4dHVyZVNpemUpXFxudmVjMiBnZXRDdWJlVVYodmVjMyBkaXJlY3Rpb24sIGZsb2F0IHJvdWdobmVzc0xldmVsLCBmbG9hdCBtaXBMZXZlbCkge1xcblxcdG1pcExldmVsID0gcm91Z2huZXNzTGV2ZWwgPiBjdWJlVVZfbWF4TG9kczIgLSAzLjAgPyAwLjAgOiBtaXBMZXZlbDtcXG5cXHRmbG9hdCBhID0gMTYuMCAqIGN1YmVVVl9yY3BUZXh0dXJlU2l6ZTtcXG5cXHR2ZWMyIGV4cDJfcGFja2VkID0gZXhwMiggdmVjMiggcm91Z2huZXNzTGV2ZWwsIG1pcExldmVsICkgKTtcXG5cXHR2ZWMyIHJjcF9leHAyX3BhY2tlZCA9IHZlYzIoIDEuMCApIC8gZXhwMl9wYWNrZWQ7XFxuXFx0ZmxvYXQgcG93U2NhbGUgPSBleHAyX3BhY2tlZC54ICogZXhwMl9wYWNrZWQueTtcXG5cXHRmbG9hdCBzY2FsZSA9IHJjcF9leHAyX3BhY2tlZC54ICogcmNwX2V4cDJfcGFja2VkLnkgKiAwLjI1O1xcblxcdGZsb2F0IG1pcE9mZnNldCA9IDAuNzUqKDEuMCAtIHJjcF9leHAyX3BhY2tlZC55KSAqIHJjcF9leHAyX3BhY2tlZC54O1xcblxcdGJvb2wgYlJlcyA9IG1pcExldmVsID09IDAuMDtcXG5cXHRzY2FsZSA9ICBiUmVzICYmIChzY2FsZSA8IGEpID8gYSA6IHNjYWxlO1xcblxcdHZlYzMgcjtcXG5cXHR2ZWMyIG9mZnNldDtcXG5cXHRpbnQgZmFjZSA9IGdldEZhY2VGcm9tRGlyZWN0aW9uKGRpcmVjdGlvbik7XFxuXFx0ZmxvYXQgcmNwUG93U2NhbGUgPSAxLjAgLyBwb3dTY2FsZTtcXG5cXHRpZiggZmFjZSA9PSAwKSB7XFxuXFx0XFx0ciA9IHZlYzMoZGlyZWN0aW9uLngsIC1kaXJlY3Rpb24ueiwgZGlyZWN0aW9uLnkpO1xcblxcdFxcdG9mZnNldCA9IHZlYzIoMC4wK21pcE9mZnNldCwwLjc1ICogcmNwUG93U2NhbGUpO1xcblxcdFxcdG9mZnNldC55ID0gYlJlcyAmJiAob2Zmc2V0LnkgPCAyLjAqYSkgPyAgYSA6IG9mZnNldC55O1xcblxcdH1cXG5cXHRlbHNlIGlmKCBmYWNlID09IDEpIHtcXG5cXHRcXHRyID0gdmVjMyhkaXJlY3Rpb24ueSwgZGlyZWN0aW9uLngsIGRpcmVjdGlvbi56KTtcXG5cXHRcXHRvZmZzZXQgPSB2ZWMyKHNjYWxlK21pcE9mZnNldCwgMC43NSAqIHJjcFBvd1NjYWxlKTtcXG5cXHRcXHRvZmZzZXQueSA9IGJSZXMgJiYgKG9mZnNldC55IDwgMi4wKmEpID8gIGEgOiBvZmZzZXQueTtcXG5cXHR9XFxuXFx0ZWxzZSBpZiggZmFjZSA9PSAyKSB7XFxuXFx0XFx0ciA9IHZlYzMoZGlyZWN0aW9uLnosIGRpcmVjdGlvbi54LCBkaXJlY3Rpb24ueSk7XFxuXFx0XFx0b2Zmc2V0ID0gdmVjMigyLjAqc2NhbGUrbWlwT2Zmc2V0LCAwLjc1ICogcmNwUG93U2NhbGUpO1xcblxcdFxcdG9mZnNldC55ID0gYlJlcyAmJiAob2Zmc2V0LnkgPCAyLjAqYSkgPyAgYSA6IG9mZnNldC55O1xcblxcdH1cXG5cXHRlbHNlIGlmKCBmYWNlID09IDMpIHtcXG5cXHRcXHRyID0gdmVjMyhkaXJlY3Rpb24ueCwgZGlyZWN0aW9uLnosIGRpcmVjdGlvbi55KTtcXG5cXHRcXHRvZmZzZXQgPSB2ZWMyKDAuMCttaXBPZmZzZXQsMC41ICogcmNwUG93U2NhbGUpO1xcblxcdFxcdG9mZnNldC55ID0gYlJlcyAmJiAob2Zmc2V0LnkgPCAyLjAqYSkgPyAgMC4wIDogb2Zmc2V0Lnk7XFxuXFx0fVxcblxcdGVsc2UgaWYoIGZhY2UgPT0gNCkge1xcblxcdFxcdHIgPSB2ZWMzKGRpcmVjdGlvbi55LCBkaXJlY3Rpb24ueCwgLWRpcmVjdGlvbi56KTtcXG5cXHRcXHRvZmZzZXQgPSB2ZWMyKHNjYWxlK21pcE9mZnNldCwgMC41ICogcmNwUG93U2NhbGUpO1xcblxcdFxcdG9mZnNldC55ID0gYlJlcyAmJiAob2Zmc2V0LnkgPCAyLjAqYSkgPyAgMC4wIDogb2Zmc2V0Lnk7XFxuXFx0fVxcblxcdGVsc2Uge1xcblxcdFxcdHIgPSB2ZWMzKGRpcmVjdGlvbi56LCAtZGlyZWN0aW9uLngsIGRpcmVjdGlvbi55KTtcXG5cXHRcXHRvZmZzZXQgPSB2ZWMyKDIuMCpzY2FsZSttaXBPZmZzZXQsIDAuNSAqIHJjcFBvd1NjYWxlKTtcXG5cXHRcXHRvZmZzZXQueSA9IGJSZXMgJiYgKG9mZnNldC55IDwgMi4wKmEpID8gIDAuMCA6IG9mZnNldC55O1xcblxcdH1cXG5cXHRyID0gbm9ybWFsaXplKHIpO1xcblxcdGZsb2F0IHRleGVsT2Zmc2V0ID0gMC41ICogY3ViZVVWX3JjcFRleHR1cmVTaXplO1xcblxcdHZlYzIgcyA9ICggci55eiAvIGFicyggci54ICkgKyB2ZWMyKCAxLjAgKSApICogMC41O1xcblxcdHZlYzIgYmFzZSA9IG9mZnNldCArIHZlYzIoIHRleGVsT2Zmc2V0ICk7XFxuXFx0cmV0dXJuIGJhc2UgKyBzICogKCBzY2FsZSAtIDIuMCAqIHRleGVsT2Zmc2V0ICk7XFxufVxcbiNkZWZpbmUgY3ViZVVWX21heExvZHMzIChsb2cyKGN1YmVVVl90ZXh0dXJlU2l6ZSowLjI1KSAtIDMuMClcXG52ZWM0IHRleHR1cmVDdWJlVVYodmVjMyByZWZsZWN0ZWREaXJlY3Rpb24sIGZsb2F0IHJvdWdobmVzcyApIHtcXG5cXHRmbG9hdCByb3VnaG5lc3NWYWwgPSByb3VnaG5lc3MqIGN1YmVVVl9tYXhMb2RzMztcXG5cXHRmbG9hdCByMSA9IGZsb29yKHJvdWdobmVzc1ZhbCk7XFxuXFx0ZmxvYXQgcjIgPSByMSArIDEuMDtcXG5cXHRmbG9hdCB0ID0gZnJhY3Qocm91Z2huZXNzVmFsKTtcXG5cXHR2ZWMyIG1pcEluZm8gPSBNaXBMZXZlbEluZm8ocmVmbGVjdGVkRGlyZWN0aW9uLCByMSwgcm91Z2huZXNzKTtcXG5cXHRmbG9hdCBzID0gbWlwSW5mby55O1xcblxcdGZsb2F0IGxldmVsMCA9IG1pcEluZm8ueDtcXG5cXHRmbG9hdCBsZXZlbDEgPSBsZXZlbDAgKyAxLjA7XFxuXFx0bGV2ZWwxID0gbGV2ZWwxID4gNS4wID8gNS4wIDogbGV2ZWwxO1xcblxcdGxldmVsMCArPSBtaW4oIGZsb29yKCBzICsgMC41ICksIDUuMCApO1xcblxcdHZlYzIgdXZfMTAgPSBnZXRDdWJlVVYocmVmbGVjdGVkRGlyZWN0aW9uLCByMSwgbGV2ZWwwKTtcXG5cXHR2ZWM0IGNvbG9yMTAgPSBlbnZNYXBUZXhlbFRvTGluZWFyKHRleHR1cmUyRChlbnZNYXAsIHV2XzEwKSk7XFxuXFx0dmVjMiB1dl8yMCA9IGdldEN1YmVVVihyZWZsZWN0ZWREaXJlY3Rpb24sIHIyLCBsZXZlbDApO1xcblxcdHZlYzQgY29sb3IyMCA9IGVudk1hcFRleGVsVG9MaW5lYXIodGV4dHVyZTJEKGVudk1hcCwgdXZfMjApKTtcXG5cXHR2ZWM0IHJlc3VsdCA9IG1peChjb2xvcjEwLCBjb2xvcjIwLCB0KTtcXG5cXHRyZXR1cm4gdmVjNChyZXN1bHQucmdiLCAxLjApO1xcbn1cXG4jZW5kaWZcXG5cIjtcblxuICAgIHZhciBkZWZhdWx0bm9ybWFsX3ZlcnRleCA9IFwiI2lmZGVmIEZMSVBfU0lERURcXG5cXHRvYmplY3ROb3JtYWwgPSAtb2JqZWN0Tm9ybWFsO1xcbiNlbmRpZlxcbnZlYzMgdHJhbnNmb3JtZWROb3JtYWwgPSBub3JtYWxNYXRyaXggKiBvYmplY3ROb3JtYWw7XFxuXCI7XG5cbiAgICB2YXIgZGlzcGxhY2VtZW50bWFwX3BhcnNfdmVydGV4ID0gXCIjaWZkZWYgVVNFX0RJU1BMQUNFTUVOVE1BUFxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIGRpc3BsYWNlbWVudE1hcDtcXG5cXHR1bmlmb3JtIGZsb2F0IGRpc3BsYWNlbWVudFNjYWxlO1xcblxcdHVuaWZvcm0gZmxvYXQgZGlzcGxhY2VtZW50QmlhcztcXG4jZW5kaWZcXG5cIjtcblxuICAgIHZhciBkaXNwbGFjZW1lbnRtYXBfdmVydGV4ID0gXCIjaWZkZWYgVVNFX0RJU1BMQUNFTUVOVE1BUFxcblxcdHRyYW5zZm9ybWVkICs9IG5vcm1hbCAqICggdGV4dHVyZTJEKCBkaXNwbGFjZW1lbnRNYXAsIHV2ICkueCAqIGRpc3BsYWNlbWVudFNjYWxlICsgZGlzcGxhY2VtZW50QmlhcyApO1xcbiNlbmRpZlxcblwiO1xuXG4gICAgdmFyIGVtaXNzaXZlbWFwX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX0VNSVNTSVZFTUFQXFxuXFx0dmVjNCBlbWlzc2l2ZUNvbG9yID0gdGV4dHVyZTJEKCBlbWlzc2l2ZU1hcCwgdlV2ICk7XFxuXFx0ZW1pc3NpdmVDb2xvci5yZ2IgPSBlbWlzc2l2ZU1hcFRleGVsVG9MaW5lYXIoIGVtaXNzaXZlQ29sb3IgKS5yZ2I7XFxuXFx0dG90YWxFbWlzc2l2ZVJhZGlhbmNlICo9IGVtaXNzaXZlQ29sb3IucmdiO1xcbiNlbmRpZlxcblwiO1xuXG4gICAgdmFyIGVtaXNzaXZlbWFwX3BhcnNfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfRU1JU1NJVkVNQVBcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBlbWlzc2l2ZU1hcDtcXG4jZW5kaWZcXG5cIjtcblxuICAgIHZhciBlbmNvZGluZ3NfZnJhZ21lbnQgPSBcIiAgZ2xfRnJhZ0NvbG9yID0gbGluZWFyVG9PdXRwdXRUZXhlbCggZ2xfRnJhZ0NvbG9yICk7XFxuXCI7XG5cbiAgICB2YXIgZW5jb2RpbmdzX3BhcnNfZnJhZ21lbnQgPSBcIlxcbnZlYzQgTGluZWFyVG9MaW5lYXIoIGluIHZlYzQgdmFsdWUgKSB7XFxuICByZXR1cm4gdmFsdWU7XFxufVxcbnZlYzQgR2FtbWFUb0xpbmVhciggaW4gdmVjNCB2YWx1ZSwgaW4gZmxvYXQgZ2FtbWFGYWN0b3IgKSB7XFxuICByZXR1cm4gdmVjNCggcG93KCB2YWx1ZS54eXosIHZlYzMoIGdhbW1hRmFjdG9yICkgKSwgdmFsdWUudyApO1xcbn1cXG52ZWM0IExpbmVhclRvR2FtbWEoIGluIHZlYzQgdmFsdWUsIGluIGZsb2F0IGdhbW1hRmFjdG9yICkge1xcbiAgcmV0dXJuIHZlYzQoIHBvdyggdmFsdWUueHl6LCB2ZWMzKCAxLjAgLyBnYW1tYUZhY3RvciApICksIHZhbHVlLncgKTtcXG59XFxudmVjNCBzUkdCVG9MaW5lYXIoIGluIHZlYzQgdmFsdWUgKSB7XFxuICByZXR1cm4gdmVjNCggbWl4KCBwb3coIHZhbHVlLnJnYiAqIDAuOTQ3ODY3Mjk4NiArIHZlYzMoIDAuMDUyMTMyNzAxNCApLCB2ZWMzKCAyLjQgKSApLCB2YWx1ZS5yZ2IgKiAwLjA3NzM5OTM4MDgsIHZlYzMoIGxlc3NUaGFuRXF1YWwoIHZhbHVlLnJnYiwgdmVjMyggMC4wNDA0NSApICkgKSApLCB2YWx1ZS53ICk7XFxufVxcbnZlYzQgTGluZWFyVG9zUkdCKCBpbiB2ZWM0IHZhbHVlICkge1xcbiAgcmV0dXJuIHZlYzQoIG1peCggcG93KCB2YWx1ZS5yZ2IsIHZlYzMoIDAuNDE2NjYgKSApICogMS4wNTUgLSB2ZWMzKCAwLjA1NSApLCB2YWx1ZS5yZ2IgKiAxMi45MiwgdmVjMyggbGVzc1RoYW5FcXVhbCggdmFsdWUucmdiLCB2ZWMzKCAwLjAwMzEzMDggKSApICkgKSwgdmFsdWUudyApO1xcbn1cXG52ZWM0IFJHQkVUb0xpbmVhciggaW4gdmVjNCB2YWx1ZSApIHtcXG4gIHJldHVybiB2ZWM0KCB2YWx1ZS5yZ2IgKiBleHAyKCB2YWx1ZS5hICogMjU1LjAgLSAxMjguMCApLCAxLjAgKTtcXG59XFxudmVjNCBMaW5lYXJUb1JHQkUoIGluIHZlYzQgdmFsdWUgKSB7XFxuICBmbG9hdCBtYXhDb21wb25lbnQgPSBtYXgoIG1heCggdmFsdWUuciwgdmFsdWUuZyApLCB2YWx1ZS5iICk7XFxuICBmbG9hdCBmRXhwID0gY2xhbXAoIGNlaWwoIGxvZzIoIG1heENvbXBvbmVudCApICksIC0xMjguMCwgMTI3LjAgKTtcXG4gIHJldHVybiB2ZWM0KCB2YWx1ZS5yZ2IgLyBleHAyKCBmRXhwICksICggZkV4cCArIDEyOC4wICkgLyAyNTUuMCApO1xcbn1cXG52ZWM0IFJHQk1Ub0xpbmVhciggaW4gdmVjNCB2YWx1ZSwgaW4gZmxvYXQgbWF4UmFuZ2UgKSB7XFxuICByZXR1cm4gdmVjNCggdmFsdWUueHl6ICogdmFsdWUudyAqIG1heFJhbmdlLCAxLjAgKTtcXG59XFxudmVjNCBMaW5lYXJUb1JHQk0oIGluIHZlYzQgdmFsdWUsIGluIGZsb2F0IG1heFJhbmdlICkge1xcbiAgZmxvYXQgbWF4UkdCID0gbWF4KCB2YWx1ZS54LCBtYXgoIHZhbHVlLmcsIHZhbHVlLmIgKSApO1xcbiAgZmxvYXQgTSAgICAgID0gY2xhbXAoIG1heFJHQiAvIG1heFJhbmdlLCAwLjAsIDEuMCApO1xcbiAgTSAgICAgICAgICAgID0gY2VpbCggTSAqIDI1NS4wICkgLyAyNTUuMDtcXG4gIHJldHVybiB2ZWM0KCB2YWx1ZS5yZ2IgLyAoIE0gKiBtYXhSYW5nZSApLCBNICk7XFxufVxcbnZlYzQgUkdCRFRvTGluZWFyKCBpbiB2ZWM0IHZhbHVlLCBpbiBmbG9hdCBtYXhSYW5nZSApIHtcXG4gICAgcmV0dXJuIHZlYzQoIHZhbHVlLnJnYiAqICggKCBtYXhSYW5nZSAvIDI1NS4wICkgLyB2YWx1ZS5hICksIDEuMCApO1xcbn1cXG52ZWM0IExpbmVhclRvUkdCRCggaW4gdmVjNCB2YWx1ZSwgaW4gZmxvYXQgbWF4UmFuZ2UgKSB7XFxuICAgIGZsb2F0IG1heFJHQiA9IG1heCggdmFsdWUueCwgbWF4KCB2YWx1ZS5nLCB2YWx1ZS5iICkgKTtcXG4gICAgZmxvYXQgRCAgICAgID0gbWF4KCBtYXhSYW5nZSAvIG1heFJHQiwgMS4wICk7XFxuICAgIEQgICAgICAgICAgICA9IG1pbiggZmxvb3IoIEQgKSAvIDI1NS4wLCAxLjAgKTtcXG4gICAgcmV0dXJuIHZlYzQoIHZhbHVlLnJnYiAqICggRCAqICggMjU1LjAgLyBtYXhSYW5nZSApICksIEQgKTtcXG59XFxuY29uc3QgbWF0MyBjTG9nTHV2TSA9IG1hdDMoIDAuMjIwOSwgMC4zMzkwLCAwLjQxODQsIDAuMTEzOCwgMC42NzgwLCAwLjczMTksIDAuMDEwMiwgMC4xMTMwLCAwLjI5NjkgKTtcXG52ZWM0IExpbmVhclRvTG9nTHV2KCBpbiB2ZWM0IHZhbHVlICkgIHtcXG4gIHZlYzMgWHBfWV9YWVpwID0gdmFsdWUucmdiICogY0xvZ0x1dk07XFxuICBYcF9ZX1hZWnAgPSBtYXgoWHBfWV9YWVpwLCB2ZWMzKDFlLTYsIDFlLTYsIDFlLTYpKTtcXG4gIHZlYzQgdlJlc3VsdDtcXG4gIHZSZXN1bHQueHkgPSBYcF9ZX1hZWnAueHkgLyBYcF9ZX1hZWnAuejtcXG4gIGZsb2F0IExlID0gMi4wICogbG9nMihYcF9ZX1hZWnAueSkgKyAxMjcuMDtcXG4gIHZSZXN1bHQudyA9IGZyYWN0KExlKTtcXG4gIHZSZXN1bHQueiA9IChMZSAtIChmbG9vcih2UmVzdWx0LncqMjU1LjApKS8yNTUuMCkvMjU1LjA7XFxuICByZXR1cm4gdlJlc3VsdDtcXG59XFxuY29uc3QgbWF0MyBjTG9nTHV2SW52ZXJzZU0gPSBtYXQzKCA2LjAwMTQsIC0yLjcwMDgsIC0xLjc5OTYsIC0xLjMzMjAsIDMuMTAyOSwgLTUuNzcyMSwgMC4zMDA4LCAtMS4wODgyLCA1LjYyNjggKTtcXG52ZWM0IExvZ0x1dlRvTGluZWFyKCBpbiB2ZWM0IHZhbHVlICkge1xcbiAgZmxvYXQgTGUgPSB2YWx1ZS56ICogMjU1LjAgKyB2YWx1ZS53O1xcbiAgdmVjMyBYcF9ZX1hZWnA7XFxuICBYcF9ZX1hZWnAueSA9IGV4cDIoKExlIC0gMTI3LjApIC8gMi4wKTtcXG4gIFhwX1lfWFlacC56ID0gWHBfWV9YWVpwLnkgLyB2YWx1ZS55O1xcbiAgWHBfWV9YWVpwLnggPSB2YWx1ZS54ICogWHBfWV9YWVpwLno7XFxuICB2ZWMzIHZSR0IgPSBYcF9ZX1hZWnAucmdiICogY0xvZ0x1dkludmVyc2VNO1xcbiAgcmV0dXJuIHZlYzQoIG1heCh2UkdCLCAwLjApLCAxLjAgKTtcXG59XFxuXCI7XG5cbiAgICB2YXIgZW52bWFwX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX0VOVk1BUFxcblxcdCNpZiBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSB8fCBkZWZpbmVkKCBQSE9ORyApXFxuXFx0XFx0dmVjMyBjYW1lcmFUb1ZlcnRleCA9IG5vcm1hbGl6ZSggdldvcmxkUG9zaXRpb24gLSBjYW1lcmFQb3NpdGlvbiApO1xcblxcdFxcdHZlYzMgd29ybGROb3JtYWwgPSBpbnZlcnNlVHJhbnNmb3JtRGlyZWN0aW9uKCBub3JtYWwsIHZpZXdNYXRyaXggKTtcXG5cXHRcXHQjaWZkZWYgRU5WTUFQX01PREVfUkVGTEVDVElPTlxcblxcdFxcdFxcdHZlYzMgcmVmbGVjdFZlYyA9IHJlZmxlY3QoIGNhbWVyYVRvVmVydGV4LCB3b3JsZE5vcm1hbCApO1xcblxcdFxcdCNlbHNlXFxuXFx0XFx0XFx0dmVjMyByZWZsZWN0VmVjID0gcmVmcmFjdCggY2FtZXJhVG9WZXJ0ZXgsIHdvcmxkTm9ybWFsLCByZWZyYWN0aW9uUmF0aW8gKTtcXG5cXHRcXHQjZW5kaWZcXG5cXHQjZWxzZVxcblxcdFxcdHZlYzMgcmVmbGVjdFZlYyA9IHZSZWZsZWN0O1xcblxcdCNlbmRpZlxcblxcdCNpZmRlZiBFTlZNQVBfVFlQRV9DVUJFXFxuXFx0XFx0dmVjNCBlbnZDb2xvciA9IHRleHR1cmVDdWJlKCBlbnZNYXAsIGZsaXBOb3JtYWwgKiB2ZWMzKCBmbGlwRW52TWFwICogcmVmbGVjdFZlYy54LCByZWZsZWN0VmVjLnl6ICkgKTtcXG5cXHQjZWxpZiBkZWZpbmVkKCBFTlZNQVBfVFlQRV9FUVVJUkVDIClcXG5cXHRcXHR2ZWMyIHNhbXBsZVVWO1xcblxcdFxcdHNhbXBsZVVWLnkgPSBzYXR1cmF0ZSggZmxpcE5vcm1hbCAqIHJlZmxlY3RWZWMueSAqIDAuNSArIDAuNSApO1xcblxcdFxcdHNhbXBsZVVWLnggPSBhdGFuKCBmbGlwTm9ybWFsICogcmVmbGVjdFZlYy56LCBmbGlwTm9ybWFsICogcmVmbGVjdFZlYy54ICkgKiBSRUNJUFJPQ0FMX1BJMiArIDAuNTtcXG5cXHRcXHR2ZWM0IGVudkNvbG9yID0gdGV4dHVyZTJEKCBlbnZNYXAsIHNhbXBsZVVWICk7XFxuXFx0I2VsaWYgZGVmaW5lZCggRU5WTUFQX1RZUEVfU1BIRVJFIClcXG5cXHRcXHR2ZWMzIHJlZmxlY3RWaWV3ID0gZmxpcE5vcm1hbCAqIG5vcm1hbGl6ZSggKCB2aWV3TWF0cml4ICogdmVjNCggcmVmbGVjdFZlYywgMC4wICkgKS54eXogKyB2ZWMzKCAwLjAsIDAuMCwgMS4wICkgKTtcXG5cXHRcXHR2ZWM0IGVudkNvbG9yID0gdGV4dHVyZTJEKCBlbnZNYXAsIHJlZmxlY3RWaWV3Lnh5ICogMC41ICsgMC41ICk7XFxuXFx0I2Vsc2VcXG5cXHRcXHR2ZWM0IGVudkNvbG9yID0gdmVjNCggMC4wICk7XFxuXFx0I2VuZGlmXFxuXFx0ZW52Q29sb3IgPSBlbnZNYXBUZXhlbFRvTGluZWFyKCBlbnZDb2xvciApO1xcblxcdCNpZmRlZiBFTlZNQVBfQkxFTkRJTkdfTVVMVElQTFlcXG5cXHRcXHRvdXRnb2luZ0xpZ2h0ID0gbWl4KCBvdXRnb2luZ0xpZ2h0LCBvdXRnb2luZ0xpZ2h0ICogZW52Q29sb3IueHl6LCBzcGVjdWxhclN0cmVuZ3RoICogcmVmbGVjdGl2aXR5ICk7XFxuXFx0I2VsaWYgZGVmaW5lZCggRU5WTUFQX0JMRU5ESU5HX01JWCApXFxuXFx0XFx0b3V0Z29pbmdMaWdodCA9IG1peCggb3V0Z29pbmdMaWdodCwgZW52Q29sb3IueHl6LCBzcGVjdWxhclN0cmVuZ3RoICogcmVmbGVjdGl2aXR5ICk7XFxuXFx0I2VsaWYgZGVmaW5lZCggRU5WTUFQX0JMRU5ESU5HX0FERCApXFxuXFx0XFx0b3V0Z29pbmdMaWdodCArPSBlbnZDb2xvci54eXogKiBzcGVjdWxhclN0cmVuZ3RoICogcmVmbGVjdGl2aXR5O1xcblxcdCNlbmRpZlxcbiNlbmRpZlxcblwiO1xuXG4gICAgdmFyIGVudm1hcF9wYXJzX2ZyYWdtZW50ID0gXCIjaWYgZGVmaW5lZCggVVNFX0VOVk1BUCApIHx8IGRlZmluZWQoIFBIWVNJQ0FMIClcXG5cXHR1bmlmb3JtIGZsb2F0IHJlZmxlY3Rpdml0eTtcXG5cXHR1bmlmb3JtIGZsb2F0IGVudk1hcEludGVuc3RpeTtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX0VOVk1BUFxcblxcdCNpZiAhIGRlZmluZWQoIFBIWVNJQ0FMICkgJiYgKCBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSB8fCBkZWZpbmVkKCBQSE9ORyApIClcXG5cXHRcXHR2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XFxuXFx0I2VuZGlmXFxuXFx0I2lmZGVmIEVOVk1BUF9UWVBFX0NVQkVcXG5cXHRcXHR1bmlmb3JtIHNhbXBsZXJDdWJlIGVudk1hcDtcXG5cXHQjZWxzZVxcblxcdFxcdHVuaWZvcm0gc2FtcGxlcjJEIGVudk1hcDtcXG5cXHQjZW5kaWZcXG5cXHR1bmlmb3JtIGZsb2F0IGZsaXBFbnZNYXA7XFxuXFx0I2lmIGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApIHx8IGRlZmluZWQoIFBIT05HICkgfHwgZGVmaW5lZCggUEhZU0lDQUwgKVxcblxcdFxcdHVuaWZvcm0gZmxvYXQgcmVmcmFjdGlvblJhdGlvO1xcblxcdCNlbHNlXFxuXFx0XFx0dmFyeWluZyB2ZWMzIHZSZWZsZWN0O1xcblxcdCNlbmRpZlxcbiNlbmRpZlxcblwiO1xuXG4gICAgdmFyIGVudm1hcF9wYXJzX3ZlcnRleCA9IFwiI2lmZGVmIFVTRV9FTlZNQVBcXG5cXHQjaWYgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkgfHwgZGVmaW5lZCggUEhPTkcgKVxcblxcdFxcdHZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcXG5cXHQjZWxzZVxcblxcdFxcdHZhcnlpbmcgdmVjMyB2UmVmbGVjdDtcXG5cXHRcXHR1bmlmb3JtIGZsb2F0IHJlZnJhY3Rpb25SYXRpbztcXG5cXHQjZW5kaWZcXG4jZW5kaWZcXG5cIjtcblxuICAgIHZhciBlbnZtYXBfdmVydGV4ID0gXCIjaWZkZWYgVVNFX0VOVk1BUFxcblxcdCNpZiBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSB8fCBkZWZpbmVkKCBQSE9ORyApXFxuXFx0XFx0dldvcmxkUG9zaXRpb24gPSB3b3JsZFBvc2l0aW9uLnh5ejtcXG5cXHQjZWxzZVxcblxcdFxcdHZlYzMgY2FtZXJhVG9WZXJ0ZXggPSBub3JtYWxpemUoIHdvcmxkUG9zaXRpb24ueHl6IC0gY2FtZXJhUG9zaXRpb24gKTtcXG5cXHRcXHR2ZWMzIHdvcmxkTm9ybWFsID0gaW52ZXJzZVRyYW5zZm9ybURpcmVjdGlvbiggdHJhbnNmb3JtZWROb3JtYWwsIHZpZXdNYXRyaXggKTtcXG5cXHRcXHQjaWZkZWYgRU5WTUFQX01PREVfUkVGTEVDVElPTlxcblxcdFxcdFxcdHZSZWZsZWN0ID0gcmVmbGVjdCggY2FtZXJhVG9WZXJ0ZXgsIHdvcmxkTm9ybWFsICk7XFxuXFx0XFx0I2Vsc2VcXG5cXHRcXHRcXHR2UmVmbGVjdCA9IHJlZnJhY3QoIGNhbWVyYVRvVmVydGV4LCB3b3JsZE5vcm1hbCwgcmVmcmFjdGlvblJhdGlvICk7XFxuXFx0XFx0I2VuZGlmXFxuXFx0I2VuZGlmXFxuI2VuZGlmXFxuXCI7XG5cbiAgICB2YXIgZm9nX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX0ZPR1xcblxcdCNpZmRlZiBVU0VfTE9HREVQVEhCVUZfRVhUXFxuXFx0XFx0ZmxvYXQgZGVwdGggPSBnbF9GcmFnRGVwdGhFWFQgLyBnbF9GcmFnQ29vcmQudztcXG5cXHQjZWxzZVxcblxcdFxcdGZsb2F0IGRlcHRoID0gZ2xfRnJhZ0Nvb3JkLnogLyBnbF9GcmFnQ29vcmQudztcXG5cXHQjZW5kaWZcXG5cXHQjaWZkZWYgRk9HX0VYUDJcXG5cXHRcXHRmbG9hdCBmb2dGYWN0b3IgPSB3aGl0ZUNvbXBsaW1lbnQoIGV4cDIoIC0gZm9nRGVuc2l0eSAqIGZvZ0RlbnNpdHkgKiBkZXB0aCAqIGRlcHRoICogTE9HMiApICk7XFxuXFx0I2Vsc2VcXG5cXHRcXHRmbG9hdCBmb2dGYWN0b3IgPSBzbW9vdGhzdGVwKCBmb2dOZWFyLCBmb2dGYXIsIGRlcHRoICk7XFxuXFx0I2VuZGlmXFxuXFx0Z2xfRnJhZ0NvbG9yLnJnYiA9IG1peCggZ2xfRnJhZ0NvbG9yLnJnYiwgZm9nQ29sb3IsIGZvZ0ZhY3RvciApO1xcbiNlbmRpZlxcblwiO1xuXG4gICAgdmFyIGZvZ19wYXJzX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX0ZPR1xcblxcdHVuaWZvcm0gdmVjMyBmb2dDb2xvcjtcXG5cXHQjaWZkZWYgRk9HX0VYUDJcXG5cXHRcXHR1bmlmb3JtIGZsb2F0IGZvZ0RlbnNpdHk7XFxuXFx0I2Vsc2VcXG5cXHRcXHR1bmlmb3JtIGZsb2F0IGZvZ05lYXI7XFxuXFx0XFx0dW5pZm9ybSBmbG9hdCBmb2dGYXI7XFxuXFx0I2VuZGlmXFxuI2VuZGlmXCI7XG5cbiAgICB2YXIgbGlnaHRtYXBfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfTElHSFRNQVBcXG5cXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKz0gUEkgKiB0ZXh0dXJlMkQoIGxpZ2h0TWFwLCB2VXYyICkueHl6ICogbGlnaHRNYXBJbnRlbnNpdHk7XFxuI2VuZGlmXFxuXCI7XG5cbiAgICB2YXIgbGlnaHRtYXBfcGFyc19mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9MSUdIVE1BUFxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIGxpZ2h0TWFwO1xcblxcdHVuaWZvcm0gZmxvYXQgbGlnaHRNYXBJbnRlbnNpdHk7XFxuI2VuZGlmXCI7XG5cbiAgICB2YXIgbGlnaHRzX2xhbWJlcnRfdmVydGV4ID0gXCJ2ZWMzIGRpZmZ1c2UgPSB2ZWMzKCAxLjAgKTtcXG5HZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5O1xcbmdlb21ldHJ5LnBvc2l0aW9uID0gbXZQb3NpdGlvbi54eXo7XFxuZ2VvbWV0cnkubm9ybWFsID0gbm9ybWFsaXplKCB0cmFuc2Zvcm1lZE5vcm1hbCApO1xcbmdlb21ldHJ5LnZpZXdEaXIgPSBub3JtYWxpemUoIC1tdlBvc2l0aW9uLnh5eiApO1xcbkdlb21ldHJpY0NvbnRleHQgYmFja0dlb21ldHJ5O1xcbmJhY2tHZW9tZXRyeS5wb3NpdGlvbiA9IGdlb21ldHJ5LnBvc2l0aW9uO1xcbmJhY2tHZW9tZXRyeS5ub3JtYWwgPSAtZ2VvbWV0cnkubm9ybWFsO1xcbmJhY2tHZW9tZXRyeS52aWV3RGlyID0gZ2VvbWV0cnkudmlld0RpcjtcXG52TGlnaHRGcm9udCA9IHZlYzMoIDAuMCApO1xcbiNpZmRlZiBET1VCTEVfU0lERURcXG5cXHR2TGlnaHRCYWNrID0gdmVjMyggMC4wICk7XFxuI2VuZGlmXFxuSW5jaWRlbnRMaWdodCBkaXJlY3RMaWdodDtcXG5mbG9hdCBkb3ROTDtcXG52ZWMzIGRpcmVjdExpZ2h0Q29sb3JfRGlmZnVzZTtcXG4jaWYgTlVNX1BPSU5UX0xJR0hUUyA+IDBcXG5cXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fUE9JTlRfTElHSFRTOyBpICsrICkge1xcblxcdFxcdGdldFBvaW50RGlyZWN0TGlnaHRJcnJhZGlhbmNlKCBwb2ludExpZ2h0c1sgaSBdLCBnZW9tZXRyeSwgZGlyZWN0TGlnaHQgKTtcXG5cXHRcXHRkb3ROTCA9IGRvdCggZ2VvbWV0cnkubm9ybWFsLCBkaXJlY3RMaWdodC5kaXJlY3Rpb24gKTtcXG5cXHRcXHRkaXJlY3RMaWdodENvbG9yX0RpZmZ1c2UgPSBQSSAqIGRpcmVjdExpZ2h0LmNvbG9yO1xcblxcdFxcdHZMaWdodEZyb250ICs9IHNhdHVyYXRlKCBkb3ROTCApICogZGlyZWN0TGlnaHRDb2xvcl9EaWZmdXNlO1xcblxcdFxcdCNpZmRlZiBET1VCTEVfU0lERURcXG5cXHRcXHRcXHR2TGlnaHRCYWNrICs9IHNhdHVyYXRlKCAtZG90TkwgKSAqIGRpcmVjdExpZ2h0Q29sb3JfRGlmZnVzZTtcXG5cXHRcXHQjZW5kaWZcXG5cXHR9XFxuI2VuZGlmXFxuI2lmIE5VTV9TUE9UX0xJR0hUUyA+IDBcXG5cXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fU1BPVF9MSUdIVFM7IGkgKysgKSB7XFxuXFx0XFx0Z2V0U3BvdERpcmVjdExpZ2h0SXJyYWRpYW5jZSggc3BvdExpZ2h0c1sgaSBdLCBnZW9tZXRyeSwgZGlyZWN0TGlnaHQgKTtcXG5cXHRcXHRkb3ROTCA9IGRvdCggZ2VvbWV0cnkubm9ybWFsLCBkaXJlY3RMaWdodC5kaXJlY3Rpb24gKTtcXG5cXHRcXHRkaXJlY3RMaWdodENvbG9yX0RpZmZ1c2UgPSBQSSAqIGRpcmVjdExpZ2h0LmNvbG9yO1xcblxcdFxcdHZMaWdodEZyb250ICs9IHNhdHVyYXRlKCBkb3ROTCApICogZGlyZWN0TGlnaHRDb2xvcl9EaWZmdXNlO1xcblxcdFxcdCNpZmRlZiBET1VCTEVfU0lERURcXG5cXHRcXHRcXHR2TGlnaHRCYWNrICs9IHNhdHVyYXRlKCAtZG90TkwgKSAqIGRpcmVjdExpZ2h0Q29sb3JfRGlmZnVzZTtcXG5cXHRcXHQjZW5kaWZcXG5cXHR9XFxuI2VuZGlmXFxuI2lmIE5VTV9ESVJfTElHSFRTID4gMFxcblxcdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9ESVJfTElHSFRTOyBpICsrICkge1xcblxcdFxcdGdldERpcmVjdGlvbmFsRGlyZWN0TGlnaHRJcnJhZGlhbmNlKCBkaXJlY3Rpb25hbExpZ2h0c1sgaSBdLCBnZW9tZXRyeSwgZGlyZWN0TGlnaHQgKTtcXG5cXHRcXHRkb3ROTCA9IGRvdCggZ2VvbWV0cnkubm9ybWFsLCBkaXJlY3RMaWdodC5kaXJlY3Rpb24gKTtcXG5cXHRcXHRkaXJlY3RMaWdodENvbG9yX0RpZmZ1c2UgPSBQSSAqIGRpcmVjdExpZ2h0LmNvbG9yO1xcblxcdFxcdHZMaWdodEZyb250ICs9IHNhdHVyYXRlKCBkb3ROTCApICogZGlyZWN0TGlnaHRDb2xvcl9EaWZmdXNlO1xcblxcdFxcdCNpZmRlZiBET1VCTEVfU0lERURcXG5cXHRcXHRcXHR2TGlnaHRCYWNrICs9IHNhdHVyYXRlKCAtZG90TkwgKSAqIGRpcmVjdExpZ2h0Q29sb3JfRGlmZnVzZTtcXG5cXHRcXHQjZW5kaWZcXG5cXHR9XFxuI2VuZGlmXFxuI2lmIE5VTV9IRU1JX0xJR0hUUyA+IDBcXG5cXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fSEVNSV9MSUdIVFM7IGkgKysgKSB7XFxuXFx0XFx0dkxpZ2h0RnJvbnQgKz0gZ2V0SGVtaXNwaGVyZUxpZ2h0SXJyYWRpYW5jZSggaGVtaXNwaGVyZUxpZ2h0c1sgaSBdLCBnZW9tZXRyeSApO1xcblxcdFxcdCNpZmRlZiBET1VCTEVfU0lERURcXG5cXHRcXHRcXHR2TGlnaHRCYWNrICs9IGdldEhlbWlzcGhlcmVMaWdodElycmFkaWFuY2UoIGhlbWlzcGhlcmVMaWdodHNbIGkgXSwgYmFja0dlb21ldHJ5ICk7XFxuXFx0XFx0I2VuZGlmXFxuXFx0fVxcbiNlbmRpZlxcblwiO1xuXG4gICAgdmFyIGxpZ2h0c19wYXJzID0gXCJ1bmlmb3JtIHZlYzMgYW1iaWVudExpZ2h0Q29sb3I7XFxudmVjMyBnZXRBbWJpZW50TGlnaHRJcnJhZGlhbmNlKCBjb25zdCBpbiB2ZWMzIGFtYmllbnRMaWdodENvbG9yICkge1xcblxcdHZlYzMgaXJyYWRpYW5jZSA9IGFtYmllbnRMaWdodENvbG9yO1xcblxcdCNpZm5kZWYgUEhZU0lDQUxMWV9DT1JSRUNUX0xJR0hUU1xcblxcdFxcdGlycmFkaWFuY2UgKj0gUEk7XFxuXFx0I2VuZGlmXFxuXFx0cmV0dXJuIGlycmFkaWFuY2U7XFxufVxcbiNpZiBOVU1fRElSX0xJR0hUUyA+IDBcXG5cXHRzdHJ1Y3QgRGlyZWN0aW9uYWxMaWdodCB7XFxuXFx0XFx0dmVjMyBkaXJlY3Rpb247XFxuXFx0XFx0dmVjMyBjb2xvcjtcXG5cXHRcXHRpbnQgc2hhZG93O1xcblxcdFxcdGZsb2F0IHNoYWRvd0JpYXM7XFxuXFx0XFx0ZmxvYXQgc2hhZG93UmFkaXVzO1xcblxcdFxcdHZlYzIgc2hhZG93TWFwU2l6ZTtcXG5cXHR9O1xcblxcdHVuaWZvcm0gRGlyZWN0aW9uYWxMaWdodCBkaXJlY3Rpb25hbExpZ2h0c1sgTlVNX0RJUl9MSUdIVFMgXTtcXG5cXHR2b2lkIGdldERpcmVjdGlvbmFsRGlyZWN0TGlnaHRJcnJhZGlhbmNlKCBjb25zdCBpbiBEaXJlY3Rpb25hbExpZ2h0IGRpcmVjdGlvbmFsTGlnaHQsIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIG91dCBJbmNpZGVudExpZ2h0IGRpcmVjdExpZ2h0ICkge1xcblxcdFxcdGRpcmVjdExpZ2h0LmNvbG9yID0gZGlyZWN0aW9uYWxMaWdodC5jb2xvcjtcXG5cXHRcXHRkaXJlY3RMaWdodC5kaXJlY3Rpb24gPSBkaXJlY3Rpb25hbExpZ2h0LmRpcmVjdGlvbjtcXG5cXHRcXHRkaXJlY3RMaWdodC52aXNpYmxlID0gdHJ1ZTtcXG5cXHR9XFxuI2VuZGlmXFxuI2lmIE5VTV9QT0lOVF9MSUdIVFMgPiAwXFxuXFx0c3RydWN0IFBvaW50TGlnaHQge1xcblxcdFxcdHZlYzMgcG9zaXRpb247XFxuXFx0XFx0dmVjMyBjb2xvcjtcXG5cXHRcXHRmbG9hdCBkaXN0YW5jZTtcXG5cXHRcXHRmbG9hdCBkZWNheTtcXG5cXHRcXHRpbnQgc2hhZG93O1xcblxcdFxcdGZsb2F0IHNoYWRvd0JpYXM7XFxuXFx0XFx0ZmxvYXQgc2hhZG93UmFkaXVzO1xcblxcdFxcdHZlYzIgc2hhZG93TWFwU2l6ZTtcXG5cXHR9O1xcblxcdHVuaWZvcm0gUG9pbnRMaWdodCBwb2ludExpZ2h0c1sgTlVNX1BPSU5UX0xJR0hUUyBdO1xcblxcdHZvaWQgZ2V0UG9pbnREaXJlY3RMaWdodElycmFkaWFuY2UoIGNvbnN0IGluIFBvaW50TGlnaHQgcG9pbnRMaWdodCwgY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgb3V0IEluY2lkZW50TGlnaHQgZGlyZWN0TGlnaHQgKSB7XFxuXFx0XFx0dmVjMyBsVmVjdG9yID0gcG9pbnRMaWdodC5wb3NpdGlvbiAtIGdlb21ldHJ5LnBvc2l0aW9uO1xcblxcdFxcdGRpcmVjdExpZ2h0LmRpcmVjdGlvbiA9IG5vcm1hbGl6ZSggbFZlY3RvciApO1xcblxcdFxcdGZsb2F0IGxpZ2h0RGlzdGFuY2UgPSBsZW5ndGgoIGxWZWN0b3IgKTtcXG5cXHRcXHRpZiAoIHRlc3RMaWdodEluUmFuZ2UoIGxpZ2h0RGlzdGFuY2UsIHBvaW50TGlnaHQuZGlzdGFuY2UgKSApIHtcXG5cXHRcXHRcXHRkaXJlY3RMaWdodC5jb2xvciA9IHBvaW50TGlnaHQuY29sb3I7XFxuXFx0XFx0XFx0ZGlyZWN0TGlnaHQuY29sb3IgKj0gcHVuY3R1YWxMaWdodEludGVuc2l0eVRvSXJyYWRpYW5jZUZhY3RvciggbGlnaHREaXN0YW5jZSwgcG9pbnRMaWdodC5kaXN0YW5jZSwgcG9pbnRMaWdodC5kZWNheSApO1xcblxcdFxcdFxcdGRpcmVjdExpZ2h0LnZpc2libGUgPSB0cnVlO1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0ZGlyZWN0TGlnaHQuY29sb3IgPSB2ZWMzKCAwLjAgKTtcXG5cXHRcXHRcXHRkaXJlY3RMaWdodC52aXNpYmxlID0gZmFsc2U7XFxuXFx0XFx0fVxcblxcdH1cXG4jZW5kaWZcXG4jaWYgTlVNX1NQT1RfTElHSFRTID4gMFxcblxcdHN0cnVjdCBTcG90TGlnaHQge1xcblxcdFxcdHZlYzMgcG9zaXRpb247XFxuXFx0XFx0dmVjMyBkaXJlY3Rpb247XFxuXFx0XFx0dmVjMyBjb2xvcjtcXG5cXHRcXHRmbG9hdCBkaXN0YW5jZTtcXG5cXHRcXHRmbG9hdCBkZWNheTtcXG5cXHRcXHRmbG9hdCBjb25lQ29zO1xcblxcdFxcdGZsb2F0IHBlbnVtYnJhQ29zO1xcblxcdFxcdGludCBzaGFkb3c7XFxuXFx0XFx0ZmxvYXQgc2hhZG93QmlhcztcXG5cXHRcXHRmbG9hdCBzaGFkb3dSYWRpdXM7XFxuXFx0XFx0dmVjMiBzaGFkb3dNYXBTaXplO1xcblxcdH07XFxuXFx0dW5pZm9ybSBTcG90TGlnaHQgc3BvdExpZ2h0c1sgTlVNX1NQT1RfTElHSFRTIF07XFxuXFx0dm9pZCBnZXRTcG90RGlyZWN0TGlnaHRJcnJhZGlhbmNlKCBjb25zdCBpbiBTcG90TGlnaHQgc3BvdExpZ2h0LCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBvdXQgSW5jaWRlbnRMaWdodCBkaXJlY3RMaWdodCAgKSB7XFxuXFx0XFx0dmVjMyBsVmVjdG9yID0gc3BvdExpZ2h0LnBvc2l0aW9uIC0gZ2VvbWV0cnkucG9zaXRpb247XFxuXFx0XFx0ZGlyZWN0TGlnaHQuZGlyZWN0aW9uID0gbm9ybWFsaXplKCBsVmVjdG9yICk7XFxuXFx0XFx0ZmxvYXQgbGlnaHREaXN0YW5jZSA9IGxlbmd0aCggbFZlY3RvciApO1xcblxcdFxcdGZsb2F0IGFuZ2xlQ29zID0gZG90KCBkaXJlY3RMaWdodC5kaXJlY3Rpb24sIHNwb3RMaWdodC5kaXJlY3Rpb24gKTtcXG5cXHRcXHRpZiAoIGFsbCggYnZlYzIoIGFuZ2xlQ29zID4gc3BvdExpZ2h0LmNvbmVDb3MsIHRlc3RMaWdodEluUmFuZ2UoIGxpZ2h0RGlzdGFuY2UsIHNwb3RMaWdodC5kaXN0YW5jZSApICkgKSApIHtcXG5cXHRcXHRcXHRmbG9hdCBzcG90RWZmZWN0ID0gc21vb3Roc3RlcCggc3BvdExpZ2h0LmNvbmVDb3MsIHNwb3RMaWdodC5wZW51bWJyYUNvcywgYW5nbGVDb3MgKTtcXG5cXHRcXHRcXHRkaXJlY3RMaWdodC5jb2xvciA9IHNwb3RMaWdodC5jb2xvcjtcXG5cXHRcXHRcXHRkaXJlY3RMaWdodC5jb2xvciAqPSBzcG90RWZmZWN0ICogcHVuY3R1YWxMaWdodEludGVuc2l0eVRvSXJyYWRpYW5jZUZhY3RvciggbGlnaHREaXN0YW5jZSwgc3BvdExpZ2h0LmRpc3RhbmNlLCBzcG90TGlnaHQuZGVjYXkgKTtcXG5cXHRcXHRcXHRkaXJlY3RMaWdodC52aXNpYmxlID0gdHJ1ZTtcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdGRpcmVjdExpZ2h0LmNvbG9yID0gdmVjMyggMC4wICk7XFxuXFx0XFx0XFx0ZGlyZWN0TGlnaHQudmlzaWJsZSA9IGZhbHNlO1xcblxcdFxcdH1cXG5cXHR9XFxuI2VuZGlmXFxuI2lmIE5VTV9IRU1JX0xJR0hUUyA+IDBcXG5cXHRzdHJ1Y3QgSGVtaXNwaGVyZUxpZ2h0IHtcXG5cXHRcXHR2ZWMzIGRpcmVjdGlvbjtcXG5cXHRcXHR2ZWMzIHNreUNvbG9yO1xcblxcdFxcdHZlYzMgZ3JvdW5kQ29sb3I7XFxuXFx0fTtcXG5cXHR1bmlmb3JtIEhlbWlzcGhlcmVMaWdodCBoZW1pc3BoZXJlTGlnaHRzWyBOVU1fSEVNSV9MSUdIVFMgXTtcXG5cXHR2ZWMzIGdldEhlbWlzcGhlcmVMaWdodElycmFkaWFuY2UoIGNvbnN0IGluIEhlbWlzcGhlcmVMaWdodCBoZW1pTGlnaHQsIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnkgKSB7XFxuXFx0XFx0ZmxvYXQgZG90TkwgPSBkb3QoIGdlb21ldHJ5Lm5vcm1hbCwgaGVtaUxpZ2h0LmRpcmVjdGlvbiApO1xcblxcdFxcdGZsb2F0IGhlbWlEaWZmdXNlV2VpZ2h0ID0gMC41ICogZG90TkwgKyAwLjU7XFxuXFx0XFx0dmVjMyBpcnJhZGlhbmNlID0gbWl4KCBoZW1pTGlnaHQuZ3JvdW5kQ29sb3IsIGhlbWlMaWdodC5za3lDb2xvciwgaGVtaURpZmZ1c2VXZWlnaHQgKTtcXG5cXHRcXHQjaWZuZGVmIFBIWVNJQ0FMTFlfQ09SUkVDVF9MSUdIVFNcXG5cXHRcXHRcXHRpcnJhZGlhbmNlICo9IFBJO1xcblxcdFxcdCNlbmRpZlxcblxcdFxcdHJldHVybiBpcnJhZGlhbmNlO1xcblxcdH1cXG4jZW5kaWZcXG4jaWYgZGVmaW5lZCggVVNFX0VOVk1BUCApICYmIGRlZmluZWQoIFBIWVNJQ0FMIClcXG5cXHR2ZWMzIGdldExpZ2h0UHJvYmVJbmRpcmVjdElycmFkaWFuY2UoIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIGNvbnN0IGluIGludCBtYXhNSVBMZXZlbCApIHtcXG5cXHRcXHQjaW5jbHVkZSA8bm9ybWFsX2ZsaXA+XFxuXFx0XFx0dmVjMyB3b3JsZE5vcm1hbCA9IGludmVyc2VUcmFuc2Zvcm1EaXJlY3Rpb24oIGdlb21ldHJ5Lm5vcm1hbCwgdmlld01hdHJpeCApO1xcblxcdFxcdCNpZmRlZiBFTlZNQVBfVFlQRV9DVUJFXFxuXFx0XFx0XFx0dmVjMyBxdWVyeVZlYyA9IGZsaXBOb3JtYWwgKiB2ZWMzKCBmbGlwRW52TWFwICogd29ybGROb3JtYWwueCwgd29ybGROb3JtYWwueXogKTtcXG5cXHRcXHRcXHQjaWZkZWYgVEVYVFVSRV9MT0RfRVhUXFxuXFx0XFx0XFx0XFx0dmVjNCBlbnZNYXBDb2xvciA9IHRleHR1cmVDdWJlTG9kRVhUKCBlbnZNYXAsIHF1ZXJ5VmVjLCBmbG9hdCggbWF4TUlQTGV2ZWwgKSApO1xcblxcdFxcdFxcdCNlbHNlXFxuXFx0XFx0XFx0XFx0dmVjNCBlbnZNYXBDb2xvciA9IHRleHR1cmVDdWJlKCBlbnZNYXAsIHF1ZXJ5VmVjLCBmbG9hdCggbWF4TUlQTGV2ZWwgKSApO1xcblxcdFxcdFxcdCNlbmRpZlxcblxcdFxcdFxcdGVudk1hcENvbG9yLnJnYiA9IGVudk1hcFRleGVsVG9MaW5lYXIoIGVudk1hcENvbG9yICkucmdiO1xcblxcdFxcdCNlbGlmIGRlZmluZWQoIEVOVk1BUF9UWVBFX0NVQkVfVVYgKVxcblxcdFxcdFxcdHZlYzMgcXVlcnlWZWMgPSBmbGlwTm9ybWFsICogdmVjMyggZmxpcEVudk1hcCAqIHdvcmxkTm9ybWFsLngsIHdvcmxkTm9ybWFsLnl6ICk7XFxuXFx0XFx0XFx0dmVjNCBlbnZNYXBDb2xvciA9IHRleHR1cmVDdWJlVVYoIHF1ZXJ5VmVjLCAxLjAgKTtcXG5cXHRcXHQjZWxzZVxcblxcdFxcdFxcdHZlYzQgZW52TWFwQ29sb3IgPSB2ZWM0KCAwLjAgKTtcXG5cXHRcXHQjZW5kaWZcXG5cXHRcXHRyZXR1cm4gUEkgKiBlbnZNYXBDb2xvci5yZ2IgKiBlbnZNYXBJbnRlbnNpdHk7XFxuXFx0fVxcblxcdGZsb2F0IGdldFNwZWN1bGFyTUlQTGV2ZWwoIGNvbnN0IGluIGZsb2F0IGJsaW5uU2hpbmluZXNzRXhwb25lbnQsIGNvbnN0IGluIGludCBtYXhNSVBMZXZlbCApIHtcXG5cXHRcXHRmbG9hdCBtYXhNSVBMZXZlbFNjYWxhciA9IGZsb2F0KCBtYXhNSVBMZXZlbCApO1xcblxcdFxcdGZsb2F0IGRlc2lyZWRNSVBMZXZlbCA9IG1heE1JUExldmVsU2NhbGFyIC0gMC43OTI0OCAtIDAuNSAqIGxvZzIoIHBvdzIoIGJsaW5uU2hpbmluZXNzRXhwb25lbnQgKSArIDEuMCApO1xcblxcdFxcdHJldHVybiBjbGFtcCggZGVzaXJlZE1JUExldmVsLCAwLjAsIG1heE1JUExldmVsU2NhbGFyICk7XFxuXFx0fVxcblxcdHZlYzMgZ2V0TGlnaHRQcm9iZUluZGlyZWN0UmFkaWFuY2UoIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIGNvbnN0IGluIGZsb2F0IGJsaW5uU2hpbmluZXNzRXhwb25lbnQsIGNvbnN0IGluIGludCBtYXhNSVBMZXZlbCApIHtcXG5cXHRcXHQjaWZkZWYgRU5WTUFQX01PREVfUkVGTEVDVElPTlxcblxcdFxcdFxcdHZlYzMgcmVmbGVjdFZlYyA9IHJlZmxlY3QoIC1nZW9tZXRyeS52aWV3RGlyLCBnZW9tZXRyeS5ub3JtYWwgKTtcXG5cXHRcXHQjZWxzZVxcblxcdFxcdFxcdHZlYzMgcmVmbGVjdFZlYyA9IHJlZnJhY3QoIC1nZW9tZXRyeS52aWV3RGlyLCBnZW9tZXRyeS5ub3JtYWwsIHJlZnJhY3Rpb25SYXRpbyApO1xcblxcdFxcdCNlbmRpZlxcblxcdFxcdCNpbmNsdWRlIDxub3JtYWxfZmxpcD5cXG5cXHRcXHRyZWZsZWN0VmVjID0gaW52ZXJzZVRyYW5zZm9ybURpcmVjdGlvbiggcmVmbGVjdFZlYywgdmlld01hdHJpeCApO1xcblxcdFxcdGZsb2F0IHNwZWN1bGFyTUlQTGV2ZWwgPSBnZXRTcGVjdWxhck1JUExldmVsKCBibGlublNoaW5pbmVzc0V4cG9uZW50LCBtYXhNSVBMZXZlbCApO1xcblxcdFxcdCNpZmRlZiBFTlZNQVBfVFlQRV9DVUJFXFxuXFx0XFx0XFx0dmVjMyBxdWVyeVJlZmxlY3RWZWMgPSBmbGlwTm9ybWFsICogdmVjMyggZmxpcEVudk1hcCAqIHJlZmxlY3RWZWMueCwgcmVmbGVjdFZlYy55eiApO1xcblxcdFxcdFxcdCNpZmRlZiBURVhUVVJFX0xPRF9FWFRcXG5cXHRcXHRcXHRcXHR2ZWM0IGVudk1hcENvbG9yID0gdGV4dHVyZUN1YmVMb2RFWFQoIGVudk1hcCwgcXVlcnlSZWZsZWN0VmVjLCBzcGVjdWxhck1JUExldmVsICk7XFxuXFx0XFx0XFx0I2Vsc2VcXG5cXHRcXHRcXHRcXHR2ZWM0IGVudk1hcENvbG9yID0gdGV4dHVyZUN1YmUoIGVudk1hcCwgcXVlcnlSZWZsZWN0VmVjLCBzcGVjdWxhck1JUExldmVsICk7XFxuXFx0XFx0XFx0I2VuZGlmXFxuXFx0XFx0XFx0ZW52TWFwQ29sb3IucmdiID0gZW52TWFwVGV4ZWxUb0xpbmVhciggZW52TWFwQ29sb3IgKS5yZ2I7XFxuXFx0XFx0I2VsaWYgZGVmaW5lZCggRU5WTUFQX1RZUEVfQ1VCRV9VViApXFxuXFx0XFx0XFx0dmVjMyBxdWVyeVJlZmxlY3RWZWMgPSBmbGlwTm9ybWFsICogdmVjMyggZmxpcEVudk1hcCAqIHJlZmxlY3RWZWMueCwgcmVmbGVjdFZlYy55eiApO1xcblxcdFxcdFxcdHZlYzQgZW52TWFwQ29sb3IgPSB0ZXh0dXJlQ3ViZVVWKHF1ZXJ5UmVmbGVjdFZlYywgQmxpbm5FeHBvbmVudFRvR0dYUm91Z2huZXNzKGJsaW5uU2hpbmluZXNzRXhwb25lbnQpKTtcXG5cXHRcXHQjZWxpZiBkZWZpbmVkKCBFTlZNQVBfVFlQRV9FUVVJUkVDIClcXG5cXHRcXHRcXHR2ZWMyIHNhbXBsZVVWO1xcblxcdFxcdFxcdHNhbXBsZVVWLnkgPSBzYXR1cmF0ZSggZmxpcE5vcm1hbCAqIHJlZmxlY3RWZWMueSAqIDAuNSArIDAuNSApO1xcblxcdFxcdFxcdHNhbXBsZVVWLnggPSBhdGFuKCBmbGlwTm9ybWFsICogcmVmbGVjdFZlYy56LCBmbGlwTm9ybWFsICogcmVmbGVjdFZlYy54ICkgKiBSRUNJUFJPQ0FMX1BJMiArIDAuNTtcXG5cXHRcXHRcXHQjaWZkZWYgVEVYVFVSRV9MT0RfRVhUXFxuXFx0XFx0XFx0XFx0dmVjNCBlbnZNYXBDb2xvciA9IHRleHR1cmUyRExvZEVYVCggZW52TWFwLCBzYW1wbGVVViwgc3BlY3VsYXJNSVBMZXZlbCApO1xcblxcdFxcdFxcdCNlbHNlXFxuXFx0XFx0XFx0XFx0dmVjNCBlbnZNYXBDb2xvciA9IHRleHR1cmUyRCggZW52TWFwLCBzYW1wbGVVViwgc3BlY3VsYXJNSVBMZXZlbCApO1xcblxcdFxcdFxcdCNlbmRpZlxcblxcdFxcdFxcdGVudk1hcENvbG9yLnJnYiA9IGVudk1hcFRleGVsVG9MaW5lYXIoIGVudk1hcENvbG9yICkucmdiO1xcblxcdFxcdCNlbGlmIGRlZmluZWQoIEVOVk1BUF9UWVBFX1NQSEVSRSApXFxuXFx0XFx0XFx0dmVjMyByZWZsZWN0VmlldyA9IGZsaXBOb3JtYWwgKiBub3JtYWxpemUoICggdmlld01hdHJpeCAqIHZlYzQoIHJlZmxlY3RWZWMsIDAuMCApICkueHl6ICsgdmVjMyggMC4wLDAuMCwxLjAgKSApO1xcblxcdFxcdFxcdCNpZmRlZiBURVhUVVJFX0xPRF9FWFRcXG5cXHRcXHRcXHRcXHR2ZWM0IGVudk1hcENvbG9yID0gdGV4dHVyZTJETG9kRVhUKCBlbnZNYXAsIHJlZmxlY3RWaWV3Lnh5ICogMC41ICsgMC41LCBzcGVjdWxhck1JUExldmVsICk7XFxuXFx0XFx0XFx0I2Vsc2VcXG5cXHRcXHRcXHRcXHR2ZWM0IGVudk1hcENvbG9yID0gdGV4dHVyZTJEKCBlbnZNYXAsIHJlZmxlY3RWaWV3Lnh5ICogMC41ICsgMC41LCBzcGVjdWxhck1JUExldmVsICk7XFxuXFx0XFx0XFx0I2VuZGlmXFxuXFx0XFx0XFx0ZW52TWFwQ29sb3IucmdiID0gZW52TWFwVGV4ZWxUb0xpbmVhciggZW52TWFwQ29sb3IgKS5yZ2I7XFxuXFx0XFx0I2VuZGlmXFxuXFx0XFx0cmV0dXJuIGVudk1hcENvbG9yLnJnYiAqIGVudk1hcEludGVuc2l0eTtcXG5cXHR9XFxuI2VuZGlmXFxuXCI7XG5cbiAgICB2YXIgbGlnaHRzX3Bob25nX2ZyYWdtZW50ID0gXCJCbGlublBob25nTWF0ZXJpYWwgbWF0ZXJpYWw7XFxubWF0ZXJpYWwuZGlmZnVzZUNvbG9yID0gZGlmZnVzZUNvbG9yLnJnYjtcXG5tYXRlcmlhbC5zcGVjdWxhckNvbG9yID0gc3BlY3VsYXI7XFxubWF0ZXJpYWwuc3BlY3VsYXJTaGluaW5lc3MgPSBzaGluaW5lc3M7XFxubWF0ZXJpYWwuc3BlY3VsYXJTdHJlbmd0aCA9IHNwZWN1bGFyU3RyZW5ndGg7XFxuXCI7XG5cbiAgICB2YXIgbGlnaHRzX3Bob25nX3BhcnNfZnJhZ21lbnQgPSBcInZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1xcbiNpZm5kZWYgRkxBVF9TSEFERURcXG5cXHR2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcXG4jZW5kaWZcXG5zdHJ1Y3QgQmxpbm5QaG9uZ01hdGVyaWFsIHtcXG5cXHR2ZWMzXFx0ZGlmZnVzZUNvbG9yO1xcblxcdHZlYzNcXHRzcGVjdWxhckNvbG9yO1xcblxcdGZsb2F0XFx0c3BlY3VsYXJTaGluaW5lc3M7XFxuXFx0ZmxvYXRcXHRzcGVjdWxhclN0cmVuZ3RoO1xcbn07XFxudm9pZCBSRV9EaXJlY3RfQmxpbm5QaG9uZyggY29uc3QgaW4gSW5jaWRlbnRMaWdodCBkaXJlY3RMaWdodCwgY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgY29uc3QgaW4gQmxpbm5QaG9uZ01hdGVyaWFsIG1hdGVyaWFsLCBpbm91dCBSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCApIHtcXG5cXHRmbG9hdCBkb3ROTCA9IHNhdHVyYXRlKCBkb3QoIGdlb21ldHJ5Lm5vcm1hbCwgZGlyZWN0TGlnaHQuZGlyZWN0aW9uICkgKTtcXG5cXHR2ZWMzIGlycmFkaWFuY2UgPSBkb3ROTCAqIGRpcmVjdExpZ2h0LmNvbG9yO1xcblxcdCNpZm5kZWYgUEhZU0lDQUxMWV9DT1JSRUNUX0xJR0hUU1xcblxcdFxcdGlycmFkaWFuY2UgKj0gUEk7XFxuXFx0I2VuZGlmXFxuXFx0cmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSArPSBpcnJhZGlhbmNlICogQlJERl9EaWZmdXNlX0xhbWJlcnQoIG1hdGVyaWFsLmRpZmZ1c2VDb2xvciApO1xcblxcdHJlZmxlY3RlZExpZ2h0LmRpcmVjdFNwZWN1bGFyICs9IGlycmFkaWFuY2UgKiBCUkRGX1NwZWN1bGFyX0JsaW5uUGhvbmcoIGRpcmVjdExpZ2h0LCBnZW9tZXRyeSwgbWF0ZXJpYWwuc3BlY3VsYXJDb2xvciwgbWF0ZXJpYWwuc3BlY3VsYXJTaGluaW5lc3MgKSAqIG1hdGVyaWFsLnNwZWN1bGFyU3RyZW5ndGg7XFxufVxcbnZvaWQgUkVfSW5kaXJlY3REaWZmdXNlX0JsaW5uUGhvbmcoIGNvbnN0IGluIHZlYzMgaXJyYWRpYW5jZSwgY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgY29uc3QgaW4gQmxpbm5QaG9uZ01hdGVyaWFsIG1hdGVyaWFsLCBpbm91dCBSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCApIHtcXG5cXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKz0gaXJyYWRpYW5jZSAqIEJSREZfRGlmZnVzZV9MYW1iZXJ0KCBtYXRlcmlhbC5kaWZmdXNlQ29sb3IgKTtcXG59XFxuI2RlZmluZSBSRV9EaXJlY3RcXHRcXHRcXHRcXHRSRV9EaXJlY3RfQmxpbm5QaG9uZ1xcbiNkZWZpbmUgUkVfSW5kaXJlY3REaWZmdXNlXFx0XFx0UkVfSW5kaXJlY3REaWZmdXNlX0JsaW5uUGhvbmdcXG4jZGVmaW5lIE1hdGVyaWFsX0xpZ2h0UHJvYmVMT0QoIG1hdGVyaWFsIClcXHQoMClcXG5cIjtcblxuICAgIHZhciBsaWdodHNfcGh5c2ljYWxfZnJhZ21lbnQgPSBcIlBoeXNpY2FsTWF0ZXJpYWwgbWF0ZXJpYWw7XFxubWF0ZXJpYWwuZGlmZnVzZUNvbG9yID0gZGlmZnVzZUNvbG9yLnJnYiAqICggMS4wIC0gbWV0YWxuZXNzRmFjdG9yICk7XFxubWF0ZXJpYWwuc3BlY3VsYXJSb3VnaG5lc3MgPSBjbGFtcCggcm91Z2huZXNzRmFjdG9yLCAwLjA0LCAxLjAgKTtcXG4jaWZkZWYgU1RBTkRBUkRcXG5cXHRtYXRlcmlhbC5zcGVjdWxhckNvbG9yID0gbWl4KCB2ZWMzKCBERUZBVUxUX1NQRUNVTEFSX0NPRUZGSUNJRU5UICksIGRpZmZ1c2VDb2xvci5yZ2IsIG1ldGFsbmVzc0ZhY3RvciApO1xcbiNlbHNlXFxuXFx0bWF0ZXJpYWwuc3BlY3VsYXJDb2xvciA9IG1peCggdmVjMyggTUFYSU1VTV9TUEVDVUxBUl9DT0VGRklDSUVOVCAqIHBvdzIoIHJlZmxlY3Rpdml0eSApICksIGRpZmZ1c2VDb2xvci5yZ2IsIG1ldGFsbmVzc0ZhY3RvciApO1xcblxcdG1hdGVyaWFsLmNsZWFyQ29hdCA9IHNhdHVyYXRlKCBjbGVhckNvYXQgKTtcXHRtYXRlcmlhbC5jbGVhckNvYXRSb3VnaG5lc3MgPSBjbGFtcCggY2xlYXJDb2F0Um91Z2huZXNzLCAwLjA0LCAxLjAgKTtcXG4jZW5kaWZcXG5cIjtcblxuICAgIHZhciBsaWdodHNfcGh5c2ljYWxfcGFyc19mcmFnbWVudCA9IFwic3RydWN0IFBoeXNpY2FsTWF0ZXJpYWwge1xcblxcdHZlYzNcXHRkaWZmdXNlQ29sb3I7XFxuXFx0ZmxvYXRcXHRzcGVjdWxhclJvdWdobmVzcztcXG5cXHR2ZWMzXFx0c3BlY3VsYXJDb2xvcjtcXG5cXHQjaWZuZGVmIFNUQU5EQVJEXFxuXFx0XFx0ZmxvYXQgY2xlYXJDb2F0O1xcblxcdFxcdGZsb2F0IGNsZWFyQ29hdFJvdWdobmVzcztcXG5cXHQjZW5kaWZcXG59O1xcbiNkZWZpbmUgTUFYSU1VTV9TUEVDVUxBUl9DT0VGRklDSUVOVCAwLjE2XFxuI2RlZmluZSBERUZBVUxUX1NQRUNVTEFSX0NPRUZGSUNJRU5UIDAuMDRcXG5mbG9hdCBjbGVhckNvYXRESFJBcHByb3goIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcywgY29uc3QgaW4gZmxvYXQgZG90TkwgKSB7XFxuXFx0cmV0dXJuIERFRkFVTFRfU1BFQ1VMQVJfQ09FRkZJQ0lFTlQgKyAoIDEuMCAtIERFRkFVTFRfU1BFQ1VMQVJfQ09FRkZJQ0lFTlQgKSAqICggcG93KCAxLjAgLSBkb3ROTCwgNS4wICkgKiBwb3coIDEuMCAtIHJvdWdobmVzcywgMi4wICkgKTtcXG59XFxudm9pZCBSRV9EaXJlY3RfUGh5c2ljYWwoIGNvbnN0IGluIEluY2lkZW50TGlnaHQgZGlyZWN0TGlnaHQsIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIGNvbnN0IGluIFBoeXNpY2FsTWF0ZXJpYWwgbWF0ZXJpYWwsIGlub3V0IFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ICkge1xcblxcdGZsb2F0IGRvdE5MID0gc2F0dXJhdGUoIGRvdCggZ2VvbWV0cnkubm9ybWFsLCBkaXJlY3RMaWdodC5kaXJlY3Rpb24gKSApO1xcblxcdHZlYzMgaXJyYWRpYW5jZSA9IGRvdE5MICogZGlyZWN0TGlnaHQuY29sb3I7XFxuXFx0I2lmbmRlZiBQSFlTSUNBTExZX0NPUlJFQ1RfTElHSFRTXFxuXFx0XFx0aXJyYWRpYW5jZSAqPSBQSTtcXG5cXHQjZW5kaWZcXG5cXHQjaWZuZGVmIFNUQU5EQVJEXFxuXFx0XFx0ZmxvYXQgY2xlYXJDb2F0REhSID0gbWF0ZXJpYWwuY2xlYXJDb2F0ICogY2xlYXJDb2F0REhSQXBwcm94KCBtYXRlcmlhbC5jbGVhckNvYXRSb3VnaG5lc3MsIGRvdE5MICk7XFxuXFx0I2Vsc2VcXG5cXHRcXHRmbG9hdCBjbGVhckNvYXRESFIgPSAwLjA7XFxuXFx0I2VuZGlmXFxuXFx0cmVmbGVjdGVkTGlnaHQuZGlyZWN0U3BlY3VsYXIgKz0gKCAxLjAgLSBjbGVhckNvYXRESFIgKSAqIGlycmFkaWFuY2UgKiBCUkRGX1NwZWN1bGFyX0dHWCggZGlyZWN0TGlnaHQsIGdlb21ldHJ5LCBtYXRlcmlhbC5zcGVjdWxhckNvbG9yLCBtYXRlcmlhbC5zcGVjdWxhclJvdWdobmVzcyApO1xcblxcdHJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgKz0gKCAxLjAgLSBjbGVhckNvYXRESFIgKSAqIGlycmFkaWFuY2UgKiBCUkRGX0RpZmZ1c2VfTGFtYmVydCggbWF0ZXJpYWwuZGlmZnVzZUNvbG9yICk7XFxuXFx0I2lmbmRlZiBTVEFOREFSRFxcblxcdFxcdHJlZmxlY3RlZExpZ2h0LmRpcmVjdFNwZWN1bGFyICs9IGlycmFkaWFuY2UgKiBtYXRlcmlhbC5jbGVhckNvYXQgKiBCUkRGX1NwZWN1bGFyX0dHWCggZGlyZWN0TGlnaHQsIGdlb21ldHJ5LCB2ZWMzKCBERUZBVUxUX1NQRUNVTEFSX0NPRUZGSUNJRU5UICksIG1hdGVyaWFsLmNsZWFyQ29hdFJvdWdobmVzcyApO1xcblxcdCNlbmRpZlxcbn1cXG52b2lkIFJFX0luZGlyZWN0RGlmZnVzZV9QaHlzaWNhbCggY29uc3QgaW4gdmVjMyBpcnJhZGlhbmNlLCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBjb25zdCBpbiBQaHlzaWNhbE1hdGVyaWFsIG1hdGVyaWFsLCBpbm91dCBSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCApIHtcXG5cXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKz0gaXJyYWRpYW5jZSAqIEJSREZfRGlmZnVzZV9MYW1iZXJ0KCBtYXRlcmlhbC5kaWZmdXNlQ29sb3IgKTtcXG59XFxudm9pZCBSRV9JbmRpcmVjdFNwZWN1bGFyX1BoeXNpY2FsKCBjb25zdCBpbiB2ZWMzIHJhZGlhbmNlLCBjb25zdCBpbiB2ZWMzIGNsZWFyQ29hdFJhZGlhbmNlLCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBjb25zdCBpbiBQaHlzaWNhbE1hdGVyaWFsIG1hdGVyaWFsLCBpbm91dCBSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCApIHtcXG5cXHQjaWZuZGVmIFNUQU5EQVJEXFxuXFx0XFx0ZmxvYXQgZG90TlYgPSBzYXR1cmF0ZSggZG90KCBnZW9tZXRyeS5ub3JtYWwsIGdlb21ldHJ5LnZpZXdEaXIgKSApO1xcblxcdFxcdGZsb2F0IGRvdE5MID0gZG90TlY7XFxuXFx0XFx0ZmxvYXQgY2xlYXJDb2F0REhSID0gbWF0ZXJpYWwuY2xlYXJDb2F0ICogY2xlYXJDb2F0REhSQXBwcm94KCBtYXRlcmlhbC5jbGVhckNvYXRSb3VnaG5lc3MsIGRvdE5MICk7XFxuXFx0I2Vsc2VcXG5cXHRcXHRmbG9hdCBjbGVhckNvYXRESFIgPSAwLjA7XFxuXFx0I2VuZGlmXFxuXFx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3RTcGVjdWxhciArPSAoIDEuMCAtIGNsZWFyQ29hdERIUiApICogcmFkaWFuY2UgKiBCUkRGX1NwZWN1bGFyX0dHWF9FbnZpcm9ubWVudCggZ2VvbWV0cnksIG1hdGVyaWFsLnNwZWN1bGFyQ29sb3IsIG1hdGVyaWFsLnNwZWN1bGFyUm91Z2huZXNzICk7XFxuXFx0I2lmbmRlZiBTVEFOREFSRFxcblxcdFxcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0U3BlY3VsYXIgKz0gY2xlYXJDb2F0UmFkaWFuY2UgKiBtYXRlcmlhbC5jbGVhckNvYXQgKiBCUkRGX1NwZWN1bGFyX0dHWF9FbnZpcm9ubWVudCggZ2VvbWV0cnksIHZlYzMoIERFRkFVTFRfU1BFQ1VMQVJfQ09FRkZJQ0lFTlQgKSwgbWF0ZXJpYWwuY2xlYXJDb2F0Um91Z2huZXNzICk7XFxuXFx0I2VuZGlmXFxufVxcbiNkZWZpbmUgUkVfRGlyZWN0XFx0XFx0XFx0XFx0UkVfRGlyZWN0X1BoeXNpY2FsXFxuI2RlZmluZSBSRV9JbmRpcmVjdERpZmZ1c2VcXHRcXHRSRV9JbmRpcmVjdERpZmZ1c2VfUGh5c2ljYWxcXG4jZGVmaW5lIFJFX0luZGlyZWN0U3BlY3VsYXJcXHRcXHRSRV9JbmRpcmVjdFNwZWN1bGFyX1BoeXNpY2FsXFxuI2RlZmluZSBNYXRlcmlhbF9CbGlublNoaW5pbmVzc0V4cG9uZW50KCBtYXRlcmlhbCApICAgR0dYUm91Z2huZXNzVG9CbGlubkV4cG9uZW50KCBtYXRlcmlhbC5zcGVjdWxhclJvdWdobmVzcyApXFxuI2RlZmluZSBNYXRlcmlhbF9DbGVhckNvYXRfQmxpbm5TaGluaW5lc3NFeHBvbmVudCggbWF0ZXJpYWwgKSAgIEdHWFJvdWdobmVzc1RvQmxpbm5FeHBvbmVudCggbWF0ZXJpYWwuY2xlYXJDb2F0Um91Z2huZXNzIClcXG5mbG9hdCBjb21wdXRlU3BlY3VsYXJPY2NsdXNpb24oIGNvbnN0IGluIGZsb2F0IGRvdE5WLCBjb25zdCBpbiBmbG9hdCBhbWJpZW50T2NjbHVzaW9uLCBjb25zdCBpbiBmbG9hdCByb3VnaG5lc3MgKSB7XFxuXFx0cmV0dXJuIHNhdHVyYXRlKCBwb3coIGRvdE5WICsgYW1iaWVudE9jY2x1c2lvbiwgZXhwMiggLSAxNi4wICogcm91Z2huZXNzIC0gMS4wICkgKSAtIDEuMCArIGFtYmllbnRPY2NsdXNpb24gKTtcXG59XFxuXCI7XG5cbiAgICB2YXIgbGlnaHRzX3RlbXBsYXRlID0gXCJcXG5HZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5O1xcbmdlb21ldHJ5LnBvc2l0aW9uID0gLSB2Vmlld1Bvc2l0aW9uO1xcbmdlb21ldHJ5Lm5vcm1hbCA9IG5vcm1hbDtcXG5nZW9tZXRyeS52aWV3RGlyID0gbm9ybWFsaXplKCB2Vmlld1Bvc2l0aW9uICk7XFxuSW5jaWRlbnRMaWdodCBkaXJlY3RMaWdodDtcXG4jaWYgKCBOVU1fUE9JTlRfTElHSFRTID4gMCApICYmIGRlZmluZWQoIFJFX0RpcmVjdCApXFxuXFx0UG9pbnRMaWdodCBwb2ludExpZ2h0O1xcblxcdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9QT0lOVF9MSUdIVFM7IGkgKysgKSB7XFxuXFx0XFx0cG9pbnRMaWdodCA9IHBvaW50TGlnaHRzWyBpIF07XFxuXFx0XFx0Z2V0UG9pbnREaXJlY3RMaWdodElycmFkaWFuY2UoIHBvaW50TGlnaHQsIGdlb21ldHJ5LCBkaXJlY3RMaWdodCApO1xcblxcdFxcdCNpZmRlZiBVU0VfU0hBRE9XTUFQXFxuXFx0XFx0ZGlyZWN0TGlnaHQuY29sb3IgKj0gYWxsKCBidmVjMiggcG9pbnRMaWdodC5zaGFkb3csIGRpcmVjdExpZ2h0LnZpc2libGUgKSApID8gZ2V0UG9pbnRTaGFkb3coIHBvaW50U2hhZG93TWFwWyBpIF0sIHBvaW50TGlnaHQuc2hhZG93TWFwU2l6ZSwgcG9pbnRMaWdodC5zaGFkb3dCaWFzLCBwb2ludExpZ2h0LnNoYWRvd1JhZGl1cywgdlBvaW50U2hhZG93Q29vcmRbIGkgXSApIDogMS4wO1xcblxcdFxcdCNlbmRpZlxcblxcdFxcdFJFX0RpcmVjdCggZGlyZWN0TGlnaHQsIGdlb21ldHJ5LCBtYXRlcmlhbCwgcmVmbGVjdGVkTGlnaHQgKTtcXG5cXHR9XFxuI2VuZGlmXFxuI2lmICggTlVNX1NQT1RfTElHSFRTID4gMCApICYmIGRlZmluZWQoIFJFX0RpcmVjdCApXFxuXFx0U3BvdExpZ2h0IHNwb3RMaWdodDtcXG5cXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fU1BPVF9MSUdIVFM7IGkgKysgKSB7XFxuXFx0XFx0c3BvdExpZ2h0ID0gc3BvdExpZ2h0c1sgaSBdO1xcblxcdFxcdGdldFNwb3REaXJlY3RMaWdodElycmFkaWFuY2UoIHNwb3RMaWdodCwgZ2VvbWV0cnksIGRpcmVjdExpZ2h0ICk7XFxuXFx0XFx0I2lmZGVmIFVTRV9TSEFET1dNQVBcXG5cXHRcXHRkaXJlY3RMaWdodC5jb2xvciAqPSBhbGwoIGJ2ZWMyKCBzcG90TGlnaHQuc2hhZG93LCBkaXJlY3RMaWdodC52aXNpYmxlICkgKSA/IGdldFNoYWRvdyggc3BvdFNoYWRvd01hcFsgaSBdLCBzcG90TGlnaHQuc2hhZG93TWFwU2l6ZSwgc3BvdExpZ2h0LnNoYWRvd0JpYXMsIHNwb3RMaWdodC5zaGFkb3dSYWRpdXMsIHZTcG90U2hhZG93Q29vcmRbIGkgXSApIDogMS4wO1xcblxcdFxcdCNlbmRpZlxcblxcdFxcdFJFX0RpcmVjdCggZGlyZWN0TGlnaHQsIGdlb21ldHJ5LCBtYXRlcmlhbCwgcmVmbGVjdGVkTGlnaHQgKTtcXG5cXHR9XFxuI2VuZGlmXFxuI2lmICggTlVNX0RJUl9MSUdIVFMgPiAwICkgJiYgZGVmaW5lZCggUkVfRGlyZWN0IClcXG5cXHREaXJlY3Rpb25hbExpZ2h0IGRpcmVjdGlvbmFsTGlnaHQ7XFxuXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX0RJUl9MSUdIVFM7IGkgKysgKSB7XFxuXFx0XFx0ZGlyZWN0aW9uYWxMaWdodCA9IGRpcmVjdGlvbmFsTGlnaHRzWyBpIF07XFxuXFx0XFx0Z2V0RGlyZWN0aW9uYWxEaXJlY3RMaWdodElycmFkaWFuY2UoIGRpcmVjdGlvbmFsTGlnaHQsIGdlb21ldHJ5LCBkaXJlY3RMaWdodCApO1xcblxcdFxcdCNpZmRlZiBVU0VfU0hBRE9XTUFQXFxuXFx0XFx0ZGlyZWN0TGlnaHQuY29sb3IgKj0gYWxsKCBidmVjMiggZGlyZWN0aW9uYWxMaWdodC5zaGFkb3csIGRpcmVjdExpZ2h0LnZpc2libGUgKSApID8gZ2V0U2hhZG93KCBkaXJlY3Rpb25hbFNoYWRvd01hcFsgaSBdLCBkaXJlY3Rpb25hbExpZ2h0LnNoYWRvd01hcFNpemUsIGRpcmVjdGlvbmFsTGlnaHQuc2hhZG93QmlhcywgZGlyZWN0aW9uYWxMaWdodC5zaGFkb3dSYWRpdXMsIHZEaXJlY3Rpb25hbFNoYWRvd0Nvb3JkWyBpIF0gKSA6IDEuMDtcXG5cXHRcXHQjZW5kaWZcXG5cXHRcXHRSRV9EaXJlY3QoIGRpcmVjdExpZ2h0LCBnZW9tZXRyeSwgbWF0ZXJpYWwsIHJlZmxlY3RlZExpZ2h0ICk7XFxuXFx0fVxcbiNlbmRpZlxcbiNpZiBkZWZpbmVkKCBSRV9JbmRpcmVjdERpZmZ1c2UgKVxcblxcdHZlYzMgaXJyYWRpYW5jZSA9IGdldEFtYmllbnRMaWdodElycmFkaWFuY2UoIGFtYmllbnRMaWdodENvbG9yICk7XFxuXFx0I2lmZGVmIFVTRV9MSUdIVE1BUFxcblxcdFxcdHZlYzMgbGlnaHRNYXBJcnJhZGlhbmNlID0gdGV4dHVyZTJEKCBsaWdodE1hcCwgdlV2MiApLnh5eiAqIGxpZ2h0TWFwSW50ZW5zaXR5O1xcblxcdFxcdCNpZm5kZWYgUEhZU0lDQUxMWV9DT1JSRUNUX0xJR0hUU1xcblxcdFxcdFxcdGxpZ2h0TWFwSXJyYWRpYW5jZSAqPSBQSTtcXG5cXHRcXHQjZW5kaWZcXG5cXHRcXHRpcnJhZGlhbmNlICs9IGxpZ2h0TWFwSXJyYWRpYW5jZTtcXG5cXHQjZW5kaWZcXG5cXHQjaWYgKCBOVU1fSEVNSV9MSUdIVFMgPiAwIClcXG5cXHRcXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fSEVNSV9MSUdIVFM7IGkgKysgKSB7XFxuXFx0XFx0XFx0aXJyYWRpYW5jZSArPSBnZXRIZW1pc3BoZXJlTGlnaHRJcnJhZGlhbmNlKCBoZW1pc3BoZXJlTGlnaHRzWyBpIF0sIGdlb21ldHJ5ICk7XFxuXFx0XFx0fVxcblxcdCNlbmRpZlxcblxcdCNpZiBkZWZpbmVkKCBVU0VfRU5WTUFQICkgJiYgZGVmaW5lZCggUEhZU0lDQUwgKSAmJiBkZWZpbmVkKCBFTlZNQVBfVFlQRV9DVUJFX1VWIClcXG5cXHQgXFx0aXJyYWRpYW5jZSArPSBnZXRMaWdodFByb2JlSW5kaXJlY3RJcnJhZGlhbmNlKCBnZW9tZXRyeSwgOCApO1xcblxcdCNlbmRpZlxcblxcdFJFX0luZGlyZWN0RGlmZnVzZSggaXJyYWRpYW5jZSwgZ2VvbWV0cnksIG1hdGVyaWFsLCByZWZsZWN0ZWRMaWdodCApO1xcbiNlbmRpZlxcbiNpZiBkZWZpbmVkKCBVU0VfRU5WTUFQICkgJiYgZGVmaW5lZCggUkVfSW5kaXJlY3RTcGVjdWxhciApXFxuXFx0dmVjMyByYWRpYW5jZSA9IGdldExpZ2h0UHJvYmVJbmRpcmVjdFJhZGlhbmNlKCBnZW9tZXRyeSwgTWF0ZXJpYWxfQmxpbm5TaGluaW5lc3NFeHBvbmVudCggbWF0ZXJpYWwgKSwgOCApO1xcblxcdCNpZm5kZWYgU1RBTkRBUkRcXG5cXHRcXHR2ZWMzIGNsZWFyQ29hdFJhZGlhbmNlID0gZ2V0TGlnaHRQcm9iZUluZGlyZWN0UmFkaWFuY2UoIGdlb21ldHJ5LCBNYXRlcmlhbF9DbGVhckNvYXRfQmxpbm5TaGluaW5lc3NFeHBvbmVudCggbWF0ZXJpYWwgKSwgOCApO1xcblxcdCNlbHNlXFxuXFx0XFx0dmVjMyBjbGVhckNvYXRSYWRpYW5jZSA9IHZlYzMoIDAuMCApO1xcblxcdCNlbmRpZlxcblxcdFxcdFxcblxcdFJFX0luZGlyZWN0U3BlY3VsYXIoIHJhZGlhbmNlLCBjbGVhckNvYXRSYWRpYW5jZSwgZ2VvbWV0cnksIG1hdGVyaWFsLCByZWZsZWN0ZWRMaWdodCApO1xcbiNlbmRpZlxcblwiO1xuXG4gICAgdmFyIGxvZ2RlcHRoYnVmX2ZyYWdtZW50ID0gXCIjaWYgZGVmaW5lZChVU0VfTE9HREVQVEhCVUYpICYmIGRlZmluZWQoVVNFX0xPR0RFUFRIQlVGX0VYVClcXG5cXHRnbF9GcmFnRGVwdGhFWFQgPSBsb2cyKHZGcmFnRGVwdGgpICogbG9nRGVwdGhCdWZGQyAqIDAuNTtcXG4jZW5kaWZcIjtcblxuICAgIHZhciBsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX0xPR0RFUFRIQlVGXFxuXFx0dW5pZm9ybSBmbG9hdCBsb2dEZXB0aEJ1ZkZDO1xcblxcdCNpZmRlZiBVU0VfTE9HREVQVEhCVUZfRVhUXFxuXFx0XFx0dmFyeWluZyBmbG9hdCB2RnJhZ0RlcHRoO1xcblxcdCNlbmRpZlxcbiNlbmRpZlxcblwiO1xuXG4gICAgdmFyIGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4ID0gXCIjaWZkZWYgVVNFX0xPR0RFUFRIQlVGXFxuXFx0I2lmZGVmIFVTRV9MT0dERVBUSEJVRl9FWFRcXG5cXHRcXHR2YXJ5aW5nIGZsb2F0IHZGcmFnRGVwdGg7XFxuXFx0I2VuZGlmXFxuXFx0dW5pZm9ybSBmbG9hdCBsb2dEZXB0aEJ1ZkZDO1xcbiNlbmRpZlwiO1xuXG4gICAgdmFyIGxvZ2RlcHRoYnVmX3ZlcnRleCA9IFwiI2lmZGVmIFVTRV9MT0dERVBUSEJVRlxcblxcdGdsX1Bvc2l0aW9uLnogPSBsb2cyKG1heCggRVBTSUxPTiwgZ2xfUG9zaXRpb24udyArIDEuMCApKSAqIGxvZ0RlcHRoQnVmRkM7XFxuXFx0I2lmZGVmIFVTRV9MT0dERVBUSEJVRl9FWFRcXG5cXHRcXHR2RnJhZ0RlcHRoID0gMS4wICsgZ2xfUG9zaXRpb24udztcXG5cXHQjZWxzZVxcblxcdFxcdGdsX1Bvc2l0aW9uLnogPSAoZ2xfUG9zaXRpb24ueiAtIDEuMCkgKiBnbF9Qb3NpdGlvbi53O1xcblxcdCNlbmRpZlxcbiNlbmRpZlxcblwiO1xuXG4gICAgdmFyIG1hcF9mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9NQVBcXG5cXHR2ZWM0IHRleGVsQ29sb3IgPSB0ZXh0dXJlMkQoIG1hcCwgdlV2ICk7XFxuXFx0dGV4ZWxDb2xvciA9IG1hcFRleGVsVG9MaW5lYXIoIHRleGVsQ29sb3IgKTtcXG5cXHRkaWZmdXNlQ29sb3IgKj0gdGV4ZWxDb2xvcjtcXG4jZW5kaWZcXG5cIjtcblxuICAgIHZhciBtYXBfcGFyc19mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9NQVBcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBtYXA7XFxuI2VuZGlmXFxuXCI7XG5cbiAgICB2YXIgbWFwX3BhcnRpY2xlX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX01BUFxcblxcdHZlYzQgbWFwVGV4ZWwgPSB0ZXh0dXJlMkQoIG1hcCwgdmVjMiggZ2xfUG9pbnRDb29yZC54LCAxLjAgLSBnbF9Qb2ludENvb3JkLnkgKSAqIG9mZnNldFJlcGVhdC56dyArIG9mZnNldFJlcGVhdC54eSApO1xcblxcdGRpZmZ1c2VDb2xvciAqPSBtYXBUZXhlbFRvTGluZWFyKCBtYXBUZXhlbCApO1xcbiNlbmRpZlxcblwiO1xuXG4gICAgdmFyIG1hcF9wYXJ0aWNsZV9wYXJzX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX01BUFxcblxcdHVuaWZvcm0gdmVjNCBvZmZzZXRSZXBlYXQ7XFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgbWFwO1xcbiNlbmRpZlxcblwiO1xuXG4gICAgdmFyIG1ldGFsbmVzc21hcF9mcmFnbWVudCA9IFwiZmxvYXQgbWV0YWxuZXNzRmFjdG9yID0gbWV0YWxuZXNzO1xcbiNpZmRlZiBVU0VfTUVUQUxORVNTTUFQXFxuXFx0dmVjNCB0ZXhlbE1ldGFsbmVzcyA9IHRleHR1cmUyRCggbWV0YWxuZXNzTWFwLCB2VXYgKTtcXG5cXHRtZXRhbG5lc3NGYWN0b3IgKj0gdGV4ZWxNZXRhbG5lc3MucjtcXG4jZW5kaWZcXG5cIjtcblxuICAgIHZhciBtZXRhbG5lc3NtYXBfcGFyc19mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9NRVRBTE5FU1NNQVBcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBtZXRhbG5lc3NNYXA7XFxuI2VuZGlmXCI7XG5cbiAgICB2YXIgbW9ycGhub3JtYWxfdmVydGV4ID0gXCIjaWZkZWYgVVNFX01PUlBITk9STUFMU1xcblxcdG9iamVjdE5vcm1hbCArPSAoIG1vcnBoTm9ybWFsMCAtIG5vcm1hbCApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAwIF07XFxuXFx0b2JqZWN0Tm9ybWFsICs9ICggbW9ycGhOb3JtYWwxIC0gbm9ybWFsICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDEgXTtcXG5cXHRvYmplY3ROb3JtYWwgKz0gKCBtb3JwaE5vcm1hbDIgLSBub3JtYWwgKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMiBdO1xcblxcdG9iamVjdE5vcm1hbCArPSAoIG1vcnBoTm9ybWFsMyAtIG5vcm1hbCApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAzIF07XFxuI2VuZGlmXFxuXCI7XG5cbiAgICB2YXIgbW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXggPSBcIiNpZmRlZiBVU0VfTU9SUEhUQVJHRVRTXFxuXFx0I2lmbmRlZiBVU0VfTU9SUEhOT1JNQUxTXFxuXFx0dW5pZm9ybSBmbG9hdCBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDggXTtcXG5cXHQjZWxzZVxcblxcdHVuaWZvcm0gZmxvYXQgbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyA0IF07XFxuXFx0I2VuZGlmXFxuI2VuZGlmXCI7XG5cbiAgICB2YXIgbW9ycGh0YXJnZXRfdmVydGV4ID0gXCIjaWZkZWYgVVNFX01PUlBIVEFSR0VUU1xcblxcdHRyYW5zZm9ybWVkICs9ICggbW9ycGhUYXJnZXQwIC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMCBdO1xcblxcdHRyYW5zZm9ybWVkICs9ICggbW9ycGhUYXJnZXQxIC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMSBdO1xcblxcdHRyYW5zZm9ybWVkICs9ICggbW9ycGhUYXJnZXQyIC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMiBdO1xcblxcdHRyYW5zZm9ybWVkICs9ICggbW9ycGhUYXJnZXQzIC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMyBdO1xcblxcdCNpZm5kZWYgVVNFX01PUlBITk9STUFMU1xcblxcdHRyYW5zZm9ybWVkICs9ICggbW9ycGhUYXJnZXQ0IC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgNCBdO1xcblxcdHRyYW5zZm9ybWVkICs9ICggbW9ycGhUYXJnZXQ1IC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgNSBdO1xcblxcdHRyYW5zZm9ybWVkICs9ICggbW9ycGhUYXJnZXQ2IC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgNiBdO1xcblxcdHRyYW5zZm9ybWVkICs9ICggbW9ycGhUYXJnZXQ3IC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgNyBdO1xcblxcdCNlbmRpZlxcbiNlbmRpZlxcblwiO1xuXG4gICAgdmFyIG5vcm1hbF9mbGlwID0gXCIjaWZkZWYgRE9VQkxFX1NJREVEXFxuXFx0ZmxvYXQgZmxpcE5vcm1hbCA9ICggZmxvYXQoIGdsX0Zyb250RmFjaW5nICkgKiAyLjAgLSAxLjAgKTtcXG4jZWxzZVxcblxcdGZsb2F0IGZsaXBOb3JtYWwgPSAxLjA7XFxuI2VuZGlmXFxuXCI7XG5cbiAgICB2YXIgbm9ybWFsX2ZyYWdtZW50ID0gXCIjaWZkZWYgRkxBVF9TSEFERURcXG5cXHR2ZWMzIGZkeCA9IHZlYzMoIGRGZHgoIHZWaWV3UG9zaXRpb24ueCApLCBkRmR4KCB2Vmlld1Bvc2l0aW9uLnkgKSwgZEZkeCggdlZpZXdQb3NpdGlvbi56ICkgKTtcXG5cXHR2ZWMzIGZkeSA9IHZlYzMoIGRGZHkoIHZWaWV3UG9zaXRpb24ueCApLCBkRmR5KCB2Vmlld1Bvc2l0aW9uLnkgKSwgZEZkeSggdlZpZXdQb3NpdGlvbi56ICkgKTtcXG5cXHR2ZWMzIG5vcm1hbCA9IG5vcm1hbGl6ZSggY3Jvc3MoIGZkeCwgZmR5ICkgKTtcXG4jZWxzZVxcblxcdHZlYzMgbm9ybWFsID0gbm9ybWFsaXplKCB2Tm9ybWFsICkgKiBmbGlwTm9ybWFsO1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfTk9STUFMTUFQXFxuXFx0bm9ybWFsID0gcGVydHVyYk5vcm1hbDJBcmIoIC12Vmlld1Bvc2l0aW9uLCBub3JtYWwgKTtcXG4jZWxpZiBkZWZpbmVkKCBVU0VfQlVNUE1BUCApXFxuXFx0bm9ybWFsID0gcGVydHVyYk5vcm1hbEFyYiggLXZWaWV3UG9zaXRpb24sIG5vcm1hbCwgZEhkeHlfZndkKCkgKTtcXG4jZW5kaWZcXG5cIjtcblxuICAgIHZhciBub3JtYWxtYXBfcGFyc19mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9OT1JNQUxNQVBcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBub3JtYWxNYXA7XFxuXFx0dW5pZm9ybSB2ZWMyIG5vcm1hbFNjYWxlO1xcblxcdHZlYzMgcGVydHVyYk5vcm1hbDJBcmIoIHZlYzMgZXllX3BvcywgdmVjMyBzdXJmX25vcm0gKSB7XFxuXFx0XFx0dmVjMyBxMCA9IGRGZHgoIGV5ZV9wb3MueHl6ICk7XFxuXFx0XFx0dmVjMyBxMSA9IGRGZHkoIGV5ZV9wb3MueHl6ICk7XFxuXFx0XFx0dmVjMiBzdDAgPSBkRmR4KCB2VXYuc3QgKTtcXG5cXHRcXHR2ZWMyIHN0MSA9IGRGZHkoIHZVdi5zdCApO1xcblxcdFxcdHZlYzMgUyA9IG5vcm1hbGl6ZSggcTAgKiBzdDEudCAtIHExICogc3QwLnQgKTtcXG5cXHRcXHR2ZWMzIFQgPSBub3JtYWxpemUoIC1xMCAqIHN0MS5zICsgcTEgKiBzdDAucyApO1xcblxcdFxcdHZlYzMgTiA9IG5vcm1hbGl6ZSggc3VyZl9ub3JtICk7XFxuXFx0XFx0dmVjMyBtYXBOID0gdGV4dHVyZTJEKCBub3JtYWxNYXAsIHZVdiApLnh5eiAqIDIuMCAtIDEuMDtcXG5cXHRcXHRtYXBOLnh5ID0gbm9ybWFsU2NhbGUgKiBtYXBOLnh5O1xcblxcdFxcdG1hdDMgdHNuID0gbWF0MyggUywgVCwgTiApO1xcblxcdFxcdHJldHVybiBub3JtYWxpemUoIHRzbiAqIG1hcE4gKTtcXG5cXHR9XFxuI2VuZGlmXFxuXCI7XG5cbiAgICB2YXIgcGFja2luZyA9IFwidmVjMyBwYWNrTm9ybWFsVG9SR0IoIGNvbnN0IGluIHZlYzMgbm9ybWFsICkge1xcbiAgcmV0dXJuIG5vcm1hbGl6ZSggbm9ybWFsICkgKiAwLjUgKyAwLjU7XFxufVxcbnZlYzMgdW5wYWNrUkdCVG9Ob3JtYWwoIGNvbnN0IGluIHZlYzMgcmdiICkge1xcbiAgcmV0dXJuIDEuMCAtIDIuMCAqIHJnYi54eXo7XFxufVxcbmNvbnN0IGZsb2F0IFBhY2tVcHNjYWxlID0gMjU2LiAvIDI1NS47Y29uc3QgZmxvYXQgVW5wYWNrRG93bnNjYWxlID0gMjU1LiAvIDI1Ni47XFxuY29uc3QgdmVjMyBQYWNrRmFjdG9ycyA9IHZlYzMoIDI1Ni4gKiAyNTYuICogMjU2LiwgMjU2LiAqIDI1Ni4sICAyNTYuICk7XFxuY29uc3QgdmVjNCBVbnBhY2tGYWN0b3JzID0gVW5wYWNrRG93bnNjYWxlIC8gdmVjNCggUGFja0ZhY3RvcnMsIDEuICk7XFxuY29uc3QgZmxvYXQgU2hpZnRSaWdodDggPSAxLiAvIDI1Ni47XFxudmVjNCBwYWNrRGVwdGhUb1JHQkEoIGNvbnN0IGluIGZsb2F0IHYgKSB7XFxuXFx0dmVjNCByID0gdmVjNCggZnJhY3QoIHYgKiBQYWNrRmFjdG9ycyApLCB2ICk7XFxuXFx0ci55encgLT0gci54eXogKiBTaGlmdFJpZ2h0ODtcXHRyZXR1cm4gciAqIFBhY2tVcHNjYWxlO1xcbn1cXG5mbG9hdCB1bnBhY2tSR0JBVG9EZXB0aCggY29uc3QgaW4gdmVjNCB2ICkge1xcblxcdHJldHVybiBkb3QoIHYsIFVucGFja0ZhY3RvcnMgKTtcXG59XFxuZmxvYXQgdmlld1pUb09ydGhvZ3JhcGhpY0RlcHRoKCBjb25zdCBpbiBmbG9hdCB2aWV3WiwgY29uc3QgaW4gZmxvYXQgbmVhciwgY29uc3QgaW4gZmxvYXQgZmFyICkge1xcbiAgcmV0dXJuICggdmlld1ogKyBuZWFyICkgLyAoIG5lYXIgLSBmYXIgKTtcXG59XFxuZmxvYXQgb3J0aG9ncmFwaGljRGVwdGhUb1ZpZXdaKCBjb25zdCBpbiBmbG9hdCBsaW5lYXJDbGlwWiwgY29uc3QgaW4gZmxvYXQgbmVhciwgY29uc3QgaW4gZmxvYXQgZmFyICkge1xcbiAgcmV0dXJuIGxpbmVhckNsaXBaICogKCBuZWFyIC0gZmFyICkgLSBuZWFyO1xcbn1cXG5mbG9hdCB2aWV3WlRvUGVyc3BlY3RpdmVEZXB0aCggY29uc3QgaW4gZmxvYXQgdmlld1osIGNvbnN0IGluIGZsb2F0IG5lYXIsIGNvbnN0IGluIGZsb2F0IGZhciApIHtcXG4gIHJldHVybiAoKCBuZWFyICsgdmlld1ogKSAqIGZhciApIC8gKCggZmFyIC0gbmVhciApICogdmlld1ogKTtcXG59XFxuZmxvYXQgcGVyc3BlY3RpdmVEZXB0aFRvVmlld1ooIGNvbnN0IGluIGZsb2F0IGludkNsaXBaLCBjb25zdCBpbiBmbG9hdCBuZWFyLCBjb25zdCBpbiBmbG9hdCBmYXIgKSB7XFxuICByZXR1cm4gKCBuZWFyICogZmFyICkgLyAoICggZmFyIC0gbmVhciApICogaW52Q2xpcFogLSBmYXIgKTtcXG59XFxuXCI7XG5cbiAgICB2YXIgcHJlbXVsdGlwbGllZF9hbHBoYV9mcmFnbWVudCA9IFwiI2lmZGVmIFBSRU1VTFRJUExJRURfQUxQSEFcXG5cXHRnbF9GcmFnQ29sb3IucmdiICo9IGdsX0ZyYWdDb2xvci5hO1xcbiNlbmRpZlxcblwiO1xuXG4gICAgdmFyIHByb2plY3RfdmVydGV4ID0gXCIjaWZkZWYgVVNFX1NLSU5OSU5HXFxuXFx0dmVjNCBtdlBvc2l0aW9uID0gbW9kZWxWaWV3TWF0cml4ICogc2tpbm5lZDtcXG4jZWxzZVxcblxcdHZlYzQgbXZQb3NpdGlvbiA9IG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHRyYW5zZm9ybWVkLCAxLjAgKTtcXG4jZW5kaWZcXG5nbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtdlBvc2l0aW9uO1xcblwiO1xuXG4gICAgdmFyIHJvdWdobmVzc21hcF9mcmFnbWVudCA9IFwiZmxvYXQgcm91Z2huZXNzRmFjdG9yID0gcm91Z2huZXNzO1xcbiNpZmRlZiBVU0VfUk9VR0hORVNTTUFQXFxuXFx0dmVjNCB0ZXhlbFJvdWdobmVzcyA9IHRleHR1cmUyRCggcm91Z2huZXNzTWFwLCB2VXYgKTtcXG5cXHRyb3VnaG5lc3NGYWN0b3IgKj0gdGV4ZWxSb3VnaG5lc3MucjtcXG4jZW5kaWZcXG5cIjtcblxuICAgIHZhciByb3VnaG5lc3NtYXBfcGFyc19mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9ST1VHSE5FU1NNQVBcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCByb3VnaG5lc3NNYXA7XFxuI2VuZGlmXCI7XG5cbiAgICB2YXIgc2hhZG93bWFwX3BhcnNfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfU0hBRE9XTUFQXFxuXFx0I2lmIE5VTV9ESVJfTElHSFRTID4gMFxcblxcdFxcdHVuaWZvcm0gc2FtcGxlcjJEIGRpcmVjdGlvbmFsU2hhZG93TWFwWyBOVU1fRElSX0xJR0hUUyBdO1xcblxcdFxcdHZhcnlpbmcgdmVjNCB2RGlyZWN0aW9uYWxTaGFkb3dDb29yZFsgTlVNX0RJUl9MSUdIVFMgXTtcXG5cXHQjZW5kaWZcXG5cXHQjaWYgTlVNX1NQT1RfTElHSFRTID4gMFxcblxcdFxcdHVuaWZvcm0gc2FtcGxlcjJEIHNwb3RTaGFkb3dNYXBbIE5VTV9TUE9UX0xJR0hUUyBdO1xcblxcdFxcdHZhcnlpbmcgdmVjNCB2U3BvdFNoYWRvd0Nvb3JkWyBOVU1fU1BPVF9MSUdIVFMgXTtcXG5cXHQjZW5kaWZcXG5cXHQjaWYgTlVNX1BPSU5UX0xJR0hUUyA+IDBcXG5cXHRcXHR1bmlmb3JtIHNhbXBsZXIyRCBwb2ludFNoYWRvd01hcFsgTlVNX1BPSU5UX0xJR0hUUyBdO1xcblxcdFxcdHZhcnlpbmcgdmVjNCB2UG9pbnRTaGFkb3dDb29yZFsgTlVNX1BPSU5UX0xJR0hUUyBdO1xcblxcdCNlbmRpZlxcblxcdGZsb2F0IHRleHR1cmUyRENvbXBhcmUoIHNhbXBsZXIyRCBkZXB0aHMsIHZlYzIgdXYsIGZsb2F0IGNvbXBhcmUgKSB7XFxuXFx0XFx0cmV0dXJuIHN0ZXAoIGNvbXBhcmUsIHVucGFja1JHQkFUb0RlcHRoKCB0ZXh0dXJlMkQoIGRlcHRocywgdXYgKSApICk7XFxuXFx0fVxcblxcdGZsb2F0IHRleHR1cmUyRFNoYWRvd0xlcnAoIHNhbXBsZXIyRCBkZXB0aHMsIHZlYzIgc2l6ZSwgdmVjMiB1diwgZmxvYXQgY29tcGFyZSApIHtcXG5cXHRcXHRjb25zdCB2ZWMyIG9mZnNldCA9IHZlYzIoIDAuMCwgMS4wICk7XFxuXFx0XFx0dmVjMiB0ZXhlbFNpemUgPSB2ZWMyKCAxLjAgKSAvIHNpemU7XFxuXFx0XFx0dmVjMiBjZW50cm9pZFVWID0gZmxvb3IoIHV2ICogc2l6ZSArIDAuNSApIC8gc2l6ZTtcXG5cXHRcXHRmbG9hdCBsYiA9IHRleHR1cmUyRENvbXBhcmUoIGRlcHRocywgY2VudHJvaWRVViArIHRleGVsU2l6ZSAqIG9mZnNldC54eCwgY29tcGFyZSApO1xcblxcdFxcdGZsb2F0IGx0ID0gdGV4dHVyZTJEQ29tcGFyZSggZGVwdGhzLCBjZW50cm9pZFVWICsgdGV4ZWxTaXplICogb2Zmc2V0Lnh5LCBjb21wYXJlICk7XFxuXFx0XFx0ZmxvYXQgcmIgPSB0ZXh0dXJlMkRDb21wYXJlKCBkZXB0aHMsIGNlbnRyb2lkVVYgKyB0ZXhlbFNpemUgKiBvZmZzZXQueXgsIGNvbXBhcmUgKTtcXG5cXHRcXHRmbG9hdCBydCA9IHRleHR1cmUyRENvbXBhcmUoIGRlcHRocywgY2VudHJvaWRVViArIHRleGVsU2l6ZSAqIG9mZnNldC55eSwgY29tcGFyZSApO1xcblxcdFxcdHZlYzIgZiA9IGZyYWN0KCB1diAqIHNpemUgKyAwLjUgKTtcXG5cXHRcXHRmbG9hdCBhID0gbWl4KCBsYiwgbHQsIGYueSApO1xcblxcdFxcdGZsb2F0IGIgPSBtaXgoIHJiLCBydCwgZi55ICk7XFxuXFx0XFx0ZmxvYXQgYyA9IG1peCggYSwgYiwgZi54ICk7XFxuXFx0XFx0cmV0dXJuIGM7XFxuXFx0fVxcblxcdGZsb2F0IGdldFNoYWRvdyggc2FtcGxlcjJEIHNoYWRvd01hcCwgdmVjMiBzaGFkb3dNYXBTaXplLCBmbG9hdCBzaGFkb3dCaWFzLCBmbG9hdCBzaGFkb3dSYWRpdXMsIHZlYzQgc2hhZG93Q29vcmQgKSB7XFxuXFx0XFx0c2hhZG93Q29vcmQueHl6IC89IHNoYWRvd0Nvb3JkLnc7XFxuXFx0XFx0c2hhZG93Q29vcmQueiArPSBzaGFkb3dCaWFzO1xcblxcdFxcdGJ2ZWM0IGluRnJ1c3R1bVZlYyA9IGJ2ZWM0ICggc2hhZG93Q29vcmQueCA+PSAwLjAsIHNoYWRvd0Nvb3JkLnggPD0gMS4wLCBzaGFkb3dDb29yZC55ID49IDAuMCwgc2hhZG93Q29vcmQueSA8PSAxLjAgKTtcXG5cXHRcXHRib29sIGluRnJ1c3R1bSA9IGFsbCggaW5GcnVzdHVtVmVjICk7XFxuXFx0XFx0YnZlYzIgZnJ1c3R1bVRlc3RWZWMgPSBidmVjMiggaW5GcnVzdHVtLCBzaGFkb3dDb29yZC56IDw9IDEuMCApO1xcblxcdFxcdGJvb2wgZnJ1c3R1bVRlc3QgPSBhbGwoIGZydXN0dW1UZXN0VmVjICk7XFxuXFx0XFx0aWYgKCBmcnVzdHVtVGVzdCApIHtcXG5cXHRcXHQjaWYgZGVmaW5lZCggU0hBRE9XTUFQX1RZUEVfUENGIClcXG5cXHRcXHRcXHR2ZWMyIHRleGVsU2l6ZSA9IHZlYzIoIDEuMCApIC8gc2hhZG93TWFwU2l6ZTtcXG5cXHRcXHRcXHRmbG9hdCBkeDAgPSAtIHRleGVsU2l6ZS54ICogc2hhZG93UmFkaXVzO1xcblxcdFxcdFxcdGZsb2F0IGR5MCA9IC0gdGV4ZWxTaXplLnkgKiBzaGFkb3dSYWRpdXM7XFxuXFx0XFx0XFx0ZmxvYXQgZHgxID0gKyB0ZXhlbFNpemUueCAqIHNoYWRvd1JhZGl1cztcXG5cXHRcXHRcXHRmbG9hdCBkeTEgPSArIHRleGVsU2l6ZS55ICogc2hhZG93UmFkaXVzO1xcblxcdFxcdFxcdHJldHVybiAoXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MCwgZHkwICksIHNoYWRvd0Nvb3JkLnogKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIDAuMCwgZHkwICksIHNoYWRvd0Nvb3JkLnogKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MSwgZHkwICksIHNoYWRvd0Nvb3JkLnogKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MCwgMC4wICksIHNoYWRvd0Nvb3JkLnogKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSwgc2hhZG93Q29vcmQueiApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCAwLjAgKSwgc2hhZG93Q29vcmQueiApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgwLCBkeTEgKSwgc2hhZG93Q29vcmQueiApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggMC4wLCBkeTEgKSwgc2hhZG93Q29vcmQueiApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCBkeTEgKSwgc2hhZG93Q29vcmQueiApXFxuXFx0XFx0XFx0KSAqICggMS4wIC8gOS4wICk7XFxuXFx0XFx0I2VsaWYgZGVmaW5lZCggU0hBRE9XTUFQX1RZUEVfUENGX1NPRlQgKVxcblxcdFxcdFxcdHZlYzIgdGV4ZWxTaXplID0gdmVjMiggMS4wICkgLyBzaGFkb3dNYXBTaXplO1xcblxcdFxcdFxcdGZsb2F0IGR4MCA9IC0gdGV4ZWxTaXplLnggKiBzaGFkb3dSYWRpdXM7XFxuXFx0XFx0XFx0ZmxvYXQgZHkwID0gLSB0ZXhlbFNpemUueSAqIHNoYWRvd1JhZGl1cztcXG5cXHRcXHRcXHRmbG9hdCBkeDEgPSArIHRleGVsU2l6ZS54ICogc2hhZG93UmFkaXVzO1xcblxcdFxcdFxcdGZsb2F0IGR5MSA9ICsgdGV4ZWxTaXplLnkgKiBzaGFkb3dSYWRpdXM7XFxuXFx0XFx0XFx0cmV0dXJuIChcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRTaGFkb3dMZXJwKCBzaGFkb3dNYXAsIHNoYWRvd01hcFNpemUsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgwLCBkeTAgKSwgc2hhZG93Q29vcmQueiApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRTaGFkb3dMZXJwKCBzaGFkb3dNYXAsIHNoYWRvd01hcFNpemUsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggMC4wLCBkeTAgKSwgc2hhZG93Q29vcmQueiApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRTaGFkb3dMZXJwKCBzaGFkb3dNYXAsIHNoYWRvd01hcFNpemUsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCBkeTAgKSwgc2hhZG93Q29vcmQueiApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRTaGFkb3dMZXJwKCBzaGFkb3dNYXAsIHNoYWRvd01hcFNpemUsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgwLCAwLjAgKSwgc2hhZG93Q29vcmQueiApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRTaGFkb3dMZXJwKCBzaGFkb3dNYXAsIHNoYWRvd01hcFNpemUsIHNoYWRvd0Nvb3JkLnh5LCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRFNoYWRvd0xlcnAoIHNoYWRvd01hcCwgc2hhZG93TWFwU2l6ZSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDEsIDAuMCApLCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRFNoYWRvd0xlcnAoIHNoYWRvd01hcCwgc2hhZG93TWFwU2l6ZSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDAsIGR5MSApLCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRFNoYWRvd0xlcnAoIHNoYWRvd01hcCwgc2hhZG93TWFwU2l6ZSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCAwLjAsIGR5MSApLCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRFNoYWRvd0xlcnAoIHNoYWRvd01hcCwgc2hhZG93TWFwU2l6ZSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDEsIGR5MSApLCBzaGFkb3dDb29yZC56IClcXG5cXHRcXHRcXHQpICogKCAxLjAgLyA5LjAgKTtcXG5cXHRcXHQjZWxzZVxcblxcdFxcdFxcdHJldHVybiB0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5LCBzaGFkb3dDb29yZC56ICk7XFxuXFx0XFx0I2VuZGlmXFxuXFx0XFx0fVxcblxcdFxcdHJldHVybiAxLjA7XFxuXFx0fVxcblxcdHZlYzIgY3ViZVRvVVYoIHZlYzMgdiwgZmxvYXQgdGV4ZWxTaXplWSApIHtcXG5cXHRcXHR2ZWMzIGFic1YgPSBhYnMoIHYgKTtcXG5cXHRcXHRmbG9hdCBzY2FsZVRvQ3ViZSA9IDEuMCAvIG1heCggYWJzVi54LCBtYXgoIGFic1YueSwgYWJzVi56ICkgKTtcXG5cXHRcXHRhYnNWICo9IHNjYWxlVG9DdWJlO1xcblxcdFxcdHYgKj0gc2NhbGVUb0N1YmUgKiAoIDEuMCAtIDIuMCAqIHRleGVsU2l6ZVkgKTtcXG5cXHRcXHR2ZWMyIHBsYW5hciA9IHYueHk7XFxuXFx0XFx0ZmxvYXQgYWxtb3N0QVRleGVsID0gMS41ICogdGV4ZWxTaXplWTtcXG5cXHRcXHRmbG9hdCBhbG1vc3RPbmUgPSAxLjAgLSBhbG1vc3RBVGV4ZWw7XFxuXFx0XFx0aWYgKCBhYnNWLnogPj0gYWxtb3N0T25lICkge1xcblxcdFxcdFxcdGlmICggdi56ID4gMC4wIClcXG5cXHRcXHRcXHRcXHRwbGFuYXIueCA9IDQuMCAtIHYueDtcXG5cXHRcXHR9IGVsc2UgaWYgKCBhYnNWLnggPj0gYWxtb3N0T25lICkge1xcblxcdFxcdFxcdGZsb2F0IHNpZ25YID0gc2lnbiggdi54ICk7XFxuXFx0XFx0XFx0cGxhbmFyLnggPSB2LnogKiBzaWduWCArIDIuMCAqIHNpZ25YO1xcblxcdFxcdH0gZWxzZSBpZiAoIGFic1YueSA+PSBhbG1vc3RPbmUgKSB7XFxuXFx0XFx0XFx0ZmxvYXQgc2lnblkgPSBzaWduKCB2LnkgKTtcXG5cXHRcXHRcXHRwbGFuYXIueCA9IHYueCArIDIuMCAqIHNpZ25ZICsgMi4wO1xcblxcdFxcdFxcdHBsYW5hci55ID0gdi56ICogc2lnblkgLSAyLjA7XFxuXFx0XFx0fVxcblxcdFxcdHJldHVybiB2ZWMyKCAwLjEyNSwgMC4yNSApICogcGxhbmFyICsgdmVjMiggMC4zNzUsIDAuNzUgKTtcXG5cXHR9XFxuXFx0ZmxvYXQgZ2V0UG9pbnRTaGFkb3coIHNhbXBsZXIyRCBzaGFkb3dNYXAsIHZlYzIgc2hhZG93TWFwU2l6ZSwgZmxvYXQgc2hhZG93QmlhcywgZmxvYXQgc2hhZG93UmFkaXVzLCB2ZWM0IHNoYWRvd0Nvb3JkICkge1xcblxcdFxcdHZlYzIgdGV4ZWxTaXplID0gdmVjMiggMS4wICkgLyAoIHNoYWRvd01hcFNpemUgKiB2ZWMyKCA0LjAsIDIuMCApICk7XFxuXFx0XFx0dmVjMyBsaWdodFRvUG9zaXRpb24gPSBzaGFkb3dDb29yZC54eXo7XFxuXFx0XFx0dmVjMyBiZDNEID0gbm9ybWFsaXplKCBsaWdodFRvUG9zaXRpb24gKTtcXG5cXHRcXHRmbG9hdCBkcCA9ICggbGVuZ3RoKCBsaWdodFRvUG9zaXRpb24gKSAtIHNoYWRvd0JpYXMgKSAvIDEwMDAuMDtcXG5cXHRcXHQjaWYgZGVmaW5lZCggU0hBRE9XTUFQX1RZUEVfUENGICkgfHwgZGVmaW5lZCggU0hBRE9XTUFQX1RZUEVfUENGX1NPRlQgKVxcblxcdFxcdFxcdHZlYzIgb2Zmc2V0ID0gdmVjMiggLSAxLCAxICkgKiBzaGFkb3dSYWRpdXMgKiB0ZXhlbFNpemUueTtcXG5cXHRcXHRcXHRyZXR1cm4gKFxcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgY3ViZVRvVVYoIGJkM0QgKyBvZmZzZXQueHl5LCB0ZXhlbFNpemUueSApLCBkcCApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnl5eSwgdGV4ZWxTaXplLnkgKSwgZHAgKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC54eXgsIHRleGVsU2l6ZS55ICksIGRwICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgY3ViZVRvVVYoIGJkM0QgKyBvZmZzZXQueXl4LCB0ZXhlbFNpemUueSApLCBkcCApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNELCB0ZXhlbFNpemUueSApLCBkcCApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnh4eSwgdGV4ZWxTaXplLnkgKSwgZHAgKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC55eHksIHRleGVsU2l6ZS55ICksIGRwICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgY3ViZVRvVVYoIGJkM0QgKyBvZmZzZXQueHh4LCB0ZXhlbFNpemUueSApLCBkcCApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnl4eCwgdGV4ZWxTaXplLnkgKSwgZHAgKVxcblxcdFxcdFxcdCkgKiAoIDEuMCAvIDkuMCApO1xcblxcdFxcdCNlbHNlXFxuXFx0XFx0XFx0cmV0dXJuIHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgY3ViZVRvVVYoIGJkM0QsIHRleGVsU2l6ZS55ICksIGRwICk7XFxuXFx0XFx0I2VuZGlmXFxuXFx0fVxcbiNlbmRpZlxcblwiO1xuXG4gICAgdmFyIHNoYWRvd21hcF9wYXJzX3ZlcnRleCA9IFwiI2lmZGVmIFVTRV9TSEFET1dNQVBcXG5cXHQjaWYgTlVNX0RJUl9MSUdIVFMgPiAwXFxuXFx0XFx0dW5pZm9ybSBtYXQ0IGRpcmVjdGlvbmFsU2hhZG93TWF0cml4WyBOVU1fRElSX0xJR0hUUyBdO1xcblxcdFxcdHZhcnlpbmcgdmVjNCB2RGlyZWN0aW9uYWxTaGFkb3dDb29yZFsgTlVNX0RJUl9MSUdIVFMgXTtcXG5cXHQjZW5kaWZcXG5cXHQjaWYgTlVNX1NQT1RfTElHSFRTID4gMFxcblxcdFxcdHVuaWZvcm0gbWF0NCBzcG90U2hhZG93TWF0cml4WyBOVU1fU1BPVF9MSUdIVFMgXTtcXG5cXHRcXHR2YXJ5aW5nIHZlYzQgdlNwb3RTaGFkb3dDb29yZFsgTlVNX1NQT1RfTElHSFRTIF07XFxuXFx0I2VuZGlmXFxuXFx0I2lmIE5VTV9QT0lOVF9MSUdIVFMgPiAwXFxuXFx0XFx0dW5pZm9ybSBtYXQ0IHBvaW50U2hhZG93TWF0cml4WyBOVU1fUE9JTlRfTElHSFRTIF07XFxuXFx0XFx0dmFyeWluZyB2ZWM0IHZQb2ludFNoYWRvd0Nvb3JkWyBOVU1fUE9JTlRfTElHSFRTIF07XFxuXFx0I2VuZGlmXFxuI2VuZGlmXFxuXCI7XG5cbiAgICB2YXIgc2hhZG93bWFwX3ZlcnRleCA9IFwiI2lmZGVmIFVTRV9TSEFET1dNQVBcXG5cXHQjaWYgTlVNX0RJUl9MSUdIVFMgPiAwXFxuXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX0RJUl9MSUdIVFM7IGkgKysgKSB7XFxuXFx0XFx0dkRpcmVjdGlvbmFsU2hhZG93Q29vcmRbIGkgXSA9IGRpcmVjdGlvbmFsU2hhZG93TWF0cml4WyBpIF0gKiB3b3JsZFBvc2l0aW9uO1xcblxcdH1cXG5cXHQjZW5kaWZcXG5cXHQjaWYgTlVNX1NQT1RfTElHSFRTID4gMFxcblxcdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9TUE9UX0xJR0hUUzsgaSArKyApIHtcXG5cXHRcXHR2U3BvdFNoYWRvd0Nvb3JkWyBpIF0gPSBzcG90U2hhZG93TWF0cml4WyBpIF0gKiB3b3JsZFBvc2l0aW9uO1xcblxcdH1cXG5cXHQjZW5kaWZcXG5cXHQjaWYgTlVNX1BPSU5UX0xJR0hUUyA+IDBcXG5cXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fUE9JTlRfTElHSFRTOyBpICsrICkge1xcblxcdFxcdHZQb2ludFNoYWRvd0Nvb3JkWyBpIF0gPSBwb2ludFNoYWRvd01hdHJpeFsgaSBdICogd29ybGRQb3NpdGlvbjtcXG5cXHR9XFxuXFx0I2VuZGlmXFxuI2VuZGlmXFxuXCI7XG5cbiAgICB2YXIgc2hhZG93bWFza19wYXJzX2ZyYWdtZW50ID0gXCJmbG9hdCBnZXRTaGFkb3dNYXNrKCkge1xcblxcdGZsb2F0IHNoYWRvdyA9IDEuMDtcXG5cXHQjaWZkZWYgVVNFX1NIQURPV01BUFxcblxcdCNpZiBOVU1fRElSX0xJR0hUUyA+IDBcXG5cXHREaXJlY3Rpb25hbExpZ2h0IGRpcmVjdGlvbmFsTGlnaHQ7XFxuXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX0RJUl9MSUdIVFM7IGkgKysgKSB7XFxuXFx0XFx0ZGlyZWN0aW9uYWxMaWdodCA9IGRpcmVjdGlvbmFsTGlnaHRzWyBpIF07XFxuXFx0XFx0c2hhZG93ICo9IGJvb2woIGRpcmVjdGlvbmFsTGlnaHQuc2hhZG93ICkgPyBnZXRTaGFkb3coIGRpcmVjdGlvbmFsU2hhZG93TWFwWyBpIF0sIGRpcmVjdGlvbmFsTGlnaHQuc2hhZG93TWFwU2l6ZSwgZGlyZWN0aW9uYWxMaWdodC5zaGFkb3dCaWFzLCBkaXJlY3Rpb25hbExpZ2h0LnNoYWRvd1JhZGl1cywgdkRpcmVjdGlvbmFsU2hhZG93Q29vcmRbIGkgXSApIDogMS4wO1xcblxcdH1cXG5cXHQjZW5kaWZcXG5cXHQjaWYgTlVNX1NQT1RfTElHSFRTID4gMFxcblxcdFNwb3RMaWdodCBzcG90TGlnaHQ7XFxuXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX1NQT1RfTElHSFRTOyBpICsrICkge1xcblxcdFxcdHNwb3RMaWdodCA9IHNwb3RMaWdodHNbIGkgXTtcXG5cXHRcXHRzaGFkb3cgKj0gYm9vbCggc3BvdExpZ2h0LnNoYWRvdyApID8gZ2V0U2hhZG93KCBzcG90U2hhZG93TWFwWyBpIF0sIHNwb3RMaWdodC5zaGFkb3dNYXBTaXplLCBzcG90TGlnaHQuc2hhZG93Qmlhcywgc3BvdExpZ2h0LnNoYWRvd1JhZGl1cywgdlNwb3RTaGFkb3dDb29yZFsgaSBdICkgOiAxLjA7XFxuXFx0fVxcblxcdCNlbmRpZlxcblxcdCNpZiBOVU1fUE9JTlRfTElHSFRTID4gMFxcblxcdFBvaW50TGlnaHQgcG9pbnRMaWdodDtcXG5cXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fUE9JTlRfTElHSFRTOyBpICsrICkge1xcblxcdFxcdHBvaW50TGlnaHQgPSBwb2ludExpZ2h0c1sgaSBdO1xcblxcdFxcdHNoYWRvdyAqPSBib29sKCBwb2ludExpZ2h0LnNoYWRvdyApID8gZ2V0UG9pbnRTaGFkb3coIHBvaW50U2hhZG93TWFwWyBpIF0sIHBvaW50TGlnaHQuc2hhZG93TWFwU2l6ZSwgcG9pbnRMaWdodC5zaGFkb3dCaWFzLCBwb2ludExpZ2h0LnNoYWRvd1JhZGl1cywgdlBvaW50U2hhZG93Q29vcmRbIGkgXSApIDogMS4wO1xcblxcdH1cXG5cXHQjZW5kaWZcXG5cXHQjZW5kaWZcXG5cXHRyZXR1cm4gc2hhZG93O1xcbn1cXG5cIjtcblxuICAgIHZhciBza2luYmFzZV92ZXJ0ZXggPSBcIiNpZmRlZiBVU0VfU0tJTk5JTkdcXG5cXHRtYXQ0IGJvbmVNYXRYID0gZ2V0Qm9uZU1hdHJpeCggc2tpbkluZGV4LnggKTtcXG5cXHRtYXQ0IGJvbmVNYXRZID0gZ2V0Qm9uZU1hdHJpeCggc2tpbkluZGV4LnkgKTtcXG5cXHRtYXQ0IGJvbmVNYXRaID0gZ2V0Qm9uZU1hdHJpeCggc2tpbkluZGV4LnogKTtcXG5cXHRtYXQ0IGJvbmVNYXRXID0gZ2V0Qm9uZU1hdHJpeCggc2tpbkluZGV4LncgKTtcXG4jZW5kaWZcIjtcblxuICAgIHZhciBza2lubmluZ19wYXJzX3ZlcnRleCA9IFwiI2lmZGVmIFVTRV9TS0lOTklOR1xcblxcdHVuaWZvcm0gbWF0NCBiaW5kTWF0cml4O1xcblxcdHVuaWZvcm0gbWF0NCBiaW5kTWF0cml4SW52ZXJzZTtcXG5cXHQjaWZkZWYgQk9ORV9URVhUVVJFXFxuXFx0XFx0dW5pZm9ybSBzYW1wbGVyMkQgYm9uZVRleHR1cmU7XFxuXFx0XFx0dW5pZm9ybSBpbnQgYm9uZVRleHR1cmVXaWR0aDtcXG5cXHRcXHR1bmlmb3JtIGludCBib25lVGV4dHVyZUhlaWdodDtcXG5cXHRcXHRtYXQ0IGdldEJvbmVNYXRyaXgoIGNvbnN0IGluIGZsb2F0IGkgKSB7XFxuXFx0XFx0XFx0ZmxvYXQgaiA9IGkgKiA0LjA7XFxuXFx0XFx0XFx0ZmxvYXQgeCA9IG1vZCggaiwgZmxvYXQoIGJvbmVUZXh0dXJlV2lkdGggKSApO1xcblxcdFxcdFxcdGZsb2F0IHkgPSBmbG9vciggaiAvIGZsb2F0KCBib25lVGV4dHVyZVdpZHRoICkgKTtcXG5cXHRcXHRcXHRmbG9hdCBkeCA9IDEuMCAvIGZsb2F0KCBib25lVGV4dHVyZVdpZHRoICk7XFxuXFx0XFx0XFx0ZmxvYXQgZHkgPSAxLjAgLyBmbG9hdCggYm9uZVRleHR1cmVIZWlnaHQgKTtcXG5cXHRcXHRcXHR5ID0gZHkgKiAoIHkgKyAwLjUgKTtcXG5cXHRcXHRcXHR2ZWM0IHYxID0gdGV4dHVyZTJEKCBib25lVGV4dHVyZSwgdmVjMiggZHggKiAoIHggKyAwLjUgKSwgeSApICk7XFxuXFx0XFx0XFx0dmVjNCB2MiA9IHRleHR1cmUyRCggYm9uZVRleHR1cmUsIHZlYzIoIGR4ICogKCB4ICsgMS41ICksIHkgKSApO1xcblxcdFxcdFxcdHZlYzQgdjMgPSB0ZXh0dXJlMkQoIGJvbmVUZXh0dXJlLCB2ZWMyKCBkeCAqICggeCArIDIuNSApLCB5ICkgKTtcXG5cXHRcXHRcXHR2ZWM0IHY0ID0gdGV4dHVyZTJEKCBib25lVGV4dHVyZSwgdmVjMiggZHggKiAoIHggKyAzLjUgKSwgeSApICk7XFxuXFx0XFx0XFx0bWF0NCBib25lID0gbWF0NCggdjEsIHYyLCB2MywgdjQgKTtcXG5cXHRcXHRcXHRyZXR1cm4gYm9uZTtcXG5cXHRcXHR9XFxuXFx0I2Vsc2VcXG5cXHRcXHR1bmlmb3JtIG1hdDQgYm9uZU1hdHJpY2VzWyBNQVhfQk9ORVMgXTtcXG5cXHRcXHRtYXQ0IGdldEJvbmVNYXRyaXgoIGNvbnN0IGluIGZsb2F0IGkgKSB7XFxuXFx0XFx0XFx0bWF0NCBib25lID0gYm9uZU1hdHJpY2VzWyBpbnQoaSkgXTtcXG5cXHRcXHRcXHRyZXR1cm4gYm9uZTtcXG5cXHRcXHR9XFxuXFx0I2VuZGlmXFxuI2VuZGlmXFxuXCI7XG5cbiAgICB2YXIgc2tpbm5pbmdfdmVydGV4ID0gXCIjaWZkZWYgVVNFX1NLSU5OSU5HXFxuXFx0dmVjNCBza2luVmVydGV4ID0gYmluZE1hdHJpeCAqIHZlYzQoIHRyYW5zZm9ybWVkLCAxLjAgKTtcXG5cXHR2ZWM0IHNraW5uZWQgPSB2ZWM0KCAwLjAgKTtcXG5cXHRza2lubmVkICs9IGJvbmVNYXRYICogc2tpblZlcnRleCAqIHNraW5XZWlnaHQueDtcXG5cXHRza2lubmVkICs9IGJvbmVNYXRZICogc2tpblZlcnRleCAqIHNraW5XZWlnaHQueTtcXG5cXHRza2lubmVkICs9IGJvbmVNYXRaICogc2tpblZlcnRleCAqIHNraW5XZWlnaHQuejtcXG5cXHRza2lubmVkICs9IGJvbmVNYXRXICogc2tpblZlcnRleCAqIHNraW5XZWlnaHQudztcXG5cXHRza2lubmVkICA9IGJpbmRNYXRyaXhJbnZlcnNlICogc2tpbm5lZDtcXG4jZW5kaWZcXG5cIjtcblxuICAgIHZhciBza2lubm9ybWFsX3ZlcnRleCA9IFwiI2lmZGVmIFVTRV9TS0lOTklOR1xcblxcdG1hdDQgc2tpbk1hdHJpeCA9IG1hdDQoIDAuMCApO1xcblxcdHNraW5NYXRyaXggKz0gc2tpbldlaWdodC54ICogYm9uZU1hdFg7XFxuXFx0c2tpbk1hdHJpeCArPSBza2luV2VpZ2h0LnkgKiBib25lTWF0WTtcXG5cXHRza2luTWF0cml4ICs9IHNraW5XZWlnaHQueiAqIGJvbmVNYXRaO1xcblxcdHNraW5NYXRyaXggKz0gc2tpbldlaWdodC53ICogYm9uZU1hdFc7XFxuXFx0c2tpbk1hdHJpeCAgPSBiaW5kTWF0cml4SW52ZXJzZSAqIHNraW5NYXRyaXggKiBiaW5kTWF0cml4O1xcblxcdG9iamVjdE5vcm1hbCA9IHZlYzQoIHNraW5NYXRyaXggKiB2ZWM0KCBvYmplY3ROb3JtYWwsIDAuMCApICkueHl6O1xcbiNlbmRpZlxcblwiO1xuXG4gICAgdmFyIHNwZWN1bGFybWFwX2ZyYWdtZW50ID0gXCJmbG9hdCBzcGVjdWxhclN0cmVuZ3RoO1xcbiNpZmRlZiBVU0VfU1BFQ1VMQVJNQVBcXG5cXHR2ZWM0IHRleGVsU3BlY3VsYXIgPSB0ZXh0dXJlMkQoIHNwZWN1bGFyTWFwLCB2VXYgKTtcXG5cXHRzcGVjdWxhclN0cmVuZ3RoID0gdGV4ZWxTcGVjdWxhci5yO1xcbiNlbHNlXFxuXFx0c3BlY3VsYXJTdHJlbmd0aCA9IDEuMDtcXG4jZW5kaWZcIjtcblxuICAgIHZhciBzcGVjdWxhcm1hcF9wYXJzX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX1NQRUNVTEFSTUFQXFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgc3BlY3VsYXJNYXA7XFxuI2VuZGlmXCI7XG5cbiAgICB2YXIgdG9uZW1hcHBpbmdfZnJhZ21lbnQgPSBcIiNpZiBkZWZpbmVkKCBUT05FX01BUFBJTkcgKVxcbiAgZ2xfRnJhZ0NvbG9yLnJnYiA9IHRvbmVNYXBwaW5nKCBnbF9GcmFnQ29sb3IucmdiICk7XFxuI2VuZGlmXFxuXCI7XG5cbiAgICB2YXIgdG9uZW1hcHBpbmdfcGFyc19mcmFnbWVudCA9IFwiI2RlZmluZSBzYXR1cmF0ZShhKSBjbGFtcCggYSwgMC4wLCAxLjAgKVxcbnVuaWZvcm0gZmxvYXQgdG9uZU1hcHBpbmdFeHBvc3VyZTtcXG51bmlmb3JtIGZsb2F0IHRvbmVNYXBwaW5nV2hpdGVQb2ludDtcXG52ZWMzIExpbmVhclRvbmVNYXBwaW5nKCB2ZWMzIGNvbG9yICkge1xcbiAgcmV0dXJuIHRvbmVNYXBwaW5nRXhwb3N1cmUgKiBjb2xvcjtcXG59XFxudmVjMyBSZWluaGFyZFRvbmVNYXBwaW5nKCB2ZWMzIGNvbG9yICkge1xcbiAgY29sb3IgKj0gdG9uZU1hcHBpbmdFeHBvc3VyZTtcXG4gIHJldHVybiBzYXR1cmF0ZSggY29sb3IgLyAoIHZlYzMoIDEuMCApICsgY29sb3IgKSApO1xcbn1cXG4jZGVmaW5lIFVuY2hhcnRlZDJIZWxwZXIoIHggKSBtYXgoICggKCB4ICogKCAwLjE1ICogeCArIDAuMTAgKiAwLjUwICkgKyAwLjIwICogMC4wMiApIC8gKCB4ICogKCAwLjE1ICogeCArIDAuNTAgKSArIDAuMjAgKiAwLjMwICkgKSAtIDAuMDIgLyAwLjMwLCB2ZWMzKCAwLjAgKSApXFxudmVjMyBVbmNoYXJ0ZWQyVG9uZU1hcHBpbmcoIHZlYzMgY29sb3IgKSB7XFxuICBjb2xvciAqPSB0b25lTWFwcGluZ0V4cG9zdXJlO1xcbiAgcmV0dXJuIHNhdHVyYXRlKCBVbmNoYXJ0ZWQySGVscGVyKCBjb2xvciApIC8gVW5jaGFydGVkMkhlbHBlciggdmVjMyggdG9uZU1hcHBpbmdXaGl0ZVBvaW50ICkgKSApO1xcbn1cXG52ZWMzIE9wdGltaXplZENpbmVvblRvbmVNYXBwaW5nKCB2ZWMzIGNvbG9yICkge1xcbiAgY29sb3IgKj0gdG9uZU1hcHBpbmdFeHBvc3VyZTtcXG4gIGNvbG9yID0gbWF4KCB2ZWMzKCAwLjAgKSwgY29sb3IgLSAwLjAwNCApO1xcbiAgcmV0dXJuIHBvdyggKCBjb2xvciAqICggNi4yICogY29sb3IgKyAwLjUgKSApIC8gKCBjb2xvciAqICggNi4yICogY29sb3IgKyAxLjcgKSArIDAuMDYgKSwgdmVjMyggMi4yICkgKTtcXG59XFxuXCI7XG5cbiAgICB2YXIgdXZfcGFyc19mcmFnbWVudCA9IFwiI2lmIGRlZmluZWQoIFVTRV9NQVAgKSB8fCBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSB8fCBkZWZpbmVkKCBVU0VfU1BFQ1VMQVJNQVAgKSB8fCBkZWZpbmVkKCBVU0VfQUxQSEFNQVAgKSB8fCBkZWZpbmVkKCBVU0VfRU1JU1NJVkVNQVAgKSB8fCBkZWZpbmVkKCBVU0VfUk9VR0hORVNTTUFQICkgfHwgZGVmaW5lZCggVVNFX01FVEFMTkVTU01BUCApXFxuXFx0dmFyeWluZyB2ZWMyIHZVdjtcXG4jZW5kaWZcIjtcblxuICAgIHZhciB1dl9wYXJzX3ZlcnRleCA9IFwiI2lmIGRlZmluZWQoIFVTRV9NQVAgKSB8fCBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSB8fCBkZWZpbmVkKCBVU0VfU1BFQ1VMQVJNQVAgKSB8fCBkZWZpbmVkKCBVU0VfQUxQSEFNQVAgKSB8fCBkZWZpbmVkKCBVU0VfRU1JU1NJVkVNQVAgKSB8fCBkZWZpbmVkKCBVU0VfUk9VR0hORVNTTUFQICkgfHwgZGVmaW5lZCggVVNFX01FVEFMTkVTU01BUCApXFxuXFx0dmFyeWluZyB2ZWMyIHZVdjtcXG5cXHR1bmlmb3JtIHZlYzQgb2Zmc2V0UmVwZWF0O1xcbiNlbmRpZlxcblwiO1xuXG4gICAgdmFyIHV2X3ZlcnRleCA9IFwiI2lmIGRlZmluZWQoIFVTRV9NQVAgKSB8fCBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSB8fCBkZWZpbmVkKCBVU0VfU1BFQ1VMQVJNQVAgKSB8fCBkZWZpbmVkKCBVU0VfQUxQSEFNQVAgKSB8fCBkZWZpbmVkKCBVU0VfRU1JU1NJVkVNQVAgKSB8fCBkZWZpbmVkKCBVU0VfUk9VR0hORVNTTUFQICkgfHwgZGVmaW5lZCggVVNFX01FVEFMTkVTU01BUCApXFxuXFx0dlV2ID0gdXYgKiBvZmZzZXRSZXBlYXQuencgKyBvZmZzZXRSZXBlYXQueHk7XFxuI2VuZGlmXCI7XG5cbiAgICB2YXIgdXYyX3BhcnNfZnJhZ21lbnQgPSBcIiNpZiBkZWZpbmVkKCBVU0VfTElHSFRNQVAgKSB8fCBkZWZpbmVkKCBVU0VfQU9NQVAgKVxcblxcdHZhcnlpbmcgdmVjMiB2VXYyO1xcbiNlbmRpZlwiO1xuXG4gICAgdmFyIHV2Ml9wYXJzX3ZlcnRleCA9IFwiI2lmIGRlZmluZWQoIFVTRV9MSUdIVE1BUCApIHx8IGRlZmluZWQoIFVTRV9BT01BUCApXFxuXFx0YXR0cmlidXRlIHZlYzIgdXYyO1xcblxcdHZhcnlpbmcgdmVjMiB2VXYyO1xcbiNlbmRpZlwiO1xuXG4gICAgdmFyIHV2Ml92ZXJ0ZXggPSBcIiNpZiBkZWZpbmVkKCBVU0VfTElHSFRNQVAgKSB8fCBkZWZpbmVkKCBVU0VfQU9NQVAgKVxcblxcdHZVdjIgPSB1djI7XFxuI2VuZGlmXCI7XG5cbiAgICB2YXIgd29ybGRwb3NfdmVydGV4ID0gXCIjaWYgZGVmaW5lZCggVVNFX0VOVk1BUCApIHx8IGRlZmluZWQoIFBIT05HICkgfHwgZGVmaW5lZCggUEhZU0lDQUwgKSB8fCBkZWZpbmVkKCBMQU1CRVJUICkgfHwgZGVmaW5lZCAoIFVTRV9TSEFET1dNQVAgKVxcblxcdCNpZmRlZiBVU0VfU0tJTk5JTkdcXG5cXHRcXHR2ZWM0IHdvcmxkUG9zaXRpb24gPSBtb2RlbE1hdHJpeCAqIHNraW5uZWQ7XFxuXFx0I2Vsc2VcXG5cXHRcXHR2ZWM0IHdvcmxkUG9zaXRpb24gPSBtb2RlbE1hdHJpeCAqIHZlYzQoIHRyYW5zZm9ybWVkLCAxLjAgKTtcXG5cXHQjZW5kaWZcXG4jZW5kaWZcXG5cIjtcblxuICAgIHZhciBjdWJlX2ZyYWcgPSBcInVuaWZvcm0gc2FtcGxlckN1YmUgdEN1YmU7XFxudW5pZm9ybSBmbG9hdCB0RmxpcDtcXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxudmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1xcbiNpbmNsdWRlIDxjb21tb24+XFxudm9pZCBtYWluKCkge1xcblxcdGdsX0ZyYWdDb2xvciA9IHRleHR1cmVDdWJlKCB0Q3ViZSwgdmVjMyggdEZsaXAgKiB2V29ybGRQb3NpdGlvbi54LCB2V29ybGRQb3NpdGlvbi55eiApICk7XFxuXFx0Z2xfRnJhZ0NvbG9yLmEgKj0gb3BhY2l0eTtcXG59XFxuXCI7XG5cbiAgICB2YXIgY3ViZV92ZXJ0ID0gXCJ2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XFxuI2luY2x1ZGUgPGNvbW1vbj5cXG52b2lkIG1haW4oKSB7XFxuXFx0dldvcmxkUG9zaXRpb24gPSB0cmFuc2Zvcm1EaXJlY3Rpb24oIHBvc2l0aW9uLCBtb2RlbE1hdHJpeCApO1xcblxcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4Plxcbn1cXG5cIjtcblxuICAgIHZhciBkZXB0aF9mcmFnID0gXCIjaWYgREVQVEhfUEFDS0lORyA9PSAzMjAwXFxuXFx0dW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcbiNlbmRpZlxcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPHBhY2tpbmc+XFxuI2luY2x1ZGUgPHV2X3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxhbHBoYW1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudD5cXG52b2lkIG1haW4oKSB7XFxuXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD5cXG5cXHR2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIDEuMCApO1xcblxcdCNpZiBERVBUSF9QQUNLSU5HID09IDMyMDBcXG5cXHRcXHRkaWZmdXNlQ29sb3IuYSA9IG9wYWNpdHk7XFxuXFx0I2VuZGlmXFxuXFx0I2luY2x1ZGUgPG1hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8YWxwaGFtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhdGVzdF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfZnJhZ21lbnQ+XFxuXFx0I2lmIERFUFRIX1BBQ0tJTkcgPT0gMzIwMFxcblxcdFxcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIHZlYzMoIGdsX0ZyYWdDb29yZC56ICksIG9wYWNpdHkgKTtcXG5cXHQjZWxpZiBERVBUSF9QQUNLSU5HID09IDMyMDFcXG5cXHRcXHRnbF9GcmFnQ29sb3IgPSBwYWNrRGVwdGhUb1JHQkEoIGdsX0ZyYWdDb29yZC56ICk7XFxuXFx0I2VuZGlmXFxufVxcblwiO1xuXG4gICAgdmFyIGRlcHRoX3ZlcnQgPSBcIiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPHV2X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxza2lubmluZ19wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD5cXG52b2lkIG1haW4oKSB7XFxuXFx0I2luY2x1ZGUgPHV2X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbmJhc2VfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbm5pbmdfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4Plxcbn1cXG5cIjtcblxuICAgIHZhciBkaXN0YW5jZVJHQkFfZnJhZyA9IFwidW5pZm9ybSB2ZWMzIGxpZ2h0UG9zO1xcbnZhcnlpbmcgdmVjNCB2V29ybGRQb3NpdGlvbjtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDxwYWNraW5nPlxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudD5cXG52b2lkIG1haW4gKCkge1xcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+XFxuXFx0Z2xfRnJhZ0NvbG9yID0gcGFja0RlcHRoVG9SR0JBKCBsZW5ndGgoIHZXb3JsZFBvc2l0aW9uLnh5eiAtIGxpZ2h0UG9zLnh5eiApIC8gMTAwMC4wICk7XFxufVxcblwiO1xuXG4gICAgdmFyIGRpc3RhbmNlUkdCQV92ZXJ0ID0gXCJ2YXJ5aW5nIHZlYzQgdldvcmxkUG9zaXRpb247XFxuI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHNraW5uaW5nX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg+XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDxza2luYmFzZV92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGJlZ2luX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGh0YXJnZXRfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2lubmluZ192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4PlxcblxcdCNpbmNsdWRlIDx3b3JsZHBvc192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg+XFxuXFx0dldvcmxkUG9zaXRpb24gPSB3b3JsZFBvc2l0aW9uO1xcbn1cXG5cIjtcblxuICAgIHZhciBlcXVpcmVjdF9mcmFnID0gXCJ1bmlmb3JtIHNhbXBsZXIyRCB0RXF1aXJlY3Q7XFxudW5pZm9ybSBmbG9hdCB0RmxpcDtcXG52YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XFxuI2luY2x1ZGUgPGNvbW1vbj5cXG52b2lkIG1haW4oKSB7XFxuXFx0dmVjMyBkaXJlY3Rpb24gPSBub3JtYWxpemUoIHZXb3JsZFBvc2l0aW9uICk7XFxuXFx0dmVjMiBzYW1wbGVVVjtcXG5cXHRzYW1wbGVVVi55ID0gc2F0dXJhdGUoIHRGbGlwICogZGlyZWN0aW9uLnkgKiAtMC41ICsgMC41ICk7XFxuXFx0c2FtcGxlVVYueCA9IGF0YW4oIGRpcmVjdGlvbi56LCBkaXJlY3Rpb24ueCApICogUkVDSVBST0NBTF9QSTIgKyAwLjU7XFxuXFx0Z2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKCB0RXF1aXJlY3QsIHNhbXBsZVVWICk7XFxufVxcblwiO1xuXG4gICAgdmFyIGVxdWlyZWN0X3ZlcnQgPSBcInZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbnZvaWQgbWFpbigpIHtcXG5cXHR2V29ybGRQb3NpdGlvbiA9IHRyYW5zZm9ybURpcmVjdGlvbiggcG9zaXRpb24sIG1vZGVsTWF0cml4ICk7XFxuXFx0I2luY2x1ZGUgPGJlZ2luX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XFxufVxcblwiO1xuXG4gICAgdmFyIGxpbmVkYXNoZWRfZnJhZyA9IFwidW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcbnVuaWZvcm0gZmxvYXQgZGFzaFNpemU7XFxudW5pZm9ybSBmbG9hdCB0b3RhbFNpemU7XFxudmFyeWluZyBmbG9hdCB2TGluZURpc3RhbmNlO1xcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGZvZ19wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudD5cXG52b2lkIG1haW4oKSB7XFxuXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD5cXG5cXHRpZiAoIG1vZCggdkxpbmVEaXN0YW5jZSwgdG90YWxTaXplICkgPiBkYXNoU2l6ZSApIHtcXG5cXHRcXHRkaXNjYXJkO1xcblxcdH1cXG5cXHR2ZWMzIG91dGdvaW5nTGlnaHQgPSB2ZWMzKCAwLjAgKTtcXG5cXHR2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTtcXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGNvbG9yX2ZyYWdtZW50PlxcblxcdG91dGdvaW5nTGlnaHQgPSBkaWZmdXNlQ29sb3IucmdiO1xcblxcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIG91dGdvaW5nTGlnaHQsIGRpZmZ1c2VDb2xvci5hICk7XFxuXFx0I2luY2x1ZGUgPHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxlbmNvZGluZ3NfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGZvZ19mcmFnbWVudD5cXG59XFxuXCI7XG5cbiAgICB2YXIgbGluZWRhc2hlZF92ZXJ0ID0gXCJ1bmlmb3JtIGZsb2F0IHNjYWxlO1xcbmF0dHJpYnV0ZSBmbG9hdCBsaW5lRGlzdGFuY2U7XFxudmFyeWluZyBmbG9hdCB2TGluZURpc3RhbmNlO1xcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4PlxcbnZvaWQgbWFpbigpIHtcXG5cXHQjaW5jbHVkZSA8Y29sb3JfdmVydGV4PlxcblxcdHZMaW5lRGlzdGFuY2UgPSBzY2FsZSAqIGxpbmVEaXN0YW5jZTtcXG5cXHR2ZWM0IG12UG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XFxuXFx0Z2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbXZQb3NpdGlvbjtcXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4Plxcbn1cXG5cIjtcblxuICAgIHZhciBtZXNoYmFzaWNfZnJhZyA9IFwidW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcbiNpZm5kZWYgRkxBVF9TSEFERURcXG5cXHR2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcXG4jZW5kaWZcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDxjb2xvcl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDx1dl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDx1djJfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGFscGhhbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGFvbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGVudm1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxmb2dfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8c3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+XFxuXFx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7XFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGNvbG9yX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxhbHBoYW1hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8YWxwaGF0ZXN0X2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxzcGVjdWxhcm1hcF9mcmFnbWVudD5cXG5cXHRSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodDtcXG5cXHRyZWZsZWN0ZWRMaWdodC5kaXJlY3REaWZmdXNlID0gdmVjMyggMC4wICk7XFxuXFx0cmVmbGVjdGVkTGlnaHQuZGlyZWN0U3BlY3VsYXIgPSB2ZWMzKCAwLjAgKTtcXG5cXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgPSBkaWZmdXNlQ29sb3IucmdiO1xcblxcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0U3BlY3VsYXIgPSB2ZWMzKCAwLjAgKTtcXG5cXHQjaW5jbHVkZSA8YW9tYXBfZnJhZ21lbnQ+XFxuXFx0dmVjMyBvdXRnb2luZ0xpZ2h0ID0gcmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlO1xcblxcdCNpbmNsdWRlIDxub3JtYWxfZmxpcD5cXG5cXHQjaW5jbHVkZSA8ZW52bWFwX2ZyYWdtZW50PlxcblxcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIG91dGdvaW5nTGlnaHQsIGRpZmZ1c2VDb2xvci5hICk7XFxuXFx0I2luY2x1ZGUgPHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxlbmNvZGluZ3NfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGZvZ19mcmFnbWVudD5cXG59XFxuXCI7XG5cbiAgICB2YXIgbWVzaGJhc2ljX3ZlcnQgPSBcIiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPHV2X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDx1djJfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGVudm1hcF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Y29sb3JfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxza2lubmluZ19wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD5cXG52b2lkIG1haW4oKSB7XFxuXFx0I2luY2x1ZGUgPHV2X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8dXYyX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Y29sb3JfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2luYmFzZV92ZXJ0ZXg+XFxuXFx0I2lmZGVmIFVTRV9FTlZNQVBcXG5cXHQjaW5jbHVkZSA8YmVnaW5ub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaG5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5ub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxkZWZhdWx0bm9ybWFsX3ZlcnRleD5cXG5cXHQjZW5kaWZcXG5cXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaHRhcmdldF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5uaW5nX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8d29ybGRwb3NfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxlbnZtYXBfdmVydGV4Plxcbn1cXG5cIjtcblxuICAgIHZhciBtZXNobGFtYmVydF9mcmFnID0gXCJ1bmlmb3JtIHZlYzMgZGlmZnVzZTtcXG51bmlmb3JtIHZlYzMgZW1pc3NpdmU7XFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcbnZhcnlpbmcgdmVjMyB2TGlnaHRGcm9udDtcXG4jaWZkZWYgRE9VQkxFX1NJREVEXFxuXFx0dmFyeWluZyB2ZWMzIHZMaWdodEJhY2s7XFxuI2VuZGlmXFxuI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8cGFja2luZz5cXG4jaW5jbHVkZSA8Y29sb3JfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8dXYyX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxhbHBoYW1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxhb21hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxsaWdodG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxlbWlzc2l2ZW1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxlbnZtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YnNkZnM+XFxuI2luY2x1ZGUgPGxpZ2h0c19wYXJzPlxcbiNpbmNsdWRlIDxmb2dfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHNoYWRvd21hc2tfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8c3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+XFxuXFx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7XFxuXFx0UmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgPSBSZWZsZWN0ZWRMaWdodCggdmVjMyggMC4wICksIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICkgKTtcXG5cXHR2ZWMzIHRvdGFsRW1pc3NpdmVSYWRpYW5jZSA9IGVtaXNzaXZlO1xcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxjb2xvcl9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8YWxwaGFtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhdGVzdF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8c3BlY3VsYXJtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGVtaXNzaXZlbWFwX2ZyYWdtZW50PlxcblxcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSA9IGdldEFtYmllbnRMaWdodElycmFkaWFuY2UoIGFtYmllbnRMaWdodENvbG9yICk7XFxuXFx0I2luY2x1ZGUgPGxpZ2h0bWFwX2ZyYWdtZW50PlxcblxcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSAqPSBCUkRGX0RpZmZ1c2VfTGFtYmVydCggZGlmZnVzZUNvbG9yLnJnYiApO1xcblxcdCNpZmRlZiBET1VCTEVfU0lERURcXG5cXHRcXHRyZWZsZWN0ZWRMaWdodC5kaXJlY3REaWZmdXNlID0gKCBnbF9Gcm9udEZhY2luZyApID8gdkxpZ2h0RnJvbnQgOiB2TGlnaHRCYWNrO1xcblxcdCNlbHNlXFxuXFx0XFx0cmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSA9IHZMaWdodEZyb250O1xcblxcdCNlbmRpZlxcblxcdHJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgKj0gQlJERl9EaWZmdXNlX0xhbWJlcnQoIGRpZmZ1c2VDb2xvci5yZ2IgKSAqIGdldFNoYWRvd01hc2soKTtcXG5cXHQjaW5jbHVkZSA8YW9tYXBfZnJhZ21lbnQ+XFxuXFx0dmVjMyBvdXRnb2luZ0xpZ2h0ID0gcmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSArIHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSArIHRvdGFsRW1pc3NpdmVSYWRpYW5jZTtcXG5cXHQjaW5jbHVkZSA8bm9ybWFsX2ZsaXA+XFxuXFx0I2luY2x1ZGUgPGVudm1hcF9mcmFnbWVudD5cXG5cXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCBvdXRnb2luZ0xpZ2h0LCBkaWZmdXNlQ29sb3IuYSApO1xcblxcdCNpbmNsdWRlIDxwcmVtdWx0aXBsaWVkX2FscGhhX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8ZW5jb2RpbmdzX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxmb2dfZnJhZ21lbnQ+XFxufVxcblwiO1xuXG4gICAgdmFyIG1lc2hsYW1iZXJ0X3ZlcnQgPSBcIiNkZWZpbmUgTEFNQkVSVFxcbnZhcnlpbmcgdmVjMyB2TGlnaHRGcm9udDtcXG4jaWZkZWYgRE9VQkxFX1NJREVEXFxuXFx0dmFyeWluZyB2ZWMzIHZMaWdodEJhY2s7XFxuI2VuZGlmXFxuI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8dXZfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHV2Ml9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8ZW52bWFwX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxic2Rmcz5cXG4jaW5jbHVkZSA8bGlnaHRzX3BhcnM+XFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8c2tpbm5pbmdfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHNoYWRvd21hcF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD5cXG52b2lkIG1haW4oKSB7XFxuXFx0I2luY2x1ZGUgPHV2X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8dXYyX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Y29sb3JfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxiZWdpbm5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBobm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbmJhc2VfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2lubm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8ZGVmYXVsdG5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGJlZ2luX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGh0YXJnZXRfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2lubmluZ192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHdvcmxkcG9zX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8ZW52bWFwX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bGlnaHRzX2xhbWJlcnRfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxzaGFkb3dtYXBfdmVydGV4Plxcbn1cXG5cIjtcblxuICAgIHZhciBtZXNocGhvbmdfZnJhZyA9IFwiI2RlZmluZSBQSE9OR1xcbnVuaWZvcm0gdmVjMyBkaWZmdXNlO1xcbnVuaWZvcm0gdmVjMyBlbWlzc2l2ZTtcXG51bmlmb3JtIHZlYzMgc3BlY3VsYXI7XFxudW5pZm9ybSBmbG9hdCBzaGluaW5lc3M7XFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPHBhY2tpbmc+XFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHV2X3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHV2Ml9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YWxwaGFtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YW9tYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bGlnaHRtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8ZW1pc3NpdmVtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8ZW52bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGZvZ19wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxic2Rmcz5cXG4jaW5jbHVkZSA8bGlnaHRzX3BhcnM+XFxuI2luY2x1ZGUgPGxpZ2h0c19waG9uZ19wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxzaGFkb3dtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YnVtcG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxub3JtYWxtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8c3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+XFxuXFx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7XFxuXFx0UmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgPSBSZWZsZWN0ZWRMaWdodCggdmVjMyggMC4wICksIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICkgKTtcXG5cXHR2ZWMzIHRvdGFsRW1pc3NpdmVSYWRpYW5jZSA9IGVtaXNzaXZlO1xcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxjb2xvcl9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8YWxwaGFtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhdGVzdF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8c3BlY3VsYXJtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPG5vcm1hbF9mbGlwPlxcblxcdCNpbmNsdWRlIDxub3JtYWxfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGVtaXNzaXZlbWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxsaWdodHNfcGhvbmdfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGxpZ2h0c190ZW1wbGF0ZT5cXG5cXHQjaW5jbHVkZSA8YW9tYXBfZnJhZ21lbnQ+XFxuXFx0dmVjMyBvdXRnb2luZ0xpZ2h0ID0gcmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSArIHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSArIHJlZmxlY3RlZExpZ2h0LmRpcmVjdFNwZWN1bGFyICsgcmVmbGVjdGVkTGlnaHQuaW5kaXJlY3RTcGVjdWxhciArIHRvdGFsRW1pc3NpdmVSYWRpYW5jZTtcXG5cXHQjaW5jbHVkZSA8ZW52bWFwX2ZyYWdtZW50PlxcblxcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIG91dGdvaW5nTGlnaHQsIGRpZmZ1c2VDb2xvci5hICk7XFxuXFx0I2luY2x1ZGUgPHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxlbmNvZGluZ3NfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGZvZ19mcmFnbWVudD5cXG59XFxuXCI7XG5cbiAgICB2YXIgbWVzaHBob25nX3ZlcnQgPSBcIiNkZWZpbmUgUEhPTkdcXG52YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcXG4jaWZuZGVmIEZMQVRfU0hBREVEXFxuXFx0dmFyeWluZyB2ZWMzIHZOb3JtYWw7XFxuI2VuZGlmXFxuI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8dXZfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHV2Ml9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxlbnZtYXBfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8c2tpbm5pbmdfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHNoYWRvd21hcF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD5cXG52b2lkIG1haW4oKSB7XFxuXFx0I2luY2x1ZGUgPHV2X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8dXYyX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Y29sb3JfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxiZWdpbm5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBobm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbmJhc2VfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2lubm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8ZGVmYXVsdG5vcm1hbF92ZXJ0ZXg+XFxuI2lmbmRlZiBGTEFUX1NIQURFRFxcblxcdHZOb3JtYWwgPSBub3JtYWxpemUoIHRyYW5zZm9ybWVkTm9ybWFsICk7XFxuI2VuZGlmXFxuXFx0I2luY2x1ZGUgPGJlZ2luX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGh0YXJnZXRfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2lubmluZ192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg+XFxuXFx0dlZpZXdQb3NpdGlvbiA9IC0gbXZQb3NpdGlvbi54eXo7XFxuXFx0I2luY2x1ZGUgPHdvcmxkcG9zX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8ZW52bWFwX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2hhZG93bWFwX3ZlcnRleD5cXG59XFxuXCI7XG5cbiAgICB2YXIgbWVzaHBoeXNpY2FsX2ZyYWcgPSBcIiNkZWZpbmUgUEhZU0lDQUxcXG51bmlmb3JtIHZlYzMgZGlmZnVzZTtcXG51bmlmb3JtIHZlYzMgZW1pc3NpdmU7XFxudW5pZm9ybSBmbG9hdCByb3VnaG5lc3M7XFxudW5pZm9ybSBmbG9hdCBtZXRhbG5lc3M7XFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcbiNpZm5kZWYgU1RBTkRBUkRcXG5cXHR1bmlmb3JtIGZsb2F0IGNsZWFyQ29hdDtcXG5cXHR1bmlmb3JtIGZsb2F0IGNsZWFyQ29hdFJvdWdobmVzcztcXG4jZW5kaWZcXG51bmlmb3JtIGZsb2F0IGVudk1hcEludGVuc2l0eTtcXG52YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcXG4jaWZuZGVmIEZMQVRfU0hBREVEXFxuXFx0dmFyeWluZyB2ZWMzIHZOb3JtYWw7XFxuI2VuZGlmXFxuI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8cGFja2luZz5cXG4jaW5jbHVkZSA8Y29sb3JfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8dXYyX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxhbHBoYW1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxhb21hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxsaWdodG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxlbWlzc2l2ZW1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxlbnZtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Zm9nX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGJzZGZzPlxcbiNpbmNsdWRlIDxjdWJlX3V2X3JlZmxlY3Rpb25fZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxpZ2h0c19wYXJzPlxcbiNpbmNsdWRlIDxsaWdodHNfcGh5c2ljYWxfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGJ1bXBtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bm9ybWFsbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHJvdWdobmVzc21hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxtZXRhbG5lc3NtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+XFxuXFx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7XFxuXFx0UmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgPSBSZWZsZWN0ZWRMaWdodCggdmVjMyggMC4wICksIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICkgKTtcXG5cXHR2ZWMzIHRvdGFsRW1pc3NpdmVSYWRpYW5jZSA9IGVtaXNzaXZlO1xcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxjb2xvcl9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8YWxwaGFtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhdGVzdF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8c3BlY3VsYXJtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPHJvdWdobmVzc21hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bWV0YWxuZXNzbWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxub3JtYWxfZmxpcD5cXG5cXHQjaW5jbHVkZSA8bm9ybWFsX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxlbWlzc2l2ZW1hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bGlnaHRzX3BoeXNpY2FsX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxsaWdodHNfdGVtcGxhdGU+XFxuXFx0I2luY2x1ZGUgPGFvbWFwX2ZyYWdtZW50PlxcblxcdHZlYzMgb3V0Z29pbmdMaWdodCA9IHJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgKyByZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKyByZWZsZWN0ZWRMaWdodC5kaXJlY3RTcGVjdWxhciArIHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0U3BlY3VsYXIgKyB0b3RhbEVtaXNzaXZlUmFkaWFuY2U7XFxuXFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggb3V0Z29pbmdMaWdodCwgZGlmZnVzZUNvbG9yLmEgKTtcXG5cXHQjaW5jbHVkZSA8cHJlbXVsdGlwbGllZF9hbHBoYV9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGVuY29kaW5nc19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Zm9nX2ZyYWdtZW50Plxcbn1cXG5cIjtcblxuICAgIHZhciBtZXNocGh5c2ljYWxfdmVydCA9IFwiI2RlZmluZSBQSFlTSUNBTFxcbnZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1xcbiNpZm5kZWYgRkxBVF9TSEFERURcXG5cXHR2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcXG4jZW5kaWZcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDx1dl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8dXYyX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8c2tpbm5pbmdfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHNoYWRvd21hcF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8c3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD5cXG52b2lkIG1haW4oKSB7XFxuXFx0I2luY2x1ZGUgPHV2X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8dXYyX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Y29sb3JfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxiZWdpbm5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBobm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbmJhc2VfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2lubm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8ZGVmYXVsdG5vcm1hbF92ZXJ0ZXg+XFxuI2lmbmRlZiBGTEFUX1NIQURFRFxcblxcdHZOb3JtYWwgPSBub3JtYWxpemUoIHRyYW5zZm9ybWVkTm9ybWFsICk7XFxuI2VuZGlmXFxuXFx0I2luY2x1ZGUgPGJlZ2luX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGh0YXJnZXRfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2lubmluZ192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg+XFxuXFx0dlZpZXdQb3NpdGlvbiA9IC0gbXZQb3NpdGlvbi54eXo7XFxuXFx0I2luY2x1ZGUgPHdvcmxkcG9zX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2hhZG93bWFwX3ZlcnRleD5cXG59XFxuXCI7XG5cbiAgICB2YXIgbm9ybWFsX2ZyYWcgPSBcInVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXG52YXJ5aW5nIHZlYzMgdk5vcm1hbDtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDxwYWNraW5nPlxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudD5cXG52b2lkIG1haW4oKSB7XFxuXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD5cXG5cXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCBwYWNrTm9ybWFsVG9SR0IoIHZOb3JtYWwgKSwgb3BhY2l0eSApO1xcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD5cXG59XFxuXCI7XG5cbiAgICB2YXIgbm9ybWFsX3ZlcnQgPSBcInZhcnlpbmcgdmVjMyB2Tm9ybWFsO1xcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4PlxcbnZvaWQgbWFpbigpIHtcXG5cXHR2Tm9ybWFsID0gbm9ybWFsaXplKCBub3JtYWxNYXRyaXggKiBub3JtYWwgKTtcXG5cXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaHRhcmdldF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg+XFxufVxcblwiO1xuXG4gICAgdmFyIHBvaW50c19mcmFnID0gXCJ1bmlmb3JtIHZlYzMgZGlmZnVzZTtcXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxuI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8cGFja2luZz5cXG4jaW5jbHVkZSA8Y29sb3JfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bWFwX3BhcnRpY2xlX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGZvZ19wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxzaGFkb3dtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+XFxuXFx0dmVjMyBvdXRnb2luZ0xpZ2h0ID0gdmVjMyggMC4wICk7XFxuXFx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7XFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxtYXBfcGFydGljbGVfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGNvbG9yX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxhbHBoYXRlc3RfZnJhZ21lbnQ+XFxuXFx0b3V0Z29pbmdMaWdodCA9IGRpZmZ1c2VDb2xvci5yZ2I7XFxuXFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggb3V0Z29pbmdMaWdodCwgZGlmZnVzZUNvbG9yLmEgKTtcXG5cXHQjaW5jbHVkZSA8cHJlbXVsdGlwbGllZF9hbHBoYV9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGVuY29kaW5nc19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Zm9nX2ZyYWdtZW50Plxcbn1cXG5cIjtcblxuICAgIHZhciBwb2ludHNfdmVydCA9IFwidW5pZm9ybSBmbG9hdCBzaXplO1xcbnVuaWZvcm0gZmxvYXQgc2NhbGU7XFxuI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8Y29sb3JfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHNoYWRvd21hcF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD5cXG52b2lkIG1haW4oKSB7XFxuXFx0I2luY2x1ZGUgPGNvbG9yX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxcblxcdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cXG5cXHQjaWZkZWYgVVNFX1NJWkVBVFRFTlVBVElPTlxcblxcdFxcdGdsX1BvaW50U2l6ZSA9IHNpemUgKiAoIHNjYWxlIC8gLSBtdlBvc2l0aW9uLnogKTtcXG5cXHQjZWxzZVxcblxcdFxcdGdsX1BvaW50U2l6ZSA9IHNpemU7XFxuXFx0I2VuZGlmXFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8d29ybGRwb3NfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxzaGFkb3dtYXBfdmVydGV4Plxcbn1cXG5cIjtcblxuICAgIHZhciBzaGFkb3dfZnJhZyA9IFwidW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPHBhY2tpbmc+XFxuI2luY2x1ZGUgPGJzZGZzPlxcbiNpbmNsdWRlIDxsaWdodHNfcGFycz5cXG4jaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHNoYWRvd21hc2tfcGFyc19mcmFnbWVudD5cXG52b2lkIG1haW4oKSB7XFxuXFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggMC4wLCAwLjAsIDAuMCwgb3BhY2l0eSAqICggMS4wICAtIGdldFNoYWRvd01hc2soKSApICk7XFxufVxcblwiO1xuXG4gICAgdmFyIHNoYWRvd192ZXJ0ID0gXCIjaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfdmVydGV4PlxcbnZvaWQgbWFpbigpIHtcXG5cXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxcblxcdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8d29ybGRwb3NfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxzaGFkb3dtYXBfdmVydGV4Plxcbn1cXG5cIjtcblxuICAgIHZhciBTaGFkZXJDaHVuayA9IHtcbiAgICBcdGFscGhhbWFwX2ZyYWdtZW50OiBhbHBoYW1hcF9mcmFnbWVudCxcbiAgICBcdGFscGhhbWFwX3BhcnNfZnJhZ21lbnQ6IGFscGhhbWFwX3BhcnNfZnJhZ21lbnQsXG4gICAgXHRhbHBoYXRlc3RfZnJhZ21lbnQ6IGFscGhhdGVzdF9mcmFnbWVudCxcbiAgICBcdGFvbWFwX2ZyYWdtZW50OiBhb21hcF9mcmFnbWVudCxcbiAgICBcdGFvbWFwX3BhcnNfZnJhZ21lbnQ6IGFvbWFwX3BhcnNfZnJhZ21lbnQsXG4gICAgXHRiZWdpbl92ZXJ0ZXg6IGJlZ2luX3ZlcnRleCxcbiAgICBcdGJlZ2lubm9ybWFsX3ZlcnRleDogYmVnaW5ub3JtYWxfdmVydGV4LFxuICAgIFx0YnNkZnM6IGJzZGZzLFxuICAgIFx0YnVtcG1hcF9wYXJzX2ZyYWdtZW50OiBidW1wbWFwX3BhcnNfZnJhZ21lbnQsXG4gICAgXHRjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ6IGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudCxcbiAgICBcdGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50OiBjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudCxcbiAgICBcdGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleDogY2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4LFxuICAgIFx0Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleDogY2xpcHBpbmdfcGxhbmVzX3ZlcnRleCxcbiAgICBcdGNvbG9yX2ZyYWdtZW50OiBjb2xvcl9mcmFnbWVudCxcbiAgICBcdGNvbG9yX3BhcnNfZnJhZ21lbnQ6IGNvbG9yX3BhcnNfZnJhZ21lbnQsXG4gICAgXHRjb2xvcl9wYXJzX3ZlcnRleDogY29sb3JfcGFyc192ZXJ0ZXgsXG4gICAgXHRjb2xvcl92ZXJ0ZXg6IGNvbG9yX3ZlcnRleCxcbiAgICBcdGNvbW1vbjogY29tbW9uLFxuICAgIFx0Y3ViZV91dl9yZWZsZWN0aW9uX2ZyYWdtZW50OiBjdWJlX3V2X3JlZmxlY3Rpb25fZnJhZ21lbnQsXG4gICAgXHRkZWZhdWx0bm9ybWFsX3ZlcnRleDogZGVmYXVsdG5vcm1hbF92ZXJ0ZXgsXG4gICAgXHRkaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXg6IGRpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleCxcbiAgICBcdGRpc3BsYWNlbWVudG1hcF92ZXJ0ZXg6IGRpc3BsYWNlbWVudG1hcF92ZXJ0ZXgsXG4gICAgXHRlbWlzc2l2ZW1hcF9mcmFnbWVudDogZW1pc3NpdmVtYXBfZnJhZ21lbnQsXG4gICAgXHRlbWlzc2l2ZW1hcF9wYXJzX2ZyYWdtZW50OiBlbWlzc2l2ZW1hcF9wYXJzX2ZyYWdtZW50LFxuICAgIFx0ZW5jb2RpbmdzX2ZyYWdtZW50OiBlbmNvZGluZ3NfZnJhZ21lbnQsXG4gICAgXHRlbmNvZGluZ3NfcGFyc19mcmFnbWVudDogZW5jb2RpbmdzX3BhcnNfZnJhZ21lbnQsXG4gICAgXHRlbnZtYXBfZnJhZ21lbnQ6IGVudm1hcF9mcmFnbWVudCxcbiAgICBcdGVudm1hcF9wYXJzX2ZyYWdtZW50OiBlbnZtYXBfcGFyc19mcmFnbWVudCxcbiAgICBcdGVudm1hcF9wYXJzX3ZlcnRleDogZW52bWFwX3BhcnNfdmVydGV4LFxuICAgIFx0ZW52bWFwX3ZlcnRleDogZW52bWFwX3ZlcnRleCxcbiAgICBcdGZvZ19mcmFnbWVudDogZm9nX2ZyYWdtZW50LFxuICAgIFx0Zm9nX3BhcnNfZnJhZ21lbnQ6IGZvZ19wYXJzX2ZyYWdtZW50LFxuICAgIFx0bGlnaHRtYXBfZnJhZ21lbnQ6IGxpZ2h0bWFwX2ZyYWdtZW50LFxuICAgIFx0bGlnaHRtYXBfcGFyc19mcmFnbWVudDogbGlnaHRtYXBfcGFyc19mcmFnbWVudCxcbiAgICBcdGxpZ2h0c19sYW1iZXJ0X3ZlcnRleDogbGlnaHRzX2xhbWJlcnRfdmVydGV4LFxuICAgIFx0bGlnaHRzX3BhcnM6IGxpZ2h0c19wYXJzLFxuICAgIFx0bGlnaHRzX3Bob25nX2ZyYWdtZW50OiBsaWdodHNfcGhvbmdfZnJhZ21lbnQsXG4gICAgXHRsaWdodHNfcGhvbmdfcGFyc19mcmFnbWVudDogbGlnaHRzX3Bob25nX3BhcnNfZnJhZ21lbnQsXG4gICAgXHRsaWdodHNfcGh5c2ljYWxfZnJhZ21lbnQ6IGxpZ2h0c19waHlzaWNhbF9mcmFnbWVudCxcbiAgICBcdGxpZ2h0c19waHlzaWNhbF9wYXJzX2ZyYWdtZW50OiBsaWdodHNfcGh5c2ljYWxfcGFyc19mcmFnbWVudCxcbiAgICBcdGxpZ2h0c190ZW1wbGF0ZTogbGlnaHRzX3RlbXBsYXRlLFxuICAgIFx0bG9nZGVwdGhidWZfZnJhZ21lbnQ6IGxvZ2RlcHRoYnVmX2ZyYWdtZW50LFxuICAgIFx0bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudDogbG9nZGVwdGhidWZfcGFyc19mcmFnbWVudCxcbiAgICBcdGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4OiBsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleCxcbiAgICBcdGxvZ2RlcHRoYnVmX3ZlcnRleDogbG9nZGVwdGhidWZfdmVydGV4LFxuICAgIFx0bWFwX2ZyYWdtZW50OiBtYXBfZnJhZ21lbnQsXG4gICAgXHRtYXBfcGFyc19mcmFnbWVudDogbWFwX3BhcnNfZnJhZ21lbnQsXG4gICAgXHRtYXBfcGFydGljbGVfZnJhZ21lbnQ6IG1hcF9wYXJ0aWNsZV9mcmFnbWVudCxcbiAgICBcdG1hcF9wYXJ0aWNsZV9wYXJzX2ZyYWdtZW50OiBtYXBfcGFydGljbGVfcGFyc19mcmFnbWVudCxcbiAgICBcdG1ldGFsbmVzc21hcF9mcmFnbWVudDogbWV0YWxuZXNzbWFwX2ZyYWdtZW50LFxuICAgIFx0bWV0YWxuZXNzbWFwX3BhcnNfZnJhZ21lbnQ6IG1ldGFsbmVzc21hcF9wYXJzX2ZyYWdtZW50LFxuICAgIFx0bW9ycGhub3JtYWxfdmVydGV4OiBtb3JwaG5vcm1hbF92ZXJ0ZXgsXG4gICAgXHRtb3JwaHRhcmdldF9wYXJzX3ZlcnRleDogbW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXgsXG4gICAgXHRtb3JwaHRhcmdldF92ZXJ0ZXg6IG1vcnBodGFyZ2V0X3ZlcnRleCxcbiAgICBcdG5vcm1hbF9mbGlwOiBub3JtYWxfZmxpcCxcbiAgICBcdG5vcm1hbF9mcmFnbWVudDogbm9ybWFsX2ZyYWdtZW50LFxuICAgIFx0bm9ybWFsbWFwX3BhcnNfZnJhZ21lbnQ6IG5vcm1hbG1hcF9wYXJzX2ZyYWdtZW50LFxuICAgIFx0cGFja2luZzogcGFja2luZyxcbiAgICBcdHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQ6IHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQsXG4gICAgXHRwcm9qZWN0X3ZlcnRleDogcHJvamVjdF92ZXJ0ZXgsXG4gICAgXHRyb3VnaG5lc3NtYXBfZnJhZ21lbnQ6IHJvdWdobmVzc21hcF9mcmFnbWVudCxcbiAgICBcdHJvdWdobmVzc21hcF9wYXJzX2ZyYWdtZW50OiByb3VnaG5lc3NtYXBfcGFyc19mcmFnbWVudCxcbiAgICBcdHNoYWRvd21hcF9wYXJzX2ZyYWdtZW50OiBzaGFkb3dtYXBfcGFyc19mcmFnbWVudCxcbiAgICBcdHNoYWRvd21hcF9wYXJzX3ZlcnRleDogc2hhZG93bWFwX3BhcnNfdmVydGV4LFxuICAgIFx0c2hhZG93bWFwX3ZlcnRleDogc2hhZG93bWFwX3ZlcnRleCxcbiAgICBcdHNoYWRvd21hc2tfcGFyc19mcmFnbWVudDogc2hhZG93bWFza19wYXJzX2ZyYWdtZW50LFxuICAgIFx0c2tpbmJhc2VfdmVydGV4OiBza2luYmFzZV92ZXJ0ZXgsXG4gICAgXHRza2lubmluZ19wYXJzX3ZlcnRleDogc2tpbm5pbmdfcGFyc192ZXJ0ZXgsXG4gICAgXHRza2lubmluZ192ZXJ0ZXg6IHNraW5uaW5nX3ZlcnRleCxcbiAgICBcdHNraW5ub3JtYWxfdmVydGV4OiBza2lubm9ybWFsX3ZlcnRleCxcbiAgICBcdHNwZWN1bGFybWFwX2ZyYWdtZW50OiBzcGVjdWxhcm1hcF9mcmFnbWVudCxcbiAgICBcdHNwZWN1bGFybWFwX3BhcnNfZnJhZ21lbnQ6IHNwZWN1bGFybWFwX3BhcnNfZnJhZ21lbnQsXG4gICAgXHR0b25lbWFwcGluZ19mcmFnbWVudDogdG9uZW1hcHBpbmdfZnJhZ21lbnQsXG4gICAgXHR0b25lbWFwcGluZ19wYXJzX2ZyYWdtZW50OiB0b25lbWFwcGluZ19wYXJzX2ZyYWdtZW50LFxuICAgIFx0dXZfcGFyc19mcmFnbWVudDogdXZfcGFyc19mcmFnbWVudCxcbiAgICBcdHV2X3BhcnNfdmVydGV4OiB1dl9wYXJzX3ZlcnRleCxcbiAgICBcdHV2X3ZlcnRleDogdXZfdmVydGV4LFxuICAgIFx0dXYyX3BhcnNfZnJhZ21lbnQ6IHV2Ml9wYXJzX2ZyYWdtZW50LFxuICAgIFx0dXYyX3BhcnNfdmVydGV4OiB1djJfcGFyc192ZXJ0ZXgsXG4gICAgXHR1djJfdmVydGV4OiB1djJfdmVydGV4LFxuICAgIFx0d29ybGRwb3NfdmVydGV4OiB3b3JsZHBvc192ZXJ0ZXgsXG5cbiAgICBcdGN1YmVfZnJhZzogY3ViZV9mcmFnLFxuICAgIFx0Y3ViZV92ZXJ0OiBjdWJlX3ZlcnQsXG4gICAgXHRkZXB0aF9mcmFnOiBkZXB0aF9mcmFnLFxuICAgIFx0ZGVwdGhfdmVydDogZGVwdGhfdmVydCxcbiAgICBcdGRpc3RhbmNlUkdCQV9mcmFnOiBkaXN0YW5jZVJHQkFfZnJhZyxcbiAgICBcdGRpc3RhbmNlUkdCQV92ZXJ0OiBkaXN0YW5jZVJHQkFfdmVydCxcbiAgICBcdGVxdWlyZWN0X2ZyYWc6IGVxdWlyZWN0X2ZyYWcsXG4gICAgXHRlcXVpcmVjdF92ZXJ0OiBlcXVpcmVjdF92ZXJ0LFxuICAgIFx0bGluZWRhc2hlZF9mcmFnOiBsaW5lZGFzaGVkX2ZyYWcsXG4gICAgXHRsaW5lZGFzaGVkX3ZlcnQ6IGxpbmVkYXNoZWRfdmVydCxcbiAgICBcdG1lc2hiYXNpY19mcmFnOiBtZXNoYmFzaWNfZnJhZyxcbiAgICBcdG1lc2hiYXNpY192ZXJ0OiBtZXNoYmFzaWNfdmVydCxcbiAgICBcdG1lc2hsYW1iZXJ0X2ZyYWc6IG1lc2hsYW1iZXJ0X2ZyYWcsXG4gICAgXHRtZXNobGFtYmVydF92ZXJ0OiBtZXNobGFtYmVydF92ZXJ0LFxuICAgIFx0bWVzaHBob25nX2ZyYWc6IG1lc2hwaG9uZ19mcmFnLFxuICAgIFx0bWVzaHBob25nX3ZlcnQ6IG1lc2hwaG9uZ192ZXJ0LFxuICAgIFx0bWVzaHBoeXNpY2FsX2ZyYWc6IG1lc2hwaHlzaWNhbF9mcmFnLFxuICAgIFx0bWVzaHBoeXNpY2FsX3ZlcnQ6IG1lc2hwaHlzaWNhbF92ZXJ0LFxuICAgIFx0bm9ybWFsX2ZyYWc6IG5vcm1hbF9mcmFnLFxuICAgIFx0bm9ybWFsX3ZlcnQ6IG5vcm1hbF92ZXJ0LFxuICAgIFx0cG9pbnRzX2ZyYWc6IHBvaW50c19mcmFnLFxuICAgIFx0cG9pbnRzX3ZlcnQ6IHBvaW50c192ZXJ0LFxuICAgIFx0c2hhZG93X2ZyYWc6IHNoYWRvd19mcmFnLFxuICAgIFx0c2hhZG93X3ZlcnQ6IHNoYWRvd192ZXJ0XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBDb2xvciggciwgZywgYiApIHtcblxuICAgIFx0aWYgKCBnID09PSB1bmRlZmluZWQgJiYgYiA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdC8vIHIgaXMgVEhSRUUuQ29sb3IsIGhleCBvciBzdHJpbmdcbiAgICBcdFx0cmV0dXJuIHRoaXMuc2V0KCByICk7XG5cbiAgICBcdH1cblxuICAgIFx0cmV0dXJuIHRoaXMuc2V0UkdCKCByLCBnLCBiICk7XG5cbiAgICB9XG5cbiAgICBDb2xvci5wcm90b3R5cGUgPSB7XG5cbiAgICBcdGNvbnN0cnVjdG9yOiBDb2xvcixcblxuICAgIFx0aXNDb2xvcjogdHJ1ZSxcblxuICAgIFx0cjogMSwgZzogMSwgYjogMSxcblxuICAgIFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG4gICAgXHRcdGlmICggKHZhbHVlICYmIHZhbHVlLmlzQ29sb3IpICkge1xuXG4gICAgXHRcdFx0dGhpcy5jb3B5KCB2YWx1ZSApO1xuXG4gICAgXHRcdH0gZWxzZSBpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgKSB7XG5cbiAgICBcdFx0XHR0aGlzLnNldEhleCggdmFsdWUgKTtcblxuICAgIFx0XHR9IGVsc2UgaWYgKCB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICkge1xuXG4gICAgXHRcdFx0dGhpcy5zZXRTdHlsZSggdmFsdWUgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldFNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XG5cbiAgICBcdFx0dGhpcy5yID0gc2NhbGFyO1xuICAgIFx0XHR0aGlzLmcgPSBzY2FsYXI7XG4gICAgXHRcdHRoaXMuYiA9IHNjYWxhcjtcblxuICAgIFx0fSxcblxuICAgIFx0c2V0SGV4OiBmdW5jdGlvbiAoIGhleCApIHtcblxuICAgIFx0XHRoZXggPSBNYXRoLmZsb29yKCBoZXggKTtcblxuICAgIFx0XHR0aGlzLnIgPSAoIGhleCA+PiAxNiAmIDI1NSApIC8gMjU1O1xuICAgIFx0XHR0aGlzLmcgPSAoIGhleCA+PiA4ICYgMjU1ICkgLyAyNTU7XG4gICAgXHRcdHRoaXMuYiA9ICggaGV4ICYgMjU1ICkgLyAyNTU7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldFJHQjogZnVuY3Rpb24gKCByLCBnLCBiICkge1xuXG4gICAgXHRcdHRoaXMuciA9IHI7XG4gICAgXHRcdHRoaXMuZyA9IGc7XG4gICAgXHRcdHRoaXMuYiA9IGI7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldEhTTDogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdGZ1bmN0aW9uIGh1ZTJyZ2IoIHAsIHEsIHQgKSB7XG5cbiAgICBcdFx0XHRpZiAoIHQgPCAwICkgdCArPSAxO1xuICAgIFx0XHRcdGlmICggdCA+IDEgKSB0IC09IDE7XG4gICAgXHRcdFx0aWYgKCB0IDwgMSAvIDYgKSByZXR1cm4gcCArICggcSAtIHAgKSAqIDYgKiB0O1xuICAgIFx0XHRcdGlmICggdCA8IDEgLyAyICkgcmV0dXJuIHE7XG4gICAgXHRcdFx0aWYgKCB0IDwgMiAvIDMgKSByZXR1cm4gcCArICggcSAtIHAgKSAqIDYgKiAoIDIgLyAzIC0gdCApO1xuICAgIFx0XHRcdHJldHVybiBwO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gZnVuY3Rpb24gc2V0SFNMKCBoLCBzLCBsICkge1xuXG4gICAgXHRcdFx0Ly8gaCxzLGwgcmFuZ2VzIGFyZSBpbiAwLjAgLSAxLjBcbiAgICBcdFx0XHRoID0gZXhwb3J0cy5NYXRoLmV1Y2xpZGVhbk1vZHVsbyggaCwgMSApO1xuICAgIFx0XHRcdHMgPSBleHBvcnRzLk1hdGguY2xhbXAoIHMsIDAsIDEgKTtcbiAgICBcdFx0XHRsID0gZXhwb3J0cy5NYXRoLmNsYW1wKCBsLCAwLCAxICk7XG5cbiAgICBcdFx0XHRpZiAoIHMgPT09IDAgKSB7XG5cbiAgICBcdFx0XHRcdHRoaXMuciA9IHRoaXMuZyA9IHRoaXMuYiA9IGw7XG5cbiAgICBcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHR2YXIgcCA9IGwgPD0gMC41ID8gbCAqICggMSArIHMgKSA6IGwgKyBzIC0gKCBsICogcyApO1xuICAgIFx0XHRcdFx0dmFyIHEgPSAoIDIgKiBsICkgLSBwO1xuXG4gICAgXHRcdFx0XHR0aGlzLnIgPSBodWUycmdiKCBxLCBwLCBoICsgMSAvIDMgKTtcbiAgICBcdFx0XHRcdHRoaXMuZyA9IGh1ZTJyZ2IoIHEsIHAsIGggKTtcbiAgICBcdFx0XHRcdHRoaXMuYiA9IGh1ZTJyZ2IoIHEsIHAsIGggLSAxIC8gMyApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdFx0fTtcblxuICAgIFx0fSgpLFxuXG4gICAgXHRzZXRTdHlsZTogZnVuY3Rpb24gKCBzdHlsZSApIHtcblxuICAgIFx0XHRmdW5jdGlvbiBoYW5kbGVBbHBoYSggc3RyaW5nICkge1xuXG4gICAgXHRcdFx0aWYgKCBzdHJpbmcgPT09IHVuZGVmaW5lZCApIHJldHVybjtcblxuICAgIFx0XHRcdGlmICggcGFyc2VGbG9hdCggc3RyaW5nICkgPCAxICkge1xuXG4gICAgXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Db2xvcjogQWxwaGEgY29tcG9uZW50IG9mICcgKyBzdHlsZSArICcgd2lsbCBiZSBpZ25vcmVkLicgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cblxuICAgIFx0XHR2YXIgbTtcblxuICAgIFx0XHRpZiAoIG0gPSAvXigoPzpyZ2J8aHNsKWE/KVxcKFxccyooW15cXCldKilcXCkvLmV4ZWMoIHN0eWxlICkgKSB7XG5cbiAgICBcdFx0XHQvLyByZ2IgLyBoc2xcblxuICAgIFx0XHRcdHZhciBjb2xvcjtcbiAgICBcdFx0XHR2YXIgbmFtZSA9IG1bIDEgXTtcbiAgICBcdFx0XHR2YXIgY29tcG9uZW50cyA9IG1bIDIgXTtcblxuICAgIFx0XHRcdHN3aXRjaCAoIG5hbWUgKSB7XG5cbiAgICBcdFx0XHRcdGNhc2UgJ3JnYic6XG4gICAgXHRcdFx0XHRjYXNlICdyZ2JhJzpcblxuICAgIFx0XHRcdFx0XHRpZiAoIGNvbG9yID0gL14oXFxkKylcXHMqLFxccyooXFxkKylcXHMqLFxccyooXFxkKylcXHMqKCxcXHMqKFswLTldKlxcLj9bMC05XSspXFxzKik/JC8uZXhlYyggY29tcG9uZW50cyApICkge1xuXG4gICAgXHRcdFx0XHRcdFx0Ly8gcmdiKDI1NSwwLDApIHJnYmEoMjU1LDAsMCwwLjUpXG4gICAgXHRcdFx0XHRcdFx0dGhpcy5yID0gTWF0aC5taW4oIDI1NSwgcGFyc2VJbnQoIGNvbG9yWyAxIF0sIDEwICkgKSAvIDI1NTtcbiAgICBcdFx0XHRcdFx0XHR0aGlzLmcgPSBNYXRoLm1pbiggMjU1LCBwYXJzZUludCggY29sb3JbIDIgXSwgMTAgKSApIC8gMjU1O1xuICAgIFx0XHRcdFx0XHRcdHRoaXMuYiA9IE1hdGgubWluKCAyNTUsIHBhcnNlSW50KCBjb2xvclsgMyBdLCAxMCApICkgLyAyNTU7XG5cbiAgICBcdFx0XHRcdFx0XHRoYW5kbGVBbHBoYSggY29sb3JbIDUgXSApO1xuXG4gICAgXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRcdGlmICggY29sb3IgPSAvXihcXGQrKVxcJVxccyosXFxzKihcXGQrKVxcJVxccyosXFxzKihcXGQrKVxcJVxccyooLFxccyooWzAtOV0qXFwuP1swLTldKylcXHMqKT8kLy5leGVjKCBjb21wb25lbnRzICkgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHQvLyByZ2IoMTAwJSwwJSwwJSkgcmdiYSgxMDAlLDAlLDAlLDAuNSlcbiAgICBcdFx0XHRcdFx0XHR0aGlzLnIgPSBNYXRoLm1pbiggMTAwLCBwYXJzZUludCggY29sb3JbIDEgXSwgMTAgKSApIC8gMTAwO1xuICAgIFx0XHRcdFx0XHRcdHRoaXMuZyA9IE1hdGgubWluKCAxMDAsIHBhcnNlSW50KCBjb2xvclsgMiBdLCAxMCApICkgLyAxMDA7XG4gICAgXHRcdFx0XHRcdFx0dGhpcy5iID0gTWF0aC5taW4oIDEwMCwgcGFyc2VJbnQoIGNvbG9yWyAzIF0sIDEwICkgKSAvIDEwMDtcblxuICAgIFx0XHRcdFx0XHRcdGhhbmRsZUFscGhhKCBjb2xvclsgNSBdICk7XG5cbiAgICBcdFx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdFx0YnJlYWs7XG5cbiAgICBcdFx0XHRcdGNhc2UgJ2hzbCc6XG4gICAgXHRcdFx0XHRjYXNlICdoc2xhJzpcblxuICAgIFx0XHRcdFx0XHRpZiAoIGNvbG9yID0gL14oWzAtOV0qXFwuP1swLTldKylcXHMqLFxccyooXFxkKylcXCVcXHMqLFxccyooXFxkKylcXCVcXHMqKCxcXHMqKFswLTldKlxcLj9bMC05XSspXFxzKik/JC8uZXhlYyggY29tcG9uZW50cyApICkge1xuXG4gICAgXHRcdFx0XHRcdFx0Ly8gaHNsKDEyMCw1MCUsNTAlKSBoc2xhKDEyMCw1MCUsNTAlLDAuNSlcbiAgICBcdFx0XHRcdFx0XHR2YXIgaCA9IHBhcnNlRmxvYXQoIGNvbG9yWyAxIF0gKSAvIDM2MDtcbiAgICBcdFx0XHRcdFx0XHR2YXIgcyA9IHBhcnNlSW50KCBjb2xvclsgMiBdLCAxMCApIC8gMTAwO1xuICAgIFx0XHRcdFx0XHRcdHZhciBsID0gcGFyc2VJbnQoIGNvbG9yWyAzIF0sIDEwICkgLyAxMDA7XG5cbiAgICBcdFx0XHRcdFx0XHRoYW5kbGVBbHBoYSggY29sb3JbIDUgXSApO1xuXG4gICAgXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuc2V0SFNMKCBoLCBzLCBsICk7XG5cbiAgICBcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRcdGJyZWFrO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH0gZWxzZSBpZiAoIG0gPSAvXlxcIyhbQS1GYS1mMC05XSspJC8uZXhlYyggc3R5bGUgKSApIHtcblxuICAgIFx0XHRcdC8vIGhleCBjb2xvclxuXG4gICAgXHRcdFx0dmFyIGhleCA9IG1bIDEgXTtcbiAgICBcdFx0XHR2YXIgc2l6ZSA9IGhleC5sZW5ndGg7XG5cbiAgICBcdFx0XHRpZiAoIHNpemUgPT09IDMgKSB7XG5cbiAgICBcdFx0XHRcdC8vICNmZjBcbiAgICBcdFx0XHRcdHRoaXMuciA9IHBhcnNlSW50KCBoZXguY2hhckF0KCAwICkgKyBoZXguY2hhckF0KCAwICksIDE2ICkgLyAyNTU7XG4gICAgXHRcdFx0XHR0aGlzLmcgPSBwYXJzZUludCggaGV4LmNoYXJBdCggMSApICsgaGV4LmNoYXJBdCggMSApLCAxNiApIC8gMjU1O1xuICAgIFx0XHRcdFx0dGhpcy5iID0gcGFyc2VJbnQoIGhleC5jaGFyQXQoIDIgKSArIGhleC5jaGFyQXQoIDIgKSwgMTYgKSAvIDI1NTtcblxuICAgIFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdFx0XHR9IGVsc2UgaWYgKCBzaXplID09PSA2ICkge1xuXG4gICAgXHRcdFx0XHQvLyAjZmYwMDAwXG4gICAgXHRcdFx0XHR0aGlzLnIgPSBwYXJzZUludCggaGV4LmNoYXJBdCggMCApICsgaGV4LmNoYXJBdCggMSApLCAxNiApIC8gMjU1O1xuICAgIFx0XHRcdFx0dGhpcy5nID0gcGFyc2VJbnQoIGhleC5jaGFyQXQoIDIgKSArIGhleC5jaGFyQXQoIDMgKSwgMTYgKSAvIDI1NTtcbiAgICBcdFx0XHRcdHRoaXMuYiA9IHBhcnNlSW50KCBoZXguY2hhckF0KCA0ICkgKyBoZXguY2hhckF0KCA1ICksIDE2ICkgLyAyNTU7XG5cbiAgICBcdFx0XHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoIHN0eWxlICYmIHN0eWxlLmxlbmd0aCA+IDAgKSB7XG5cbiAgICBcdFx0XHQvLyBjb2xvciBrZXl3b3Jkc1xuICAgIFx0XHRcdHZhciBoZXggPSBleHBvcnRzLkNvbG9yS2V5d29yZHNbIHN0eWxlIF07XG5cbiAgICBcdFx0XHRpZiAoIGhleCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0XHQvLyByZWRcbiAgICBcdFx0XHRcdHRoaXMuc2V0SGV4KCBoZXggKTtcblxuICAgIFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdC8vIHVua25vd24gY29sb3JcbiAgICBcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkNvbG9yOiBVbmtub3duIGNvbG9yICcgKyBzdHlsZSApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMuciwgdGhpcy5nLCB0aGlzLmIgKTtcblxuICAgIFx0fSxcblxuICAgIFx0Y29weTogZnVuY3Rpb24gKCBjb2xvciApIHtcblxuICAgIFx0XHR0aGlzLnIgPSBjb2xvci5yO1xuICAgIFx0XHR0aGlzLmcgPSBjb2xvci5nO1xuICAgIFx0XHR0aGlzLmIgPSBjb2xvci5iO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRjb3B5R2FtbWFUb0xpbmVhcjogZnVuY3Rpb24gKCBjb2xvciwgZ2FtbWFGYWN0b3IgKSB7XG5cbiAgICBcdFx0aWYgKCBnYW1tYUZhY3RvciA9PT0gdW5kZWZpbmVkICkgZ2FtbWFGYWN0b3IgPSAyLjA7XG5cbiAgICBcdFx0dGhpcy5yID0gTWF0aC5wb3coIGNvbG9yLnIsIGdhbW1hRmFjdG9yICk7XG4gICAgXHRcdHRoaXMuZyA9IE1hdGgucG93KCBjb2xvci5nLCBnYW1tYUZhY3RvciApO1xuICAgIFx0XHR0aGlzLmIgPSBNYXRoLnBvdyggY29sb3IuYiwgZ2FtbWFGYWN0b3IgKTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0Y29weUxpbmVhclRvR2FtbWE6IGZ1bmN0aW9uICggY29sb3IsIGdhbW1hRmFjdG9yICkge1xuXG4gICAgXHRcdGlmICggZ2FtbWFGYWN0b3IgPT09IHVuZGVmaW5lZCApIGdhbW1hRmFjdG9yID0gMi4wO1xuXG4gICAgXHRcdHZhciBzYWZlSW52ZXJzZSA9ICggZ2FtbWFGYWN0b3IgPiAwICkgPyAoIDEuMCAvIGdhbW1hRmFjdG9yICkgOiAxLjA7XG5cbiAgICBcdFx0dGhpcy5yID0gTWF0aC5wb3coIGNvbG9yLnIsIHNhZmVJbnZlcnNlICk7XG4gICAgXHRcdHRoaXMuZyA9IE1hdGgucG93KCBjb2xvci5nLCBzYWZlSW52ZXJzZSApO1xuICAgIFx0XHR0aGlzLmIgPSBNYXRoLnBvdyggY29sb3IuYiwgc2FmZUludmVyc2UgKTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0Y29udmVydEdhbW1hVG9MaW5lYXI6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR2YXIgciA9IHRoaXMuciwgZyA9IHRoaXMuZywgYiA9IHRoaXMuYjtcblxuICAgIFx0XHR0aGlzLnIgPSByICogcjtcbiAgICBcdFx0dGhpcy5nID0gZyAqIGc7XG4gICAgXHRcdHRoaXMuYiA9IGIgKiBiO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRjb252ZXJ0TGluZWFyVG9HYW1tYTogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHRoaXMuciA9IE1hdGguc3FydCggdGhpcy5yICk7XG4gICAgXHRcdHRoaXMuZyA9IE1hdGguc3FydCggdGhpcy5nICk7XG4gICAgXHRcdHRoaXMuYiA9IE1hdGguc3FydCggdGhpcy5iICk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGdldEhleDogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHJldHVybiAoIHRoaXMuciAqIDI1NSApIDw8IDE2IF4gKCB0aGlzLmcgKiAyNTUgKSA8PCA4IF4gKCB0aGlzLmIgKiAyNTUgKSA8PCAwO1xuXG4gICAgXHR9LFxuXG4gICAgXHRnZXRIZXhTdHJpbmc6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHRyZXR1cm4gKCAnMDAwMDAwJyArIHRoaXMuZ2V0SGV4KCkudG9TdHJpbmcoIDE2ICkgKS5zbGljZSggLSA2ICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGdldEhTTDogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgIFx0XHQvLyBoLHMsbCByYW5nZXMgYXJlIGluIDAuMCAtIDEuMFxuXG4gICAgXHRcdHZhciBoc2wgPSBvcHRpb25hbFRhcmdldCB8fCB7IGg6IDAsIHM6IDAsIGw6IDAgfTtcblxuICAgIFx0XHR2YXIgciA9IHRoaXMuciwgZyA9IHRoaXMuZywgYiA9IHRoaXMuYjtcblxuICAgIFx0XHR2YXIgbWF4ID0gTWF0aC5tYXgoIHIsIGcsIGIgKTtcbiAgICBcdFx0dmFyIG1pbiA9IE1hdGgubWluKCByLCBnLCBiICk7XG5cbiAgICBcdFx0dmFyIGh1ZSwgc2F0dXJhdGlvbjtcbiAgICBcdFx0dmFyIGxpZ2h0bmVzcyA9ICggbWluICsgbWF4ICkgLyAyLjA7XG5cbiAgICBcdFx0aWYgKCBtaW4gPT09IG1heCApIHtcblxuICAgIFx0XHRcdGh1ZSA9IDA7XG4gICAgXHRcdFx0c2F0dXJhdGlvbiA9IDA7XG5cbiAgICBcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdHZhciBkZWx0YSA9IG1heCAtIG1pbjtcblxuICAgIFx0XHRcdHNhdHVyYXRpb24gPSBsaWdodG5lc3MgPD0gMC41ID8gZGVsdGEgLyAoIG1heCArIG1pbiApIDogZGVsdGEgLyAoIDIgLSBtYXggLSBtaW4gKTtcblxuICAgIFx0XHRcdHN3aXRjaCAoIG1heCApIHtcblxuICAgIFx0XHRcdFx0Y2FzZSByOiBodWUgPSAoIGcgLSBiICkgLyBkZWx0YSArICggZyA8IGIgPyA2IDogMCApOyBicmVhaztcbiAgICBcdFx0XHRcdGNhc2UgZzogaHVlID0gKCBiIC0gciApIC8gZGVsdGEgKyAyOyBicmVhaztcbiAgICBcdFx0XHRcdGNhc2UgYjogaHVlID0gKCByIC0gZyApIC8gZGVsdGEgKyA0OyBicmVhaztcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGh1ZSAvPSA2O1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRoc2wuaCA9IGh1ZTtcbiAgICBcdFx0aHNsLnMgPSBzYXR1cmF0aW9uO1xuICAgIFx0XHRoc2wubCA9IGxpZ2h0bmVzcztcblxuICAgIFx0XHRyZXR1cm4gaHNsO1xuXG4gICAgXHR9LFxuXG4gICAgXHRnZXRTdHlsZTogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHJldHVybiAncmdiKCcgKyAoICggdGhpcy5yICogMjU1ICkgfCAwICkgKyAnLCcgKyAoICggdGhpcy5nICogMjU1ICkgfCAwICkgKyAnLCcgKyAoICggdGhpcy5iICogMjU1ICkgfCAwICkgKyAnKSc7XG5cbiAgICBcdH0sXG5cbiAgICBcdG9mZnNldEhTTDogZnVuY3Rpb24gKCBoLCBzLCBsICkge1xuXG4gICAgXHRcdHZhciBoc2wgPSB0aGlzLmdldEhTTCgpO1xuXG4gICAgXHRcdGhzbC5oICs9IGg7IGhzbC5zICs9IHM7IGhzbC5sICs9IGw7XG5cbiAgICBcdFx0dGhpcy5zZXRIU0woIGhzbC5oLCBoc2wucywgaHNsLmwgKTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0YWRkOiBmdW5jdGlvbiAoIGNvbG9yICkge1xuXG4gICAgXHRcdHRoaXMuciArPSBjb2xvci5yO1xuICAgIFx0XHR0aGlzLmcgKz0gY29sb3IuZztcbiAgICBcdFx0dGhpcy5iICs9IGNvbG9yLmI7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGFkZENvbG9yczogZnVuY3Rpb24gKCBjb2xvcjEsIGNvbG9yMiApIHtcblxuICAgIFx0XHR0aGlzLnIgPSBjb2xvcjEuciArIGNvbG9yMi5yO1xuICAgIFx0XHR0aGlzLmcgPSBjb2xvcjEuZyArIGNvbG9yMi5nO1xuICAgIFx0XHR0aGlzLmIgPSBjb2xvcjEuYiArIGNvbG9yMi5iO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRhZGRTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcblxuICAgIFx0XHR0aGlzLnIgKz0gcztcbiAgICBcdFx0dGhpcy5nICs9IHM7XG4gICAgXHRcdHRoaXMuYiArPSBzO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzdWI6IGZ1bmN0aW9uKCBjb2xvciApIHtcblxuICAgIFx0XHR0aGlzLnIgPSBNYXRoLm1heCggMCwgdGhpcy5yIC0gY29sb3IuciApO1xuICAgIFx0XHR0aGlzLmcgPSBNYXRoLm1heCggMCwgdGhpcy5nIC0gY29sb3IuZyApO1xuICAgIFx0XHR0aGlzLmIgPSBNYXRoLm1heCggMCwgdGhpcy5iIC0gY29sb3IuYiApO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRtdWx0aXBseTogZnVuY3Rpb24gKCBjb2xvciApIHtcblxuICAgIFx0XHR0aGlzLnIgKj0gY29sb3IucjtcbiAgICBcdFx0dGhpcy5nICo9IGNvbG9yLmc7XG4gICAgXHRcdHRoaXMuYiAqPSBjb2xvci5iO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRtdWx0aXBseVNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xuXG4gICAgXHRcdHRoaXMuciAqPSBzO1xuICAgIFx0XHR0aGlzLmcgKj0gcztcbiAgICBcdFx0dGhpcy5iICo9IHM7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGxlcnA6IGZ1bmN0aW9uICggY29sb3IsIGFscGhhICkge1xuXG4gICAgXHRcdHRoaXMuciArPSAoIGNvbG9yLnIgLSB0aGlzLnIgKSAqIGFscGhhO1xuICAgIFx0XHR0aGlzLmcgKz0gKCBjb2xvci5nIC0gdGhpcy5nICkgKiBhbHBoYTtcbiAgICBcdFx0dGhpcy5iICs9ICggY29sb3IuYiAtIHRoaXMuYiApICogYWxwaGE7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGVxdWFsczogZnVuY3Rpb24gKCBjICkge1xuXG4gICAgXHRcdHJldHVybiAoIGMuciA9PT0gdGhpcy5yICkgJiYgKCBjLmcgPT09IHRoaXMuZyApICYmICggYy5iID09PSB0aGlzLmIgKTtcblxuICAgIFx0fSxcblxuICAgIFx0ZnJvbUFycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XG5cbiAgICBcdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cbiAgICBcdFx0dGhpcy5yID0gYXJyYXlbIG9mZnNldCBdO1xuICAgIFx0XHR0aGlzLmcgPSBhcnJheVsgb2Zmc2V0ICsgMSBdO1xuICAgIFx0XHR0aGlzLmIgPSBhcnJheVsgb2Zmc2V0ICsgMiBdO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHR0b0FycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XG5cbiAgICBcdFx0aWYgKCBhcnJheSA9PT0gdW5kZWZpbmVkICkgYXJyYXkgPSBbXTtcbiAgICBcdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cbiAgICBcdFx0YXJyYXlbIG9mZnNldCBdID0gdGhpcy5yO1xuICAgIFx0XHRhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGhpcy5nO1xuICAgIFx0XHRhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGhpcy5iO1xuXG4gICAgXHRcdHJldHVybiBhcnJheTtcblxuICAgIFx0fSxcblxuICAgIFx0dG9KU09OOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMuZ2V0SGV4KCk7XG5cbiAgICBcdH1cblxuICAgIH07XG5cbiAgICBleHBvcnRzLkNvbG9yS2V5d29yZHMgPSB7ICdhbGljZWJsdWUnOiAweEYwRjhGRiwgJ2FudGlxdWV3aGl0ZSc6IDB4RkFFQkQ3LCAnYXF1YSc6IDB4MDBGRkZGLCAnYXF1YW1hcmluZSc6IDB4N0ZGRkQ0LCAnYXp1cmUnOiAweEYwRkZGRixcbiAgICAnYmVpZ2UnOiAweEY1RjVEQywgJ2Jpc3F1ZSc6IDB4RkZFNEM0LCAnYmxhY2snOiAweDAwMDAwMCwgJ2JsYW5jaGVkYWxtb25kJzogMHhGRkVCQ0QsICdibHVlJzogMHgwMDAwRkYsICdibHVldmlvbGV0JzogMHg4QTJCRTIsXG4gICAgJ2Jyb3duJzogMHhBNTJBMkEsICdidXJseXdvb2QnOiAweERFQjg4NywgJ2NhZGV0Ymx1ZSc6IDB4NUY5RUEwLCAnY2hhcnRyZXVzZSc6IDB4N0ZGRjAwLCAnY2hvY29sYXRlJzogMHhEMjY5MUUsICdjb3JhbCc6IDB4RkY3RjUwLFxuICAgICdjb3JuZmxvd2VyYmx1ZSc6IDB4NjQ5NUVELCAnY29ybnNpbGsnOiAweEZGRjhEQywgJ2NyaW1zb24nOiAweERDMTQzQywgJ2N5YW4nOiAweDAwRkZGRiwgJ2RhcmtibHVlJzogMHgwMDAwOEIsICdkYXJrY3lhbic6IDB4MDA4QjhCLFxuICAgICdkYXJrZ29sZGVucm9kJzogMHhCODg2MEIsICdkYXJrZ3JheSc6IDB4QTlBOUE5LCAnZGFya2dyZWVuJzogMHgwMDY0MDAsICdkYXJrZ3JleSc6IDB4QTlBOUE5LCAnZGFya2toYWtpJzogMHhCREI3NkIsICdkYXJrbWFnZW50YSc6IDB4OEIwMDhCLFxuICAgICdkYXJrb2xpdmVncmVlbic6IDB4NTU2QjJGLCAnZGFya29yYW5nZSc6IDB4RkY4QzAwLCAnZGFya29yY2hpZCc6IDB4OTkzMkNDLCAnZGFya3JlZCc6IDB4OEIwMDAwLCAnZGFya3NhbG1vbic6IDB4RTk5NjdBLCAnZGFya3NlYWdyZWVuJzogMHg4RkJDOEYsXG4gICAgJ2RhcmtzbGF0ZWJsdWUnOiAweDQ4M0Q4QiwgJ2RhcmtzbGF0ZWdyYXknOiAweDJGNEY0RiwgJ2RhcmtzbGF0ZWdyZXknOiAweDJGNEY0RiwgJ2Rhcmt0dXJxdW9pc2UnOiAweDAwQ0VEMSwgJ2Rhcmt2aW9sZXQnOiAweDk0MDBEMyxcbiAgICAnZGVlcHBpbmsnOiAweEZGMTQ5MywgJ2RlZXBza3libHVlJzogMHgwMEJGRkYsICdkaW1ncmF5JzogMHg2OTY5NjksICdkaW1ncmV5JzogMHg2OTY5NjksICdkb2RnZXJibHVlJzogMHgxRTkwRkYsICdmaXJlYnJpY2snOiAweEIyMjIyMixcbiAgICAnZmxvcmFsd2hpdGUnOiAweEZGRkFGMCwgJ2ZvcmVzdGdyZWVuJzogMHgyMjhCMjIsICdmdWNoc2lhJzogMHhGRjAwRkYsICdnYWluc2Jvcm8nOiAweERDRENEQywgJ2dob3N0d2hpdGUnOiAweEY4RjhGRiwgJ2dvbGQnOiAweEZGRDcwMCxcbiAgICAnZ29sZGVucm9kJzogMHhEQUE1MjAsICdncmF5JzogMHg4MDgwODAsICdncmVlbic6IDB4MDA4MDAwLCAnZ3JlZW55ZWxsb3cnOiAweEFERkYyRiwgJ2dyZXknOiAweDgwODA4MCwgJ2hvbmV5ZGV3JzogMHhGMEZGRjAsICdob3RwaW5rJzogMHhGRjY5QjQsXG4gICAgJ2luZGlhbnJlZCc6IDB4Q0Q1QzVDLCAnaW5kaWdvJzogMHg0QjAwODIsICdpdm9yeSc6IDB4RkZGRkYwLCAna2hha2knOiAweEYwRTY4QywgJ2xhdmVuZGVyJzogMHhFNkU2RkEsICdsYXZlbmRlcmJsdXNoJzogMHhGRkYwRjUsICdsYXduZ3JlZW4nOiAweDdDRkMwMCxcbiAgICAnbGVtb25jaGlmZm9uJzogMHhGRkZBQ0QsICdsaWdodGJsdWUnOiAweEFERDhFNiwgJ2xpZ2h0Y29yYWwnOiAweEYwODA4MCwgJ2xpZ2h0Y3lhbic6IDB4RTBGRkZGLCAnbGlnaHRnb2xkZW5yb2R5ZWxsb3cnOiAweEZBRkFEMiwgJ2xpZ2h0Z3JheSc6IDB4RDNEM0QzLFxuICAgICdsaWdodGdyZWVuJzogMHg5MEVFOTAsICdsaWdodGdyZXknOiAweEQzRDNEMywgJ2xpZ2h0cGluayc6IDB4RkZCNkMxLCAnbGlnaHRzYWxtb24nOiAweEZGQTA3QSwgJ2xpZ2h0c2VhZ3JlZW4nOiAweDIwQjJBQSwgJ2xpZ2h0c2t5Ymx1ZSc6IDB4ODdDRUZBLFxuICAgICdsaWdodHNsYXRlZ3JheSc6IDB4Nzc4ODk5LCAnbGlnaHRzbGF0ZWdyZXknOiAweDc3ODg5OSwgJ2xpZ2h0c3RlZWxibHVlJzogMHhCMEM0REUsICdsaWdodHllbGxvdyc6IDB4RkZGRkUwLCAnbGltZSc6IDB4MDBGRjAwLCAnbGltZWdyZWVuJzogMHgzMkNEMzIsXG4gICAgJ2xpbmVuJzogMHhGQUYwRTYsICdtYWdlbnRhJzogMHhGRjAwRkYsICdtYXJvb24nOiAweDgwMDAwMCwgJ21lZGl1bWFxdWFtYXJpbmUnOiAweDY2Q0RBQSwgJ21lZGl1bWJsdWUnOiAweDAwMDBDRCwgJ21lZGl1bW9yY2hpZCc6IDB4QkE1NUQzLFxuICAgICdtZWRpdW1wdXJwbGUnOiAweDkzNzBEQiwgJ21lZGl1bXNlYWdyZWVuJzogMHgzQ0IzNzEsICdtZWRpdW1zbGF0ZWJsdWUnOiAweDdCNjhFRSwgJ21lZGl1bXNwcmluZ2dyZWVuJzogMHgwMEZBOUEsICdtZWRpdW10dXJxdW9pc2UnOiAweDQ4RDFDQyxcbiAgICAnbWVkaXVtdmlvbGV0cmVkJzogMHhDNzE1ODUsICdtaWRuaWdodGJsdWUnOiAweDE5MTk3MCwgJ21pbnRjcmVhbSc6IDB4RjVGRkZBLCAnbWlzdHlyb3NlJzogMHhGRkU0RTEsICdtb2NjYXNpbic6IDB4RkZFNEI1LCAnbmF2YWpvd2hpdGUnOiAweEZGREVBRCxcbiAgICAnbmF2eSc6IDB4MDAwMDgwLCAnb2xkbGFjZSc6IDB4RkRGNUU2LCAnb2xpdmUnOiAweDgwODAwMCwgJ29saXZlZHJhYic6IDB4NkI4RTIzLCAnb3JhbmdlJzogMHhGRkE1MDAsICdvcmFuZ2VyZWQnOiAweEZGNDUwMCwgJ29yY2hpZCc6IDB4REE3MEQ2LFxuICAgICdwYWxlZ29sZGVucm9kJzogMHhFRUU4QUEsICdwYWxlZ3JlZW4nOiAweDk4RkI5OCwgJ3BhbGV0dXJxdW9pc2UnOiAweEFGRUVFRSwgJ3BhbGV2aW9sZXRyZWQnOiAweERCNzA5MywgJ3BhcGF5YXdoaXAnOiAweEZGRUZENSwgJ3BlYWNocHVmZic6IDB4RkZEQUI5LFxuICAgICdwZXJ1JzogMHhDRDg1M0YsICdwaW5rJzogMHhGRkMwQ0IsICdwbHVtJzogMHhEREEwREQsICdwb3dkZXJibHVlJzogMHhCMEUwRTYsICdwdXJwbGUnOiAweDgwMDA4MCwgJ3JlZCc6IDB4RkYwMDAwLCAncm9zeWJyb3duJzogMHhCQzhGOEYsXG4gICAgJ3JveWFsYmx1ZSc6IDB4NDE2OUUxLCAnc2FkZGxlYnJvd24nOiAweDhCNDUxMywgJ3NhbG1vbic6IDB4RkE4MDcyLCAnc2FuZHlicm93bic6IDB4RjRBNDYwLCAnc2VhZ3JlZW4nOiAweDJFOEI1NywgJ3NlYXNoZWxsJzogMHhGRkY1RUUsXG4gICAgJ3NpZW5uYSc6IDB4QTA1MjJELCAnc2lsdmVyJzogMHhDMEMwQzAsICdza3libHVlJzogMHg4N0NFRUIsICdzbGF0ZWJsdWUnOiAweDZBNUFDRCwgJ3NsYXRlZ3JheSc6IDB4NzA4MDkwLCAnc2xhdGVncmV5JzogMHg3MDgwOTAsICdzbm93JzogMHhGRkZBRkEsXG4gICAgJ3NwcmluZ2dyZWVuJzogMHgwMEZGN0YsICdzdGVlbGJsdWUnOiAweDQ2ODJCNCwgJ3Rhbic6IDB4RDJCNDhDLCAndGVhbCc6IDB4MDA4MDgwLCAndGhpc3RsZSc6IDB4RDhCRkQ4LCAndG9tYXRvJzogMHhGRjYzNDcsICd0dXJxdW9pc2UnOiAweDQwRTBEMCxcbiAgICAndmlvbGV0JzogMHhFRTgyRUUsICd3aGVhdCc6IDB4RjVERUIzLCAnd2hpdGUnOiAweEZGRkZGRiwgJ3doaXRlc21va2UnOiAweEY1RjVGNSwgJ3llbGxvdyc6IDB4RkZGRjAwLCAneWVsbG93Z3JlZW4nOiAweDlBQ0QzMiB9O1xuXG4gICAgLyoqXG4gICAgICogVW5pZm9ybXMgbGlicmFyeSBmb3Igc2hhcmVkIHdlYmdsIHNoYWRlcnNcbiAgICAgKi9cblxuICAgIHZhciBVbmlmb3Jtc0xpYiA9IHtcblxuICAgIFx0Y29tbW9uOiB7XG5cbiAgICBcdFx0ZGlmZnVzZTogeyB2YWx1ZTogbmV3IENvbG9yKCAweGVlZWVlZSApIH0sXG4gICAgXHRcdG9wYWNpdHk6IHsgdmFsdWU6IDEuMCB9LFxuXG4gICAgXHRcdG1hcDogeyB2YWx1ZTogbnVsbCB9LFxuICAgIFx0XHRvZmZzZXRSZXBlYXQ6IHsgdmFsdWU6IG5ldyBWZWN0b3I0KCAwLCAwLCAxLCAxICkgfSxcblxuICAgIFx0XHRzcGVjdWxhck1hcDogeyB2YWx1ZTogbnVsbCB9LFxuICAgIFx0XHRhbHBoYU1hcDogeyB2YWx1ZTogbnVsbCB9LFxuXG4gICAgXHRcdGVudk1hcDogeyB2YWx1ZTogbnVsbCB9LFxuICAgIFx0XHRmbGlwRW52TWFwOiB7IHZhbHVlOiAtIDEgfSxcbiAgICBcdFx0cmVmbGVjdGl2aXR5OiB7IHZhbHVlOiAxLjAgfSxcbiAgICBcdFx0cmVmcmFjdGlvblJhdGlvOiB7IHZhbHVlOiAwLjk4IH1cblxuICAgIFx0fSxcblxuICAgIFx0YW9tYXA6IHtcblxuICAgIFx0XHRhb01hcDogeyB2YWx1ZTogbnVsbCB9LFxuICAgIFx0XHRhb01hcEludGVuc2l0eTogeyB2YWx1ZTogMSB9XG5cbiAgICBcdH0sXG5cbiAgICBcdGxpZ2h0bWFwOiB7XG5cbiAgICBcdFx0bGlnaHRNYXA6IHsgdmFsdWU6IG51bGwgfSxcbiAgICBcdFx0bGlnaHRNYXBJbnRlbnNpdHk6IHsgdmFsdWU6IDEgfVxuXG4gICAgXHR9LFxuXG4gICAgXHRlbWlzc2l2ZW1hcDoge1xuXG4gICAgXHRcdGVtaXNzaXZlTWFwOiB7IHZhbHVlOiBudWxsIH1cblxuICAgIFx0fSxcblxuICAgIFx0YnVtcG1hcDoge1xuXG4gICAgXHRcdGJ1bXBNYXA6IHsgdmFsdWU6IG51bGwgfSxcbiAgICBcdFx0YnVtcFNjYWxlOiB7IHZhbHVlOiAxIH1cblxuICAgIFx0fSxcblxuICAgIFx0bm9ybWFsbWFwOiB7XG5cbiAgICBcdFx0bm9ybWFsTWFwOiB7IHZhbHVlOiBudWxsIH0sXG4gICAgXHRcdG5vcm1hbFNjYWxlOiB7IHZhbHVlOiBuZXcgVmVjdG9yMiggMSwgMSApIH1cblxuICAgIFx0fSxcblxuICAgIFx0ZGlzcGxhY2VtZW50bWFwOiB7XG5cbiAgICBcdFx0ZGlzcGxhY2VtZW50TWFwOiB7IHZhbHVlOiBudWxsIH0sXG4gICAgXHRcdGRpc3BsYWNlbWVudFNjYWxlOiB7IHZhbHVlOiAxIH0sXG4gICAgXHRcdGRpc3BsYWNlbWVudEJpYXM6IHsgdmFsdWU6IDAgfVxuXG4gICAgXHR9LFxuXG4gICAgXHRyb3VnaG5lc3NtYXA6IHtcblxuICAgIFx0XHRyb3VnaG5lc3NNYXA6IHsgdmFsdWU6IG51bGwgfVxuXG4gICAgXHR9LFxuXG4gICAgXHRtZXRhbG5lc3NtYXA6IHtcblxuICAgIFx0XHRtZXRhbG5lc3NNYXA6IHsgdmFsdWU6IG51bGwgfVxuXG4gICAgXHR9LFxuXG4gICAgXHRmb2c6IHtcblxuICAgIFx0XHRmb2dEZW5zaXR5OiB7IHZhbHVlOiAwLjAwMDI1IH0sXG4gICAgXHRcdGZvZ05lYXI6IHsgdmFsdWU6IDEgfSxcbiAgICBcdFx0Zm9nRmFyOiB7IHZhbHVlOiAyMDAwIH0sXG4gICAgXHRcdGZvZ0NvbG9yOiB7IHZhbHVlOiBuZXcgQ29sb3IoIDB4ZmZmZmZmICkgfVxuXG4gICAgXHR9LFxuXG4gICAgXHRsaWdodHM6IHtcblxuICAgIFx0XHRhbWJpZW50TGlnaHRDb2xvcjogeyB2YWx1ZTogW10gfSxcblxuICAgIFx0XHRkaXJlY3Rpb25hbExpZ2h0czogeyB2YWx1ZTogW10sIHByb3BlcnRpZXM6IHtcbiAgICBcdFx0XHRkaXJlY3Rpb246IHt9LFxuICAgIFx0XHRcdGNvbG9yOiB7fSxcblxuICAgIFx0XHRcdHNoYWRvdzoge30sXG4gICAgXHRcdFx0c2hhZG93Qmlhczoge30sXG4gICAgXHRcdFx0c2hhZG93UmFkaXVzOiB7fSxcbiAgICBcdFx0XHRzaGFkb3dNYXBTaXplOiB7fVxuICAgIFx0XHR9IH0sXG5cbiAgICBcdFx0ZGlyZWN0aW9uYWxTaGFkb3dNYXA6IHsgdmFsdWU6IFtdIH0sXG4gICAgXHRcdGRpcmVjdGlvbmFsU2hhZG93TWF0cml4OiB7IHZhbHVlOiBbXSB9LFxuXG4gICAgXHRcdHNwb3RMaWdodHM6IHsgdmFsdWU6IFtdLCBwcm9wZXJ0aWVzOiB7XG4gICAgXHRcdFx0Y29sb3I6IHt9LFxuICAgIFx0XHRcdHBvc2l0aW9uOiB7fSxcbiAgICBcdFx0XHRkaXJlY3Rpb246IHt9LFxuICAgIFx0XHRcdGRpc3RhbmNlOiB7fSxcbiAgICBcdFx0XHRjb25lQ29zOiB7fSxcbiAgICBcdFx0XHRwZW51bWJyYUNvczoge30sXG4gICAgXHRcdFx0ZGVjYXk6IHt9LFxuXG4gICAgXHRcdFx0c2hhZG93OiB7fSxcbiAgICBcdFx0XHRzaGFkb3dCaWFzOiB7fSxcbiAgICBcdFx0XHRzaGFkb3dSYWRpdXM6IHt9LFxuICAgIFx0XHRcdHNoYWRvd01hcFNpemU6IHt9XG4gICAgXHRcdH0gfSxcblxuICAgIFx0XHRzcG90U2hhZG93TWFwOiB7IHZhbHVlOiBbXSB9LFxuICAgIFx0XHRzcG90U2hhZG93TWF0cml4OiB7IHZhbHVlOiBbXSB9LFxuXG4gICAgXHRcdHBvaW50TGlnaHRzOiB7IHZhbHVlOiBbXSwgcHJvcGVydGllczoge1xuICAgIFx0XHRcdGNvbG9yOiB7fSxcbiAgICBcdFx0XHRwb3NpdGlvbjoge30sXG4gICAgXHRcdFx0ZGVjYXk6IHt9LFxuICAgIFx0XHRcdGRpc3RhbmNlOiB7fSxcblxuICAgIFx0XHRcdHNoYWRvdzoge30sXG4gICAgXHRcdFx0c2hhZG93Qmlhczoge30sXG4gICAgXHRcdFx0c2hhZG93UmFkaXVzOiB7fSxcbiAgICBcdFx0XHRzaGFkb3dNYXBTaXplOiB7fVxuICAgIFx0XHR9IH0sXG5cbiAgICBcdFx0cG9pbnRTaGFkb3dNYXA6IHsgdmFsdWU6IFtdIH0sXG4gICAgXHRcdHBvaW50U2hhZG93TWF0cml4OiB7IHZhbHVlOiBbXSB9LFxuXG4gICAgXHRcdGhlbWlzcGhlcmVMaWdodHM6IHsgdmFsdWU6IFtdLCBwcm9wZXJ0aWVzOiB7XG4gICAgXHRcdFx0ZGlyZWN0aW9uOiB7fSxcbiAgICBcdFx0XHRza3lDb2xvcjoge30sXG4gICAgXHRcdFx0Z3JvdW5kQ29sb3I6IHt9XG4gICAgXHRcdH0gfVxuXG4gICAgXHR9LFxuXG4gICAgXHRwb2ludHM6IHtcblxuICAgIFx0XHRkaWZmdXNlOiB7IHZhbHVlOiBuZXcgQ29sb3IoIDB4ZWVlZWVlICkgfSxcbiAgICBcdFx0b3BhY2l0eTogeyB2YWx1ZTogMS4wIH0sXG4gICAgXHRcdHNpemU6IHsgdmFsdWU6IDEuMCB9LFxuICAgIFx0XHRzY2FsZTogeyB2YWx1ZTogMS4wIH0sXG4gICAgXHRcdG1hcDogeyB2YWx1ZTogbnVsbCB9LFxuICAgIFx0XHRvZmZzZXRSZXBlYXQ6IHsgdmFsdWU6IG5ldyBWZWN0b3I0KCAwLCAwLCAxLCAxICkgfVxuXG4gICAgXHR9XG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAgICAgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICAgICAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gICAgICovXG5cbiAgICB2YXIgU2hhZGVyTGliID0ge1xuXG4gICAgXHRiYXNpYzoge1xuXG4gICAgXHRcdHVuaWZvcm1zOiBleHBvcnRzLlVuaWZvcm1zVXRpbHMubWVyZ2UoIFtcblxuICAgIFx0XHRcdFVuaWZvcm1zTGliLmNvbW1vbixcbiAgICBcdFx0XHRVbmlmb3Jtc0xpYi5hb21hcCxcbiAgICBcdFx0XHRVbmlmb3Jtc0xpYi5mb2dcblxuICAgIFx0XHRdICksXG5cbiAgICBcdFx0dmVydGV4U2hhZGVyOiBTaGFkZXJDaHVuay5tZXNoYmFzaWNfdmVydCxcbiAgICBcdFx0ZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLm1lc2hiYXNpY19mcmFnXG5cbiAgICBcdH0sXG5cbiAgICBcdGxhbWJlcnQ6IHtcblxuICAgIFx0XHR1bmlmb3JtczogZXhwb3J0cy5Vbmlmb3Jtc1V0aWxzLm1lcmdlKCBbXG5cbiAgICBcdFx0XHRVbmlmb3Jtc0xpYi5jb21tb24sXG4gICAgXHRcdFx0VW5pZm9ybXNMaWIuYW9tYXAsXG4gICAgXHRcdFx0VW5pZm9ybXNMaWIubGlnaHRtYXAsXG4gICAgXHRcdFx0VW5pZm9ybXNMaWIuZW1pc3NpdmVtYXAsXG4gICAgXHRcdFx0VW5pZm9ybXNMaWIuZm9nLFxuICAgIFx0XHRcdFVuaWZvcm1zTGliLmxpZ2h0cyxcblxuICAgIFx0XHRcdHtcbiAgICBcdFx0XHRcdGVtaXNzaXZlIDogeyB2YWx1ZTogbmV3IENvbG9yKCAweDAwMDAwMCApIH1cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XSApLFxuXG4gICAgXHRcdHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsubWVzaGxhbWJlcnRfdmVydCxcbiAgICBcdFx0ZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLm1lc2hsYW1iZXJ0X2ZyYWdcblxuICAgIFx0fSxcblxuICAgIFx0cGhvbmc6IHtcblxuICAgIFx0XHR1bmlmb3JtczogZXhwb3J0cy5Vbmlmb3Jtc1V0aWxzLm1lcmdlKCBbXG5cbiAgICBcdFx0XHRVbmlmb3Jtc0xpYi5jb21tb24sXG4gICAgXHRcdFx0VW5pZm9ybXNMaWIuYW9tYXAsXG4gICAgXHRcdFx0VW5pZm9ybXNMaWIubGlnaHRtYXAsXG4gICAgXHRcdFx0VW5pZm9ybXNMaWIuZW1pc3NpdmVtYXAsXG4gICAgXHRcdFx0VW5pZm9ybXNMaWIuYnVtcG1hcCxcbiAgICBcdFx0XHRVbmlmb3Jtc0xpYi5ub3JtYWxtYXAsXG4gICAgXHRcdFx0VW5pZm9ybXNMaWIuZGlzcGxhY2VtZW50bWFwLFxuICAgIFx0XHRcdFVuaWZvcm1zTGliLmZvZyxcbiAgICBcdFx0XHRVbmlmb3Jtc0xpYi5saWdodHMsXG5cbiAgICBcdFx0XHR7XG4gICAgXHRcdFx0XHRlbWlzc2l2ZSA6IHsgdmFsdWU6IG5ldyBDb2xvciggMHgwMDAwMDAgKSB9LFxuICAgIFx0XHRcdFx0c3BlY3VsYXIgOiB7IHZhbHVlOiBuZXcgQ29sb3IoIDB4MTExMTExICkgfSxcbiAgICBcdFx0XHRcdHNoaW5pbmVzczogeyB2YWx1ZTogMzAgfVxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRdICksXG5cbiAgICBcdFx0dmVydGV4U2hhZGVyOiBTaGFkZXJDaHVuay5tZXNocGhvbmdfdmVydCxcbiAgICBcdFx0ZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLm1lc2hwaG9uZ19mcmFnXG5cbiAgICBcdH0sXG5cbiAgICBcdHN0YW5kYXJkOiB7XG5cbiAgICBcdFx0dW5pZm9ybXM6IGV4cG9ydHMuVW5pZm9ybXNVdGlscy5tZXJnZSggW1xuXG4gICAgXHRcdFx0VW5pZm9ybXNMaWIuY29tbW9uLFxuICAgIFx0XHRcdFVuaWZvcm1zTGliLmFvbWFwLFxuICAgIFx0XHRcdFVuaWZvcm1zTGliLmxpZ2h0bWFwLFxuICAgIFx0XHRcdFVuaWZvcm1zTGliLmVtaXNzaXZlbWFwLFxuICAgIFx0XHRcdFVuaWZvcm1zTGliLmJ1bXBtYXAsXG4gICAgXHRcdFx0VW5pZm9ybXNMaWIubm9ybWFsbWFwLFxuICAgIFx0XHRcdFVuaWZvcm1zTGliLmRpc3BsYWNlbWVudG1hcCxcbiAgICBcdFx0XHRVbmlmb3Jtc0xpYi5yb3VnaG5lc3NtYXAsXG4gICAgXHRcdFx0VW5pZm9ybXNMaWIubWV0YWxuZXNzbWFwLFxuICAgIFx0XHRcdFVuaWZvcm1zTGliLmZvZyxcbiAgICBcdFx0XHRVbmlmb3Jtc0xpYi5saWdodHMsXG5cbiAgICBcdFx0XHR7XG4gICAgXHRcdFx0XHRlbWlzc2l2ZSA6IHsgdmFsdWU6IG5ldyBDb2xvciggMHgwMDAwMDAgKSB9LFxuICAgIFx0XHRcdFx0cm91Z2huZXNzOiB7IHZhbHVlOiAwLjUgfSxcbiAgICBcdFx0XHRcdG1ldGFsbmVzczogeyB2YWx1ZTogMCB9LFxuICAgIFx0XHRcdFx0ZW52TWFwSW50ZW5zaXR5IDogeyB2YWx1ZTogMSB9LCAvLyB0ZW1wb3JhcnlcbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XSApLFxuXG4gICAgXHRcdHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsubWVzaHBoeXNpY2FsX3ZlcnQsXG4gICAgXHRcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5tZXNocGh5c2ljYWxfZnJhZ1xuXG4gICAgXHR9LFxuXG4gICAgXHRwb2ludHM6IHtcblxuICAgIFx0XHR1bmlmb3JtczogZXhwb3J0cy5Vbmlmb3Jtc1V0aWxzLm1lcmdlKCBbXG5cbiAgICBcdFx0XHRVbmlmb3Jtc0xpYi5wb2ludHMsXG4gICAgXHRcdFx0VW5pZm9ybXNMaWIuZm9nXG5cbiAgICBcdFx0XSApLFxuXG4gICAgXHRcdHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsucG9pbnRzX3ZlcnQsXG4gICAgXHRcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5wb2ludHNfZnJhZ1xuXG4gICAgXHR9LFxuXG4gICAgXHRkYXNoZWQ6IHtcblxuICAgIFx0XHR1bmlmb3JtczogZXhwb3J0cy5Vbmlmb3Jtc1V0aWxzLm1lcmdlKCBbXG5cbiAgICBcdFx0XHRVbmlmb3Jtc0xpYi5jb21tb24sXG4gICAgXHRcdFx0VW5pZm9ybXNMaWIuZm9nLFxuXG4gICAgXHRcdFx0e1xuICAgIFx0XHRcdFx0c2NhbGUgICAgOiB7IHZhbHVlOiAxIH0sXG4gICAgXHRcdFx0XHRkYXNoU2l6ZSA6IHsgdmFsdWU6IDEgfSxcbiAgICBcdFx0XHRcdHRvdGFsU2l6ZTogeyB2YWx1ZTogMiB9XG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdF0gKSxcblxuICAgIFx0XHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLmxpbmVkYXNoZWRfdmVydCxcbiAgICBcdFx0ZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLmxpbmVkYXNoZWRfZnJhZ1xuXG4gICAgXHR9LFxuXG4gICAgXHRkZXB0aDoge1xuXG4gICAgXHRcdHVuaWZvcm1zOiBleHBvcnRzLlVuaWZvcm1zVXRpbHMubWVyZ2UoIFtcblxuICAgIFx0XHRcdFVuaWZvcm1zTGliLmNvbW1vbixcbiAgICBcdFx0XHRVbmlmb3Jtc0xpYi5kaXNwbGFjZW1lbnRtYXBcblxuICAgIFx0XHRdICksXG5cbiAgICBcdFx0dmVydGV4U2hhZGVyOiBTaGFkZXJDaHVuay5kZXB0aF92ZXJ0LFxuICAgIFx0XHRmcmFnbWVudFNoYWRlcjogU2hhZGVyQ2h1bmsuZGVwdGhfZnJhZ1xuXG4gICAgXHR9LFxuXG4gICAgXHRub3JtYWw6IHtcblxuICAgIFx0XHR1bmlmb3Jtczoge1xuXG4gICAgXHRcdFx0b3BhY2l0eSA6IHsgdmFsdWU6IDEuMCB9XG5cbiAgICBcdFx0fSxcblxuICAgIFx0XHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLm5vcm1hbF92ZXJ0LFxuICAgIFx0XHRmcmFnbWVudFNoYWRlcjogU2hhZGVyQ2h1bmsubm9ybWFsX2ZyYWdcblxuICAgIFx0fSxcblxuICAgIFx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIFx0Ly9cdEN1YmUgbWFwIHNoYWRlclxuICAgIFx0IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuICAgIFx0Y3ViZToge1xuXG4gICAgXHRcdHVuaWZvcm1zOiB7XG4gICAgXHRcdFx0dEN1YmU6IHsgdmFsdWU6IG51bGwgfSxcbiAgICBcdFx0XHR0RmxpcDogeyB2YWx1ZTogLSAxIH0sXG4gICAgXHRcdFx0b3BhY2l0eTogeyB2YWx1ZTogMS4wIH1cbiAgICBcdFx0fSxcblxuICAgIFx0XHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLmN1YmVfdmVydCxcbiAgICBcdFx0ZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLmN1YmVfZnJhZ1xuXG4gICAgXHR9LFxuXG4gICAgXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgXHQvL1x0Q3ViZSBtYXAgc2hhZGVyXG4gICAgXHQgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG4gICAgXHRlcXVpcmVjdDoge1xuXG4gICAgXHRcdHVuaWZvcm1zOiB7XG4gICAgXHRcdFx0dEVxdWlyZWN0OiB7IHZhbHVlOiBudWxsIH0sXG4gICAgXHRcdFx0dEZsaXA6IHsgdmFsdWU6IC0gMSB9XG4gICAgXHRcdH0sXG5cbiAgICBcdFx0dmVydGV4U2hhZGVyOiBTaGFkZXJDaHVuay5lcXVpcmVjdF92ZXJ0LFxuICAgIFx0XHRmcmFnbWVudFNoYWRlcjogU2hhZGVyQ2h1bmsuZXF1aXJlY3RfZnJhZ1xuXG4gICAgXHR9LFxuXG4gICAgXHRkaXN0YW5jZVJHQkE6IHtcblxuICAgIFx0XHR1bmlmb3Jtczoge1xuXG4gICAgXHRcdFx0bGlnaHRQb3M6IHsgdmFsdWU6IG5ldyBWZWN0b3IzKCkgfVxuXG4gICAgXHRcdH0sXG5cbiAgICBcdFx0dmVydGV4U2hhZGVyOiBTaGFkZXJDaHVuay5kaXN0YW5jZVJHQkFfdmVydCxcbiAgICBcdFx0ZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLmRpc3RhbmNlUkdCQV9mcmFnXG5cbiAgICBcdH1cblxuICAgIH07XG5cbiAgICBTaGFkZXJMaWIucGh5c2ljYWwgPSB7XG5cbiAgICBcdHVuaWZvcm1zOiBleHBvcnRzLlVuaWZvcm1zVXRpbHMubWVyZ2UoIFtcblxuICAgIFx0XHRTaGFkZXJMaWIuc3RhbmRhcmQudW5pZm9ybXMsXG5cbiAgICBcdFx0e1xuICAgIFx0XHRcdGNsZWFyQ29hdDogeyB2YWx1ZTogMCB9LFxuICAgIFx0XHRcdGNsZWFyQ29hdFJvdWdobmVzczogeyB2YWx1ZTogMCB9XG4gICAgXHRcdH1cblxuICAgIFx0XSApLFxuXG4gICAgXHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLm1lc2hwaHlzaWNhbF92ZXJ0LFxuICAgIFx0ZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLm1lc2hwaHlzaWNhbF9mcmFnXG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gQm94MiggbWluLCBtYXggKSB7XG5cbiAgICBcdHRoaXMubWluID0gKCBtaW4gIT09IHVuZGVmaW5lZCApID8gbWluIDogbmV3IFZlY3RvcjIoICsgSW5maW5pdHksICsgSW5maW5pdHkgKTtcbiAgICBcdHRoaXMubWF4ID0gKCBtYXggIT09IHVuZGVmaW5lZCApID8gbWF4IDogbmV3IFZlY3RvcjIoIC0gSW5maW5pdHksIC0gSW5maW5pdHkgKTtcblxuICAgIH1cblxuICAgIEJveDIucHJvdG90eXBlID0ge1xuXG4gICAgXHRjb25zdHJ1Y3RvcjogQm94MixcblxuICAgIFx0c2V0OiBmdW5jdGlvbiAoIG1pbiwgbWF4ICkge1xuXG4gICAgXHRcdHRoaXMubWluLmNvcHkoIG1pbiApO1xuICAgIFx0XHR0aGlzLm1heC5jb3B5KCBtYXggKTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0c2V0RnJvbVBvaW50czogZnVuY3Rpb24gKCBwb2ludHMgKSB7XG5cbiAgICBcdFx0dGhpcy5tYWtlRW1wdHkoKTtcblxuICAgIFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgXHRcdFx0dGhpcy5leHBhbmRCeVBvaW50KCBwb2ludHNbIGkgXSApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0c2V0RnJvbUNlbnRlckFuZFNpemU6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR2YXIgdjEgPSBuZXcgVmVjdG9yMigpO1xuXG4gICAgXHRcdHJldHVybiBmdW5jdGlvbiBzZXRGcm9tQ2VudGVyQW5kU2l6ZSggY2VudGVyLCBzaXplICkge1xuXG4gICAgXHRcdFx0dmFyIGhhbGZTaXplID0gdjEuY29weSggc2l6ZSApLm11bHRpcGx5U2NhbGFyKCAwLjUgKTtcbiAgICBcdFx0XHR0aGlzLm1pbi5jb3B5KCBjZW50ZXIgKS5zdWIoIGhhbGZTaXplICk7XG4gICAgXHRcdFx0dGhpcy5tYXguY29weSggY2VudGVyICkuYWRkKCBoYWxmU2l6ZSApO1xuXG4gICAgXHRcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdFx0fTtcblxuICAgIFx0fSgpLFxuXG4gICAgXHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuICAgIFx0fSxcblxuICAgIFx0Y29weTogZnVuY3Rpb24gKCBib3ggKSB7XG5cbiAgICBcdFx0dGhpcy5taW4uY29weSggYm94Lm1pbiApO1xuICAgIFx0XHR0aGlzLm1heC5jb3B5KCBib3gubWF4ICk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdG1ha2VFbXB0eTogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHRoaXMubWluLnggPSB0aGlzLm1pbi55ID0gKyBJbmZpbml0eTtcbiAgICBcdFx0dGhpcy5tYXgueCA9IHRoaXMubWF4LnkgPSAtIEluZmluaXR5O1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRpc0VtcHR5OiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0Ly8gdGhpcyBpcyBhIG1vcmUgcm9idXN0IGNoZWNrIGZvciBlbXB0eSB0aGFuICggdm9sdW1lIDw9IDAgKSBiZWNhdXNlIHZvbHVtZSBjYW4gZ2V0IHBvc2l0aXZlIHdpdGggdHdvIG5lZ2F0aXZlIGF4ZXNcblxuICAgIFx0XHRyZXR1cm4gKCB0aGlzLm1heC54IDwgdGhpcy5taW4ueCApIHx8ICggdGhpcy5tYXgueSA8IHRoaXMubWluLnkgKTtcblxuICAgIFx0fSxcblxuICAgIFx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgXHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMigpO1xuICAgIFx0XHRyZXR1cm4gdGhpcy5pc0VtcHR5KCkgPyByZXN1bHQuc2V0KCAwLCAwICkgOiByZXN1bHQuYWRkVmVjdG9ycyggdGhpcy5taW4sIHRoaXMubWF4ICkubXVsdGlwbHlTY2FsYXIoIDAuNSApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRnZXRTaXplOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgXHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMigpO1xuICAgIFx0XHRyZXR1cm4gdGhpcy5pc0VtcHR5KCkgPyByZXN1bHQuc2V0KCAwLCAwICkgOiByZXN1bHQuc3ViVmVjdG9ycyggdGhpcy5tYXgsIHRoaXMubWluICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGV4cGFuZEJ5UG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XG5cbiAgICBcdFx0dGhpcy5taW4ubWluKCBwb2ludCApO1xuICAgIFx0XHR0aGlzLm1heC5tYXgoIHBvaW50ICk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGV4cGFuZEJ5VmVjdG9yOiBmdW5jdGlvbiAoIHZlY3RvciApIHtcblxuICAgIFx0XHR0aGlzLm1pbi5zdWIoIHZlY3RvciApO1xuICAgIFx0XHR0aGlzLm1heC5hZGQoIHZlY3RvciApO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRleHBhbmRCeVNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XG5cbiAgICBcdFx0dGhpcy5taW4uYWRkU2NhbGFyKCAtIHNjYWxhciApO1xuICAgIFx0XHR0aGlzLm1heC5hZGRTY2FsYXIoIHNjYWxhciApO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRjb250YWluc1BvaW50OiBmdW5jdGlvbiAoIHBvaW50ICkge1xuXG4gICAgXHRcdGlmICggcG9pbnQueCA8IHRoaXMubWluLnggfHwgcG9pbnQueCA+IHRoaXMubWF4LnggfHxcbiAgICBcdFx0ICAgICBwb2ludC55IDwgdGhpcy5taW4ueSB8fCBwb2ludC55ID4gdGhpcy5tYXgueSApIHtcblxuICAgIFx0XHRcdHJldHVybiBmYWxzZTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIHRydWU7XG5cbiAgICBcdH0sXG5cbiAgICBcdGNvbnRhaW5zQm94OiBmdW5jdGlvbiAoIGJveCApIHtcblxuICAgIFx0XHRpZiAoICggdGhpcy5taW4ueCA8PSBib3gubWluLnggKSAmJiAoIGJveC5tYXgueCA8PSB0aGlzLm1heC54ICkgJiZcbiAgICBcdFx0ICAgICAoIHRoaXMubWluLnkgPD0gYm94Lm1pbi55ICkgJiYgKCBib3gubWF4LnkgPD0gdGhpcy5tYXgueSApICkge1xuXG4gICAgXHRcdFx0cmV0dXJuIHRydWU7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiBmYWxzZTtcblxuICAgIFx0fSxcblxuICAgIFx0Z2V0UGFyYW1ldGVyOiBmdW5jdGlvbiAoIHBvaW50LCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgIFx0XHQvLyBUaGlzIGNhbiBwb3RlbnRpYWxseSBoYXZlIGEgZGl2aWRlIGJ5IHplcm8gaWYgdGhlIGJveFxuICAgIFx0XHQvLyBoYXMgYSBzaXplIGRpbWVuc2lvbiBvZiAwLlxuXG4gICAgXHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMigpO1xuXG4gICAgXHRcdHJldHVybiByZXN1bHQuc2V0KFxuICAgIFx0XHRcdCggcG9pbnQueCAtIHRoaXMubWluLnggKSAvICggdGhpcy5tYXgueCAtIHRoaXMubWluLnggKSxcbiAgICBcdFx0XHQoIHBvaW50LnkgLSB0aGlzLm1pbi55ICkgLyAoIHRoaXMubWF4LnkgLSB0aGlzLm1pbi55IClcbiAgICBcdFx0KTtcblxuICAgIFx0fSxcblxuICAgIFx0aW50ZXJzZWN0c0JveDogZnVuY3Rpb24gKCBib3ggKSB7XG5cbiAgICBcdFx0Ly8gdXNpbmcgNiBzcGxpdHRpbmcgcGxhbmVzIHRvIHJ1bGUgb3V0IGludGVyc2VjdGlvbnMuXG5cbiAgICBcdFx0aWYgKCBib3gubWF4LnggPCB0aGlzLm1pbi54IHx8IGJveC5taW4ueCA+IHRoaXMubWF4LnggfHxcbiAgICBcdFx0ICAgICBib3gubWF4LnkgPCB0aGlzLm1pbi55IHx8IGJveC5taW4ueSA+IHRoaXMubWF4LnkgKSB7XG5cbiAgICBcdFx0XHRyZXR1cm4gZmFsc2U7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiB0cnVlO1xuXG4gICAgXHR9LFxuXG4gICAgXHRjbGFtcFBvaW50OiBmdW5jdGlvbiAoIHBvaW50LCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgIFx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjIoKTtcbiAgICBcdFx0cmV0dXJuIHJlc3VsdC5jb3B5KCBwb2ludCApLmNsYW1wKCB0aGlzLm1pbiwgdGhpcy5tYXggKTtcblxuICAgIFx0fSxcblxuICAgIFx0ZGlzdGFuY2VUb1BvaW50OiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dmFyIHYxID0gbmV3IFZlY3RvcjIoKTtcblxuICAgIFx0XHRyZXR1cm4gZnVuY3Rpb24gZGlzdGFuY2VUb1BvaW50KCBwb2ludCApIHtcblxuICAgIFx0XHRcdHZhciBjbGFtcGVkUG9pbnQgPSB2MS5jb3B5KCBwb2ludCApLmNsYW1wKCB0aGlzLm1pbiwgdGhpcy5tYXggKTtcbiAgICBcdFx0XHRyZXR1cm4gY2xhbXBlZFBvaW50LnN1YiggcG9pbnQgKS5sZW5ndGgoKTtcblxuICAgIFx0XHR9O1xuXG4gICAgXHR9KCksXG5cbiAgICBcdGludGVyc2VjdDogZnVuY3Rpb24gKCBib3ggKSB7XG5cbiAgICBcdFx0dGhpcy5taW4ubWF4KCBib3gubWluICk7XG4gICAgXHRcdHRoaXMubWF4Lm1pbiggYm94Lm1heCApO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHR1bmlvbjogZnVuY3Rpb24gKCBib3ggKSB7XG5cbiAgICBcdFx0dGhpcy5taW4ubWluKCBib3gubWluICk7XG4gICAgXHRcdHRoaXMubWF4Lm1heCggYm94Lm1heCApO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHR0cmFuc2xhdGU6IGZ1bmN0aW9uICggb2Zmc2V0ICkge1xuXG4gICAgXHRcdHRoaXMubWluLmFkZCggb2Zmc2V0ICk7XG4gICAgXHRcdHRoaXMubWF4LmFkZCggb2Zmc2V0ICk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGVxdWFsczogZnVuY3Rpb24gKCBib3ggKSB7XG5cbiAgICBcdFx0cmV0dXJuIGJveC5taW4uZXF1YWxzKCB0aGlzLm1pbiApICYmIGJveC5tYXguZXF1YWxzKCB0aGlzLm1heCApO1xuXG4gICAgXHR9XG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAgICAgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gTGVuc0ZsYXJlUGx1Z2luKCByZW5kZXJlciwgZmxhcmVzICkge1xuXG4gICAgXHR2YXIgZ2wgPSByZW5kZXJlci5jb250ZXh0O1xuICAgIFx0dmFyIHN0YXRlID0gcmVuZGVyZXIuc3RhdGU7XG5cbiAgICBcdHZhciB2ZXJ0ZXhCdWZmZXIsIGVsZW1lbnRCdWZmZXI7XG4gICAgXHR2YXIgc2hhZGVyLCBwcm9ncmFtLCBhdHRyaWJ1dGVzLCB1bmlmb3JtcztcblxuICAgIFx0dmFyIHRlbXBUZXh0dXJlLCBvY2NsdXNpb25UZXh0dXJlO1xuXG4gICAgXHRmdW5jdGlvbiBpbml0KCkge1xuXG4gICAgXHRcdHZhciB2ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIFtcbiAgICBcdFx0XHQtIDEsIC0gMSwgIDAsIDAsXG4gICAgXHRcdFx0IDEsIC0gMSwgIDEsIDAsXG4gICAgXHRcdFx0IDEsICAxLCAgMSwgMSxcbiAgICBcdFx0XHQtIDEsICAxLCAgMCwgMVxuICAgIFx0XHRdICk7XG5cbiAgICBcdFx0dmFyIGZhY2VzID0gbmV3IFVpbnQxNkFycmF5KCBbXG4gICAgXHRcdFx0MCwgMSwgMixcbiAgICBcdFx0XHQwLCAyLCAzXG4gICAgXHRcdF0gKTtcblxuICAgIFx0XHQvLyBidWZmZXJzXG5cbiAgICBcdFx0dmVydGV4QnVmZmVyICAgICA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIFx0XHRlbGVtZW50QnVmZmVyICAgID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG5cbiAgICBcdFx0Z2wuYmluZEJ1ZmZlciggZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0ZXhCdWZmZXIgKTtcbiAgICBcdFx0Z2wuYnVmZmVyRGF0YSggZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0aWNlcywgZ2wuU1RBVElDX0RSQVcgKTtcblxuICAgIFx0XHRnbC5iaW5kQnVmZmVyKCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgZWxlbWVudEJ1ZmZlciApO1xuICAgIFx0XHRnbC5idWZmZXJEYXRhKCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgZmFjZXMsIGdsLlNUQVRJQ19EUkFXICk7XG5cbiAgICBcdFx0Ly8gdGV4dHVyZXNcblxuICAgIFx0XHR0ZW1wVGV4dHVyZSAgICAgID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICAgIFx0XHRvY2NsdXNpb25UZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuXG4gICAgXHRcdHN0YXRlLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFXzJELCB0ZW1wVGV4dHVyZSApO1xuICAgIFx0XHRnbC50ZXhJbWFnZTJEKCBnbC5URVhUVVJFXzJELCAwLCBnbC5SR0IsIDE2LCAxNiwgMCwgZ2wuUkdCLCBnbC5VTlNJR05FRF9CWVRFLCBudWxsICk7XG4gICAgXHRcdGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFICk7XG4gICAgXHRcdGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFICk7XG4gICAgXHRcdGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTkVBUkVTVCApO1xuICAgIFx0XHRnbC50ZXhQYXJhbWV0ZXJpKCBnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QgKTtcblxuICAgIFx0XHRzdGF0ZS5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgb2NjbHVzaW9uVGV4dHVyZSApO1xuICAgIFx0XHRnbC50ZXhJbWFnZTJEKCBnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCAxNiwgMTYsIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIG51bGwgKTtcbiAgICBcdFx0Z2wudGV4UGFyYW1ldGVyaSggZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UgKTtcbiAgICBcdFx0Z2wudGV4UGFyYW1ldGVyaSggZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UgKTtcbiAgICBcdFx0Z2wudGV4UGFyYW1ldGVyaSggZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUICk7XG4gICAgXHRcdGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTkVBUkVTVCApO1xuXG4gICAgXHRcdHNoYWRlciA9IHtcblxuICAgIFx0XHRcdHZlcnRleFNoYWRlcjogW1xuXG4gICAgXHRcdFx0XHRcInVuaWZvcm0gbG93cCBpbnQgcmVuZGVyVHlwZTtcIixcblxuICAgIFx0XHRcdFx0XCJ1bmlmb3JtIHZlYzMgc2NyZWVuUG9zaXRpb247XCIsXG4gICAgXHRcdFx0XHRcInVuaWZvcm0gdmVjMiBzY2FsZTtcIixcbiAgICBcdFx0XHRcdFwidW5pZm9ybSBmbG9hdCByb3RhdGlvbjtcIixcblxuICAgIFx0XHRcdFx0XCJ1bmlmb3JtIHNhbXBsZXIyRCBvY2NsdXNpb25NYXA7XCIsXG5cbiAgICBcdFx0XHRcdFwiYXR0cmlidXRlIHZlYzIgcG9zaXRpb247XCIsXG4gICAgXHRcdFx0XHRcImF0dHJpYnV0ZSB2ZWMyIHV2O1wiLFxuXG4gICAgXHRcdFx0XHRcInZhcnlpbmcgdmVjMiB2VVY7XCIsXG4gICAgXHRcdFx0XHRcInZhcnlpbmcgZmxvYXQgdlZpc2liaWxpdHk7XCIsXG5cbiAgICBcdFx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxuXG4gICAgXHRcdFx0XHRcdFwidlVWID0gdXY7XCIsXG5cbiAgICBcdFx0XHRcdFx0XCJ2ZWMyIHBvcyA9IHBvc2l0aW9uO1wiLFxuXG4gICAgXHRcdFx0XHRcdFwiaWYgKCByZW5kZXJUeXBlID09IDIgKSB7XCIsXG5cbiAgICBcdFx0XHRcdFx0XHRcInZlYzQgdmlzaWJpbGl0eSA9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjEsIDAuMSApICk7XCIsXG4gICAgXHRcdFx0XHRcdFx0XCJ2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjUsIDAuMSApICk7XCIsXG4gICAgXHRcdFx0XHRcdFx0XCJ2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjksIDAuMSApICk7XCIsXG4gICAgXHRcdFx0XHRcdFx0XCJ2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjksIDAuNSApICk7XCIsXG4gICAgXHRcdFx0XHRcdFx0XCJ2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjksIDAuOSApICk7XCIsXG4gICAgXHRcdFx0XHRcdFx0XCJ2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjUsIDAuOSApICk7XCIsXG4gICAgXHRcdFx0XHRcdFx0XCJ2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjEsIDAuOSApICk7XCIsXG4gICAgXHRcdFx0XHRcdFx0XCJ2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjEsIDAuNSApICk7XCIsXG4gICAgXHRcdFx0XHRcdFx0XCJ2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjUsIDAuNSApICk7XCIsXG5cbiAgICBcdFx0XHRcdFx0XHRcInZWaXNpYmlsaXR5ID0gICAgICAgIHZpc2liaWxpdHkuciAvIDkuMDtcIixcbiAgICBcdFx0XHRcdFx0XHRcInZWaXNpYmlsaXR5ICo9IDEuMCAtIHZpc2liaWxpdHkuZyAvIDkuMDtcIixcbiAgICBcdFx0XHRcdFx0XHRcInZWaXNpYmlsaXR5ICo9ICAgICAgIHZpc2liaWxpdHkuYiAvIDkuMDtcIixcbiAgICBcdFx0XHRcdFx0XHRcInZWaXNpYmlsaXR5ICo9IDEuMCAtIHZpc2liaWxpdHkuYSAvIDkuMDtcIixcblxuICAgIFx0XHRcdFx0XHRcdFwicG9zLnggPSBjb3MoIHJvdGF0aW9uICkgKiBwb3NpdGlvbi54IC0gc2luKCByb3RhdGlvbiApICogcG9zaXRpb24ueTtcIixcbiAgICBcdFx0XHRcdFx0XHRcInBvcy55ID0gc2luKCByb3RhdGlvbiApICogcG9zaXRpb24ueCArIGNvcyggcm90YXRpb24gKSAqIHBvc2l0aW9uLnk7XCIsXG5cbiAgICBcdFx0XHRcdFx0XCJ9XCIsXG5cbiAgICBcdFx0XHRcdFx0XCJnbF9Qb3NpdGlvbiA9IHZlYzQoICggcG9zICogc2NhbGUgKyBzY3JlZW5Qb3NpdGlvbi54eSApLnh5LCBzY3JlZW5Qb3NpdGlvbi56LCAxLjAgKTtcIixcblxuICAgIFx0XHRcdFx0XCJ9XCJcblxuICAgIFx0XHRcdF0uam9pbiggXCJcXG5cIiApLFxuXG4gICAgXHRcdFx0ZnJhZ21lbnRTaGFkZXI6IFtcblxuICAgIFx0XHRcdFx0XCJ1bmlmb3JtIGxvd3AgaW50IHJlbmRlclR5cGU7XCIsXG5cbiAgICBcdFx0XHRcdFwidW5pZm9ybSBzYW1wbGVyMkQgbWFwO1wiLFxuICAgIFx0XHRcdFx0XCJ1bmlmb3JtIGZsb2F0IG9wYWNpdHk7XCIsXG4gICAgXHRcdFx0XHRcInVuaWZvcm0gdmVjMyBjb2xvcjtcIixcblxuICAgIFx0XHRcdFx0XCJ2YXJ5aW5nIHZlYzIgdlVWO1wiLFxuICAgIFx0XHRcdFx0XCJ2YXJ5aW5nIGZsb2F0IHZWaXNpYmlsaXR5O1wiLFxuXG4gICAgXHRcdFx0XHRcInZvaWQgbWFpbigpIHtcIixcblxuICAgIFx0XHRcdFx0XHQvLyBwaW5rIHNxdWFyZVxuXG4gICAgXHRcdFx0XHRcdFwiaWYgKCByZW5kZXJUeXBlID09IDAgKSB7XCIsXG5cbiAgICBcdFx0XHRcdFx0XHRcImdsX0ZyYWdDb2xvciA9IHZlYzQoIDEuMCwgMC4wLCAxLjAsIDAuMCApO1wiLFxuXG4gICAgXHRcdFx0XHRcdC8vIHJlc3RvcmVcblxuICAgIFx0XHRcdFx0XHRcIn0gZWxzZSBpZiAoIHJlbmRlclR5cGUgPT0gMSApIHtcIixcblxuICAgIFx0XHRcdFx0XHRcdFwiZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKCBtYXAsIHZVViApO1wiLFxuXG4gICAgXHRcdFx0XHRcdC8vIGZsYXJlXG5cbiAgICBcdFx0XHRcdFx0XCJ9IGVsc2Uge1wiLFxuXG4gICAgXHRcdFx0XHRcdFx0XCJ2ZWM0IHRleHR1cmUgPSB0ZXh0dXJlMkQoIG1hcCwgdlVWICk7XCIsXG4gICAgXHRcdFx0XHRcdFx0XCJ0ZXh0dXJlLmEgKj0gb3BhY2l0eSAqIHZWaXNpYmlsaXR5O1wiLFxuICAgIFx0XHRcdFx0XHRcdFwiZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTtcIixcbiAgICBcdFx0XHRcdFx0XHRcImdsX0ZyYWdDb2xvci5yZ2IgKj0gY29sb3I7XCIsXG5cbiAgICBcdFx0XHRcdFx0XCJ9XCIsXG5cbiAgICBcdFx0XHRcdFwifVwiXG5cbiAgICBcdFx0XHRdLmpvaW4oIFwiXFxuXCIgKVxuXG4gICAgXHRcdH07XG5cbiAgICBcdFx0cHJvZ3JhbSA9IGNyZWF0ZVByb2dyYW0oIHNoYWRlciApO1xuXG4gICAgXHRcdGF0dHJpYnV0ZXMgPSB7XG4gICAgXHRcdFx0dmVydGV4OiBnbC5nZXRBdHRyaWJMb2NhdGlvbiAoIHByb2dyYW0sIFwicG9zaXRpb25cIiApLFxuICAgIFx0XHRcdHV2OiAgICAgZ2wuZ2V0QXR0cmliTG9jYXRpb24gKCBwcm9ncmFtLCBcInV2XCIgKVxuICAgIFx0XHR9O1xuXG4gICAgXHRcdHVuaWZvcm1zID0ge1xuICAgIFx0XHRcdHJlbmRlclR5cGU6ICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sIFwicmVuZGVyVHlwZVwiICksXG4gICAgXHRcdFx0bWFwOiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgXCJtYXBcIiApLFxuICAgIFx0XHRcdG9jY2x1c2lvbk1hcDogICBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sIFwib2NjbHVzaW9uTWFwXCIgKSxcbiAgICBcdFx0XHRvcGFjaXR5OiAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCBcIm9wYWNpdHlcIiApLFxuICAgIFx0XHRcdGNvbG9yOiAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sIFwiY29sb3JcIiApLFxuICAgIFx0XHRcdHNjYWxlOiAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sIFwic2NhbGVcIiApLFxuICAgIFx0XHRcdHJvdGF0aW9uOiAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sIFwicm90YXRpb25cIiApLFxuICAgIFx0XHRcdHNjcmVlblBvc2l0aW9uOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sIFwic2NyZWVuUG9zaXRpb25cIiApXG4gICAgXHRcdH07XG5cbiAgICBcdH1cblxuICAgIFx0LypcbiAgICBcdCAqIFJlbmRlciBsZW5zIGZsYXJlc1xuICAgIFx0ICogTWV0aG9kOiByZW5kZXJzIDE2eDE2IDB4ZmYwMGZmLWNvbG9yZWQgcG9pbnRzIHNjYXR0ZXJlZCBvdmVyIHRoZSBsaWdodCBzb3VyY2UgYXJlYSxcbiAgICBcdCAqICAgICAgICAgcmVhZHMgdGhlc2UgYmFjayBhbmQgY2FsY3VsYXRlcyBvY2NsdXNpb24uXG4gICAgXHQgKi9cblxuICAgIFx0dGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoIHNjZW5lLCBjYW1lcmEsIHZpZXdwb3J0ICkge1xuXG4gICAgXHRcdGlmICggZmxhcmVzLmxlbmd0aCA9PT0gMCApIHJldHVybjtcblxuICAgIFx0XHR2YXIgdGVtcFBvc2l0aW9uID0gbmV3IFZlY3RvcjMoKTtcblxuICAgIFx0XHR2YXIgaW52QXNwZWN0ID0gdmlld3BvcnQudyAvIHZpZXdwb3J0LnosXG4gICAgXHRcdFx0aGFsZlZpZXdwb3J0V2lkdGggPSB2aWV3cG9ydC56ICogMC41LFxuICAgIFx0XHRcdGhhbGZWaWV3cG9ydEhlaWdodCA9IHZpZXdwb3J0LncgKiAwLjU7XG5cbiAgICBcdFx0dmFyIHNpemUgPSAxNiAvIHZpZXdwb3J0LncsXG4gICAgXHRcdFx0c2NhbGUgPSBuZXcgVmVjdG9yMiggc2l6ZSAqIGludkFzcGVjdCwgc2l6ZSApO1xuXG4gICAgXHRcdHZhciBzY3JlZW5Qb3NpdGlvbiA9IG5ldyBWZWN0b3IzKCAxLCAxLCAwICksXG4gICAgXHRcdFx0c2NyZWVuUG9zaXRpb25QaXhlbHMgPSBuZXcgVmVjdG9yMiggMSwgMSApO1xuXG4gICAgXHRcdHZhciB2YWxpZEFyZWEgPSBuZXcgQm94MigpO1xuXG4gICAgXHRcdHZhbGlkQXJlYS5taW4uc2V0KCAwLCAwICk7XG4gICAgXHRcdHZhbGlkQXJlYS5tYXguc2V0KCB2aWV3cG9ydC56IC0gMTYsIHZpZXdwb3J0LncgLSAxNiApO1xuXG4gICAgXHRcdGlmICggcHJvZ3JhbSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0aW5pdCgpO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRnbC51c2VQcm9ncmFtKCBwcm9ncmFtICk7XG5cbiAgICBcdFx0c3RhdGUuaW5pdEF0dHJpYnV0ZXMoKTtcbiAgICBcdFx0c3RhdGUuZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLnZlcnRleCApO1xuICAgIFx0XHRzdGF0ZS5lbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMudXYgKTtcbiAgICBcdFx0c3RhdGUuZGlzYWJsZVVudXNlZEF0dHJpYnV0ZXMoKTtcblxuICAgIFx0XHQvLyBsb29wIHRocm91Z2ggYWxsIGxlbnMgZmxhcmVzIHRvIHVwZGF0ZSB0aGVpciBvY2NsdXNpb24gYW5kIHBvc2l0aW9uc1xuICAgIFx0XHQvLyBzZXR1cCBnbCBhbmQgY29tbW9uIHVzZWQgYXR0cmlicy91bmlmb3Jtc1xuXG4gICAgXHRcdGdsLnVuaWZvcm0xaSggdW5pZm9ybXMub2NjbHVzaW9uTWFwLCAwICk7XG4gICAgXHRcdGdsLnVuaWZvcm0xaSggdW5pZm9ybXMubWFwLCAxICk7XG5cbiAgICBcdFx0Z2wuYmluZEJ1ZmZlciggZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0ZXhCdWZmZXIgKTtcbiAgICBcdFx0Z2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy52ZXJ0ZXgsIDIsIGdsLkZMT0FULCBmYWxzZSwgMiAqIDgsIDAgKTtcbiAgICBcdFx0Z2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy51diwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAyICogOCwgOCApO1xuXG4gICAgXHRcdGdsLmJpbmRCdWZmZXIoIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBlbGVtZW50QnVmZmVyICk7XG5cbiAgICBcdFx0c3RhdGUuZGlzYWJsZSggZ2wuQ1VMTF9GQUNFICk7XG4gICAgXHRcdHN0YXRlLnNldERlcHRoV3JpdGUoIGZhbHNlICk7XG5cbiAgICBcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gZmxhcmVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICBcdFx0XHRzaXplID0gMTYgLyB2aWV3cG9ydC53O1xuICAgIFx0XHRcdHNjYWxlLnNldCggc2l6ZSAqIGludkFzcGVjdCwgc2l6ZSApO1xuXG4gICAgXHRcdFx0Ly8gY2FsYyBvYmplY3Qgc2NyZWVuIHBvc2l0aW9uXG5cbiAgICBcdFx0XHR2YXIgZmxhcmUgPSBmbGFyZXNbIGkgXTtcblxuICAgIFx0XHRcdHRlbXBQb3NpdGlvbi5zZXQoIGZsYXJlLm1hdHJpeFdvcmxkLmVsZW1lbnRzWyAxMiBdLCBmbGFyZS5tYXRyaXhXb3JsZC5lbGVtZW50c1sgMTMgXSwgZmxhcmUubWF0cml4V29ybGQuZWxlbWVudHNbIDE0IF0gKTtcblxuICAgIFx0XHRcdHRlbXBQb3NpdGlvbi5hcHBseU1hdHJpeDQoIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UgKTtcbiAgICBcdFx0XHR0ZW1wUG9zaXRpb24uYXBwbHlQcm9qZWN0aW9uKCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeCApO1xuXG4gICAgXHRcdFx0Ly8gc2V0dXAgYXJyYXlzIGZvciBnbCBwcm9ncmFtc1xuXG4gICAgXHRcdFx0c2NyZWVuUG9zaXRpb24uY29weSggdGVtcFBvc2l0aW9uICk7XG5cbiAgICBcdFx0XHQvLyBob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbCBjb29yZGluYXRlIG9mIHRoZSBsb3dlciBsZWZ0IGNvcm5lciBvZiB0aGUgcGl4ZWxzIHRvIGNvcHlcblxuICAgIFx0XHRcdHNjcmVlblBvc2l0aW9uUGl4ZWxzLnggPSB2aWV3cG9ydC54ICsgKCBzY3JlZW5Qb3NpdGlvbi54ICogaGFsZlZpZXdwb3J0V2lkdGggKSArIGhhbGZWaWV3cG9ydFdpZHRoIC0gODtcbiAgICBcdFx0XHRzY3JlZW5Qb3NpdGlvblBpeGVscy55ID0gdmlld3BvcnQueSArICggc2NyZWVuUG9zaXRpb24ueSAqIGhhbGZWaWV3cG9ydEhlaWdodCApICsgaGFsZlZpZXdwb3J0SGVpZ2h0IC0gODtcblxuICAgIFx0XHRcdC8vIHNjcmVlbiBjdWxsXG5cbiAgICBcdFx0XHRpZiAoIHZhbGlkQXJlYS5jb250YWluc1BvaW50KCBzY3JlZW5Qb3NpdGlvblBpeGVscyApID09PSB0cnVlICkge1xuXG4gICAgXHRcdFx0XHQvLyBzYXZlIGN1cnJlbnQgUkdCIHRvIHRlbXAgdGV4dHVyZVxuXG4gICAgXHRcdFx0XHRzdGF0ZS5hY3RpdmVUZXh0dXJlKCBnbC5URVhUVVJFMCApO1xuICAgIFx0XHRcdFx0c3RhdGUuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIG51bGwgKTtcbiAgICBcdFx0XHRcdHN0YXRlLmFjdGl2ZVRleHR1cmUoIGdsLlRFWFRVUkUxICk7XG4gICAgXHRcdFx0XHRzdGF0ZS5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgdGVtcFRleHR1cmUgKTtcbiAgICBcdFx0XHRcdGdsLmNvcHlUZXhJbWFnZTJEKCBnbC5URVhUVVJFXzJELCAwLCBnbC5SR0IsIHNjcmVlblBvc2l0aW9uUGl4ZWxzLngsIHNjcmVlblBvc2l0aW9uUGl4ZWxzLnksIDE2LCAxNiwgMCApO1xuXG5cbiAgICBcdFx0XHRcdC8vIHJlbmRlciBwaW5rIHF1YWRcblxuICAgIFx0XHRcdFx0Z2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5yZW5kZXJUeXBlLCAwICk7XG4gICAgXHRcdFx0XHRnbC51bmlmb3JtMmYoIHVuaWZvcm1zLnNjYWxlLCBzY2FsZS54LCBzY2FsZS55ICk7XG4gICAgXHRcdFx0XHRnbC51bmlmb3JtM2YoIHVuaWZvcm1zLnNjcmVlblBvc2l0aW9uLCBzY3JlZW5Qb3NpdGlvbi54LCBzY3JlZW5Qb3NpdGlvbi55LCBzY3JlZW5Qb3NpdGlvbi56ICk7XG5cbiAgICBcdFx0XHRcdHN0YXRlLmRpc2FibGUoIGdsLkJMRU5EICk7XG4gICAgXHRcdFx0XHRzdGF0ZS5lbmFibGUoIGdsLkRFUFRIX1RFU1QgKTtcblxuICAgIFx0XHRcdFx0Z2wuZHJhd0VsZW1lbnRzKCBnbC5UUklBTkdMRVMsIDYsIGdsLlVOU0lHTkVEX1NIT1JULCAwICk7XG5cblxuICAgIFx0XHRcdFx0Ly8gY29weSByZXN1bHQgdG8gb2NjbHVzaW9uTWFwXG5cbiAgICBcdFx0XHRcdHN0YXRlLmFjdGl2ZVRleHR1cmUoIGdsLlRFWFRVUkUwICk7XG4gICAgXHRcdFx0XHRzdGF0ZS5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgb2NjbHVzaW9uVGV4dHVyZSApO1xuICAgIFx0XHRcdFx0Z2wuY29weVRleEltYWdlMkQoIGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIHNjcmVlblBvc2l0aW9uUGl4ZWxzLngsIHNjcmVlblBvc2l0aW9uUGl4ZWxzLnksIDE2LCAxNiwgMCApO1xuXG5cbiAgICBcdFx0XHRcdC8vIHJlc3RvcmUgZ3JhcGhpY3NcblxuICAgIFx0XHRcdFx0Z2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5yZW5kZXJUeXBlLCAxICk7XG4gICAgXHRcdFx0XHRzdGF0ZS5kaXNhYmxlKCBnbC5ERVBUSF9URVNUICk7XG5cbiAgICBcdFx0XHRcdHN0YXRlLmFjdGl2ZVRleHR1cmUoIGdsLlRFWFRVUkUxICk7XG4gICAgXHRcdFx0XHRzdGF0ZS5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgdGVtcFRleHR1cmUgKTtcbiAgICBcdFx0XHRcdGdsLmRyYXdFbGVtZW50cyggZ2wuVFJJQU5HTEVTLCA2LCBnbC5VTlNJR05FRF9TSE9SVCwgMCApO1xuXG5cbiAgICBcdFx0XHRcdC8vIHVwZGF0ZSBvYmplY3QgcG9zaXRpb25zXG5cbiAgICBcdFx0XHRcdGZsYXJlLnBvc2l0aW9uU2NyZWVuLmNvcHkoIHNjcmVlblBvc2l0aW9uICk7XG5cbiAgICBcdFx0XHRcdGlmICggZmxhcmUuY3VzdG9tVXBkYXRlQ2FsbGJhY2sgKSB7XG5cbiAgICBcdFx0XHRcdFx0ZmxhcmUuY3VzdG9tVXBkYXRlQ2FsbGJhY2soIGZsYXJlICk7XG5cbiAgICBcdFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdFx0ZmxhcmUudXBkYXRlTGVuc0ZsYXJlcygpO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdC8vIHJlbmRlciBmbGFyZXNcblxuICAgIFx0XHRcdFx0Z2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5yZW5kZXJUeXBlLCAyICk7XG4gICAgXHRcdFx0XHRzdGF0ZS5lbmFibGUoIGdsLkJMRU5EICk7XG5cbiAgICBcdFx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBmbGFyZS5sZW5zRmxhcmVzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG4gICAgXHRcdFx0XHRcdHZhciBzcHJpdGUgPSBmbGFyZS5sZW5zRmxhcmVzWyBqIF07XG5cbiAgICBcdFx0XHRcdFx0aWYgKCBzcHJpdGUub3BhY2l0eSA+IDAuMDAxICYmIHNwcml0ZS5zY2FsZSA+IDAuMDAxICkge1xuXG4gICAgXHRcdFx0XHRcdFx0c2NyZWVuUG9zaXRpb24ueCA9IHNwcml0ZS54O1xuICAgIFx0XHRcdFx0XHRcdHNjcmVlblBvc2l0aW9uLnkgPSBzcHJpdGUueTtcbiAgICBcdFx0XHRcdFx0XHRzY3JlZW5Qb3NpdGlvbi56ID0gc3ByaXRlLno7XG5cbiAgICBcdFx0XHRcdFx0XHRzaXplID0gc3ByaXRlLnNpemUgKiBzcHJpdGUuc2NhbGUgLyB2aWV3cG9ydC53O1xuXG4gICAgXHRcdFx0XHRcdFx0c2NhbGUueCA9IHNpemUgKiBpbnZBc3BlY3Q7XG4gICAgXHRcdFx0XHRcdFx0c2NhbGUueSA9IHNpemU7XG5cbiAgICBcdFx0XHRcdFx0XHRnbC51bmlmb3JtM2YoIHVuaWZvcm1zLnNjcmVlblBvc2l0aW9uLCBzY3JlZW5Qb3NpdGlvbi54LCBzY3JlZW5Qb3NpdGlvbi55LCBzY3JlZW5Qb3NpdGlvbi56ICk7XG4gICAgXHRcdFx0XHRcdFx0Z2wudW5pZm9ybTJmKCB1bmlmb3Jtcy5zY2FsZSwgc2NhbGUueCwgc2NhbGUueSApO1xuICAgIFx0XHRcdFx0XHRcdGdsLnVuaWZvcm0xZiggdW5pZm9ybXMucm90YXRpb24sIHNwcml0ZS5yb3RhdGlvbiApO1xuXG4gICAgXHRcdFx0XHRcdFx0Z2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5vcGFjaXR5LCBzcHJpdGUub3BhY2l0eSApO1xuICAgIFx0XHRcdFx0XHRcdGdsLnVuaWZvcm0zZiggdW5pZm9ybXMuY29sb3IsIHNwcml0ZS5jb2xvci5yLCBzcHJpdGUuY29sb3IuZywgc3ByaXRlLmNvbG9yLmIgKTtcblxuICAgIFx0XHRcdFx0XHRcdHN0YXRlLnNldEJsZW5kaW5nKCBzcHJpdGUuYmxlbmRpbmcsIHNwcml0ZS5ibGVuZEVxdWF0aW9uLCBzcHJpdGUuYmxlbmRTcmMsIHNwcml0ZS5ibGVuZERzdCApO1xuICAgIFx0XHRcdFx0XHRcdHJlbmRlcmVyLnNldFRleHR1cmUyRCggc3ByaXRlLnRleHR1cmUsIDEgKTtcblxuICAgIFx0XHRcdFx0XHRcdGdsLmRyYXdFbGVtZW50cyggZ2wuVFJJQU5HTEVTLCA2LCBnbC5VTlNJR05FRF9TSE9SVCwgMCApO1xuXG4gICAgXHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHQvLyByZXN0b3JlIGdsXG5cbiAgICBcdFx0c3RhdGUuZW5hYmxlKCBnbC5DVUxMX0ZBQ0UgKTtcbiAgICBcdFx0c3RhdGUuZW5hYmxlKCBnbC5ERVBUSF9URVNUICk7XG4gICAgXHRcdHN0YXRlLnNldERlcHRoV3JpdGUoIHRydWUgKTtcblxuICAgIFx0XHRyZW5kZXJlci5yZXNldEdMU3RhdGUoKTtcblxuICAgIFx0fTtcblxuICAgIFx0ZnVuY3Rpb24gY3JlYXRlUHJvZ3JhbSggc2hhZGVyICkge1xuXG4gICAgXHRcdHZhciBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuXG4gICAgXHRcdHZhciBmcmFnbWVudFNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlciggZ2wuRlJBR01FTlRfU0hBREVSICk7XG4gICAgXHRcdHZhciB2ZXJ0ZXhTaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoIGdsLlZFUlRFWF9TSEFERVIgKTtcblxuICAgIFx0XHR2YXIgcHJlZml4ID0gXCJwcmVjaXNpb24gXCIgKyByZW5kZXJlci5nZXRQcmVjaXNpb24oKSArIFwiIGZsb2F0O1xcblwiO1xuXG4gICAgXHRcdGdsLnNoYWRlclNvdXJjZSggZnJhZ21lbnRTaGFkZXIsIHByZWZpeCArIHNoYWRlci5mcmFnbWVudFNoYWRlciApO1xuICAgIFx0XHRnbC5zaGFkZXJTb3VyY2UoIHZlcnRleFNoYWRlciwgcHJlZml4ICsgc2hhZGVyLnZlcnRleFNoYWRlciApO1xuXG4gICAgXHRcdGdsLmNvbXBpbGVTaGFkZXIoIGZyYWdtZW50U2hhZGVyICk7XG4gICAgXHRcdGdsLmNvbXBpbGVTaGFkZXIoIHZlcnRleFNoYWRlciApO1xuXG4gICAgXHRcdGdsLmF0dGFjaFNoYWRlciggcHJvZ3JhbSwgZnJhZ21lbnRTaGFkZXIgKTtcbiAgICBcdFx0Z2wuYXR0YWNoU2hhZGVyKCBwcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIgKTtcblxuICAgIFx0XHRnbC5saW5rUHJvZ3JhbSggcHJvZ3JhbSApO1xuXG4gICAgXHRcdHJldHVybiBwcm9ncmFtO1xuXG4gICAgXHR9XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICAgICAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBTcHJpdGVQbHVnaW4oIHJlbmRlcmVyLCBzcHJpdGVzICkge1xuXG4gICAgXHR2YXIgZ2wgPSByZW5kZXJlci5jb250ZXh0O1xuICAgIFx0dmFyIHN0YXRlID0gcmVuZGVyZXIuc3RhdGU7XG5cbiAgICBcdHZhciB2ZXJ0ZXhCdWZmZXIsIGVsZW1lbnRCdWZmZXI7XG4gICAgXHR2YXIgcHJvZ3JhbSwgYXR0cmlidXRlcywgdW5pZm9ybXM7XG5cbiAgICBcdHZhciB0ZXh0dXJlO1xuXG4gICAgXHQvLyBkZWNvbXBvc2UgbWF0cml4V29ybGRcblxuICAgIFx0dmFyIHNwcml0ZVBvc2l0aW9uID0gbmV3IFZlY3RvcjMoKTtcbiAgICBcdHZhciBzcHJpdGVSb3RhdGlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG4gICAgXHR2YXIgc3ByaXRlU2NhbGUgPSBuZXcgVmVjdG9yMygpO1xuXG4gICAgXHRmdW5jdGlvbiBpbml0KCkge1xuXG4gICAgXHRcdHZhciB2ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIFtcbiAgICBcdFx0XHQtIDAuNSwgLSAwLjUsICAwLCAwLFxuICAgIFx0XHRcdCAgMC41LCAtIDAuNSwgIDEsIDAsXG4gICAgXHRcdFx0ICAwLjUsICAgMC41LCAgMSwgMSxcbiAgICBcdFx0XHQtIDAuNSwgICAwLjUsICAwLCAxXG4gICAgXHRcdF0gKTtcblxuICAgIFx0XHR2YXIgZmFjZXMgPSBuZXcgVWludDE2QXJyYXkoIFtcbiAgICBcdFx0XHQwLCAxLCAyLFxuICAgIFx0XHRcdDAsIDIsIDNcbiAgICBcdFx0XSApO1xuXG4gICAgXHRcdHZlcnRleEJ1ZmZlciAgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBcdFx0ZWxlbWVudEJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuXG4gICAgXHRcdGdsLmJpbmRCdWZmZXIoIGdsLkFSUkFZX0JVRkZFUiwgdmVydGV4QnVmZmVyICk7XG4gICAgXHRcdGdsLmJ1ZmZlckRhdGEoIGdsLkFSUkFZX0JVRkZFUiwgdmVydGljZXMsIGdsLlNUQVRJQ19EUkFXICk7XG5cbiAgICBcdFx0Z2wuYmluZEJ1ZmZlciggZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGVsZW1lbnRCdWZmZXIgKTtcbiAgICBcdFx0Z2wuYnVmZmVyRGF0YSggZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGZhY2VzLCBnbC5TVEFUSUNfRFJBVyApO1xuXG4gICAgXHRcdHByb2dyYW0gPSBjcmVhdGVQcm9ncmFtKCk7XG5cbiAgICBcdFx0YXR0cmlidXRlcyA9IHtcbiAgICBcdFx0XHRwb3NpdGlvbjpcdFx0XHRnbC5nZXRBdHRyaWJMb2NhdGlvbiAoIHByb2dyYW0sICdwb3NpdGlvbicgKSxcbiAgICBcdFx0XHR1djpcdFx0XHRcdFx0Z2wuZ2V0QXR0cmliTG9jYXRpb24gKCBwcm9ncmFtLCAndXYnIClcbiAgICBcdFx0fTtcblxuICAgIFx0XHR1bmlmb3JtcyA9IHtcbiAgICBcdFx0XHR1dk9mZnNldDpcdFx0XHRnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICd1dk9mZnNldCcgKSxcbiAgICBcdFx0XHR1dlNjYWxlOlx0XHRcdGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ3V2U2NhbGUnICksXG5cbiAgICBcdFx0XHRyb3RhdGlvbjpcdFx0XHRnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdyb3RhdGlvbicgKSxcbiAgICBcdFx0XHRzY2FsZTpcdFx0XHRcdGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ3NjYWxlJyApLFxuXG4gICAgXHRcdFx0Y29sb3I6XHRcdFx0XHRnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdjb2xvcicgKSxcbiAgICBcdFx0XHRtYXA6XHRcdFx0XHRnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdtYXAnICksXG4gICAgXHRcdFx0b3BhY2l0eTpcdFx0XHRnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdvcGFjaXR5JyApLFxuXG4gICAgXHRcdFx0bW9kZWxWaWV3TWF0cml4OiBcdGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ21vZGVsVmlld01hdHJpeCcgKSxcbiAgICBcdFx0XHRwcm9qZWN0aW9uTWF0cml4Olx0Z2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAncHJvamVjdGlvbk1hdHJpeCcgKSxcblxuICAgIFx0XHRcdGZvZ1R5cGU6XHRcdFx0Z2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnZm9nVHlwZScgKSxcbiAgICBcdFx0XHRmb2dEZW5zaXR5Olx0XHRcdGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ2ZvZ0RlbnNpdHknICksXG4gICAgXHRcdFx0Zm9nTmVhcjpcdFx0XHRnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdmb2dOZWFyJyApLFxuICAgIFx0XHRcdGZvZ0ZhcjpcdFx0XHRcdGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ2ZvZ0ZhcicgKSxcbiAgICBcdFx0XHRmb2dDb2xvcjpcdFx0XHRnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdmb2dDb2xvcicgKSxcblxuICAgIFx0XHRcdGFscGhhVGVzdDpcdFx0XHRnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdhbHBoYVRlc3QnIClcbiAgICBcdFx0fTtcblxuICAgIFx0XHR2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCcsICdjYW52YXMnICk7XG4gICAgXHRcdGNhbnZhcy53aWR0aCA9IDg7XG4gICAgXHRcdGNhbnZhcy5oZWlnaHQgPSA4O1xuXG4gICAgXHRcdHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoICcyZCcgKTtcbiAgICBcdFx0Y29udGV4dC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgIFx0XHRjb250ZXh0LmZpbGxSZWN0KCAwLCAwLCA4LCA4ICk7XG5cbiAgICBcdFx0dGV4dHVyZSA9IG5ldyBUZXh0dXJlKCBjYW52YXMgKTtcbiAgICBcdFx0dGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICBcdH1cblxuICAgIFx0dGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoIHNjZW5lLCBjYW1lcmEgKSB7XG5cbiAgICBcdFx0aWYgKCBzcHJpdGVzLmxlbmd0aCA9PT0gMCApIHJldHVybjtcblxuICAgIFx0XHQvLyBzZXR1cCBnbFxuXG4gICAgXHRcdGlmICggcHJvZ3JhbSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0aW5pdCgpO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRnbC51c2VQcm9ncmFtKCBwcm9ncmFtICk7XG5cbiAgICBcdFx0c3RhdGUuaW5pdEF0dHJpYnV0ZXMoKTtcbiAgICBcdFx0c3RhdGUuZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLnBvc2l0aW9uICk7XG4gICAgXHRcdHN0YXRlLmVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlcy51diApO1xuICAgIFx0XHRzdGF0ZS5kaXNhYmxlVW51c2VkQXR0cmlidXRlcygpO1xuXG4gICAgXHRcdHN0YXRlLmRpc2FibGUoIGdsLkNVTExfRkFDRSApO1xuICAgIFx0XHRzdGF0ZS5lbmFibGUoIGdsLkJMRU5EICk7XG5cbiAgICBcdFx0Z2wuYmluZEJ1ZmZlciggZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0ZXhCdWZmZXIgKTtcbiAgICBcdFx0Z2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy5wb3NpdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAyICogOCwgMCApO1xuICAgIFx0XHRnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLnV2LCAyLCBnbC5GTE9BVCwgZmFsc2UsIDIgKiA4LCA4ICk7XG5cbiAgICBcdFx0Z2wuYmluZEJ1ZmZlciggZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGVsZW1lbnRCdWZmZXIgKTtcblxuICAgIFx0XHRnbC51bmlmb3JtTWF0cml4NGZ2KCB1bmlmb3Jtcy5wcm9qZWN0aW9uTWF0cml4LCBmYWxzZSwgY2FtZXJhLnByb2plY3Rpb25NYXRyaXguZWxlbWVudHMgKTtcblxuICAgIFx0XHRzdGF0ZS5hY3RpdmVUZXh0dXJlKCBnbC5URVhUVVJFMCApO1xuICAgIFx0XHRnbC51bmlmb3JtMWkoIHVuaWZvcm1zLm1hcCwgMCApO1xuXG4gICAgXHRcdHZhciBvbGRGb2dUeXBlID0gMDtcbiAgICBcdFx0dmFyIHNjZW5lRm9nVHlwZSA9IDA7XG4gICAgXHRcdHZhciBmb2cgPSBzY2VuZS5mb2c7XG5cbiAgICBcdFx0aWYgKCBmb2cgKSB7XG5cbiAgICBcdFx0XHRnbC51bmlmb3JtM2YoIHVuaWZvcm1zLmZvZ0NvbG9yLCBmb2cuY29sb3IuciwgZm9nLmNvbG9yLmcsIGZvZy5jb2xvci5iICk7XG5cbiAgICBcdFx0XHRpZiAoIChmb2cgJiYgZm9nLmlzRm9nKSApIHtcblxuICAgIFx0XHRcdFx0Z2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5mb2dOZWFyLCBmb2cubmVhciApO1xuICAgIFx0XHRcdFx0Z2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5mb2dGYXIsIGZvZy5mYXIgKTtcblxuICAgIFx0XHRcdFx0Z2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5mb2dUeXBlLCAxICk7XG4gICAgXHRcdFx0XHRvbGRGb2dUeXBlID0gMTtcbiAgICBcdFx0XHRcdHNjZW5lRm9nVHlwZSA9IDE7XG5cbiAgICBcdFx0XHR9IGVsc2UgaWYgKCAoZm9nICYmIGZvZy5pc0ZvZ0V4cDIpICkge1xuXG4gICAgXHRcdFx0XHRnbC51bmlmb3JtMWYoIHVuaWZvcm1zLmZvZ0RlbnNpdHksIGZvZy5kZW5zaXR5ICk7XG5cbiAgICBcdFx0XHRcdGdsLnVuaWZvcm0xaSggdW5pZm9ybXMuZm9nVHlwZSwgMiApO1xuICAgIFx0XHRcdFx0b2xkRm9nVHlwZSA9IDI7XG4gICAgXHRcdFx0XHRzY2VuZUZvZ1R5cGUgPSAyO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRnbC51bmlmb3JtMWkoIHVuaWZvcm1zLmZvZ1R5cGUsIDAgKTtcbiAgICBcdFx0XHRvbGRGb2dUeXBlID0gMDtcbiAgICBcdFx0XHRzY2VuZUZvZ1R5cGUgPSAwO1xuXG4gICAgXHRcdH1cblxuXG4gICAgXHRcdC8vIHVwZGF0ZSBwb3NpdGlvbnMgYW5kIHNvcnRcblxuICAgIFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBzcHJpdGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICBcdFx0XHR2YXIgc3ByaXRlID0gc3ByaXRlc1sgaSBdO1xuXG4gICAgXHRcdFx0c3ByaXRlLm1vZGVsVmlld01hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLCBzcHJpdGUubWF0cml4V29ybGQgKTtcbiAgICBcdFx0XHRzcHJpdGUueiA9IC0gc3ByaXRlLm1vZGVsVmlld01hdHJpeC5lbGVtZW50c1sgMTQgXTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0c3ByaXRlcy5zb3J0KCBwYWludGVyU29ydFN0YWJsZSApO1xuXG4gICAgXHRcdC8vIHJlbmRlciBhbGwgc3ByaXRlc1xuXG4gICAgXHRcdHZhciBzY2FsZSA9IFtdO1xuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHNwcml0ZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgIFx0XHRcdHZhciBzcHJpdGUgPSBzcHJpdGVzWyBpIF07XG4gICAgXHRcdFx0dmFyIG1hdGVyaWFsID0gc3ByaXRlLm1hdGVyaWFsO1xuXG4gICAgXHRcdFx0aWYgKCBtYXRlcmlhbC52aXNpYmxlID09PSBmYWxzZSApIGNvbnRpbnVlO1xuXG4gICAgXHRcdFx0Z2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5hbHBoYVRlc3QsIG1hdGVyaWFsLmFscGhhVGVzdCApO1xuICAgIFx0XHRcdGdsLnVuaWZvcm1NYXRyaXg0ZnYoIHVuaWZvcm1zLm1vZGVsVmlld01hdHJpeCwgZmFsc2UsIHNwcml0ZS5tb2RlbFZpZXdNYXRyaXguZWxlbWVudHMgKTtcblxuICAgIFx0XHRcdHNwcml0ZS5tYXRyaXhXb3JsZC5kZWNvbXBvc2UoIHNwcml0ZVBvc2l0aW9uLCBzcHJpdGVSb3RhdGlvbiwgc3ByaXRlU2NhbGUgKTtcblxuICAgIFx0XHRcdHNjYWxlWyAwIF0gPSBzcHJpdGVTY2FsZS54O1xuICAgIFx0XHRcdHNjYWxlWyAxIF0gPSBzcHJpdGVTY2FsZS55O1xuXG4gICAgXHRcdFx0dmFyIGZvZ1R5cGUgPSAwO1xuXG4gICAgXHRcdFx0aWYgKCBzY2VuZS5mb2cgJiYgbWF0ZXJpYWwuZm9nICkge1xuXG4gICAgXHRcdFx0XHRmb2dUeXBlID0gc2NlbmVGb2dUeXBlO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0aWYgKCBvbGRGb2dUeXBlICE9PSBmb2dUeXBlICkge1xuXG4gICAgXHRcdFx0XHRnbC51bmlmb3JtMWkoIHVuaWZvcm1zLmZvZ1R5cGUsIGZvZ1R5cGUgKTtcbiAgICBcdFx0XHRcdG9sZEZvZ1R5cGUgPSBmb2dUeXBlO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0aWYgKCBtYXRlcmlhbC5tYXAgIT09IG51bGwgKSB7XG5cbiAgICBcdFx0XHRcdGdsLnVuaWZvcm0yZiggdW5pZm9ybXMudXZPZmZzZXQsIG1hdGVyaWFsLm1hcC5vZmZzZXQueCwgbWF0ZXJpYWwubWFwLm9mZnNldC55ICk7XG4gICAgXHRcdFx0XHRnbC51bmlmb3JtMmYoIHVuaWZvcm1zLnV2U2NhbGUsIG1hdGVyaWFsLm1hcC5yZXBlYXQueCwgbWF0ZXJpYWwubWFwLnJlcGVhdC55ICk7XG5cbiAgICBcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRnbC51bmlmb3JtMmYoIHVuaWZvcm1zLnV2T2Zmc2V0LCAwLCAwICk7XG4gICAgXHRcdFx0XHRnbC51bmlmb3JtMmYoIHVuaWZvcm1zLnV2U2NhbGUsIDEsIDEgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGdsLnVuaWZvcm0xZiggdW5pZm9ybXMub3BhY2l0eSwgbWF0ZXJpYWwub3BhY2l0eSApO1xuICAgIFx0XHRcdGdsLnVuaWZvcm0zZiggdW5pZm9ybXMuY29sb3IsIG1hdGVyaWFsLmNvbG9yLnIsIG1hdGVyaWFsLmNvbG9yLmcsIG1hdGVyaWFsLmNvbG9yLmIgKTtcblxuICAgIFx0XHRcdGdsLnVuaWZvcm0xZiggdW5pZm9ybXMucm90YXRpb24sIG1hdGVyaWFsLnJvdGF0aW9uICk7XG4gICAgXHRcdFx0Z2wudW5pZm9ybTJmdiggdW5pZm9ybXMuc2NhbGUsIHNjYWxlICk7XG5cbiAgICBcdFx0XHRzdGF0ZS5zZXRCbGVuZGluZyggbWF0ZXJpYWwuYmxlbmRpbmcsIG1hdGVyaWFsLmJsZW5kRXF1YXRpb24sIG1hdGVyaWFsLmJsZW5kU3JjLCBtYXRlcmlhbC5ibGVuZERzdCApO1xuICAgIFx0XHRcdHN0YXRlLnNldERlcHRoVGVzdCggbWF0ZXJpYWwuZGVwdGhUZXN0ICk7XG4gICAgXHRcdFx0c3RhdGUuc2V0RGVwdGhXcml0ZSggbWF0ZXJpYWwuZGVwdGhXcml0ZSApO1xuXG4gICAgXHRcdFx0aWYgKCBtYXRlcmlhbC5tYXAgKSB7XG5cbiAgICBcdFx0XHRcdHJlbmRlcmVyLnNldFRleHR1cmUyRCggbWF0ZXJpYWwubWFwLCAwICk7XG5cbiAgICBcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRyZW5kZXJlci5zZXRUZXh0dXJlMkQoIHRleHR1cmUsIDAgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGdsLmRyYXdFbGVtZW50cyggZ2wuVFJJQU5HTEVTLCA2LCBnbC5VTlNJR05FRF9TSE9SVCwgMCApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHQvLyByZXN0b3JlIGdsXG5cbiAgICBcdFx0c3RhdGUuZW5hYmxlKCBnbC5DVUxMX0ZBQ0UgKTtcblxuICAgIFx0XHRyZW5kZXJlci5yZXNldEdMU3RhdGUoKTtcblxuICAgIFx0fTtcblxuICAgIFx0ZnVuY3Rpb24gY3JlYXRlUHJvZ3JhbSgpIHtcblxuICAgIFx0XHR2YXIgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcblxuICAgIFx0XHR2YXIgdmVydGV4U2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKCBnbC5WRVJURVhfU0hBREVSICk7XG4gICAgXHRcdHZhciBmcmFnbWVudFNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlciggZ2wuRlJBR01FTlRfU0hBREVSICk7XG5cbiAgICBcdFx0Z2wuc2hhZGVyU291cmNlKCB2ZXJ0ZXhTaGFkZXIsIFtcblxuICAgIFx0XHRcdCdwcmVjaXNpb24gJyArIHJlbmRlcmVyLmdldFByZWNpc2lvbigpICsgJyBmbG9hdDsnLFxuXG4gICAgXHRcdFx0J3VuaWZvcm0gbWF0NCBtb2RlbFZpZXdNYXRyaXg7JyxcbiAgICBcdFx0XHQndW5pZm9ybSBtYXQ0IHByb2plY3Rpb25NYXRyaXg7JyxcbiAgICBcdFx0XHQndW5pZm9ybSBmbG9hdCByb3RhdGlvbjsnLFxuICAgIFx0XHRcdCd1bmlmb3JtIHZlYzIgc2NhbGU7JyxcbiAgICBcdFx0XHQndW5pZm9ybSB2ZWMyIHV2T2Zmc2V0OycsXG4gICAgXHRcdFx0J3VuaWZvcm0gdmVjMiB1dlNjYWxlOycsXG5cbiAgICBcdFx0XHQnYXR0cmlidXRlIHZlYzIgcG9zaXRpb247JyxcbiAgICBcdFx0XHQnYXR0cmlidXRlIHZlYzIgdXY7JyxcblxuICAgIFx0XHRcdCd2YXJ5aW5nIHZlYzIgdlVWOycsXG5cbiAgICBcdFx0XHQndm9pZCBtYWluKCkgeycsXG5cbiAgICBcdFx0XHRcdCd2VVYgPSB1dk9mZnNldCArIHV2ICogdXZTY2FsZTsnLFxuXG4gICAgXHRcdFx0XHQndmVjMiBhbGlnbmVkUG9zaXRpb24gPSBwb3NpdGlvbiAqIHNjYWxlOycsXG5cbiAgICBcdFx0XHRcdCd2ZWMyIHJvdGF0ZWRQb3NpdGlvbjsnLFxuICAgIFx0XHRcdFx0J3JvdGF0ZWRQb3NpdGlvbi54ID0gY29zKCByb3RhdGlvbiApICogYWxpZ25lZFBvc2l0aW9uLnggLSBzaW4oIHJvdGF0aW9uICkgKiBhbGlnbmVkUG9zaXRpb24ueTsnLFxuICAgIFx0XHRcdFx0J3JvdGF0ZWRQb3NpdGlvbi55ID0gc2luKCByb3RhdGlvbiApICogYWxpZ25lZFBvc2l0aW9uLnggKyBjb3MoIHJvdGF0aW9uICkgKiBhbGlnbmVkUG9zaXRpb24ueTsnLFxuXG4gICAgXHRcdFx0XHQndmVjNCBmaW5hbFBvc2l0aW9uOycsXG5cbiAgICBcdFx0XHRcdCdmaW5hbFBvc2l0aW9uID0gbW9kZWxWaWV3TWF0cml4ICogdmVjNCggMC4wLCAwLjAsIDAuMCwgMS4wICk7JyxcbiAgICBcdFx0XHRcdCdmaW5hbFBvc2l0aW9uLnh5ICs9IHJvdGF0ZWRQb3NpdGlvbjsnLFxuICAgIFx0XHRcdFx0J2ZpbmFsUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogZmluYWxQb3NpdGlvbjsnLFxuXG4gICAgXHRcdFx0XHQnZ2xfUG9zaXRpb24gPSBmaW5hbFBvc2l0aW9uOycsXG5cbiAgICBcdFx0XHQnfSdcblxuICAgIFx0XHRdLmpvaW4oICdcXG4nICkgKTtcblxuICAgIFx0XHRnbC5zaGFkZXJTb3VyY2UoIGZyYWdtZW50U2hhZGVyLCBbXG5cbiAgICBcdFx0XHQncHJlY2lzaW9uICcgKyByZW5kZXJlci5nZXRQcmVjaXNpb24oKSArICcgZmxvYXQ7JyxcblxuICAgIFx0XHRcdCd1bmlmb3JtIHZlYzMgY29sb3I7JyxcbiAgICBcdFx0XHQndW5pZm9ybSBzYW1wbGVyMkQgbWFwOycsXG4gICAgXHRcdFx0J3VuaWZvcm0gZmxvYXQgb3BhY2l0eTsnLFxuXG4gICAgXHRcdFx0J3VuaWZvcm0gaW50IGZvZ1R5cGU7JyxcbiAgICBcdFx0XHQndW5pZm9ybSB2ZWMzIGZvZ0NvbG9yOycsXG4gICAgXHRcdFx0J3VuaWZvcm0gZmxvYXQgZm9nRGVuc2l0eTsnLFxuICAgIFx0XHRcdCd1bmlmb3JtIGZsb2F0IGZvZ05lYXI7JyxcbiAgICBcdFx0XHQndW5pZm9ybSBmbG9hdCBmb2dGYXI7JyxcbiAgICBcdFx0XHQndW5pZm9ybSBmbG9hdCBhbHBoYVRlc3Q7JyxcblxuICAgIFx0XHRcdCd2YXJ5aW5nIHZlYzIgdlVWOycsXG5cbiAgICBcdFx0XHQndm9pZCBtYWluKCkgeycsXG5cbiAgICBcdFx0XHRcdCd2ZWM0IHRleHR1cmUgPSB0ZXh0dXJlMkQoIG1hcCwgdlVWICk7JyxcblxuICAgIFx0XHRcdFx0J2lmICggdGV4dHVyZS5hIDwgYWxwaGFUZXN0ICkgZGlzY2FyZDsnLFxuXG4gICAgXHRcdFx0XHQnZ2xfRnJhZ0NvbG9yID0gdmVjNCggY29sb3IgKiB0ZXh0dXJlLnh5eiwgdGV4dHVyZS5hICogb3BhY2l0eSApOycsXG5cbiAgICBcdFx0XHRcdCdpZiAoIGZvZ1R5cGUgPiAwICkgeycsXG5cbiAgICBcdFx0XHRcdFx0J2Zsb2F0IGRlcHRoID0gZ2xfRnJhZ0Nvb3JkLnogLyBnbF9GcmFnQ29vcmQudzsnLFxuICAgIFx0XHRcdFx0XHQnZmxvYXQgZm9nRmFjdG9yID0gMC4wOycsXG5cbiAgICBcdFx0XHRcdFx0J2lmICggZm9nVHlwZSA9PSAxICkgeycsXG5cbiAgICBcdFx0XHRcdFx0XHQnZm9nRmFjdG9yID0gc21vb3Roc3RlcCggZm9nTmVhciwgZm9nRmFyLCBkZXB0aCApOycsXG5cbiAgICBcdFx0XHRcdFx0J30gZWxzZSB7JyxcblxuICAgIFx0XHRcdFx0XHRcdCdjb25zdCBmbG9hdCBMT0cyID0gMS40NDI2OTU7JyxcbiAgICBcdFx0XHRcdFx0XHQnZm9nRmFjdG9yID0gZXhwMiggLSBmb2dEZW5zaXR5ICogZm9nRGVuc2l0eSAqIGRlcHRoICogZGVwdGggKiBMT0cyICk7JyxcbiAgICBcdFx0XHRcdFx0XHQnZm9nRmFjdG9yID0gMS4wIC0gY2xhbXAoIGZvZ0ZhY3RvciwgMC4wLCAxLjAgKTsnLFxuXG4gICAgXHRcdFx0XHRcdCd9JyxcblxuICAgIFx0XHRcdFx0XHQnZ2xfRnJhZ0NvbG9yID0gbWl4KCBnbF9GcmFnQ29sb3IsIHZlYzQoIGZvZ0NvbG9yLCBnbF9GcmFnQ29sb3IudyApLCBmb2dGYWN0b3IgKTsnLFxuXG4gICAgXHRcdFx0XHQnfScsXG5cbiAgICBcdFx0XHQnfSdcblxuICAgIFx0XHRdLmpvaW4oICdcXG4nICkgKTtcblxuICAgIFx0XHRnbC5jb21waWxlU2hhZGVyKCB2ZXJ0ZXhTaGFkZXIgKTtcbiAgICBcdFx0Z2wuY29tcGlsZVNoYWRlciggZnJhZ21lbnRTaGFkZXIgKTtcblxuICAgIFx0XHRnbC5hdHRhY2hTaGFkZXIoIHByb2dyYW0sIHZlcnRleFNoYWRlciApO1xuICAgIFx0XHRnbC5hdHRhY2hTaGFkZXIoIHByb2dyYW0sIGZyYWdtZW50U2hhZGVyICk7XG5cbiAgICBcdFx0Z2wubGlua1Byb2dyYW0oIHByb2dyYW0gKTtcblxuICAgIFx0XHRyZXR1cm4gcHJvZ3JhbTtcblxuICAgIFx0fVxuXG4gICAgXHRmdW5jdGlvbiBwYWludGVyU29ydFN0YWJsZSggYSwgYiApIHtcblxuICAgIFx0XHRpZiAoIGEucmVuZGVyT3JkZXIgIT09IGIucmVuZGVyT3JkZXIgKSB7XG5cbiAgICBcdFx0XHRyZXR1cm4gYS5yZW5kZXJPcmRlciAtIGIucmVuZGVyT3JkZXI7XG5cbiAgICBcdFx0fSBlbHNlIGlmICggYS56ICE9PSBiLnogKSB7XG5cbiAgICBcdFx0XHRyZXR1cm4gYi56IC0gYS56O1xuXG4gICAgXHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRyZXR1cm4gYi5pZCAtIGEuaWQ7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICAgICAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBNYXRlcmlhbCgpIHtcblxuICAgIFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCAnaWQnLCB7IHZhbHVlOiBNYXRlcmlhbElkQ291bnQoKSB9ICk7XG5cbiAgICBcdHRoaXMudXVpZCA9IGV4cG9ydHMuTWF0aC5nZW5lcmF0ZVVVSUQoKTtcblxuICAgIFx0dGhpcy5uYW1lID0gJyc7XG4gICAgXHR0aGlzLnR5cGUgPSAnTWF0ZXJpYWwnO1xuXG4gICAgXHR0aGlzLmZvZyA9IHRydWU7XG4gICAgXHR0aGlzLmxpZ2h0cyA9IHRydWU7XG5cbiAgICBcdHRoaXMuYmxlbmRpbmcgPSBOb3JtYWxCbGVuZGluZztcbiAgICBcdHRoaXMuc2lkZSA9IEZyb250U2lkZTtcbiAgICBcdHRoaXMuc2hhZGluZyA9IFNtb290aFNoYWRpbmc7IC8vIFRIUkVFLkZsYXRTaGFkaW5nLCBUSFJFRS5TbW9vdGhTaGFkaW5nXG4gICAgXHR0aGlzLnZlcnRleENvbG9ycyA9IE5vQ29sb3JzOyAvLyBUSFJFRS5Ob0NvbG9ycywgVEhSRUUuVmVydGV4Q29sb3JzLCBUSFJFRS5GYWNlQ29sb3JzXG5cbiAgICBcdHRoaXMub3BhY2l0eSA9IDE7XG4gICAgXHR0aGlzLnRyYW5zcGFyZW50ID0gZmFsc2U7XG5cbiAgICBcdHRoaXMuYmxlbmRTcmMgPSBTcmNBbHBoYUZhY3RvcjtcbiAgICBcdHRoaXMuYmxlbmREc3QgPSBPbmVNaW51c1NyY0FscGhhRmFjdG9yO1xuICAgIFx0dGhpcy5ibGVuZEVxdWF0aW9uID0gQWRkRXF1YXRpb247XG4gICAgXHR0aGlzLmJsZW5kU3JjQWxwaGEgPSBudWxsO1xuICAgIFx0dGhpcy5ibGVuZERzdEFscGhhID0gbnVsbDtcbiAgICBcdHRoaXMuYmxlbmRFcXVhdGlvbkFscGhhID0gbnVsbDtcblxuICAgIFx0dGhpcy5kZXB0aEZ1bmMgPSBMZXNzRXF1YWxEZXB0aDtcbiAgICBcdHRoaXMuZGVwdGhUZXN0ID0gdHJ1ZTtcbiAgICBcdHRoaXMuZGVwdGhXcml0ZSA9IHRydWU7XG5cbiAgICBcdHRoaXMuY2xpcHBpbmdQbGFuZXMgPSBudWxsO1xuICAgIFx0dGhpcy5jbGlwU2hhZG93cyA9IGZhbHNlO1xuXG4gICAgXHR0aGlzLmNvbG9yV3JpdGUgPSB0cnVlO1xuXG4gICAgXHR0aGlzLnByZWNpc2lvbiA9IG51bGw7IC8vIG92ZXJyaWRlIHRoZSByZW5kZXJlcidzIGRlZmF1bHQgcHJlY2lzaW9uIGZvciB0aGlzIG1hdGVyaWFsXG5cbiAgICBcdHRoaXMucG9seWdvbk9mZnNldCA9IGZhbHNlO1xuICAgIFx0dGhpcy5wb2x5Z29uT2Zmc2V0RmFjdG9yID0gMDtcbiAgICBcdHRoaXMucG9seWdvbk9mZnNldFVuaXRzID0gMDtcblxuICAgIFx0dGhpcy5hbHBoYVRlc3QgPSAwO1xuICAgIFx0dGhpcy5wcmVtdWx0aXBsaWVkQWxwaGEgPSBmYWxzZTtcblxuICAgIFx0dGhpcy5vdmVyZHJhdyA9IDA7IC8vIE92ZXJkcmF3biBwaXhlbHMgKHR5cGljYWxseSBiZXR3ZWVuIDAgYW5kIDEpIGZvciBmaXhpbmcgYW50aWFsaWFzaW5nIGdhcHMgaW4gQ2FudmFzUmVuZGVyZXJcblxuICAgIFx0dGhpcy52aXNpYmxlID0gdHJ1ZTtcblxuICAgIFx0dGhpcy5fbmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgfVxuXG4gICAgTWF0ZXJpYWwucHJvdG90eXBlID0ge1xuXG4gICAgXHRjb25zdHJ1Y3RvcjogTWF0ZXJpYWwsXG5cbiAgICBcdGlzTWF0ZXJpYWw6IHRydWUsXG5cbiAgICBcdGdldCBuZWVkc1VwZGF0ZSgpIHtcblxuICAgIFx0XHRyZXR1cm4gdGhpcy5fbmVlZHNVcGRhdGU7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldCBuZWVkc1VwZGF0ZSggdmFsdWUgKSB7XG5cbiAgICBcdFx0aWYgKCB2YWx1ZSA9PT0gdHJ1ZSApIHRoaXMudXBkYXRlKCk7XG4gICAgXHRcdHRoaXMuX25lZWRzVXBkYXRlID0gdmFsdWU7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldFZhbHVlczogZnVuY3Rpb24gKCB2YWx1ZXMgKSB7XG5cbiAgICBcdFx0aWYgKCB2YWx1ZXMgPT09IHVuZGVmaW5lZCApIHJldHVybjtcblxuICAgIFx0XHRmb3IgKCB2YXIga2V5IGluIHZhbHVlcyApIHtcblxuICAgIFx0XHRcdHZhciBuZXdWYWx1ZSA9IHZhbHVlc1sga2V5IF07XG5cbiAgICBcdFx0XHRpZiAoIG5ld1ZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRcdGNvbnNvbGUud2FybiggXCJUSFJFRS5NYXRlcmlhbDogJ1wiICsga2V5ICsgXCInIHBhcmFtZXRlciBpcyB1bmRlZmluZWQuXCIgKTtcbiAgICBcdFx0XHRcdGNvbnRpbnVlO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0dmFyIGN1cnJlbnRWYWx1ZSA9IHRoaXNbIGtleSBdO1xuXG4gICAgXHRcdFx0aWYgKCBjdXJyZW50VmFsdWUgPT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0Y29uc29sZS53YXJuKCBcIlRIUkVFLlwiICsgdGhpcy50eXBlICsgXCI6ICdcIiArIGtleSArIFwiJyBpcyBub3QgYSBwcm9wZXJ0eSBvZiB0aGlzIG1hdGVyaWFsLlwiICk7XG4gICAgXHRcdFx0XHRjb250aW51ZTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGlmICggKGN1cnJlbnRWYWx1ZSAmJiBjdXJyZW50VmFsdWUuaXNDb2xvcikgKSB7XG5cbiAgICBcdFx0XHRcdGN1cnJlbnRWYWx1ZS5zZXQoIG5ld1ZhbHVlICk7XG5cbiAgICBcdFx0XHR9IGVsc2UgaWYgKCAoY3VycmVudFZhbHVlICYmIGN1cnJlbnRWYWx1ZS5pc1ZlY3RvcjMpICYmIChuZXdWYWx1ZSAmJiBuZXdWYWx1ZS5pc1ZlY3RvcjMpICkge1xuXG4gICAgXHRcdFx0XHRjdXJyZW50VmFsdWUuY29weSggbmV3VmFsdWUgKTtcblxuICAgIFx0XHRcdH0gZWxzZSBpZiAoIGtleSA9PT0gJ292ZXJkcmF3JyApIHtcblxuICAgIFx0XHRcdFx0Ly8gZW5zdXJlIG92ZXJkcmF3IGlzIGJhY2t3YXJkcy1jb21wYXRpYmxlIHdpdGggbGVnYWN5IGJvb2xlYW4gdHlwZVxuICAgIFx0XHRcdFx0dGhpc1sga2V5IF0gPSBOdW1iZXIoIG5ld1ZhbHVlICk7XG5cbiAgICBcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHR0aGlzWyBrZXkgXSA9IG5ld1ZhbHVlO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0fSxcblxuICAgIFx0dG9KU09OOiBmdW5jdGlvbiAoIG1ldGEgKSB7XG5cbiAgICBcdFx0dmFyIGlzUm9vdCA9IG1ldGEgPT09IHVuZGVmaW5lZDtcblxuICAgIFx0XHRpZiAoIGlzUm9vdCApIHtcblxuICAgIFx0XHRcdG1ldGEgPSB7XG4gICAgXHRcdFx0XHR0ZXh0dXJlczoge30sXG4gICAgXHRcdFx0XHRpbWFnZXM6IHt9XG4gICAgXHRcdFx0fTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0dmFyIGRhdGEgPSB7XG4gICAgXHRcdFx0bWV0YWRhdGE6IHtcbiAgICBcdFx0XHRcdHZlcnNpb246IDQuNCxcbiAgICBcdFx0XHRcdHR5cGU6ICdNYXRlcmlhbCcsXG4gICAgXHRcdFx0XHRnZW5lcmF0b3I6ICdNYXRlcmlhbC50b0pTT04nXG4gICAgXHRcdFx0fVxuICAgIFx0XHR9O1xuXG4gICAgXHRcdC8vIHN0YW5kYXJkIE1hdGVyaWFsIHNlcmlhbGl6YXRpb25cbiAgICBcdFx0ZGF0YS51dWlkID0gdGhpcy51dWlkO1xuICAgIFx0XHRkYXRhLnR5cGUgPSB0aGlzLnR5cGU7XG5cbiAgICBcdFx0aWYgKCB0aGlzLm5hbWUgIT09ICcnICkgZGF0YS5uYW1lID0gdGhpcy5uYW1lO1xuXG4gICAgXHRcdGlmICggKHRoaXMuY29sb3IgJiYgdGhpcy5jb2xvci5pc0NvbG9yKSApIGRhdGEuY29sb3IgPSB0aGlzLmNvbG9yLmdldEhleCgpO1xuXG4gICAgXHRcdGlmICggdGhpcy5yb3VnaG5lc3MgIT09IHVuZGVmaW5lZCApIGRhdGEucm91Z2huZXNzID0gdGhpcy5yb3VnaG5lc3M7XG4gICAgXHRcdGlmICggdGhpcy5tZXRhbG5lc3MgIT09IHVuZGVmaW5lZCApIGRhdGEubWV0YWxuZXNzID0gdGhpcy5tZXRhbG5lc3M7XG5cbiAgICBcdFx0aWYgKCAodGhpcy5lbWlzc2l2ZSAmJiB0aGlzLmVtaXNzaXZlLmlzQ29sb3IpICkgZGF0YS5lbWlzc2l2ZSA9IHRoaXMuZW1pc3NpdmUuZ2V0SGV4KCk7XG4gICAgXHRcdGlmICggKHRoaXMuc3BlY3VsYXIgJiYgdGhpcy5zcGVjdWxhci5pc0NvbG9yKSApIGRhdGEuc3BlY3VsYXIgPSB0aGlzLnNwZWN1bGFyLmdldEhleCgpO1xuICAgIFx0XHRpZiAoIHRoaXMuc2hpbmluZXNzICE9PSB1bmRlZmluZWQgKSBkYXRhLnNoaW5pbmVzcyA9IHRoaXMuc2hpbmluZXNzO1xuXG4gICAgXHRcdGlmICggKHRoaXMubWFwICYmIHRoaXMubWFwLmlzVGV4dHVyZSkgKSBkYXRhLm1hcCA9IHRoaXMubWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XG4gICAgXHRcdGlmICggKHRoaXMuYWxwaGFNYXAgJiYgdGhpcy5hbHBoYU1hcC5pc1RleHR1cmUpICkgZGF0YS5hbHBoYU1hcCA9IHRoaXMuYWxwaGFNYXAudG9KU09OKCBtZXRhICkudXVpZDtcbiAgICBcdFx0aWYgKCAodGhpcy5saWdodE1hcCAmJiB0aGlzLmxpZ2h0TWFwLmlzVGV4dHVyZSkgKSBkYXRhLmxpZ2h0TWFwID0gdGhpcy5saWdodE1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xuICAgIFx0XHRpZiAoICh0aGlzLmJ1bXBNYXAgJiYgdGhpcy5idW1wTWFwLmlzVGV4dHVyZSkgKSB7XG5cbiAgICBcdFx0XHRkYXRhLmJ1bXBNYXAgPSB0aGlzLmJ1bXBNYXAudG9KU09OKCBtZXRhICkudXVpZDtcbiAgICBcdFx0XHRkYXRhLmJ1bXBTY2FsZSA9IHRoaXMuYnVtcFNjYWxlO1xuXG4gICAgXHRcdH1cbiAgICBcdFx0aWYgKCAodGhpcy5ub3JtYWxNYXAgJiYgdGhpcy5ub3JtYWxNYXAuaXNUZXh0dXJlKSApIHtcblxuICAgIFx0XHRcdGRhdGEubm9ybWFsTWFwID0gdGhpcy5ub3JtYWxNYXAudG9KU09OKCBtZXRhICkudXVpZDtcbiAgICBcdFx0XHRkYXRhLm5vcm1hbFNjYWxlID0gdGhpcy5ub3JtYWxTY2FsZS50b0FycmF5KCk7XG5cbiAgICBcdFx0fVxuICAgIFx0XHRpZiAoICh0aGlzLmRpc3BsYWNlbWVudE1hcCAmJiB0aGlzLmRpc3BsYWNlbWVudE1hcC5pc1RleHR1cmUpICkge1xuXG4gICAgXHRcdFx0ZGF0YS5kaXNwbGFjZW1lbnRNYXAgPSB0aGlzLmRpc3BsYWNlbWVudE1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xuICAgIFx0XHRcdGRhdGEuZGlzcGxhY2VtZW50U2NhbGUgPSB0aGlzLmRpc3BsYWNlbWVudFNjYWxlO1xuICAgIFx0XHRcdGRhdGEuZGlzcGxhY2VtZW50QmlhcyA9IHRoaXMuZGlzcGxhY2VtZW50QmlhcztcblxuICAgIFx0XHR9XG4gICAgXHRcdGlmICggKHRoaXMucm91Z2huZXNzTWFwICYmIHRoaXMucm91Z2huZXNzTWFwLmlzVGV4dHVyZSkgKSBkYXRhLnJvdWdobmVzc01hcCA9IHRoaXMucm91Z2huZXNzTWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XG4gICAgXHRcdGlmICggKHRoaXMubWV0YWxuZXNzTWFwICYmIHRoaXMubWV0YWxuZXNzTWFwLmlzVGV4dHVyZSkgKSBkYXRhLm1ldGFsbmVzc01hcCA9IHRoaXMubWV0YWxuZXNzTWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XG5cbiAgICBcdFx0aWYgKCAodGhpcy5lbWlzc2l2ZU1hcCAmJiB0aGlzLmVtaXNzaXZlTWFwLmlzVGV4dHVyZSkgKSBkYXRhLmVtaXNzaXZlTWFwID0gdGhpcy5lbWlzc2l2ZU1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xuICAgIFx0XHRpZiAoICh0aGlzLnNwZWN1bGFyTWFwICYmIHRoaXMuc3BlY3VsYXJNYXAuaXNUZXh0dXJlKSApIGRhdGEuc3BlY3VsYXJNYXAgPSB0aGlzLnNwZWN1bGFyTWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XG5cbiAgICBcdFx0aWYgKCAodGhpcy5lbnZNYXAgJiYgdGhpcy5lbnZNYXAuaXNUZXh0dXJlKSApIHtcblxuICAgIFx0XHRcdGRhdGEuZW52TWFwID0gdGhpcy5lbnZNYXAudG9KU09OKCBtZXRhICkudXVpZDtcbiAgICBcdFx0XHRkYXRhLnJlZmxlY3Rpdml0eSA9IHRoaXMucmVmbGVjdGl2aXR5OyAvLyBTY2FsZSBiZWhpbmQgZW52TWFwXG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGlmICggdGhpcy5zaXplICE9PSB1bmRlZmluZWQgKSBkYXRhLnNpemUgPSB0aGlzLnNpemU7XG4gICAgXHRcdGlmICggdGhpcy5zaXplQXR0ZW51YXRpb24gIT09IHVuZGVmaW5lZCApIGRhdGEuc2l6ZUF0dGVudWF0aW9uID0gdGhpcy5zaXplQXR0ZW51YXRpb247XG5cbiAgICBcdFx0aWYgKCB0aGlzLmJsZW5kaW5nICE9PSBOb3JtYWxCbGVuZGluZyApIGRhdGEuYmxlbmRpbmcgPSB0aGlzLmJsZW5kaW5nO1xuICAgIFx0XHRpZiAoIHRoaXMuc2hhZGluZyAhPT0gU21vb3RoU2hhZGluZyApIGRhdGEuc2hhZGluZyA9IHRoaXMuc2hhZGluZztcbiAgICBcdFx0aWYgKCB0aGlzLnNpZGUgIT09IEZyb250U2lkZSApIGRhdGEuc2lkZSA9IHRoaXMuc2lkZTtcbiAgICBcdFx0aWYgKCB0aGlzLnZlcnRleENvbG9ycyAhPT0gTm9Db2xvcnMgKSBkYXRhLnZlcnRleENvbG9ycyA9IHRoaXMudmVydGV4Q29sb3JzO1xuXG4gICAgXHRcdGlmICggdGhpcy5vcGFjaXR5IDwgMSApIGRhdGEub3BhY2l0eSA9IHRoaXMub3BhY2l0eTtcbiAgICBcdFx0aWYgKCB0aGlzLnRyYW5zcGFyZW50ID09PSB0cnVlICkgZGF0YS50cmFuc3BhcmVudCA9IHRoaXMudHJhbnNwYXJlbnQ7XG5cbiAgICBcdFx0ZGF0YS5kZXB0aEZ1bmMgPSB0aGlzLmRlcHRoRnVuYztcbiAgICBcdFx0ZGF0YS5kZXB0aFRlc3QgPSB0aGlzLmRlcHRoVGVzdDtcbiAgICBcdFx0ZGF0YS5kZXB0aFdyaXRlID0gdGhpcy5kZXB0aFdyaXRlO1xuXG4gICAgXHRcdGlmICggdGhpcy5hbHBoYVRlc3QgPiAwICkgZGF0YS5hbHBoYVRlc3QgPSB0aGlzLmFscGhhVGVzdDtcbiAgICBcdFx0aWYgKCB0aGlzLnByZW11bHRpcGxpZWRBbHBoYSA9PT0gdHJ1ZSApIGRhdGEucHJlbXVsdGlwbGllZEFscGhhID0gdGhpcy5wcmVtdWx0aXBsaWVkQWxwaGE7XG4gICAgXHRcdGlmICggdGhpcy53aXJlZnJhbWUgPT09IHRydWUgKSBkYXRhLndpcmVmcmFtZSA9IHRoaXMud2lyZWZyYW1lO1xuICAgIFx0XHRpZiAoIHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID4gMSApIGRhdGEud2lyZWZyYW1lTGluZXdpZHRoID0gdGhpcy53aXJlZnJhbWVMaW5ld2lkdGg7XG4gICAgXHRcdGlmICggdGhpcy53aXJlZnJhbWVMaW5lY2FwICE9PSAncm91bmQnICkgZGF0YS53aXJlZnJhbWVMaW5lY2FwID0gdGhpcy53aXJlZnJhbWVMaW5lY2FwO1xuICAgIFx0XHRpZiAoIHRoaXMud2lyZWZyYW1lTGluZWpvaW4gIT09ICdyb3VuZCcgKSBkYXRhLndpcmVmcmFtZUxpbmVqb2luID0gdGhpcy53aXJlZnJhbWVMaW5lam9pbjtcblxuICAgIFx0XHRkYXRhLnNraW5uaW5nID0gdGhpcy5za2lubmluZztcbiAgICBcdFx0ZGF0YS5tb3JwaFRhcmdldHMgPSB0aGlzLm1vcnBoVGFyZ2V0cztcblxuICAgIFx0XHQvLyBUT0RPOiBDb3BpZWQgZnJvbSBPYmplY3QzRC50b0pTT05cblxuICAgIFx0XHRmdW5jdGlvbiBleHRyYWN0RnJvbUNhY2hlKCBjYWNoZSApIHtcblxuICAgIFx0XHRcdHZhciB2YWx1ZXMgPSBbXTtcblxuICAgIFx0XHRcdGZvciAoIHZhciBrZXkgaW4gY2FjaGUgKSB7XG5cbiAgICBcdFx0XHRcdHZhciBkYXRhID0gY2FjaGVbIGtleSBdO1xuICAgIFx0XHRcdFx0ZGVsZXRlIGRhdGEubWV0YWRhdGE7XG4gICAgXHRcdFx0XHR2YWx1ZXMucHVzaCggZGF0YSApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0cmV0dXJuIHZhbHVlcztcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKCBpc1Jvb3QgKSB7XG5cbiAgICBcdFx0XHR2YXIgdGV4dHVyZXMgPSBleHRyYWN0RnJvbUNhY2hlKCBtZXRhLnRleHR1cmVzICk7XG4gICAgXHRcdFx0dmFyIGltYWdlcyA9IGV4dHJhY3RGcm9tQ2FjaGUoIG1ldGEuaW1hZ2VzICk7XG5cbiAgICBcdFx0XHRpZiAoIHRleHR1cmVzLmxlbmd0aCA+IDAgKSBkYXRhLnRleHR1cmVzID0gdGV4dHVyZXM7XG4gICAgXHRcdFx0aWYgKCBpbWFnZXMubGVuZ3RoID4gMCApIGRhdGEuaW1hZ2VzID0gaW1hZ2VzO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gZGF0YTtcblxuICAgIFx0fSxcblxuICAgIFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xuXG4gICAgXHRcdHRoaXMubmFtZSA9IHNvdXJjZS5uYW1lO1xuXG4gICAgXHRcdHRoaXMuZm9nID0gc291cmNlLmZvZztcbiAgICBcdFx0dGhpcy5saWdodHMgPSBzb3VyY2UubGlnaHRzO1xuXG4gICAgXHRcdHRoaXMuYmxlbmRpbmcgPSBzb3VyY2UuYmxlbmRpbmc7XG4gICAgXHRcdHRoaXMuc2lkZSA9IHNvdXJjZS5zaWRlO1xuICAgIFx0XHR0aGlzLnNoYWRpbmcgPSBzb3VyY2Uuc2hhZGluZztcbiAgICBcdFx0dGhpcy52ZXJ0ZXhDb2xvcnMgPSBzb3VyY2UudmVydGV4Q29sb3JzO1xuXG4gICAgXHRcdHRoaXMub3BhY2l0eSA9IHNvdXJjZS5vcGFjaXR5O1xuICAgIFx0XHR0aGlzLnRyYW5zcGFyZW50ID0gc291cmNlLnRyYW5zcGFyZW50O1xuXG4gICAgXHRcdHRoaXMuYmxlbmRTcmMgPSBzb3VyY2UuYmxlbmRTcmM7XG4gICAgXHRcdHRoaXMuYmxlbmREc3QgPSBzb3VyY2UuYmxlbmREc3Q7XG4gICAgXHRcdHRoaXMuYmxlbmRFcXVhdGlvbiA9IHNvdXJjZS5ibGVuZEVxdWF0aW9uO1xuICAgIFx0XHR0aGlzLmJsZW5kU3JjQWxwaGEgPSBzb3VyY2UuYmxlbmRTcmNBbHBoYTtcbiAgICBcdFx0dGhpcy5ibGVuZERzdEFscGhhID0gc291cmNlLmJsZW5kRHN0QWxwaGE7XG4gICAgXHRcdHRoaXMuYmxlbmRFcXVhdGlvbkFscGhhID0gc291cmNlLmJsZW5kRXF1YXRpb25BbHBoYTtcblxuICAgIFx0XHR0aGlzLmRlcHRoRnVuYyA9IHNvdXJjZS5kZXB0aEZ1bmM7XG4gICAgXHRcdHRoaXMuZGVwdGhUZXN0ID0gc291cmNlLmRlcHRoVGVzdDtcbiAgICBcdFx0dGhpcy5kZXB0aFdyaXRlID0gc291cmNlLmRlcHRoV3JpdGU7XG5cbiAgICBcdFx0dGhpcy5jb2xvcldyaXRlID0gc291cmNlLmNvbG9yV3JpdGU7XG5cbiAgICBcdFx0dGhpcy5wcmVjaXNpb24gPSBzb3VyY2UucHJlY2lzaW9uO1xuXG4gICAgXHRcdHRoaXMucG9seWdvbk9mZnNldCA9IHNvdXJjZS5wb2x5Z29uT2Zmc2V0O1xuICAgIFx0XHR0aGlzLnBvbHlnb25PZmZzZXRGYWN0b3IgPSBzb3VyY2UucG9seWdvbk9mZnNldEZhY3RvcjtcbiAgICBcdFx0dGhpcy5wb2x5Z29uT2Zmc2V0VW5pdHMgPSBzb3VyY2UucG9seWdvbk9mZnNldFVuaXRzO1xuXG4gICAgXHRcdHRoaXMuYWxwaGFUZXN0ID0gc291cmNlLmFscGhhVGVzdDtcblxuICAgIFx0XHR0aGlzLnByZW11bHRpcGxpZWRBbHBoYSA9IHNvdXJjZS5wcmVtdWx0aXBsaWVkQWxwaGE7XG5cbiAgICBcdFx0dGhpcy5vdmVyZHJhdyA9IHNvdXJjZS5vdmVyZHJhdztcblxuICAgIFx0XHR0aGlzLnZpc2libGUgPSBzb3VyY2UudmlzaWJsZTtcbiAgICBcdFx0dGhpcy5jbGlwU2hhZG93cyA9IHNvdXJjZS5jbGlwU2hhZG93cztcblxuICAgIFx0XHR2YXIgc3JjUGxhbmVzID0gc291cmNlLmNsaXBwaW5nUGxhbmVzLFxuICAgIFx0XHRcdGRzdFBsYW5lcyA9IG51bGw7XG5cbiAgICBcdFx0aWYgKCBzcmNQbGFuZXMgIT09IG51bGwgKSB7XG5cbiAgICBcdFx0XHR2YXIgbiA9IHNyY1BsYW5lcy5sZW5ndGg7XG4gICAgXHRcdFx0ZHN0UGxhbmVzID0gbmV3IEFycmF5KCBuICk7XG5cbiAgICBcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgIT09IG47ICsrIGkgKVxuICAgIFx0XHRcdFx0ZHN0UGxhbmVzWyBpIF0gPSBzcmNQbGFuZXNbIGkgXS5jbG9uZSgpO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHR0aGlzLmNsaXBwaW5nUGxhbmVzID0gZHN0UGxhbmVzO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHR1cGRhdGU6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ3VwZGF0ZScgfSApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dGhpcy5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdkaXNwb3NlJyB9ICk7XG5cbiAgICBcdH1cblxuICAgIH07XG5cbiAgICBPYmplY3QuYXNzaWduKCBNYXRlcmlhbC5wcm90b3R5cGUsIEV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUgKTtcblxuICAgIHZhciBjb3VudCQxID0gMDtcbiAgICBmdW5jdGlvbiBNYXRlcmlhbElkQ291bnQoKSB7IHJldHVybiBjb3VudCQxKys7IH07XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICAgICAqXG4gICAgICogcGFyYW1ldGVycyA9IHtcbiAgICAgKiAgZGVmaW5lczogeyBcImxhYmVsXCIgOiBcInZhbHVlXCIgfSxcbiAgICAgKiAgdW5pZm9ybXM6IHsgXCJwYXJhbWV0ZXIxXCI6IHsgdmFsdWU6IDEuMCB9LCBcInBhcmFtZXRlcjJcIjogeyB2YWx1ZTI6IDIgfSB9LFxuICAgICAqXG4gICAgICogIGZyYWdtZW50U2hhZGVyOiA8c3RyaW5nPixcbiAgICAgKiAgdmVydGV4U2hhZGVyOiA8c3RyaW5nPixcbiAgICAgKlxuICAgICAqICB3aXJlZnJhbWU6IDxib29sZWFuPixcbiAgICAgKiAgd2lyZWZyYW1lTGluZXdpZHRoOiA8ZmxvYXQ+LFxuICAgICAqXG4gICAgICogIGxpZ2h0czogPGJvb2w+LFxuICAgICAqXG4gICAgICogIHNraW5uaW5nOiA8Ym9vbD4sXG4gICAgICogIG1vcnBoVGFyZ2V0czogPGJvb2w+LFxuICAgICAqICBtb3JwaE5vcm1hbHM6IDxib29sPlxuICAgICAqIH1cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIFNoYWRlck1hdGVyaWFsKCBwYXJhbWV0ZXJzICkge1xuXG4gICAgXHRNYXRlcmlhbC5jYWxsKCB0aGlzICk7XG5cbiAgICBcdHRoaXMudHlwZSA9ICdTaGFkZXJNYXRlcmlhbCc7XG5cbiAgICBcdHRoaXMuZGVmaW5lcyA9IHt9O1xuICAgIFx0dGhpcy51bmlmb3JtcyA9IHt9O1xuXG4gICAgXHR0aGlzLnZlcnRleFNoYWRlciA9ICd2b2lkIG1haW4oKSB7XFxuXFx0Z2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1xcbn0nO1xuICAgIFx0dGhpcy5mcmFnbWVudFNoYWRlciA9ICd2b2lkIG1haW4oKSB7XFxuXFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggMS4wLCAwLjAsIDAuMCwgMS4wICk7XFxufSc7XG5cbiAgICBcdHRoaXMubGluZXdpZHRoID0gMTtcblxuICAgIFx0dGhpcy53aXJlZnJhbWUgPSBmYWxzZTtcbiAgICBcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcblxuICAgIFx0dGhpcy5mb2cgPSBmYWxzZTsgLy8gc2V0IHRvIHVzZSBzY2VuZSBmb2dcbiAgICBcdHRoaXMubGlnaHRzID0gZmFsc2U7IC8vIHNldCB0byB1c2Ugc2NlbmUgbGlnaHRzXG4gICAgXHR0aGlzLmNsaXBwaW5nID0gZmFsc2U7IC8vIHNldCB0byB1c2UgdXNlci1kZWZpbmVkIGNsaXBwaW5nIHBsYW5lc1xuXG4gICAgXHR0aGlzLnNraW5uaW5nID0gZmFsc2U7IC8vIHNldCB0byB1c2Ugc2tpbm5pbmcgYXR0cmlidXRlIHN0cmVhbXNcbiAgICBcdHRoaXMubW9ycGhUYXJnZXRzID0gZmFsc2U7IC8vIHNldCB0byB1c2UgbW9ycGggdGFyZ2V0c1xuICAgIFx0dGhpcy5tb3JwaE5vcm1hbHMgPSBmYWxzZTsgLy8gc2V0IHRvIHVzZSBtb3JwaCBub3JtYWxzXG5cbiAgICBcdHRoaXMuZXh0ZW5zaW9ucyA9IHtcbiAgICBcdFx0ZGVyaXZhdGl2ZXM6IGZhbHNlLCAvLyBzZXQgdG8gdXNlIGRlcml2YXRpdmVzXG4gICAgXHRcdGZyYWdEZXB0aDogZmFsc2UsIC8vIHNldCB0byB1c2UgZnJhZ21lbnQgZGVwdGggdmFsdWVzXG4gICAgXHRcdGRyYXdCdWZmZXJzOiBmYWxzZSwgLy8gc2V0IHRvIHVzZSBkcmF3IGJ1ZmZlcnNcbiAgICBcdFx0c2hhZGVyVGV4dHVyZUxPRDogZmFsc2UgLy8gc2V0IHRvIHVzZSBzaGFkZXIgdGV4dHVyZSBMT0RcbiAgICBcdH07XG5cbiAgICBcdC8vIFdoZW4gcmVuZGVyZWQgZ2VvbWV0cnkgZG9lc24ndCBpbmNsdWRlIHRoZXNlIGF0dHJpYnV0ZXMgYnV0IHRoZSBtYXRlcmlhbCBkb2VzLFxuICAgIFx0Ly8gdXNlIHRoZXNlIGRlZmF1bHQgdmFsdWVzIGluIFdlYkdMLiBUaGlzIGF2b2lkcyBlcnJvcnMgd2hlbiBidWZmZXIgZGF0YSBpcyBtaXNzaW5nLlxuICAgIFx0dGhpcy5kZWZhdWx0QXR0cmlidXRlVmFsdWVzID0ge1xuICAgIFx0XHQnY29sb3InOiBbIDEsIDEsIDEgXSxcbiAgICBcdFx0J3V2JzogWyAwLCAwIF0sXG4gICAgXHRcdCd1djInOiBbIDAsIDAgXVxuICAgIFx0fTtcblxuICAgIFx0dGhpcy5pbmRleDBBdHRyaWJ1dGVOYW1lID0gdW5kZWZpbmVkO1xuXG4gICAgXHRpZiAoIHBhcmFtZXRlcnMgIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRpZiAoIHBhcmFtZXRlcnMuYXR0cmlidXRlcyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlNoYWRlck1hdGVyaWFsOiBhdHRyaWJ1dGVzIHNob3VsZCBub3cgYmUgZGVmaW5lZCBpbiBUSFJFRS5CdWZmZXJHZW9tZXRyeSBpbnN0ZWFkLicgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcblxuICAgIFx0fVxuXG4gICAgfVxuXG4gICAgU2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTWF0ZXJpYWwucHJvdG90eXBlICk7XG4gICAgU2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2hhZGVyTWF0ZXJpYWw7XG5cbiAgICBTaGFkZXJNYXRlcmlhbC5wcm90b3R5cGUuaXNTaGFkZXJNYXRlcmlhbCA9IHRydWU7XG5cbiAgICBTaGFkZXJNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xuXG4gICAgXHRNYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuICAgIFx0dGhpcy5mcmFnbWVudFNoYWRlciA9IHNvdXJjZS5mcmFnbWVudFNoYWRlcjtcbiAgICBcdHRoaXMudmVydGV4U2hhZGVyID0gc291cmNlLnZlcnRleFNoYWRlcjtcblxuICAgIFx0dGhpcy51bmlmb3JtcyA9IGV4cG9ydHMuVW5pZm9ybXNVdGlscy5jbG9uZSggc291cmNlLnVuaWZvcm1zICk7XG5cbiAgICBcdHRoaXMuZGVmaW5lcyA9IHNvdXJjZS5kZWZpbmVzO1xuXG4gICAgXHR0aGlzLndpcmVmcmFtZSA9IHNvdXJjZS53aXJlZnJhbWU7XG4gICAgXHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IHNvdXJjZS53aXJlZnJhbWVMaW5ld2lkdGg7XG5cbiAgICBcdHRoaXMubGlnaHRzID0gc291cmNlLmxpZ2h0cztcbiAgICBcdHRoaXMuY2xpcHBpbmcgPSBzb3VyY2UuY2xpcHBpbmc7XG5cbiAgICBcdHRoaXMuc2tpbm5pbmcgPSBzb3VyY2Uuc2tpbm5pbmc7XG5cbiAgICBcdHRoaXMubW9ycGhUYXJnZXRzID0gc291cmNlLm1vcnBoVGFyZ2V0cztcbiAgICBcdHRoaXMubW9ycGhOb3JtYWxzID0gc291cmNlLm1vcnBoTm9ybWFscztcblxuICAgIFx0dGhpcy5leHRlbnNpb25zID0gc291cmNlLmV4dGVuc2lvbnM7XG5cbiAgICBcdHJldHVybiB0aGlzO1xuXG4gICAgfTtcblxuICAgIFNoYWRlck1hdGVyaWFsLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoIG1ldGEgKSB7XG5cbiAgICBcdHZhciBkYXRhID0gTWF0ZXJpYWwucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzLCBtZXRhICk7XG5cbiAgICBcdGRhdGEudW5pZm9ybXMgPSB0aGlzLnVuaWZvcm1zO1xuICAgIFx0ZGF0YS52ZXJ0ZXhTaGFkZXIgPSB0aGlzLnZlcnRleFNoYWRlcjtcbiAgICBcdGRhdGEuZnJhZ21lbnRTaGFkZXIgPSB0aGlzLmZyYWdtZW50U2hhZGVyO1xuXG4gICAgXHRyZXR1cm4gZGF0YTtcblxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICAgICAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gICAgICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHBzOi8vY2xhcmEuaW9cbiAgICAgKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAgICAgKlxuICAgICAqIHBhcmFtZXRlcnMgPSB7XG4gICAgICpcbiAgICAgKiAgb3BhY2l0eTogPGZsb2F0PixcbiAgICAgKlxuICAgICAqICBtYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gICAgICpcbiAgICAgKiAgYWxwaGFNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gICAgICpcbiAgICAgKiAgZGlzcGxhY2VtZW50TWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICAgICAqICBkaXNwbGFjZW1lbnRTY2FsZTogPGZsb2F0PixcbiAgICAgKiAgZGlzcGxhY2VtZW50QmlhczogPGZsb2F0PixcbiAgICAgKlxuICAgICAqICB3aXJlZnJhbWU6IDxib29sZWFuPixcbiAgICAgKiAgd2lyZWZyYW1lTGluZXdpZHRoOiA8ZmxvYXQ+XG4gICAgICogfVxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gTWVzaERlcHRoTWF0ZXJpYWwoIHBhcmFtZXRlcnMgKSB7XG5cbiAgICBcdE1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcblxuICAgIFx0dGhpcy50eXBlID0gJ01lc2hEZXB0aE1hdGVyaWFsJztcblxuICAgIFx0dGhpcy5kZXB0aFBhY2tpbmcgPSBCYXNpY0RlcHRoUGFja2luZztcblxuICAgIFx0dGhpcy5za2lubmluZyA9IGZhbHNlO1xuICAgIFx0dGhpcy5tb3JwaFRhcmdldHMgPSBmYWxzZTtcblxuICAgIFx0dGhpcy5tYXAgPSBudWxsO1xuXG4gICAgXHR0aGlzLmFscGhhTWFwID0gbnVsbDtcblxuICAgIFx0dGhpcy5kaXNwbGFjZW1lbnRNYXAgPSBudWxsO1xuICAgIFx0dGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9IDE7XG4gICAgXHR0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSAwO1xuXG4gICAgXHR0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xuICAgIFx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSAxO1xuXG4gICAgXHR0aGlzLmZvZyA9IGZhbHNlO1xuICAgIFx0dGhpcy5saWdodHMgPSBmYWxzZTtcblxuICAgIFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcblxuICAgIH1cblxuICAgIE1lc2hEZXB0aE1hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE1hdGVyaWFsLnByb3RvdHlwZSApO1xuICAgIE1lc2hEZXB0aE1hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1lc2hEZXB0aE1hdGVyaWFsO1xuXG4gICAgTWVzaERlcHRoTWF0ZXJpYWwucHJvdG90eXBlLmlzTWVzaERlcHRoTWF0ZXJpYWwgPSB0cnVlO1xuXG4gICAgTWVzaERlcHRoTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuICAgIFx0TWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cbiAgICBcdHRoaXMuZGVwdGhQYWNraW5nID0gc291cmNlLmRlcHRoUGFja2luZztcblxuICAgIFx0dGhpcy5za2lubmluZyA9IHNvdXJjZS5za2lubmluZztcbiAgICBcdHRoaXMubW9ycGhUYXJnZXRzID0gc291cmNlLm1vcnBoVGFyZ2V0cztcblxuICAgIFx0dGhpcy5tYXAgPSBzb3VyY2UubWFwO1xuXG4gICAgXHR0aGlzLmFscGhhTWFwID0gc291cmNlLmFscGhhTWFwO1xuXG4gICAgXHR0aGlzLmRpc3BsYWNlbWVudE1hcCA9IHNvdXJjZS5kaXNwbGFjZW1lbnRNYXA7XG4gICAgXHR0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gc291cmNlLmRpc3BsYWNlbWVudFNjYWxlO1xuICAgIFx0dGhpcy5kaXNwbGFjZW1lbnRCaWFzID0gc291cmNlLmRpc3BsYWNlbWVudEJpYXM7XG5cbiAgICBcdHRoaXMud2lyZWZyYW1lID0gc291cmNlLndpcmVmcmFtZTtcbiAgICBcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gc291cmNlLndpcmVmcmFtZUxpbmV3aWR0aDtcblxuICAgIFx0cmV0dXJuIHRoaXM7XG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xuICAgICAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gQm94MyggbWluLCBtYXggKSB7XG5cbiAgICBcdHRoaXMubWluID0gKCBtaW4gIT09IHVuZGVmaW5lZCApID8gbWluIDogbmV3IFZlY3RvcjMoICsgSW5maW5pdHksICsgSW5maW5pdHksICsgSW5maW5pdHkgKTtcbiAgICBcdHRoaXMubWF4ID0gKCBtYXggIT09IHVuZGVmaW5lZCApID8gbWF4IDogbmV3IFZlY3RvcjMoIC0gSW5maW5pdHksIC0gSW5maW5pdHksIC0gSW5maW5pdHkgKTtcblxuICAgIH1cblxuICAgIEJveDMucHJvdG90eXBlID0ge1xuXG4gICAgXHRjb25zdHJ1Y3RvcjogQm94MyxcblxuICAgIFx0aXNCb3gzOiB0cnVlLFxuXG4gICAgXHRzZXQ6IGZ1bmN0aW9uICggbWluLCBtYXggKSB7XG5cbiAgICBcdFx0dGhpcy5taW4uY29weSggbWluICk7XG4gICAgXHRcdHRoaXMubWF4LmNvcHkoIG1heCApO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzZXRGcm9tQXJyYXk6IGZ1bmN0aW9uICggYXJyYXkgKSB7XG5cbiAgICBcdFx0dmFyIG1pblggPSArIEluZmluaXR5O1xuICAgIFx0XHR2YXIgbWluWSA9ICsgSW5maW5pdHk7XG4gICAgXHRcdHZhciBtaW5aID0gKyBJbmZpbml0eTtcblxuICAgIFx0XHR2YXIgbWF4WCA9IC0gSW5maW5pdHk7XG4gICAgXHRcdHZhciBtYXhZID0gLSBJbmZpbml0eTtcbiAgICBcdFx0dmFyIG1heFogPSAtIEluZmluaXR5O1xuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGw7IGkgKz0gMyApIHtcblxuICAgIFx0XHRcdHZhciB4ID0gYXJyYXlbIGkgXTtcbiAgICBcdFx0XHR2YXIgeSA9IGFycmF5WyBpICsgMSBdO1xuICAgIFx0XHRcdHZhciB6ID0gYXJyYXlbIGkgKyAyIF07XG5cbiAgICBcdFx0XHRpZiAoIHggPCBtaW5YICkgbWluWCA9IHg7XG4gICAgXHRcdFx0aWYgKCB5IDwgbWluWSApIG1pblkgPSB5O1xuICAgIFx0XHRcdGlmICggeiA8IG1pblogKSBtaW5aID0gejtcblxuICAgIFx0XHRcdGlmICggeCA+IG1heFggKSBtYXhYID0geDtcbiAgICBcdFx0XHRpZiAoIHkgPiBtYXhZICkgbWF4WSA9IHk7XG4gICAgXHRcdFx0aWYgKCB6ID4gbWF4WiApIG1heFogPSB6O1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHR0aGlzLm1pbi5zZXQoIG1pblgsIG1pblksIG1pblogKTtcbiAgICBcdFx0dGhpcy5tYXguc2V0KCBtYXhYLCBtYXhZLCBtYXhaICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldEZyb21Qb2ludHM6IGZ1bmN0aW9uICggcG9pbnRzICkge1xuXG4gICAgXHRcdHRoaXMubWFrZUVtcHR5KCk7XG5cbiAgICBcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgIFx0XHRcdHRoaXMuZXhwYW5kQnlQb2ludCggcG9pbnRzWyBpIF0gKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldEZyb21DZW50ZXJBbmRTaXplOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoKTtcblxuICAgIFx0XHRyZXR1cm4gZnVuY3Rpb24gc2V0RnJvbUNlbnRlckFuZFNpemUoIGNlbnRlciwgc2l6ZSApIHtcblxuICAgIFx0XHRcdHZhciBoYWxmU2l6ZSA9IHYxLmNvcHkoIHNpemUgKS5tdWx0aXBseVNjYWxhciggMC41ICk7XG5cbiAgICBcdFx0XHR0aGlzLm1pbi5jb3B5KCBjZW50ZXIgKS5zdWIoIGhhbGZTaXplICk7XG4gICAgXHRcdFx0dGhpcy5tYXguY29weSggY2VudGVyICkuYWRkKCBoYWxmU2l6ZSApO1xuXG4gICAgXHRcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdFx0fTtcblxuICAgIFx0fSgpLFxuXG4gICAgXHRzZXRGcm9tT2JqZWN0OiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0Ly8gQ29tcHV0ZXMgdGhlIHdvcmxkLWF4aXMtYWxpZ25lZCBib3VuZGluZyBib3ggb2YgYW4gb2JqZWN0IChpbmNsdWRpbmcgaXRzIGNoaWxkcmVuKSxcbiAgICBcdFx0Ly8gYWNjb3VudGluZyBmb3IgYm90aCB0aGUgb2JqZWN0J3MsIGFuZCBjaGlsZHJlbidzLCB3b3JsZCB0cmFuc2Zvcm1zXG5cbiAgICBcdFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoKTtcblxuICAgIFx0XHRyZXR1cm4gZnVuY3Rpb24gc2V0RnJvbU9iamVjdCggb2JqZWN0ICkge1xuXG4gICAgXHRcdFx0dmFyIHNjb3BlID0gdGhpcztcblxuICAgIFx0XHRcdG9iamVjdC51cGRhdGVNYXRyaXhXb3JsZCggdHJ1ZSApO1xuXG4gICAgXHRcdFx0dGhpcy5tYWtlRW1wdHkoKTtcblxuICAgIFx0XHRcdG9iamVjdC50cmF2ZXJzZSggZnVuY3Rpb24gKCBub2RlICkge1xuXG4gICAgXHRcdFx0XHR2YXIgZ2VvbWV0cnkgPSBub2RlLmdlb21ldHJ5O1xuXG4gICAgXHRcdFx0XHRpZiAoIGdlb21ldHJ5ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRcdFx0aWYgKCAoZ2VvbWV0cnkgJiYgZ2VvbWV0cnkuaXNHZW9tZXRyeSkgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHR2YXIgdmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcztcblxuICAgIFx0XHRcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSB2ZXJ0aWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgIFx0XHRcdFx0XHRcdFx0djEuY29weSggdmVydGljZXNbIGkgXSApO1xuICAgIFx0XHRcdFx0XHRcdFx0djEuYXBwbHlNYXRyaXg0KCBub2RlLm1hdHJpeFdvcmxkICk7XG5cbiAgICBcdFx0XHRcdFx0XHRcdHNjb3BlLmV4cGFuZEJ5UG9pbnQoIHYxICk7XG5cbiAgICBcdFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdFx0fSBlbHNlIGlmICggKGdlb21ldHJ5ICYmIGdlb21ldHJ5LmlzQnVmZmVyR2VvbWV0cnkpICkge1xuXG4gICAgXHRcdFx0XHRcdFx0dmFyIGF0dHJpYnV0ZSA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cbiAgICBcdFx0XHRcdFx0XHRpZiAoIGF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0XHRcdFx0XHR2YXIgYXJyYXksIG9mZnNldCwgc3RyaWRlO1xuXG4gICAgXHRcdFx0XHRcdFx0XHRpZiAoIChhdHRyaWJ1dGUgJiYgYXR0cmlidXRlLmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUpICkge1xuXG4gICAgXHRcdFx0XHRcdFx0XHRcdGFycmF5ID0gYXR0cmlidXRlLmRhdGEuYXJyYXk7XG4gICAgXHRcdFx0XHRcdFx0XHRcdG9mZnNldCA9IGF0dHJpYnV0ZS5vZmZzZXQ7XG4gICAgXHRcdFx0XHRcdFx0XHRcdHN0cmlkZSA9IGF0dHJpYnV0ZS5kYXRhLnN0cmlkZTtcblxuICAgIFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0XHRcdFx0XHRhcnJheSA9IGF0dHJpYnV0ZS5hcnJheTtcbiAgICBcdFx0XHRcdFx0XHRcdFx0b2Zmc2V0ID0gMDtcbiAgICBcdFx0XHRcdFx0XHRcdFx0c3RyaWRlID0gMztcblxuICAgIFx0XHRcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IG9mZnNldCwgaWwgPSBhcnJheS5sZW5ndGg7IGkgPCBpbDsgaSArPSBzdHJpZGUgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHRcdFx0djEuZnJvbUFycmF5KCBhcnJheSwgaSApO1xuICAgIFx0XHRcdFx0XHRcdFx0XHR2MS5hcHBseU1hdHJpeDQoIG5vZGUubWF0cml4V29ybGQgKTtcblxuICAgIFx0XHRcdFx0XHRcdFx0XHRzY29wZS5leHBhbmRCeVBvaW50KCB2MSApO1xuXG4gICAgXHRcdFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9ICk7XG5cbiAgICBcdFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0XHR9O1xuXG4gICAgXHR9KCksXG5cbiAgICBcdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRjb3B5OiBmdW5jdGlvbiAoIGJveCApIHtcblxuICAgIFx0XHR0aGlzLm1pbi5jb3B5KCBib3gubWluICk7XG4gICAgXHRcdHRoaXMubWF4LmNvcHkoIGJveC5tYXggKTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0bWFrZUVtcHR5OiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dGhpcy5taW4ueCA9IHRoaXMubWluLnkgPSB0aGlzLm1pbi56ID0gKyBJbmZpbml0eTtcbiAgICBcdFx0dGhpcy5tYXgueCA9IHRoaXMubWF4LnkgPSB0aGlzLm1heC56ID0gLSBJbmZpbml0eTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0aXNFbXB0eTogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdC8vIHRoaXMgaXMgYSBtb3JlIHJvYnVzdCBjaGVjayBmb3IgZW1wdHkgdGhhbiAoIHZvbHVtZSA8PSAwICkgYmVjYXVzZSB2b2x1bWUgY2FuIGdldCBwb3NpdGl2ZSB3aXRoIHR3byBuZWdhdGl2ZSBheGVzXG5cbiAgICBcdFx0cmV0dXJuICggdGhpcy5tYXgueCA8IHRoaXMubWluLnggKSB8fCAoIHRoaXMubWF4LnkgPCB0aGlzLm1pbi55ICkgfHwgKCB0aGlzLm1heC56IDwgdGhpcy5taW4ueiApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRnZXRDZW50ZXI6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICBcdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XG4gICAgXHRcdHJldHVybiB0aGlzLmlzRW1wdHkoKSA/IHJlc3VsdC5zZXQoIDAsIDAsIDAgKSA6IHJlc3VsdC5hZGRWZWN0b3JzKCB0aGlzLm1pbiwgdGhpcy5tYXggKS5tdWx0aXBseVNjYWxhciggMC41ICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGdldFNpemU6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICBcdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XG4gICAgXHRcdHJldHVybiB0aGlzLmlzRW1wdHkoKSA/IHJlc3VsdC5zZXQoIDAsIDAsIDAgKSA6IHJlc3VsdC5zdWJWZWN0b3JzKCB0aGlzLm1heCwgdGhpcy5taW4gKTtcblxuICAgIFx0fSxcblxuICAgIFx0ZXhwYW5kQnlQb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcblxuICAgIFx0XHR0aGlzLm1pbi5taW4oIHBvaW50ICk7XG4gICAgXHRcdHRoaXMubWF4Lm1heCggcG9pbnQgKTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0ZXhwYW5kQnlWZWN0b3I6IGZ1bmN0aW9uICggdmVjdG9yICkge1xuXG4gICAgXHRcdHRoaXMubWluLnN1YiggdmVjdG9yICk7XG4gICAgXHRcdHRoaXMubWF4LmFkZCggdmVjdG9yICk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGV4cGFuZEJ5U2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcblxuICAgIFx0XHR0aGlzLm1pbi5hZGRTY2FsYXIoIC0gc2NhbGFyICk7XG4gICAgXHRcdHRoaXMubWF4LmFkZFNjYWxhciggc2NhbGFyICk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGNvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XG5cbiAgICBcdFx0aWYgKCBwb2ludC54IDwgdGhpcy5taW4ueCB8fCBwb2ludC54ID4gdGhpcy5tYXgueCB8fFxuICAgIFx0XHRcdFx0IHBvaW50LnkgPCB0aGlzLm1pbi55IHx8IHBvaW50LnkgPiB0aGlzLm1heC55IHx8XG4gICAgXHRcdFx0XHQgcG9pbnQueiA8IHRoaXMubWluLnogfHwgcG9pbnQueiA+IHRoaXMubWF4LnogKSB7XG5cbiAgICBcdFx0XHRyZXR1cm4gZmFsc2U7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiB0cnVlO1xuXG4gICAgXHR9LFxuXG4gICAgXHRjb250YWluc0JveDogZnVuY3Rpb24gKCBib3ggKSB7XG5cbiAgICBcdFx0aWYgKCAoIHRoaXMubWluLnggPD0gYm94Lm1pbi54ICkgJiYgKCBib3gubWF4LnggPD0gdGhpcy5tYXgueCApICYmXG4gICAgXHRcdFx0ICggdGhpcy5taW4ueSA8PSBib3gubWluLnkgKSAmJiAoIGJveC5tYXgueSA8PSB0aGlzLm1heC55ICkgJiZcbiAgICBcdFx0XHQgKCB0aGlzLm1pbi56IDw9IGJveC5taW4ueiApICYmICggYm94Lm1heC56IDw9IHRoaXMubWF4LnogKSApIHtcblxuICAgIFx0XHRcdHJldHVybiB0cnVlO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gZmFsc2U7XG5cbiAgICBcdH0sXG5cbiAgICBcdGdldFBhcmFtZXRlcjogZnVuY3Rpb24gKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICBcdFx0Ly8gVGhpcyBjYW4gcG90ZW50aWFsbHkgaGF2ZSBhIGRpdmlkZSBieSB6ZXJvIGlmIHRoZSBib3hcbiAgICBcdFx0Ly8gaGFzIGEgc2l6ZSBkaW1lbnNpb24gb2YgMC5cblxuICAgIFx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjMoKTtcblxuICAgIFx0XHRyZXR1cm4gcmVzdWx0LnNldChcbiAgICBcdFx0XHQoIHBvaW50LnggLSB0aGlzLm1pbi54ICkgLyAoIHRoaXMubWF4LnggLSB0aGlzLm1pbi54ICksXG4gICAgXHRcdFx0KCBwb2ludC55IC0gdGhpcy5taW4ueSApIC8gKCB0aGlzLm1heC55IC0gdGhpcy5taW4ueSApLFxuICAgIFx0XHRcdCggcG9pbnQueiAtIHRoaXMubWluLnogKSAvICggdGhpcy5tYXgueiAtIHRoaXMubWluLnogKVxuICAgIFx0XHQpO1xuXG4gICAgXHR9LFxuXG4gICAgXHRpbnRlcnNlY3RzQm94OiBmdW5jdGlvbiAoIGJveCApIHtcblxuICAgIFx0XHQvLyB1c2luZyA2IHNwbGl0dGluZyBwbGFuZXMgdG8gcnVsZSBvdXQgaW50ZXJzZWN0aW9ucy5cblxuICAgIFx0XHRpZiAoIGJveC5tYXgueCA8IHRoaXMubWluLnggfHwgYm94Lm1pbi54ID4gdGhpcy5tYXgueCB8fFxuICAgIFx0XHRcdFx0IGJveC5tYXgueSA8IHRoaXMubWluLnkgfHwgYm94Lm1pbi55ID4gdGhpcy5tYXgueSB8fFxuICAgIFx0XHRcdFx0IGJveC5tYXgueiA8IHRoaXMubWluLnogfHwgYm94Lm1pbi56ID4gdGhpcy5tYXgueiApIHtcblxuICAgIFx0XHRcdHJldHVybiBmYWxzZTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIHRydWU7XG5cbiAgICBcdH0sXG5cbiAgICBcdGludGVyc2VjdHNTcGhlcmU6ICggZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHZhciBjbG9zZXN0UG9pbnQ7XG5cbiAgICBcdFx0cmV0dXJuIGZ1bmN0aW9uIGludGVyc2VjdHNTcGhlcmUoIHNwaGVyZSApIHtcblxuICAgIFx0XHRcdGlmICggY2xvc2VzdFBvaW50ID09PSB1bmRlZmluZWQgKSBjbG9zZXN0UG9pbnQgPSBuZXcgVmVjdG9yMygpO1xuXG4gICAgXHRcdFx0Ly8gRmluZCB0aGUgcG9pbnQgb24gdGhlIEFBQkIgY2xvc2VzdCB0byB0aGUgc3BoZXJlIGNlbnRlci5cbiAgICBcdFx0XHR0aGlzLmNsYW1wUG9pbnQoIHNwaGVyZS5jZW50ZXIsIGNsb3Nlc3RQb2ludCApO1xuXG4gICAgXHRcdFx0Ly8gSWYgdGhhdCBwb2ludCBpcyBpbnNpZGUgdGhlIHNwaGVyZSwgdGhlIEFBQkIgYW5kIHNwaGVyZSBpbnRlcnNlY3QuXG4gICAgXHRcdFx0cmV0dXJuIGNsb3Nlc3RQb2ludC5kaXN0YW5jZVRvU3F1YXJlZCggc3BoZXJlLmNlbnRlciApIDw9ICggc3BoZXJlLnJhZGl1cyAqIHNwaGVyZS5yYWRpdXMgKTtcblxuICAgIFx0XHR9O1xuXG4gICAgXHR9ICkoKSxcblxuICAgIFx0aW50ZXJzZWN0c1BsYW5lOiBmdW5jdGlvbiAoIHBsYW5lICkge1xuXG4gICAgXHRcdC8vIFdlIGNvbXB1dGUgdGhlIG1pbmltdW0gYW5kIG1heGltdW0gZG90IHByb2R1Y3QgdmFsdWVzLiBJZiB0aG9zZSB2YWx1ZXNcbiAgICBcdFx0Ly8gYXJlIG9uIHRoZSBzYW1lIHNpZGUgKGJhY2sgb3IgZnJvbnQpIG9mIHRoZSBwbGFuZSwgdGhlbiB0aGVyZSBpcyBubyBpbnRlcnNlY3Rpb24uXG5cbiAgICBcdFx0dmFyIG1pbiwgbWF4O1xuXG4gICAgXHRcdGlmICggcGxhbmUubm9ybWFsLnggPiAwICkge1xuXG4gICAgXHRcdFx0bWluID0gcGxhbmUubm9ybWFsLnggKiB0aGlzLm1pbi54O1xuICAgIFx0XHRcdG1heCA9IHBsYW5lLm5vcm1hbC54ICogdGhpcy5tYXgueDtcblxuICAgIFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0bWluID0gcGxhbmUubm9ybWFsLnggKiB0aGlzLm1heC54O1xuICAgIFx0XHRcdG1heCA9IHBsYW5lLm5vcm1hbC54ICogdGhpcy5taW4ueDtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKCBwbGFuZS5ub3JtYWwueSA+IDAgKSB7XG5cbiAgICBcdFx0XHRtaW4gKz0gcGxhbmUubm9ybWFsLnkgKiB0aGlzLm1pbi55O1xuICAgIFx0XHRcdG1heCArPSBwbGFuZS5ub3JtYWwueSAqIHRoaXMubWF4Lnk7XG5cbiAgICBcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdG1pbiArPSBwbGFuZS5ub3JtYWwueSAqIHRoaXMubWF4Lnk7XG4gICAgXHRcdFx0bWF4ICs9IHBsYW5lLm5vcm1hbC55ICogdGhpcy5taW4ueTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKCBwbGFuZS5ub3JtYWwueiA+IDAgKSB7XG5cbiAgICBcdFx0XHRtaW4gKz0gcGxhbmUubm9ybWFsLnogKiB0aGlzLm1pbi56O1xuICAgIFx0XHRcdG1heCArPSBwbGFuZS5ub3JtYWwueiAqIHRoaXMubWF4Lno7XG5cbiAgICBcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdG1pbiArPSBwbGFuZS5ub3JtYWwueiAqIHRoaXMubWF4Lno7XG4gICAgXHRcdFx0bWF4ICs9IHBsYW5lLm5vcm1hbC56ICogdGhpcy5taW4uejtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuICggbWluIDw9IHBsYW5lLmNvbnN0YW50ICYmIG1heCA+PSBwbGFuZS5jb25zdGFudCApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRjbGFtcFBvaW50OiBmdW5jdGlvbiAoIHBvaW50LCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgIFx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjMoKTtcbiAgICBcdFx0cmV0dXJuIHJlc3VsdC5jb3B5KCBwb2ludCApLmNsYW1wKCB0aGlzLm1pbiwgdGhpcy5tYXggKTtcblxuICAgIFx0fSxcblxuICAgIFx0ZGlzdGFuY2VUb1BvaW50OiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoKTtcblxuICAgIFx0XHRyZXR1cm4gZnVuY3Rpb24gZGlzdGFuY2VUb1BvaW50KCBwb2ludCApIHtcblxuICAgIFx0XHRcdHZhciBjbGFtcGVkUG9pbnQgPSB2MS5jb3B5KCBwb2ludCApLmNsYW1wKCB0aGlzLm1pbiwgdGhpcy5tYXggKTtcbiAgICBcdFx0XHRyZXR1cm4gY2xhbXBlZFBvaW50LnN1YiggcG9pbnQgKS5sZW5ndGgoKTtcblxuICAgIFx0XHR9O1xuXG4gICAgXHR9KCksXG5cbiAgICBcdGdldEJvdW5kaW5nU3BoZXJlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoKTtcblxuICAgIFx0XHRyZXR1cm4gZnVuY3Rpb24gZ2V0Qm91bmRpbmdTcGhlcmUoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgXHRcdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBTcGhlcmUoKTtcblxuICAgIFx0XHRcdHRoaXMuZ2V0Q2VudGVyKCByZXN1bHQuY2VudGVyICk7XG5cbiAgICBcdFx0XHRyZXN1bHQucmFkaXVzID0gdGhpcy5zaXplKCB2MSApLmxlbmd0aCgpICogMC41O1xuXG4gICAgXHRcdFx0cmV0dXJuIHJlc3VsdDtcblxuICAgIFx0XHR9O1xuXG4gICAgXHR9KCksXG5cbiAgICBcdGludGVyc2VjdDogZnVuY3Rpb24gKCBib3ggKSB7XG5cbiAgICBcdFx0dGhpcy5taW4ubWF4KCBib3gubWluICk7XG4gICAgXHRcdHRoaXMubWF4Lm1pbiggYm94Lm1heCApO1xuXG4gICAgXHRcdC8vIGVuc3VyZSB0aGF0IGlmIHRoZXJlIGlzIG5vIG92ZXJsYXAsIHRoZSByZXN1bHQgaXMgZnVsbHkgZW1wdHksIG5vdCBzbGlnaHRseSBlbXB0eSB3aXRoIG5vbi1pbmYvK2luZiB2YWx1ZXMgdGhhdCB3aWxsIGNhdXNlIHN1YnNlcXVlbmNlIGludGVyc2VjdHMgdG8gZXJyb25lb3VzbHkgcmV0dXJuIHZhbGlkIHZhbHVlcy5cbiAgICBcdFx0aWYoIHRoaXMuaXNFbXB0eSgpICkgdGhpcy5tYWtlRW1wdHkoKTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0dW5pb246IGZ1bmN0aW9uICggYm94ICkge1xuXG4gICAgXHRcdHRoaXMubWluLm1pbiggYm94Lm1pbiApO1xuICAgIFx0XHR0aGlzLm1heC5tYXgoIGJveC5tYXggKTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0YXBwbHlNYXRyaXg0OiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dmFyIHBvaW50cyA9IFtcbiAgICBcdFx0XHRuZXcgVmVjdG9yMygpLFxuICAgIFx0XHRcdG5ldyBWZWN0b3IzKCksXG4gICAgXHRcdFx0bmV3IFZlY3RvcjMoKSxcbiAgICBcdFx0XHRuZXcgVmVjdG9yMygpLFxuICAgIFx0XHRcdG5ldyBWZWN0b3IzKCksXG4gICAgXHRcdFx0bmV3IFZlY3RvcjMoKSxcbiAgICBcdFx0XHRuZXcgVmVjdG9yMygpLFxuICAgIFx0XHRcdG5ldyBWZWN0b3IzKClcbiAgICBcdFx0XTtcblxuICAgIFx0XHRyZXR1cm4gZnVuY3Rpb24gYXBwbHlNYXRyaXg0KCBtYXRyaXggKSB7XG5cbiAgICBcdFx0XHQvLyB0cmFuc2Zvcm0gb2YgZW1wdHkgYm94IGlzIGFuIGVtcHR5IGJveC5cbiAgICBcdFx0XHRpZiggdGhpcy5pc0VtcHR5KCkgKSByZXR1cm4gdGhpcztcblxuICAgIFx0XHRcdC8vIE5PVEU6IEkgYW0gdXNpbmcgYSBiaW5hcnkgcGF0dGVybiB0byBzcGVjaWZ5IGFsbCAyXjMgY29tYmluYXRpb25zIGJlbG93XG4gICAgXHRcdFx0cG9pbnRzWyAwIF0uc2V0KCB0aGlzLm1pbi54LCB0aGlzLm1pbi55LCB0aGlzLm1pbi56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMDAwXG4gICAgXHRcdFx0cG9pbnRzWyAxIF0uc2V0KCB0aGlzLm1pbi54LCB0aGlzLm1pbi55LCB0aGlzLm1heC56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMDAxXG4gICAgXHRcdFx0cG9pbnRzWyAyIF0uc2V0KCB0aGlzLm1pbi54LCB0aGlzLm1heC55LCB0aGlzLm1pbi56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMDEwXG4gICAgXHRcdFx0cG9pbnRzWyAzIF0uc2V0KCB0aGlzLm1pbi54LCB0aGlzLm1heC55LCB0aGlzLm1heC56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMDExXG4gICAgXHRcdFx0cG9pbnRzWyA0IF0uc2V0KCB0aGlzLm1heC54LCB0aGlzLm1pbi55LCB0aGlzLm1pbi56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMTAwXG4gICAgXHRcdFx0cG9pbnRzWyA1IF0uc2V0KCB0aGlzLm1heC54LCB0aGlzLm1pbi55LCB0aGlzLm1heC56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMTAxXG4gICAgXHRcdFx0cG9pbnRzWyA2IF0uc2V0KCB0aGlzLm1heC54LCB0aGlzLm1heC55LCB0aGlzLm1pbi56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMTEwXG4gICAgXHRcdFx0cG9pbnRzWyA3IF0uc2V0KCB0aGlzLm1heC54LCB0aGlzLm1heC55LCB0aGlzLm1heC56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcdC8vIDExMVxuXG4gICAgXHRcdFx0dGhpcy5zZXRGcm9tUG9pbnRzKCBwb2ludHMgKTtcblxuICAgIFx0XHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHRcdH07XG5cbiAgICBcdH0oKSxcblxuICAgIFx0dHJhbnNsYXRlOiBmdW5jdGlvbiAoIG9mZnNldCApIHtcblxuICAgIFx0XHR0aGlzLm1pbi5hZGQoIG9mZnNldCApO1xuICAgIFx0XHR0aGlzLm1heC5hZGQoIG9mZnNldCApO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRlcXVhbHM6IGZ1bmN0aW9uICggYm94ICkge1xuXG4gICAgXHRcdHJldHVybiBib3gubWluLmVxdWFscyggdGhpcy5taW4gKSAmJiBib3gubWF4LmVxdWFscyggdGhpcy5tYXggKTtcblxuICAgIFx0fVxuXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cbiAgICAgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gU3BoZXJlKCBjZW50ZXIsIHJhZGl1cyApIHtcblxuICAgIFx0dGhpcy5jZW50ZXIgPSAoIGNlbnRlciAhPT0gdW5kZWZpbmVkICkgPyBjZW50ZXIgOiBuZXcgVmVjdG9yMygpO1xuICAgIFx0dGhpcy5yYWRpdXMgPSAoIHJhZGl1cyAhPT0gdW5kZWZpbmVkICkgPyByYWRpdXMgOiAwO1xuXG4gICAgfVxuXG4gICAgU3BoZXJlLnByb3RvdHlwZSA9IHtcblxuICAgIFx0Y29uc3RydWN0b3I6IFNwaGVyZSxcblxuICAgIFx0c2V0OiBmdW5jdGlvbiAoIGNlbnRlciwgcmFkaXVzICkge1xuXG4gICAgXHRcdHRoaXMuY2VudGVyLmNvcHkoIGNlbnRlciApO1xuICAgIFx0XHR0aGlzLnJhZGl1cyA9IHJhZGl1cztcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0c2V0RnJvbVBvaW50czogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHZhciBib3ggPSBuZXcgQm94MygpO1xuXG4gICAgXHRcdHJldHVybiBmdW5jdGlvbiBzZXRGcm9tUG9pbnRzKCBwb2ludHMsIG9wdGlvbmFsQ2VudGVyICkge1xuXG4gICAgXHRcdFx0dmFyIGNlbnRlciA9IHRoaXMuY2VudGVyO1xuXG4gICAgXHRcdFx0aWYgKCBvcHRpb25hbENlbnRlciAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0XHRjZW50ZXIuY29weSggb3B0aW9uYWxDZW50ZXIgKTtcblxuICAgIFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdGJveC5zZXRGcm9tUG9pbnRzKCBwb2ludHMgKS5nZXRDZW50ZXIoIGNlbnRlciApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0dmFyIG1heFJhZGl1c1NxID0gMDtcblxuICAgIFx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICBcdFx0XHRcdG1heFJhZGl1c1NxID0gTWF0aC5tYXgoIG1heFJhZGl1c1NxLCBjZW50ZXIuZGlzdGFuY2VUb1NxdWFyZWQoIHBvaW50c1sgaSBdICkgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdHRoaXMucmFkaXVzID0gTWF0aC5zcXJ0KCBtYXhSYWRpdXNTcSApO1xuXG4gICAgXHRcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdFx0fTtcblxuICAgIFx0fSgpLFxuXG4gICAgXHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuICAgIFx0fSxcblxuICAgIFx0Y29weTogZnVuY3Rpb24gKCBzcGhlcmUgKSB7XG5cbiAgICBcdFx0dGhpcy5jZW50ZXIuY29weSggc3BoZXJlLmNlbnRlciApO1xuICAgIFx0XHR0aGlzLnJhZGl1cyA9IHNwaGVyZS5yYWRpdXM7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGVtcHR5OiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0cmV0dXJuICggdGhpcy5yYWRpdXMgPD0gMCApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRjb250YWluc1BvaW50OiBmdW5jdGlvbiAoIHBvaW50ICkge1xuXG4gICAgXHRcdHJldHVybiAoIHBvaW50LmRpc3RhbmNlVG9TcXVhcmVkKCB0aGlzLmNlbnRlciApIDw9ICggdGhpcy5yYWRpdXMgKiB0aGlzLnJhZGl1cyApICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGRpc3RhbmNlVG9Qb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcblxuICAgIFx0XHRyZXR1cm4gKCBwb2ludC5kaXN0YW5jZVRvKCB0aGlzLmNlbnRlciApIC0gdGhpcy5yYWRpdXMgKTtcblxuICAgIFx0fSxcblxuICAgIFx0aW50ZXJzZWN0c1NwaGVyZTogZnVuY3Rpb24gKCBzcGhlcmUgKSB7XG5cbiAgICBcdFx0dmFyIHJhZGl1c1N1bSA9IHRoaXMucmFkaXVzICsgc3BoZXJlLnJhZGl1cztcblxuICAgIFx0XHRyZXR1cm4gc3BoZXJlLmNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZCggdGhpcy5jZW50ZXIgKSA8PSAoIHJhZGl1c1N1bSAqIHJhZGl1c1N1bSApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRpbnRlcnNlY3RzQm94OiBmdW5jdGlvbiAoIGJveCApIHtcblxuICAgIFx0XHRyZXR1cm4gYm94LmludGVyc2VjdHNTcGhlcmUoIHRoaXMgKTtcblxuICAgIFx0fSxcblxuICAgIFx0aW50ZXJzZWN0c1BsYW5lOiBmdW5jdGlvbiAoIHBsYW5lICkge1xuXG4gICAgXHRcdC8vIFdlIHVzZSB0aGUgZm9sbG93aW5nIGVxdWF0aW9uIHRvIGNvbXB1dGUgdGhlIHNpZ25lZCBkaXN0YW5jZSBmcm9tXG4gICAgXHRcdC8vIHRoZSBjZW50ZXIgb2YgdGhlIHNwaGVyZSB0byB0aGUgcGxhbmUuXG4gICAgXHRcdC8vXG4gICAgXHRcdC8vIGRpc3RhbmNlID0gcSAqIG4gLSBkXG4gICAgXHRcdC8vXG4gICAgXHRcdC8vIElmIHRoaXMgZGlzdGFuY2UgaXMgZ3JlYXRlciB0aGFuIHRoZSByYWRpdXMgb2YgdGhlIHNwaGVyZSxcbiAgICBcdFx0Ly8gdGhlbiB0aGVyZSBpcyBubyBpbnRlcnNlY3Rpb24uXG5cbiAgICBcdFx0cmV0dXJuIE1hdGguYWJzKCB0aGlzLmNlbnRlci5kb3QoIHBsYW5lLm5vcm1hbCApIC0gcGxhbmUuY29uc3RhbnQgKSA8PSB0aGlzLnJhZGl1cztcblxuICAgIFx0fSxcblxuICAgIFx0Y2xhbXBQb2ludDogZnVuY3Rpb24gKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICBcdFx0dmFyIGRlbHRhTGVuZ3RoU3EgPSB0aGlzLmNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZCggcG9pbnQgKTtcblxuICAgIFx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjMoKTtcblxuICAgIFx0XHRyZXN1bHQuY29weSggcG9pbnQgKTtcblxuICAgIFx0XHRpZiAoIGRlbHRhTGVuZ3RoU3EgPiAoIHRoaXMucmFkaXVzICogdGhpcy5yYWRpdXMgKSApIHtcblxuICAgIFx0XHRcdHJlc3VsdC5zdWIoIHRoaXMuY2VudGVyICkubm9ybWFsaXplKCk7XG4gICAgXHRcdFx0cmVzdWx0Lm11bHRpcGx5U2NhbGFyKCB0aGlzLnJhZGl1cyApLmFkZCggdGhpcy5jZW50ZXIgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIHJlc3VsdDtcblxuICAgIFx0fSxcblxuICAgIFx0Z2V0Qm91bmRpbmdCb3g6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICBcdFx0dmFyIGJveCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBCb3gzKCk7XG5cbiAgICBcdFx0Ym94LnNldCggdGhpcy5jZW50ZXIsIHRoaXMuY2VudGVyICk7XG4gICAgXHRcdGJveC5leHBhbmRCeVNjYWxhciggdGhpcy5yYWRpdXMgKTtcblxuICAgIFx0XHRyZXR1cm4gYm94O1xuXG4gICAgXHR9LFxuXG4gICAgXHRhcHBseU1hdHJpeDQ6IGZ1bmN0aW9uICggbWF0cml4ICkge1xuXG4gICAgXHRcdHRoaXMuY2VudGVyLmFwcGx5TWF0cml4NCggbWF0cml4ICk7XG4gICAgXHRcdHRoaXMucmFkaXVzID0gdGhpcy5yYWRpdXMgKiBtYXRyaXguZ2V0TWF4U2NhbGVPbkF4aXMoKTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0dHJhbnNsYXRlOiBmdW5jdGlvbiAoIG9mZnNldCApIHtcblxuICAgIFx0XHR0aGlzLmNlbnRlci5hZGQoIG9mZnNldCApO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRlcXVhbHM6IGZ1bmN0aW9uICggc3BoZXJlICkge1xuXG4gICAgXHRcdHJldHVybiBzcGhlcmUuY2VudGVyLmVxdWFscyggdGhpcy5jZW50ZXIgKSAmJiAoIHNwaGVyZS5yYWRpdXMgPT09IHRoaXMucmFkaXVzICk7XG5cbiAgICBcdH1cblxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICAgICAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuICAgICAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cbiAgICAgKiBAYXV0aG9yIHRzY2h3XG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBNYXRyaXgzKCkge1xuXG4gICAgXHR0aGlzLmVsZW1lbnRzID0gbmV3IEZsb2F0MzJBcnJheSggW1xuXG4gICAgXHRcdDEsIDAsIDAsXG4gICAgXHRcdDAsIDEsIDAsXG4gICAgXHRcdDAsIDAsIDFcblxuICAgIFx0XSApO1xuXG4gICAgXHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPiAwICkge1xuXG4gICAgXHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5NYXRyaXgzOiB0aGUgY29uc3RydWN0b3Igbm8gbG9uZ2VyIHJlYWRzIGFyZ3VtZW50cy4gdXNlIC5zZXQoKSBpbnN0ZWFkLicgKTtcblxuICAgIFx0fVxuXG4gICAgfVxuXG4gICAgTWF0cml4My5wcm90b3R5cGUgPSB7XG5cbiAgICBcdGNvbnN0cnVjdG9yOiBNYXRyaXgzLFxuXG4gICAgXHRpc01hdHJpeDM6IHRydWUsXG5cbiAgICBcdHNldDogZnVuY3Rpb24gKCBuMTEsIG4xMiwgbjEzLCBuMjEsIG4yMiwgbjIzLCBuMzEsIG4zMiwgbjMzICkge1xuXG4gICAgXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cbiAgICBcdFx0dGVbIDAgXSA9IG4xMTsgdGVbIDEgXSA9IG4yMTsgdGVbIDIgXSA9IG4zMTtcbiAgICBcdFx0dGVbIDMgXSA9IG4xMjsgdGVbIDQgXSA9IG4yMjsgdGVbIDUgXSA9IG4zMjtcbiAgICBcdFx0dGVbIDYgXSA9IG4xMzsgdGVbIDcgXSA9IG4yMzsgdGVbIDggXSA9IG4zMztcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0aWRlbnRpdHk6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR0aGlzLnNldChcblxuICAgIFx0XHRcdDEsIDAsIDAsXG4gICAgXHRcdFx0MCwgMSwgMCxcbiAgICBcdFx0XHQwLCAwLCAxXG5cbiAgICBcdFx0KTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5mcm9tQXJyYXkoIHRoaXMuZWxlbWVudHMgKTtcblxuICAgIFx0fSxcblxuICAgIFx0Y29weTogZnVuY3Rpb24gKCBtICkge1xuXG4gICAgXHRcdHZhciBtZSA9IG0uZWxlbWVudHM7XG5cbiAgICBcdFx0dGhpcy5zZXQoXG5cbiAgICBcdFx0XHRtZVsgMCBdLCBtZVsgMyBdLCBtZVsgNiBdLFxuICAgIFx0XHRcdG1lWyAxIF0sIG1lWyA0IF0sIG1lWyA3IF0sXG4gICAgXHRcdFx0bWVbIDIgXSwgbWVbIDUgXSwgbWVbIDggXVxuXG4gICAgXHRcdCk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldEZyb21NYXRyaXg0OiBmdW5jdGlvbiggbSApIHtcblxuICAgIFx0XHR2YXIgbWUgPSBtLmVsZW1lbnRzO1xuXG4gICAgXHRcdHRoaXMuc2V0KFxuXG4gICAgXHRcdFx0bWVbIDAgXSwgbWVbIDQgXSwgbWVbICA4IF0sXG4gICAgXHRcdFx0bWVbIDEgXSwgbWVbIDUgXSwgbWVbICA5IF0sXG4gICAgXHRcdFx0bWVbIDIgXSwgbWVbIDYgXSwgbWVbIDEwIF1cblxuICAgIFx0XHQpO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRhcHBseVRvVmVjdG9yM0FycmF5OiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dmFyIHYxO1xuXG4gICAgXHRcdHJldHVybiBmdW5jdGlvbiBhcHBseVRvVmVjdG9yM0FycmF5KCBhcnJheSwgb2Zmc2V0LCBsZW5ndGggKSB7XG5cbiAgICBcdFx0XHRpZiAoIHYxID09PSB1bmRlZmluZWQgKSB2MSA9IG5ldyBWZWN0b3IzKCk7XG4gICAgXHRcdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG4gICAgXHRcdFx0aWYgKCBsZW5ndGggPT09IHVuZGVmaW5lZCApIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgIFx0XHRcdGZvciAoIHZhciBpID0gMCwgaiA9IG9mZnNldDsgaSA8IGxlbmd0aDsgaSArPSAzLCBqICs9IDMgKSB7XG5cbiAgICBcdFx0XHRcdHYxLmZyb21BcnJheSggYXJyYXksIGogKTtcbiAgICBcdFx0XHRcdHYxLmFwcGx5TWF0cml4MyggdGhpcyApO1xuICAgIFx0XHRcdFx0djEudG9BcnJheSggYXJyYXksIGogKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdHJldHVybiBhcnJheTtcblxuICAgIFx0XHR9O1xuXG4gICAgXHR9KCksXG5cbiAgICBcdGFwcGx5VG9CdWZmZXI6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR2YXIgdjE7XG5cbiAgICBcdFx0cmV0dXJuIGZ1bmN0aW9uIGFwcGx5VG9CdWZmZXIoIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGggKSB7XG5cbiAgICBcdFx0XHRpZiAoIHYxID09PSB1bmRlZmluZWQgKSB2MSA9IG5ldyBWZWN0b3IzKCk7XG4gICAgXHRcdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG4gICAgXHRcdFx0aWYgKCBsZW5ndGggPT09IHVuZGVmaW5lZCApIGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGggLyBidWZmZXIuaXRlbVNpemU7XG5cbiAgICBcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGogPSBvZmZzZXQ7IGkgPCBsZW5ndGg7IGkgKyssIGogKysgKSB7XG5cbiAgICBcdFx0XHRcdHYxLnggPSBidWZmZXIuZ2V0WCggaiApO1xuICAgIFx0XHRcdFx0djEueSA9IGJ1ZmZlci5nZXRZKCBqICk7XG4gICAgXHRcdFx0XHR2MS56ID0gYnVmZmVyLmdldFooIGogKTtcblxuICAgIFx0XHRcdFx0djEuYXBwbHlNYXRyaXgzKCB0aGlzICk7XG5cbiAgICBcdFx0XHRcdGJ1ZmZlci5zZXRYWVooIHYxLngsIHYxLnksIHYxLnogKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdHJldHVybiBidWZmZXI7XG5cbiAgICBcdFx0fTtcblxuICAgIFx0fSgpLFxuXG4gICAgXHRtdWx0aXBseVNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xuXG4gICAgXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cbiAgICBcdFx0dGVbIDAgXSAqPSBzOyB0ZVsgMyBdICo9IHM7IHRlWyA2IF0gKj0gcztcbiAgICBcdFx0dGVbIDEgXSAqPSBzOyB0ZVsgNCBdICo9IHM7IHRlWyA3IF0gKj0gcztcbiAgICBcdFx0dGVbIDIgXSAqPSBzOyB0ZVsgNSBdICo9IHM7IHRlWyA4IF0gKj0gcztcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0ZGV0ZXJtaW5hbnQ6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG4gICAgXHRcdHZhciBhID0gdGVbIDAgXSwgYiA9IHRlWyAxIF0sIGMgPSB0ZVsgMiBdLFxuICAgIFx0XHRcdGQgPSB0ZVsgMyBdLCBlID0gdGVbIDQgXSwgZiA9IHRlWyA1IF0sXG4gICAgXHRcdFx0ZyA9IHRlWyA2IF0sIGggPSB0ZVsgNyBdLCBpID0gdGVbIDggXTtcblxuICAgIFx0XHRyZXR1cm4gYSAqIGUgKiBpIC0gYSAqIGYgKiBoIC0gYiAqIGQgKiBpICsgYiAqIGYgKiBnICsgYyAqIGQgKiBoIC0gYyAqIGUgKiBnO1xuXG4gICAgXHR9LFxuXG4gICAgXHRnZXRJbnZlcnNlOiBmdW5jdGlvbiAoIG1hdHJpeCwgdGhyb3dPbkRlZ2VuZXJhdGUgKSB7XG5cbiAgICBcdFx0aWYgKCAobWF0cml4ICYmIG1hdHJpeC5pc01hdHJpeDQpICkge1xuXG4gICAgXHRcdFx0Y29uc29sZS5lcnJvciggXCJUSFJFRS5NYXRyaXgzLmdldEludmVyc2Ugbm8gbG9uZ2VyIHRha2VzIGEgTWF0cml4NCBhcmd1bWVudC5cIiApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHR2YXIgbWUgPSBtYXRyaXguZWxlbWVudHMsXG4gICAgXHRcdFx0dGUgPSB0aGlzLmVsZW1lbnRzLFxuXG4gICAgXHRcdFx0bjExID0gbWVbIDAgXSwgbjIxID0gbWVbIDEgXSwgbjMxID0gbWVbIDIgXSxcbiAgICBcdFx0XHRuMTIgPSBtZVsgMyBdLCBuMjIgPSBtZVsgNCBdLCBuMzIgPSBtZVsgNSBdLFxuICAgIFx0XHRcdG4xMyA9IG1lWyA2IF0sIG4yMyA9IG1lWyA3IF0sIG4zMyA9IG1lWyA4IF0sXG5cbiAgICBcdFx0XHR0MTEgPSBuMzMgKiBuMjIgLSBuMzIgKiBuMjMsXG4gICAgXHRcdFx0dDEyID0gbjMyICogbjEzIC0gbjMzICogbjEyLFxuICAgIFx0XHRcdHQxMyA9IG4yMyAqIG4xMiAtIG4yMiAqIG4xMyxcblxuICAgIFx0XHRcdGRldCA9IG4xMSAqIHQxMSArIG4yMSAqIHQxMiArIG4zMSAqIHQxMztcblxuICAgIFx0XHRpZiAoIGRldCA9PT0gMCApIHtcblxuICAgIFx0XHRcdHZhciBtc2cgPSBcIlRIUkVFLk1hdHJpeDMuZ2V0SW52ZXJzZSgpOiBjYW4ndCBpbnZlcnQgbWF0cml4LCBkZXRlcm1pbmFudCBpcyAwXCI7XG5cbiAgICBcdFx0XHRpZiAoIHRocm93T25EZWdlbmVyYXRlID09PSB0cnVlICkge1xuXG4gICAgXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoIG1zZyApO1xuXG4gICAgXHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0Y29uc29sZS53YXJuKCBtc2cgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdHJldHVybiB0aGlzLmlkZW50aXR5KCk7XG4gICAgXHRcdH1cblxuICAgIFx0XHR2YXIgZGV0SW52ID0gMSAvIGRldDtcblxuICAgIFx0XHR0ZVsgMCBdID0gdDExICogZGV0SW52O1xuICAgIFx0XHR0ZVsgMSBdID0gKCBuMzEgKiBuMjMgLSBuMzMgKiBuMjEgKSAqIGRldEludjtcbiAgICBcdFx0dGVbIDIgXSA9ICggbjMyICogbjIxIC0gbjMxICogbjIyICkgKiBkZXRJbnY7XG5cbiAgICBcdFx0dGVbIDMgXSA9IHQxMiAqIGRldEludjtcbiAgICBcdFx0dGVbIDQgXSA9ICggbjMzICogbjExIC0gbjMxICogbjEzICkgKiBkZXRJbnY7XG4gICAgXHRcdHRlWyA1IF0gPSAoIG4zMSAqIG4xMiAtIG4zMiAqIG4xMSApICogZGV0SW52O1xuXG4gICAgXHRcdHRlWyA2IF0gPSB0MTMgKiBkZXRJbnY7XG4gICAgXHRcdHRlWyA3IF0gPSAoIG4yMSAqIG4xMyAtIG4yMyAqIG4xMSApICogZGV0SW52O1xuICAgIFx0XHR0ZVsgOCBdID0gKCBuMjIgKiBuMTEgLSBuMjEgKiBuMTIgKSAqIGRldEludjtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0dHJhbnNwb3NlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dmFyIHRtcCwgbSA9IHRoaXMuZWxlbWVudHM7XG5cbiAgICBcdFx0dG1wID0gbVsgMSBdOyBtWyAxIF0gPSBtWyAzIF07IG1bIDMgXSA9IHRtcDtcbiAgICBcdFx0dG1wID0gbVsgMiBdOyBtWyAyIF0gPSBtWyA2IF07IG1bIDYgXSA9IHRtcDtcbiAgICBcdFx0dG1wID0gbVsgNSBdOyBtWyA1IF0gPSBtWyA3IF07IG1bIDcgXSA9IHRtcDtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0ZmxhdHRlblRvQXJyYXlPZmZzZXQ6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcblxuICAgIFx0XHRjb25zb2xlLndhcm4oIFwiVEhSRUUuTWF0cml4MzogLmZsYXR0ZW5Ub0FycmF5T2Zmc2V0IGlzIGRlcHJlY2F0ZWQgXCIgK1xuICAgIFx0XHRcdFx0XCItIGp1c3QgdXNlIC50b0FycmF5IGluc3RlYWQuXCIgKTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcy50b0FycmF5KCBhcnJheSwgb2Zmc2V0ICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGdldE5vcm1hbE1hdHJpeDogZnVuY3Rpb24gKCBtYXRyaXg0ICkge1xuXG4gICAgXHRcdHJldHVybiB0aGlzLnNldEZyb21NYXRyaXg0KCBtYXRyaXg0ICkuZ2V0SW52ZXJzZSggdGhpcyApLnRyYW5zcG9zZSgpO1xuXG4gICAgXHR9LFxuXG4gICAgXHR0cmFuc3Bvc2VJbnRvQXJyYXk6IGZ1bmN0aW9uICggciApIHtcblxuICAgIFx0XHR2YXIgbSA9IHRoaXMuZWxlbWVudHM7XG5cbiAgICBcdFx0clsgMCBdID0gbVsgMCBdO1xuICAgIFx0XHRyWyAxIF0gPSBtWyAzIF07XG4gICAgXHRcdHJbIDIgXSA9IG1bIDYgXTtcbiAgICBcdFx0clsgMyBdID0gbVsgMSBdO1xuICAgIFx0XHRyWyA0IF0gPSBtWyA0IF07XG4gICAgXHRcdHJbIDUgXSA9IG1bIDcgXTtcbiAgICBcdFx0clsgNiBdID0gbVsgMiBdO1xuICAgIFx0XHRyWyA3IF0gPSBtWyA1IF07XG4gICAgXHRcdHJbIDggXSA9IG1bIDggXTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0ZnJvbUFycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XG5cbiAgICBcdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cbiAgICBcdFx0Zm9yKCB2YXIgaSA9IDA7IGkgPCA5OyBpICsrICkge1xuXG4gICAgXHRcdFx0dGhpcy5lbGVtZW50c1sgaSBdID0gYXJyYXlbIGkgKyBvZmZzZXQgXTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdHRvQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcblxuICAgIFx0XHRpZiAoIGFycmF5ID09PSB1bmRlZmluZWQgKSBhcnJheSA9IFtdO1xuICAgIFx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuICAgIFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG4gICAgXHRcdGFycmF5WyBvZmZzZXQgXSA9IHRlWyAwIF07XG4gICAgXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0ZVsgMSBdO1xuICAgIFx0XHRhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGVbIDIgXTtcblxuICAgIFx0XHRhcnJheVsgb2Zmc2V0ICsgMyBdID0gdGVbIDMgXTtcbiAgICBcdFx0YXJyYXlbIG9mZnNldCArIDQgXSA9IHRlWyA0IF07XG4gICAgXHRcdGFycmF5WyBvZmZzZXQgKyA1IF0gPSB0ZVsgNSBdO1xuXG4gICAgXHRcdGFycmF5WyBvZmZzZXQgKyA2IF0gPSB0ZVsgNiBdO1xuICAgIFx0XHRhcnJheVsgb2Zmc2V0ICsgNyBdID0gdGVbIDcgXTtcbiAgICBcdFx0YXJyYXlbIG9mZnNldCArIDggXSAgPSB0ZVsgOCBdO1xuXG4gICAgXHRcdHJldHVybiBhcnJheTtcblxuICAgIFx0fVxuXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIFBsYW5lKCBub3JtYWwsIGNvbnN0YW50ICkge1xuXG4gICAgXHR0aGlzLm5vcm1hbCA9ICggbm9ybWFsICE9PSB1bmRlZmluZWQgKSA/IG5vcm1hbCA6IG5ldyBWZWN0b3IzKCAxLCAwLCAwICk7XG4gICAgXHR0aGlzLmNvbnN0YW50ID0gKCBjb25zdGFudCAhPT0gdW5kZWZpbmVkICkgPyBjb25zdGFudCA6IDA7XG5cbiAgICB9XG5cbiAgICBQbGFuZS5wcm90b3R5cGUgPSB7XG5cbiAgICBcdGNvbnN0cnVjdG9yOiBQbGFuZSxcblxuICAgIFx0c2V0OiBmdW5jdGlvbiAoIG5vcm1hbCwgY29uc3RhbnQgKSB7XG5cbiAgICBcdFx0dGhpcy5ub3JtYWwuY29weSggbm9ybWFsICk7XG4gICAgXHRcdHRoaXMuY29uc3RhbnQgPSBjb25zdGFudDtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0c2V0Q29tcG9uZW50czogZnVuY3Rpb24gKCB4LCB5LCB6LCB3ICkge1xuXG4gICAgXHRcdHRoaXMubm9ybWFsLnNldCggeCwgeSwgeiApO1xuICAgIFx0XHR0aGlzLmNvbnN0YW50ID0gdztcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0c2V0RnJvbU5vcm1hbEFuZENvcGxhbmFyUG9pbnQ6IGZ1bmN0aW9uICggbm9ybWFsLCBwb2ludCApIHtcblxuICAgIFx0XHR0aGlzLm5vcm1hbC5jb3B5KCBub3JtYWwgKTtcbiAgICBcdFx0dGhpcy5jb25zdGFudCA9IC0gcG9pbnQuZG90KCB0aGlzLm5vcm1hbCApO1x0Ly8gbXVzdCBiZSB0aGlzLm5vcm1hbCwgbm90IG5vcm1hbCwgYXMgdGhpcy5ub3JtYWwgaXMgbm9ybWFsaXplZFxuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzZXRGcm9tQ29wbGFuYXJQb2ludHM6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR2YXIgdjEgPSBuZXcgVmVjdG9yMygpO1xuICAgIFx0XHR2YXIgdjIgPSBuZXcgVmVjdG9yMygpO1xuXG4gICAgXHRcdHJldHVybiBmdW5jdGlvbiBzZXRGcm9tQ29wbGFuYXJQb2ludHMoIGEsIGIsIGMgKSB7XG5cbiAgICBcdFx0XHR2YXIgbm9ybWFsID0gdjEuc3ViVmVjdG9ycyggYywgYiApLmNyb3NzKCB2Mi5zdWJWZWN0b3JzKCBhLCBiICkgKS5ub3JtYWxpemUoKTtcblxuICAgIFx0XHRcdC8vIFE6IHNob3VsZCBhbiBlcnJvciBiZSB0aHJvd24gaWYgbm9ybWFsIGlzIHplcm8gKGUuZy4gZGVnZW5lcmF0ZSBwbGFuZSk/XG5cbiAgICBcdFx0XHR0aGlzLnNldEZyb21Ob3JtYWxBbmRDb3BsYW5hclBvaW50KCBub3JtYWwsIGEgKTtcblxuICAgIFx0XHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHRcdH07XG5cbiAgICBcdH0oKSxcblxuICAgIFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGNvcHk6IGZ1bmN0aW9uICggcGxhbmUgKSB7XG5cbiAgICBcdFx0dGhpcy5ub3JtYWwuY29weSggcGxhbmUubm9ybWFsICk7XG4gICAgXHRcdHRoaXMuY29uc3RhbnQgPSBwbGFuZS5jb25zdGFudDtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0bm9ybWFsaXplOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0Ly8gTm90ZTogd2lsbCBsZWFkIHRvIGEgZGl2aWRlIGJ5IHplcm8gaWYgdGhlIHBsYW5lIGlzIGludmFsaWQuXG5cbiAgICBcdFx0dmFyIGludmVyc2VOb3JtYWxMZW5ndGggPSAxLjAgLyB0aGlzLm5vcm1hbC5sZW5ndGgoKTtcbiAgICBcdFx0dGhpcy5ub3JtYWwubXVsdGlwbHlTY2FsYXIoIGludmVyc2VOb3JtYWxMZW5ndGggKTtcbiAgICBcdFx0dGhpcy5jb25zdGFudCAqPSBpbnZlcnNlTm9ybWFsTGVuZ3RoO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRuZWdhdGU6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR0aGlzLmNvbnN0YW50ICo9IC0gMTtcbiAgICBcdFx0dGhpcy5ub3JtYWwubmVnYXRlKCk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGRpc3RhbmNlVG9Qb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcblxuICAgIFx0XHRyZXR1cm4gdGhpcy5ub3JtYWwuZG90KCBwb2ludCApICsgdGhpcy5jb25zdGFudDtcblxuICAgIFx0fSxcblxuICAgIFx0ZGlzdGFuY2VUb1NwaGVyZTogZnVuY3Rpb24gKCBzcGhlcmUgKSB7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMuZGlzdGFuY2VUb1BvaW50KCBzcGhlcmUuY2VudGVyICkgLSBzcGhlcmUucmFkaXVzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRwcm9qZWN0UG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgXHRcdHJldHVybiB0aGlzLm9ydGhvUG9pbnQoIHBvaW50LCBvcHRpb25hbFRhcmdldCApLnN1YiggcG9pbnQgKS5uZWdhdGUoKTtcblxuICAgIFx0fSxcblxuICAgIFx0b3J0aG9Qb2ludDogZnVuY3Rpb24gKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICBcdFx0dmFyIHBlcnBlbmRpY3VsYXJNYWduaXR1ZGUgPSB0aGlzLmRpc3RhbmNlVG9Qb2ludCggcG9pbnQgKTtcblxuICAgIFx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjMoKTtcbiAgICBcdFx0cmV0dXJuIHJlc3VsdC5jb3B5KCB0aGlzLm5vcm1hbCApLm11bHRpcGx5U2NhbGFyKCBwZXJwZW5kaWN1bGFyTWFnbml0dWRlICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGludGVyc2VjdExpbmU6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR2YXIgdjEgPSBuZXcgVmVjdG9yMygpO1xuXG4gICAgXHRcdHJldHVybiBmdW5jdGlvbiBpbnRlcnNlY3RMaW5lKCBsaW5lLCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgIFx0XHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMygpO1xuXG4gICAgXHRcdFx0dmFyIGRpcmVjdGlvbiA9IGxpbmUuZGVsdGEoIHYxICk7XG5cbiAgICBcdFx0XHR2YXIgZGVub21pbmF0b3IgPSB0aGlzLm5vcm1hbC5kb3QoIGRpcmVjdGlvbiApO1xuXG4gICAgXHRcdFx0aWYgKCBkZW5vbWluYXRvciA9PT0gMCApIHtcblxuICAgIFx0XHRcdFx0Ly8gbGluZSBpcyBjb3BsYW5hciwgcmV0dXJuIG9yaWdpblxuICAgIFx0XHRcdFx0aWYgKCB0aGlzLmRpc3RhbmNlVG9Qb2ludCggbGluZS5zdGFydCApID09PSAwICkge1xuXG4gICAgXHRcdFx0XHRcdHJldHVybiByZXN1bHQuY29weSggbGluZS5zdGFydCApO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdC8vIFVuc3VyZSBpZiB0aGlzIGlzIHRoZSBjb3JyZWN0IG1ldGhvZCB0byBoYW5kbGUgdGhpcyBjYXNlLlxuICAgIFx0XHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdHZhciB0ID0gLSAoIGxpbmUuc3RhcnQuZG90KCB0aGlzLm5vcm1hbCApICsgdGhpcy5jb25zdGFudCApIC8gZGVub21pbmF0b3I7XG5cbiAgICBcdFx0XHRpZiAoIHQgPCAwIHx8IHQgPiAxICkge1xuXG4gICAgXHRcdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0cmV0dXJuIHJlc3VsdC5jb3B5KCBkaXJlY3Rpb24gKS5tdWx0aXBseVNjYWxhciggdCApLmFkZCggbGluZS5zdGFydCApO1xuXG4gICAgXHRcdH07XG5cbiAgICBcdH0oKSxcblxuICAgIFx0aW50ZXJzZWN0c0xpbmU6IGZ1bmN0aW9uICggbGluZSApIHtcblxuICAgIFx0XHQvLyBOb3RlOiB0aGlzIHRlc3RzIGlmIGEgbGluZSBpbnRlcnNlY3RzIHRoZSBwbGFuZSwgbm90IHdoZXRoZXIgaXQgKG9yIGl0cyBlbmQtcG9pbnRzKSBhcmUgY29wbGFuYXIgd2l0aCBpdC5cblxuICAgIFx0XHR2YXIgc3RhcnRTaWduID0gdGhpcy5kaXN0YW5jZVRvUG9pbnQoIGxpbmUuc3RhcnQgKTtcbiAgICBcdFx0dmFyIGVuZFNpZ24gPSB0aGlzLmRpc3RhbmNlVG9Qb2ludCggbGluZS5lbmQgKTtcblxuICAgIFx0XHRyZXR1cm4gKCBzdGFydFNpZ24gPCAwICYmIGVuZFNpZ24gPiAwICkgfHwgKCBlbmRTaWduIDwgMCAmJiBzdGFydFNpZ24gPiAwICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGludGVyc2VjdHNCb3g6IGZ1bmN0aW9uICggYm94ICkge1xuXG4gICAgXHRcdHJldHVybiBib3guaW50ZXJzZWN0c1BsYW5lKCB0aGlzICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGludGVyc2VjdHNTcGhlcmU6IGZ1bmN0aW9uICggc3BoZXJlICkge1xuXG4gICAgXHRcdHJldHVybiBzcGhlcmUuaW50ZXJzZWN0c1BsYW5lKCB0aGlzICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGNvcGxhbmFyUG9pbnQ6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICBcdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XG4gICAgXHRcdHJldHVybiByZXN1bHQuY29weSggdGhpcy5ub3JtYWwgKS5tdWx0aXBseVNjYWxhciggLSB0aGlzLmNvbnN0YW50ICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGFwcGx5TWF0cml4NDogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XG4gICAgXHRcdHZhciBtMSA9IG5ldyBNYXRyaXgzKCk7XG5cbiAgICBcdFx0cmV0dXJuIGZ1bmN0aW9uIGFwcGx5TWF0cml4NCggbWF0cml4LCBvcHRpb25hbE5vcm1hbE1hdHJpeCApIHtcblxuICAgIFx0XHRcdHZhciByZWZlcmVuY2VQb2ludCA9IHRoaXMuY29wbGFuYXJQb2ludCggdjEgKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xuXG4gICAgXHRcdFx0Ly8gdHJhbnNmb3JtIG5vcm1hbCBiYXNlZCBvbiB0aGVvcnkgaGVyZTpcbiAgICBcdFx0XHQvLyBodHRwOi8vd3d3LnNvbmdoby5jYS9vcGVuZ2wvZ2xfbm9ybWFsdHJhbnNmb3JtLmh0bWxcbiAgICBcdFx0XHR2YXIgbm9ybWFsTWF0cml4ID0gb3B0aW9uYWxOb3JtYWxNYXRyaXggfHwgbTEuZ2V0Tm9ybWFsTWF0cml4KCBtYXRyaXggKTtcbiAgICBcdFx0XHR2YXIgbm9ybWFsID0gdGhpcy5ub3JtYWwuYXBwbHlNYXRyaXgzKCBub3JtYWxNYXRyaXggKS5ub3JtYWxpemUoKTtcblxuICAgIFx0XHRcdC8vIHJlY2FsY3VsYXRlIGNvbnN0YW50IChsaWtlIGluIHNldEZyb21Ob3JtYWxBbmRDb3BsYW5hclBvaW50KVxuICAgIFx0XHRcdHRoaXMuY29uc3RhbnQgPSAtIHJlZmVyZW5jZVBvaW50LmRvdCggbm9ybWFsICk7XG5cbiAgICBcdFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0XHR9O1xuXG4gICAgXHR9KCksXG5cbiAgICBcdHRyYW5zbGF0ZTogZnVuY3Rpb24gKCBvZmZzZXQgKSB7XG5cbiAgICBcdFx0dGhpcy5jb25zdGFudCA9IHRoaXMuY29uc3RhbnQgLSBvZmZzZXQuZG90KCB0aGlzLm5vcm1hbCApO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRlcXVhbHM6IGZ1bmN0aW9uICggcGxhbmUgKSB7XG5cbiAgICBcdFx0cmV0dXJuIHBsYW5lLm5vcm1hbC5lcXVhbHMoIHRoaXMubm9ybWFsICkgJiYgKCBwbGFuZS5jb25zdGFudCA9PT0gdGhpcy5jb25zdGFudCApO1xuXG4gICAgXHR9XG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAgICAgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICAgICAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIEZydXN0dW0oIHAwLCBwMSwgcDIsIHAzLCBwNCwgcDUgKSB7XG5cbiAgICBcdHRoaXMucGxhbmVzID0gW1xuXG4gICAgXHRcdCggcDAgIT09IHVuZGVmaW5lZCApID8gcDAgOiBuZXcgUGxhbmUoKSxcbiAgICBcdFx0KCBwMSAhPT0gdW5kZWZpbmVkICkgPyBwMSA6IG5ldyBQbGFuZSgpLFxuICAgIFx0XHQoIHAyICE9PSB1bmRlZmluZWQgKSA/IHAyIDogbmV3IFBsYW5lKCksXG4gICAgXHRcdCggcDMgIT09IHVuZGVmaW5lZCApID8gcDMgOiBuZXcgUGxhbmUoKSxcbiAgICBcdFx0KCBwNCAhPT0gdW5kZWZpbmVkICkgPyBwNCA6IG5ldyBQbGFuZSgpLFxuICAgIFx0XHQoIHA1ICE9PSB1bmRlZmluZWQgKSA/IHA1IDogbmV3IFBsYW5lKClcblxuICAgIFx0XTtcblxuICAgIH1cblxuICAgIEZydXN0dW0ucHJvdG90eXBlID0ge1xuXG4gICAgXHRjb25zdHJ1Y3RvcjogRnJ1c3R1bSxcblxuICAgIFx0c2V0OiBmdW5jdGlvbiAoIHAwLCBwMSwgcDIsIHAzLCBwNCwgcDUgKSB7XG5cbiAgICBcdFx0dmFyIHBsYW5lcyA9IHRoaXMucGxhbmVzO1xuXG4gICAgXHRcdHBsYW5lc1sgMCBdLmNvcHkoIHAwICk7XG4gICAgXHRcdHBsYW5lc1sgMSBdLmNvcHkoIHAxICk7XG4gICAgXHRcdHBsYW5lc1sgMiBdLmNvcHkoIHAyICk7XG4gICAgXHRcdHBsYW5lc1sgMyBdLmNvcHkoIHAzICk7XG4gICAgXHRcdHBsYW5lc1sgNCBdLmNvcHkoIHA0ICk7XG4gICAgXHRcdHBsYW5lc1sgNSBdLmNvcHkoIHA1ICk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRjb3B5OiBmdW5jdGlvbiAoIGZydXN0dW0gKSB7XG5cbiAgICBcdFx0dmFyIHBsYW5lcyA9IHRoaXMucGxhbmVzO1xuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IDY7IGkgKysgKSB7XG5cbiAgICBcdFx0XHRwbGFuZXNbIGkgXS5jb3B5KCBmcnVzdHVtLnBsYW5lc1sgaSBdICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzZXRGcm9tTWF0cml4OiBmdW5jdGlvbiAoIG0gKSB7XG5cbiAgICBcdFx0dmFyIHBsYW5lcyA9IHRoaXMucGxhbmVzO1xuICAgIFx0XHR2YXIgbWUgPSBtLmVsZW1lbnRzO1xuICAgIFx0XHR2YXIgbWUwID0gbWVbIDAgXSwgbWUxID0gbWVbIDEgXSwgbWUyID0gbWVbIDIgXSwgbWUzID0gbWVbIDMgXTtcbiAgICBcdFx0dmFyIG1lNCA9IG1lWyA0IF0sIG1lNSA9IG1lWyA1IF0sIG1lNiA9IG1lWyA2IF0sIG1lNyA9IG1lWyA3IF07XG4gICAgXHRcdHZhciBtZTggPSBtZVsgOCBdLCBtZTkgPSBtZVsgOSBdLCBtZTEwID0gbWVbIDEwIF0sIG1lMTEgPSBtZVsgMTEgXTtcbiAgICBcdFx0dmFyIG1lMTIgPSBtZVsgMTIgXSwgbWUxMyA9IG1lWyAxMyBdLCBtZTE0ID0gbWVbIDE0IF0sIG1lMTUgPSBtZVsgMTUgXTtcblxuICAgIFx0XHRwbGFuZXNbIDAgXS5zZXRDb21wb25lbnRzKCBtZTMgLSBtZTAsIG1lNyAtIG1lNCwgbWUxMSAtIG1lOCwgbWUxNSAtIG1lMTIgKS5ub3JtYWxpemUoKTtcbiAgICBcdFx0cGxhbmVzWyAxIF0uc2V0Q29tcG9uZW50cyggbWUzICsgbWUwLCBtZTcgKyBtZTQsIG1lMTEgKyBtZTgsIG1lMTUgKyBtZTEyICkubm9ybWFsaXplKCk7XG4gICAgXHRcdHBsYW5lc1sgMiBdLnNldENvbXBvbmVudHMoIG1lMyArIG1lMSwgbWU3ICsgbWU1LCBtZTExICsgbWU5LCBtZTE1ICsgbWUxMyApLm5vcm1hbGl6ZSgpO1xuICAgIFx0XHRwbGFuZXNbIDMgXS5zZXRDb21wb25lbnRzKCBtZTMgLSBtZTEsIG1lNyAtIG1lNSwgbWUxMSAtIG1lOSwgbWUxNSAtIG1lMTMgKS5ub3JtYWxpemUoKTtcbiAgICBcdFx0cGxhbmVzWyA0IF0uc2V0Q29tcG9uZW50cyggbWUzIC0gbWUyLCBtZTcgLSBtZTYsIG1lMTEgLSBtZTEwLCBtZTE1IC0gbWUxNCApLm5vcm1hbGl6ZSgpO1xuICAgIFx0XHRwbGFuZXNbIDUgXS5zZXRDb21wb25lbnRzKCBtZTMgKyBtZTIsIG1lNyArIG1lNiwgbWUxMSArIG1lMTAsIG1lMTUgKyBtZTE0ICkubm9ybWFsaXplKCk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGludGVyc2VjdHNPYmplY3Q6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR2YXIgc3BoZXJlID0gbmV3IFNwaGVyZSgpO1xuXG4gICAgXHRcdHJldHVybiBmdW5jdGlvbiBpbnRlcnNlY3RzT2JqZWN0KCBvYmplY3QgKSB7XG5cbiAgICBcdFx0XHR2YXIgZ2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnk7XG5cbiAgICBcdFx0XHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlID09PSBudWxsIClcbiAgICBcdFx0XHRcdGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuXG4gICAgXHRcdFx0c3BoZXJlLmNvcHkoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlIClcbiAgICBcdFx0XHRcdC5hcHBseU1hdHJpeDQoIG9iamVjdC5tYXRyaXhXb3JsZCApO1xuXG4gICAgXHRcdFx0cmV0dXJuIHRoaXMuaW50ZXJzZWN0c1NwaGVyZSggc3BoZXJlICk7XG5cbiAgICBcdFx0fTtcblxuICAgIFx0fSgpLFxuXG4gICAgXHRpbnRlcnNlY3RzU3ByaXRlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dmFyIHNwaGVyZSA9IG5ldyBTcGhlcmUoKTtcblxuICAgIFx0XHRyZXR1cm4gZnVuY3Rpb24gaW50ZXJzZWN0c1Nwcml0ZSggc3ByaXRlICkge1xuXG4gICAgXHRcdFx0c3BoZXJlLmNlbnRlci5zZXQoIDAsIDAsIDAgKTtcbiAgICBcdFx0XHRzcGhlcmUucmFkaXVzID0gMC43MDcxMDY3ODExODY1NDc2O1xuICAgIFx0XHRcdHNwaGVyZS5hcHBseU1hdHJpeDQoIHNwcml0ZS5tYXRyaXhXb3JsZCApO1xuXG4gICAgXHRcdFx0cmV0dXJuIHRoaXMuaW50ZXJzZWN0c1NwaGVyZSggc3BoZXJlICk7XG5cbiAgICBcdFx0fTtcblxuICAgIFx0fSgpLFxuXG4gICAgXHRpbnRlcnNlY3RzU3BoZXJlOiBmdW5jdGlvbiAoIHNwaGVyZSApIHtcblxuICAgIFx0XHR2YXIgcGxhbmVzID0gdGhpcy5wbGFuZXM7XG4gICAgXHRcdHZhciBjZW50ZXIgPSBzcGhlcmUuY2VudGVyO1xuICAgIFx0XHR2YXIgbmVnUmFkaXVzID0gLSBzcGhlcmUucmFkaXVzO1xuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IDY7IGkgKysgKSB7XG5cbiAgICBcdFx0XHR2YXIgZGlzdGFuY2UgPSBwbGFuZXNbIGkgXS5kaXN0YW5jZVRvUG9pbnQoIGNlbnRlciApO1xuXG4gICAgXHRcdFx0aWYgKCBkaXN0YW5jZSA8IG5lZ1JhZGl1cyApIHtcblxuICAgIFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gdHJ1ZTtcblxuICAgIFx0fSxcblxuICAgIFx0aW50ZXJzZWN0c0JveDogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHZhciBwMSA9IG5ldyBWZWN0b3IzKCksXG4gICAgXHRcdFx0cDIgPSBuZXcgVmVjdG9yMygpO1xuXG4gICAgXHRcdHJldHVybiBmdW5jdGlvbiBpbnRlcnNlY3RzQm94KCBib3ggKSB7XG5cbiAgICBcdFx0XHR2YXIgcGxhbmVzID0gdGhpcy5wbGFuZXM7XG5cbiAgICBcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCA2IDsgaSArKyApIHtcblxuICAgIFx0XHRcdFx0dmFyIHBsYW5lID0gcGxhbmVzWyBpIF07XG5cbiAgICBcdFx0XHRcdHAxLnggPSBwbGFuZS5ub3JtYWwueCA+IDAgPyBib3gubWluLnggOiBib3gubWF4Lng7XG4gICAgXHRcdFx0XHRwMi54ID0gcGxhbmUubm9ybWFsLnggPiAwID8gYm94Lm1heC54IDogYm94Lm1pbi54O1xuICAgIFx0XHRcdFx0cDEueSA9IHBsYW5lLm5vcm1hbC55ID4gMCA/IGJveC5taW4ueSA6IGJveC5tYXgueTtcbiAgICBcdFx0XHRcdHAyLnkgPSBwbGFuZS5ub3JtYWwueSA+IDAgPyBib3gubWF4LnkgOiBib3gubWluLnk7XG4gICAgXHRcdFx0XHRwMS56ID0gcGxhbmUubm9ybWFsLnogPiAwID8gYm94Lm1pbi56IDogYm94Lm1heC56O1xuICAgIFx0XHRcdFx0cDIueiA9IHBsYW5lLm5vcm1hbC56ID4gMCA/IGJveC5tYXgueiA6IGJveC5taW4uejtcblxuICAgIFx0XHRcdFx0dmFyIGQxID0gcGxhbmUuZGlzdGFuY2VUb1BvaW50KCBwMSApO1xuICAgIFx0XHRcdFx0dmFyIGQyID0gcGxhbmUuZGlzdGFuY2VUb1BvaW50KCBwMiApO1xuXG4gICAgXHRcdFx0XHQvLyBpZiBib3RoIG91dHNpZGUgcGxhbmUsIG5vIGludGVyc2VjdGlvblxuXG4gICAgXHRcdFx0XHRpZiAoIGQxIDwgMCAmJiBkMiA8IDAgKSB7XG5cbiAgICBcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRyZXR1cm4gdHJ1ZTtcblxuICAgIFx0XHR9O1xuXG4gICAgXHR9KCksXG5cblxuICAgIFx0Y29udGFpbnNQb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcblxuICAgIFx0XHR2YXIgcGxhbmVzID0gdGhpcy5wbGFuZXM7XG5cbiAgICBcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgNjsgaSArKyApIHtcblxuICAgIFx0XHRcdGlmICggcGxhbmVzWyBpIF0uZGlzdGFuY2VUb1BvaW50KCBwb2ludCApIDwgMCApIHtcblxuICAgIFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gdHJ1ZTtcblxuICAgIFx0fVxuXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIFdlYkdMU2hhZG93TWFwKCBfcmVuZGVyZXIsIF9saWdodHMsIF9vYmplY3RzLCBjYXBhYmlsaXRpZXMgKSB7XG5cbiAgICBcdHZhciBfZ2wgPSBfcmVuZGVyZXIuY29udGV4dCxcbiAgICBcdF9zdGF0ZSA9IF9yZW5kZXJlci5zdGF0ZSxcbiAgICBcdF9mcnVzdHVtID0gbmV3IEZydXN0dW0oKSxcbiAgICBcdF9wcm9qU2NyZWVuTWF0cml4ID0gbmV3IE1hdHJpeDQoKSxcblxuICAgIFx0X2xpZ2h0U2hhZG93cyA9IF9saWdodHMuc2hhZG93cyxcblxuICAgIFx0X3NoYWRvd01hcFNpemUgPSBuZXcgVmVjdG9yMigpLFxuICAgIFx0X21heFNoYWRvd01hcFNpemUgPSBuZXcgVmVjdG9yMiggY2FwYWJpbGl0aWVzLm1heFRleHR1cmVTaXplLCBjYXBhYmlsaXRpZXMubWF4VGV4dHVyZVNpemUgKSxcblxuICAgIFx0X2xvb2tUYXJnZXQgPSBuZXcgVmVjdG9yMygpLFxuICAgIFx0X2xpZ2h0UG9zaXRpb25Xb3JsZCA9IG5ldyBWZWN0b3IzKCksXG5cbiAgICBcdF9yZW5kZXJMaXN0ID0gW10sXG5cbiAgICBcdF9Nb3JwaGluZ0ZsYWcgPSAxLFxuICAgIFx0X1NraW5uaW5nRmxhZyA9IDIsXG5cbiAgICBcdF9OdW1iZXJPZk1hdGVyaWFsVmFyaWFudHMgPSAoIF9Nb3JwaGluZ0ZsYWcgfCBfU2tpbm5pbmdGbGFnICkgKyAxLFxuXG4gICAgXHRfZGVwdGhNYXRlcmlhbHMgPSBuZXcgQXJyYXkoIF9OdW1iZXJPZk1hdGVyaWFsVmFyaWFudHMgKSxcbiAgICBcdF9kaXN0YW5jZU1hdGVyaWFscyA9IG5ldyBBcnJheSggX051bWJlck9mTWF0ZXJpYWxWYXJpYW50cyApLFxuXG4gICAgXHRfbWF0ZXJpYWxDYWNoZSA9IHt9O1xuXG4gICAgXHR2YXIgY3ViZURpcmVjdGlvbnMgPSBbXG4gICAgXHRcdG5ldyBWZWN0b3IzKCAxLCAwLCAwICksIG5ldyBWZWN0b3IzKCAtIDEsIDAsIDAgKSwgbmV3IFZlY3RvcjMoIDAsIDAsIDEgKSxcbiAgICBcdFx0bmV3IFZlY3RvcjMoIDAsIDAsIC0gMSApLCBuZXcgVmVjdG9yMyggMCwgMSwgMCApLCBuZXcgVmVjdG9yMyggMCwgLSAxLCAwIClcbiAgICBcdF07XG5cbiAgICBcdHZhciBjdWJlVXBzID0gW1xuICAgIFx0XHRuZXcgVmVjdG9yMyggMCwgMSwgMCApLCBuZXcgVmVjdG9yMyggMCwgMSwgMCApLCBuZXcgVmVjdG9yMyggMCwgMSwgMCApLFxuICAgIFx0XHRuZXcgVmVjdG9yMyggMCwgMSwgMCApLCBuZXcgVmVjdG9yMyggMCwgMCwgMSApLFx0bmV3IFZlY3RvcjMoIDAsIDAsIC0gMSApXG4gICAgXHRdO1xuXG4gICAgXHR2YXIgY3ViZTJEVmlld1BvcnRzID0gW1xuICAgIFx0XHRuZXcgVmVjdG9yNCgpLCBuZXcgVmVjdG9yNCgpLCBuZXcgVmVjdG9yNCgpLFxuICAgIFx0XHRuZXcgVmVjdG9yNCgpLCBuZXcgVmVjdG9yNCgpLCBuZXcgVmVjdG9yNCgpXG4gICAgXHRdO1xuXG4gICAgXHQvLyBpbml0XG5cbiAgICBcdHZhciBkZXB0aE1hdGVyaWFsVGVtcGxhdGUgPSBuZXcgTWVzaERlcHRoTWF0ZXJpYWwoKTtcbiAgICBcdGRlcHRoTWF0ZXJpYWxUZW1wbGF0ZS5kZXB0aFBhY2tpbmcgPSBSR0JBRGVwdGhQYWNraW5nO1xuICAgIFx0ZGVwdGhNYXRlcmlhbFRlbXBsYXRlLmNsaXBwaW5nID0gdHJ1ZTtcblxuICAgIFx0dmFyIGRpc3RhbmNlU2hhZGVyID0gU2hhZGVyTGliWyBcImRpc3RhbmNlUkdCQVwiIF07XG4gICAgXHR2YXIgZGlzdGFuY2VVbmlmb3JtcyA9IGV4cG9ydHMuVW5pZm9ybXNVdGlscy5jbG9uZSggZGlzdGFuY2VTaGFkZXIudW5pZm9ybXMgKTtcblxuICAgIFx0Zm9yICggdmFyIGkgPSAwOyBpICE9PSBfTnVtYmVyT2ZNYXRlcmlhbFZhcmlhbnRzOyArKyBpICkge1xuXG4gICAgXHRcdHZhciB1c2VNb3JwaGluZyA9ICggaSAmIF9Nb3JwaGluZ0ZsYWcgKSAhPT0gMDtcbiAgICBcdFx0dmFyIHVzZVNraW5uaW5nID0gKCBpICYgX1NraW5uaW5nRmxhZyApICE9PSAwO1xuXG4gICAgXHRcdHZhciBkZXB0aE1hdGVyaWFsID0gZGVwdGhNYXRlcmlhbFRlbXBsYXRlLmNsb25lKCk7XG4gICAgXHRcdGRlcHRoTWF0ZXJpYWwubW9ycGhUYXJnZXRzID0gdXNlTW9ycGhpbmc7XG4gICAgXHRcdGRlcHRoTWF0ZXJpYWwuc2tpbm5pbmcgPSB1c2VTa2lubmluZztcblxuICAgIFx0XHRfZGVwdGhNYXRlcmlhbHNbIGkgXSA9IGRlcHRoTWF0ZXJpYWw7XG5cbiAgICBcdFx0dmFyIGRpc3RhbmNlTWF0ZXJpYWwgPSBuZXcgU2hhZGVyTWF0ZXJpYWwoIHtcbiAgICBcdFx0XHRkZWZpbmVzOiB7XG4gICAgXHRcdFx0XHQnVVNFX1NIQURPV01BUCc6ICcnXG4gICAgXHRcdFx0fSxcbiAgICBcdFx0XHR1bmlmb3JtczogZGlzdGFuY2VVbmlmb3JtcyxcbiAgICBcdFx0XHR2ZXJ0ZXhTaGFkZXI6IGRpc3RhbmNlU2hhZGVyLnZlcnRleFNoYWRlcixcbiAgICBcdFx0XHRmcmFnbWVudFNoYWRlcjogZGlzdGFuY2VTaGFkZXIuZnJhZ21lbnRTaGFkZXIsXG4gICAgXHRcdFx0bW9ycGhUYXJnZXRzOiB1c2VNb3JwaGluZyxcbiAgICBcdFx0XHRza2lubmluZzogdXNlU2tpbm5pbmcsXG4gICAgXHRcdFx0Y2xpcHBpbmc6IHRydWVcbiAgICBcdFx0fSApO1xuXG4gICAgXHRcdF9kaXN0YW5jZU1hdGVyaWFsc1sgaSBdID0gZGlzdGFuY2VNYXRlcmlhbDtcblxuICAgIFx0fVxuXG4gICAgXHQvL1xuXG4gICAgXHR2YXIgc2NvcGUgPSB0aGlzO1xuXG4gICAgXHR0aGlzLmVuYWJsZWQgPSBmYWxzZTtcblxuICAgIFx0dGhpcy5hdXRvVXBkYXRlID0gdHJ1ZTtcbiAgICBcdHRoaXMubmVlZHNVcGRhdGUgPSBmYWxzZTtcblxuICAgIFx0dGhpcy50eXBlID0gUENGU2hhZG93TWFwO1xuXG4gICAgXHR0aGlzLnJlbmRlclJldmVyc2VTaWRlZCA9IHRydWU7XG4gICAgXHR0aGlzLnJlbmRlclNpbmdsZVNpZGVkID0gdHJ1ZTtcblxuICAgIFx0dGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoIHNjZW5lLCBjYW1lcmEgKSB7XG5cbiAgICBcdFx0aWYgKCBzY29wZS5lbmFibGVkID09PSBmYWxzZSApIHJldHVybjtcbiAgICBcdFx0aWYgKCBzY29wZS5hdXRvVXBkYXRlID09PSBmYWxzZSAmJiBzY29wZS5uZWVkc1VwZGF0ZSA9PT0gZmFsc2UgKSByZXR1cm47XG5cbiAgICBcdFx0aWYgKCBfbGlnaHRTaGFkb3dzLmxlbmd0aCA9PT0gMCApIHJldHVybjtcblxuICAgIFx0XHQvLyBTZXQgR0wgc3RhdGUgZm9yIGRlcHRoIG1hcC5cbiAgICBcdFx0X3N0YXRlLmNsZWFyQ29sb3IoIDEsIDEsIDEsIDEgKTtcbiAgICBcdFx0X3N0YXRlLmRpc2FibGUoIF9nbC5CTEVORCApO1xuICAgIFx0XHRfc3RhdGUuc2V0RGVwdGhUZXN0KCB0cnVlICk7XG4gICAgXHRcdF9zdGF0ZS5zZXRTY2lzc29yVGVzdCggZmFsc2UgKTtcblxuICAgIFx0XHQvLyByZW5kZXIgZGVwdGggbWFwXG5cbiAgICBcdFx0dmFyIGZhY2VDb3VudCwgaXNQb2ludExpZ2h0O1xuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBfbGlnaHRTaGFkb3dzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgXHRcdFx0dmFyIGxpZ2h0ID0gX2xpZ2h0U2hhZG93c1sgaSBdO1xuICAgIFx0XHRcdHZhciBzaGFkb3cgPSBsaWdodC5zaGFkb3c7XG5cbiAgICBcdFx0XHRpZiAoIHNoYWRvdyA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFNoYWRvd01hcDonLCBsaWdodCwgJ2hhcyBubyBzaGFkb3cuJyApO1xuICAgIFx0XHRcdFx0Y29udGludWU7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHR2YXIgc2hhZG93Q2FtZXJhID0gc2hhZG93LmNhbWVyYTtcblxuICAgIFx0XHRcdF9zaGFkb3dNYXBTaXplLmNvcHkoIHNoYWRvdy5tYXBTaXplICk7XG4gICAgXHRcdFx0X3NoYWRvd01hcFNpemUubWluKCBfbWF4U2hhZG93TWFwU2l6ZSApO1xuXG4gICAgXHRcdFx0aWYgKCAobGlnaHQgJiYgbGlnaHQuaXNQb2ludExpZ2h0KSApIHtcblxuICAgIFx0XHRcdFx0ZmFjZUNvdW50ID0gNjtcbiAgICBcdFx0XHRcdGlzUG9pbnRMaWdodCA9IHRydWU7XG5cbiAgICBcdFx0XHRcdHZhciB2cFdpZHRoID0gX3NoYWRvd01hcFNpemUueDtcbiAgICBcdFx0XHRcdHZhciB2cEhlaWdodCA9IF9zaGFkb3dNYXBTaXplLnk7XG5cbiAgICBcdFx0XHRcdC8vIFRoZXNlIHZpZXdwb3J0cyBtYXAgYSBjdWJlLW1hcCBvbnRvIGEgMkQgdGV4dHVyZSB3aXRoIHRoZVxuICAgIFx0XHRcdFx0Ly8gZm9sbG93aW5nIG9yaWVudGF0aW9uOlxuICAgIFx0XHRcdFx0Ly9cbiAgICBcdFx0XHRcdC8vICB4elhaXG4gICAgXHRcdFx0XHQvLyAgIHkgWVxuICAgIFx0XHRcdFx0Ly9cbiAgICBcdFx0XHRcdC8vIFggLSBQb3NpdGl2ZSB4IGRpcmVjdGlvblxuICAgIFx0XHRcdFx0Ly8geCAtIE5lZ2F0aXZlIHggZGlyZWN0aW9uXG4gICAgXHRcdFx0XHQvLyBZIC0gUG9zaXRpdmUgeSBkaXJlY3Rpb25cbiAgICBcdFx0XHRcdC8vIHkgLSBOZWdhdGl2ZSB5IGRpcmVjdGlvblxuICAgIFx0XHRcdFx0Ly8gWiAtIFBvc2l0aXZlIHogZGlyZWN0aW9uXG4gICAgXHRcdFx0XHQvLyB6IC0gTmVnYXRpdmUgeiBkaXJlY3Rpb25cblxuICAgIFx0XHRcdFx0Ly8gcG9zaXRpdmUgWFxuICAgIFx0XHRcdFx0Y3ViZTJEVmlld1BvcnRzWyAwIF0uc2V0KCB2cFdpZHRoICogMiwgdnBIZWlnaHQsIHZwV2lkdGgsIHZwSGVpZ2h0ICk7XG4gICAgXHRcdFx0XHQvLyBuZWdhdGl2ZSBYXG4gICAgXHRcdFx0XHRjdWJlMkRWaWV3UG9ydHNbIDEgXS5zZXQoIDAsIHZwSGVpZ2h0LCB2cFdpZHRoLCB2cEhlaWdodCApO1xuICAgIFx0XHRcdFx0Ly8gcG9zaXRpdmUgWlxuICAgIFx0XHRcdFx0Y3ViZTJEVmlld1BvcnRzWyAyIF0uc2V0KCB2cFdpZHRoICogMywgdnBIZWlnaHQsIHZwV2lkdGgsIHZwSGVpZ2h0ICk7XG4gICAgXHRcdFx0XHQvLyBuZWdhdGl2ZSBaXG4gICAgXHRcdFx0XHRjdWJlMkRWaWV3UG9ydHNbIDMgXS5zZXQoIHZwV2lkdGgsIHZwSGVpZ2h0LCB2cFdpZHRoLCB2cEhlaWdodCApO1xuICAgIFx0XHRcdFx0Ly8gcG9zaXRpdmUgWVxuICAgIFx0XHRcdFx0Y3ViZTJEVmlld1BvcnRzWyA0IF0uc2V0KCB2cFdpZHRoICogMywgMCwgdnBXaWR0aCwgdnBIZWlnaHQgKTtcbiAgICBcdFx0XHRcdC8vIG5lZ2F0aXZlIFlcbiAgICBcdFx0XHRcdGN1YmUyRFZpZXdQb3J0c1sgNSBdLnNldCggdnBXaWR0aCwgMCwgdnBXaWR0aCwgdnBIZWlnaHQgKTtcblxuICAgIFx0XHRcdFx0X3NoYWRvd01hcFNpemUueCAqPSA0LjA7XG4gICAgXHRcdFx0XHRfc2hhZG93TWFwU2l6ZS55ICo9IDIuMDtcblxuICAgIFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdGZhY2VDb3VudCA9IDE7XG4gICAgXHRcdFx0XHRpc1BvaW50TGlnaHQgPSBmYWxzZTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGlmICggc2hhZG93Lm1hcCA9PT0gbnVsbCApIHtcblxuICAgIFx0XHRcdFx0dmFyIHBhcnMgPSB7IG1pbkZpbHRlcjogTmVhcmVzdEZpbHRlciwgbWFnRmlsdGVyOiBOZWFyZXN0RmlsdGVyLCBmb3JtYXQ6IFJHQkFGb3JtYXQgfTtcblxuICAgIFx0XHRcdFx0c2hhZG93Lm1hcCA9IG5ldyBXZWJHTFJlbmRlclRhcmdldCggX3NoYWRvd01hcFNpemUueCwgX3NoYWRvd01hcFNpemUueSwgcGFycyApO1xuXG4gICAgXHRcdFx0XHRzaGFkb3dDYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0aWYgKCAoc2hhZG93ICYmIHNoYWRvdy5pc1Nwb3RMaWdodFNoYWRvdykgKSB7XG5cbiAgICBcdFx0XHRcdHNoYWRvdy51cGRhdGUoIGxpZ2h0ICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHR2YXIgc2hhZG93TWFwID0gc2hhZG93Lm1hcDtcbiAgICBcdFx0XHR2YXIgc2hhZG93TWF0cml4ID0gc2hhZG93Lm1hdHJpeDtcblxuICAgIFx0XHRcdF9saWdodFBvc2l0aW9uV29ybGQuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC5tYXRyaXhXb3JsZCApO1xuICAgIFx0XHRcdHNoYWRvd0NhbWVyYS5wb3NpdGlvbi5jb3B5KCBfbGlnaHRQb3NpdGlvbldvcmxkICk7XG5cbiAgICBcdFx0XHRfcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KCBzaGFkb3dNYXAgKTtcbiAgICBcdFx0XHRfcmVuZGVyZXIuY2xlYXIoKTtcblxuICAgIFx0XHRcdC8vIHJlbmRlciBzaGFkb3cgbWFwIGZvciBlYWNoIGN1YmUgZmFjZSAoaWYgb21uaS1kaXJlY3Rpb25hbCkgb3JcbiAgICBcdFx0XHQvLyBydW4gYSBzaW5nbGUgcGFzcyBpZiBub3RcblxuICAgIFx0XHRcdGZvciAoIHZhciBmYWNlID0gMDsgZmFjZSA8IGZhY2VDb3VudDsgZmFjZSArKyApIHtcblxuICAgIFx0XHRcdFx0aWYgKCBpc1BvaW50TGlnaHQgKSB7XG5cbiAgICBcdFx0XHRcdFx0X2xvb2tUYXJnZXQuY29weSggc2hhZG93Q2FtZXJhLnBvc2l0aW9uICk7XG4gICAgXHRcdFx0XHRcdF9sb29rVGFyZ2V0LmFkZCggY3ViZURpcmVjdGlvbnNbIGZhY2UgXSApO1xuICAgIFx0XHRcdFx0XHRzaGFkb3dDYW1lcmEudXAuY29weSggY3ViZVVwc1sgZmFjZSBdICk7XG4gICAgXHRcdFx0XHRcdHNoYWRvd0NhbWVyYS5sb29rQXQoIF9sb29rVGFyZ2V0ICk7XG5cbiAgICBcdFx0XHRcdFx0dmFyIHZwRGltZW5zaW9ucyA9IGN1YmUyRFZpZXdQb3J0c1sgZmFjZSBdO1xuICAgIFx0XHRcdFx0XHRfc3RhdGUudmlld3BvcnQoIHZwRGltZW5zaW9ucyApO1xuXG4gICAgXHRcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRcdF9sb29rVGFyZ2V0LnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQudGFyZ2V0Lm1hdHJpeFdvcmxkICk7XG4gICAgXHRcdFx0XHRcdHNoYWRvd0NhbWVyYS5sb29rQXQoIF9sb29rVGFyZ2V0ICk7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0c2hhZG93Q2FtZXJhLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG4gICAgXHRcdFx0XHRzaGFkb3dDYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLmdldEludmVyc2UoIHNoYWRvd0NhbWVyYS5tYXRyaXhXb3JsZCApO1xuXG4gICAgXHRcdFx0XHQvLyBjb21wdXRlIHNoYWRvdyBtYXRyaXhcblxuICAgIFx0XHRcdFx0c2hhZG93TWF0cml4LnNldChcbiAgICBcdFx0XHRcdFx0MC41LCAwLjAsIDAuMCwgMC41LFxuICAgIFx0XHRcdFx0XHQwLjAsIDAuNSwgMC4wLCAwLjUsXG4gICAgXHRcdFx0XHRcdDAuMCwgMC4wLCAwLjUsIDAuNSxcbiAgICBcdFx0XHRcdFx0MC4wLCAwLjAsIDAuMCwgMS4wXG4gICAgXHRcdFx0XHQpO1xuXG4gICAgXHRcdFx0XHRzaGFkb3dNYXRyaXgubXVsdGlwbHkoIHNoYWRvd0NhbWVyYS5wcm9qZWN0aW9uTWF0cml4ICk7XG4gICAgXHRcdFx0XHRzaGFkb3dNYXRyaXgubXVsdGlwbHkoIHNoYWRvd0NhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UgKTtcblxuICAgIFx0XHRcdFx0Ly8gdXBkYXRlIGNhbWVyYSBtYXRyaWNlcyBhbmQgZnJ1c3R1bVxuXG4gICAgXHRcdFx0XHRfcHJvalNjcmVlbk1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBzaGFkb3dDYW1lcmEucHJvamVjdGlvbk1hdHJpeCwgc2hhZG93Q2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSApO1xuICAgIFx0XHRcdFx0X2ZydXN0dW0uc2V0RnJvbU1hdHJpeCggX3Byb2pTY3JlZW5NYXRyaXggKTtcblxuICAgIFx0XHRcdFx0Ly8gc2V0IG9iamVjdCBtYXRyaWNlcyAmIGZydXN0dW0gY3VsbGluZ1xuXG4gICAgXHRcdFx0XHRfcmVuZGVyTGlzdC5sZW5ndGggPSAwO1xuXG4gICAgXHRcdFx0XHRwcm9qZWN0T2JqZWN0KCBzY2VuZSwgY2FtZXJhLCBzaGFkb3dDYW1lcmEgKTtcblxuICAgIFx0XHRcdFx0Ly8gcmVuZGVyIHNoYWRvdyBtYXBcbiAgICBcdFx0XHRcdC8vIHJlbmRlciByZWd1bGFyIG9iamVjdHNcblxuICAgIFx0XHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IF9yZW5kZXJMaXN0Lmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG4gICAgXHRcdFx0XHRcdHZhciBvYmplY3QgPSBfcmVuZGVyTGlzdFsgaiBdO1xuICAgIFx0XHRcdFx0XHR2YXIgZ2VvbWV0cnkgPSBfb2JqZWN0cy51cGRhdGUoIG9iamVjdCApO1xuICAgIFx0XHRcdFx0XHR2YXIgbWF0ZXJpYWwgPSBvYmplY3QubWF0ZXJpYWw7XG5cbiAgICBcdFx0XHRcdFx0aWYgKCAobWF0ZXJpYWwgJiYgbWF0ZXJpYWwuaXNNdWx0aU1hdGVyaWFsKSApIHtcblxuICAgIFx0XHRcdFx0XHRcdHZhciBncm91cHMgPSBnZW9tZXRyeS5ncm91cHM7XG4gICAgXHRcdFx0XHRcdFx0dmFyIG1hdGVyaWFscyA9IG1hdGVyaWFsLm1hdGVyaWFscztcblxuICAgIFx0XHRcdFx0XHRcdGZvciAoIHZhciBrID0gMCwga2wgPSBncm91cHMubGVuZ3RoOyBrIDwga2w7IGsgKysgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHRcdHZhciBncm91cCA9IGdyb3Vwc1sgayBdO1xuICAgIFx0XHRcdFx0XHRcdFx0dmFyIGdyb3VwTWF0ZXJpYWwgPSBtYXRlcmlhbHNbIGdyb3VwLm1hdGVyaWFsSW5kZXggXTtcblxuICAgIFx0XHRcdFx0XHRcdFx0aWYgKCBncm91cE1hdGVyaWFsLnZpc2libGUgPT09IHRydWUgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHRcdFx0dmFyIGRlcHRoTWF0ZXJpYWwgPSBnZXREZXB0aE1hdGVyaWFsKCBvYmplY3QsIGdyb3VwTWF0ZXJpYWwsIGlzUG9pbnRMaWdodCwgX2xpZ2h0UG9zaXRpb25Xb3JsZCApO1xuICAgIFx0XHRcdFx0XHRcdFx0XHRfcmVuZGVyZXIucmVuZGVyQnVmZmVyRGlyZWN0KCBzaGFkb3dDYW1lcmEsIG51bGwsIGdlb21ldHJ5LCBkZXB0aE1hdGVyaWFsLCBvYmplY3QsIGdyb3VwICk7XG5cbiAgICBcdFx0XHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRcdFx0dmFyIGRlcHRoTWF0ZXJpYWwgPSBnZXREZXB0aE1hdGVyaWFsKCBvYmplY3QsIG1hdGVyaWFsLCBpc1BvaW50TGlnaHQsIF9saWdodFBvc2l0aW9uV29ybGQgKTtcbiAgICBcdFx0XHRcdFx0XHRfcmVuZGVyZXIucmVuZGVyQnVmZmVyRGlyZWN0KCBzaGFkb3dDYW1lcmEsIG51bGwsIGdlb21ldHJ5LCBkZXB0aE1hdGVyaWFsLCBvYmplY3QsIG51bGwgKTtcblxuICAgIFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdFx0Ly8gUmVzdG9yZSBHTCBzdGF0ZS5cbiAgICBcdFx0dmFyIGNsZWFyQ29sb3IgPSBfcmVuZGVyZXIuZ2V0Q2xlYXJDb2xvcigpLFxuICAgIFx0XHRjbGVhckFscGhhID0gX3JlbmRlcmVyLmdldENsZWFyQWxwaGEoKTtcbiAgICBcdFx0X3JlbmRlcmVyLnNldENsZWFyQ29sb3IoIGNsZWFyQ29sb3IsIGNsZWFyQWxwaGEgKTtcblxuICAgIFx0XHRzY29wZS5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG4gICAgXHR9O1xuXG4gICAgXHRmdW5jdGlvbiBnZXREZXB0aE1hdGVyaWFsKCBvYmplY3QsIG1hdGVyaWFsLCBpc1BvaW50TGlnaHQsIGxpZ2h0UG9zaXRpb25Xb3JsZCApIHtcblxuICAgIFx0XHR2YXIgZ2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnk7XG5cbiAgICBcdFx0dmFyIHJlc3VsdCA9IG51bGw7XG5cbiAgICBcdFx0dmFyIG1hdGVyaWFsVmFyaWFudHMgPSBfZGVwdGhNYXRlcmlhbHM7XG4gICAgXHRcdHZhciBjdXN0b21NYXRlcmlhbCA9IG9iamVjdC5jdXN0b21EZXB0aE1hdGVyaWFsO1xuXG4gICAgXHRcdGlmICggaXNQb2ludExpZ2h0ICkge1xuXG4gICAgXHRcdFx0bWF0ZXJpYWxWYXJpYW50cyA9IF9kaXN0YW5jZU1hdGVyaWFscztcbiAgICBcdFx0XHRjdXN0b21NYXRlcmlhbCA9IG9iamVjdC5jdXN0b21EaXN0YW5jZU1hdGVyaWFsO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoICEgY3VzdG9tTWF0ZXJpYWwgKSB7XG5cbiAgICBcdFx0XHR2YXIgdXNlTW9ycGhpbmcgPSBmYWxzZTtcblxuICAgIFx0XHRcdGlmICggbWF0ZXJpYWwubW9ycGhUYXJnZXRzICkge1xuXG4gICAgXHRcdFx0XHRpZiAoIChnZW9tZXRyeSAmJiBnZW9tZXRyeS5pc0J1ZmZlckdlb21ldHJ5KSApIHtcblxuICAgIFx0XHRcdFx0XHR1c2VNb3JwaGluZyA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcyAmJiBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb24gJiYgZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uLmxlbmd0aCA+IDA7XG5cbiAgICBcdFx0XHRcdH0gZWxzZSBpZiAoIChnZW9tZXRyeSAmJiBnZW9tZXRyeS5pc0dlb21ldHJ5KSApIHtcblxuICAgIFx0XHRcdFx0XHR1c2VNb3JwaGluZyA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0cyAmJiBnZW9tZXRyeS5tb3JwaFRhcmdldHMubGVuZ3RoID4gMDtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0dmFyIHVzZVNraW5uaW5nID0gb2JqZWN0LmlzU2tpbm5lZE1lc2ggJiYgbWF0ZXJpYWwuc2tpbm5pbmc7XG5cbiAgICBcdFx0XHR2YXIgdmFyaWFudEluZGV4ID0gMDtcblxuICAgIFx0XHRcdGlmICggdXNlTW9ycGhpbmcgKSB2YXJpYW50SW5kZXggfD0gX01vcnBoaW5nRmxhZztcbiAgICBcdFx0XHRpZiAoIHVzZVNraW5uaW5nICkgdmFyaWFudEluZGV4IHw9IF9Ta2lubmluZ0ZsYWc7XG5cbiAgICBcdFx0XHRyZXN1bHQgPSBtYXRlcmlhbFZhcmlhbnRzWyB2YXJpYW50SW5kZXggXTtcblxuICAgIFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0cmVzdWx0ID0gY3VzdG9tTWF0ZXJpYWw7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGlmICggX3JlbmRlcmVyLmxvY2FsQ2xpcHBpbmdFbmFibGVkICYmXG4gICAgXHRcdFx0IG1hdGVyaWFsLmNsaXBTaGFkb3dzID09PSB0cnVlICYmXG4gICAgXHRcdFx0XHRtYXRlcmlhbC5jbGlwcGluZ1BsYW5lcy5sZW5ndGggIT09IDAgKSB7XG5cbiAgICBcdFx0XHQvLyBpbiB0aGlzIGNhc2Ugd2UgbmVlZCBhIHVuaXF1ZSBtYXRlcmlhbCBpbnN0YW5jZSByZWZsZWN0aW5nIHRoZVxuICAgIFx0XHRcdC8vIGFwcHJvcHJpYXRlIHN0YXRlXG5cbiAgICBcdFx0XHR2YXIga2V5QSA9IHJlc3VsdC51dWlkLCBrZXlCID0gbWF0ZXJpYWwudXVpZDtcblxuICAgIFx0XHRcdHZhciBtYXRlcmlhbHNGb3JWYXJpYW50ID0gX21hdGVyaWFsQ2FjaGVbIGtleUEgXTtcblxuICAgIFx0XHRcdGlmICggbWF0ZXJpYWxzRm9yVmFyaWFudCA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0XHRtYXRlcmlhbHNGb3JWYXJpYW50ID0ge307XG4gICAgXHRcdFx0XHRfbWF0ZXJpYWxDYWNoZVsga2V5QSBdID0gbWF0ZXJpYWxzRm9yVmFyaWFudDtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdHZhciBjYWNoZWRNYXRlcmlhbCA9IG1hdGVyaWFsc0ZvclZhcmlhbnRbIGtleUIgXTtcblxuICAgIFx0XHRcdGlmICggY2FjaGVkTWF0ZXJpYWwgPT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0Y2FjaGVkTWF0ZXJpYWwgPSByZXN1bHQuY2xvbmUoKTtcbiAgICBcdFx0XHRcdG1hdGVyaWFsc0ZvclZhcmlhbnRbIGtleUIgXSA9IGNhY2hlZE1hdGVyaWFsO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0cmVzdWx0ID0gY2FjaGVkTWF0ZXJpYWw7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJlc3VsdC52aXNpYmxlID0gbWF0ZXJpYWwudmlzaWJsZTtcbiAgICBcdFx0cmVzdWx0LndpcmVmcmFtZSA9IG1hdGVyaWFsLndpcmVmcmFtZTtcblxuICAgIFx0XHR2YXIgc2lkZSA9IG1hdGVyaWFsLnNpZGU7XG5cbiAgICBcdFx0aWYgKCBzY29wZS5yZW5kZXJTaW5nbGVTaWRlZCAmJiBzaWRlID09IERvdWJsZVNpZGUgKSB7XG5cbiAgICBcdFx0XHRzaWRlID0gRnJvbnRTaWRlO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoIHNjb3BlLnJlbmRlclJldmVyc2VTaWRlZCApIHtcblxuICAgIFx0XHRcdGlmICggc2lkZSA9PT0gRnJvbnRTaWRlICkgc2lkZSA9IEJhY2tTaWRlO1xuICAgIFx0XHRcdGVsc2UgaWYgKCBzaWRlID09PSBCYWNrU2lkZSApIHNpZGUgPSBGcm9udFNpZGU7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJlc3VsdC5zaWRlID0gc2lkZTtcblxuICAgIFx0XHRyZXN1bHQuY2xpcFNoYWRvd3MgPSBtYXRlcmlhbC5jbGlwU2hhZG93cztcbiAgICBcdFx0cmVzdWx0LmNsaXBwaW5nUGxhbmVzID0gbWF0ZXJpYWwuY2xpcHBpbmdQbGFuZXM7XG5cbiAgICBcdFx0cmVzdWx0LndpcmVmcmFtZUxpbmV3aWR0aCA9IG1hdGVyaWFsLndpcmVmcmFtZUxpbmV3aWR0aDtcbiAgICBcdFx0cmVzdWx0LmxpbmV3aWR0aCA9IG1hdGVyaWFsLmxpbmV3aWR0aDtcblxuICAgIFx0XHRpZiAoIGlzUG9pbnRMaWdodCAmJiByZXN1bHQudW5pZm9ybXMubGlnaHRQb3MgIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdHJlc3VsdC51bmlmb3Jtcy5saWdodFBvcy52YWx1ZS5jb3B5KCBsaWdodFBvc2l0aW9uV29ybGQgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIHJlc3VsdDtcblxuICAgIFx0fVxuXG4gICAgXHRmdW5jdGlvbiBwcm9qZWN0T2JqZWN0KCBvYmplY3QsIGNhbWVyYSwgc2hhZG93Q2FtZXJhICkge1xuXG4gICAgXHRcdGlmICggb2JqZWN0LnZpc2libGUgPT09IGZhbHNlICkgcmV0dXJuO1xuXG4gICAgXHRcdHZhciB2aXNpYmxlID0gKCBvYmplY3QubGF5ZXJzLm1hc2sgJiBjYW1lcmEubGF5ZXJzLm1hc2sgKSAhPT0gMDtcblxuICAgIFx0XHRpZiAoIHZpc2libGUgJiYgKCBvYmplY3QuaXNNZXNoIHx8IG9iamVjdC5pc0xpbmUgfHwgb2JqZWN0LmlzUG9pbnRzICkgKSB7XG5cbiAgICBcdFx0XHRpZiAoIG9iamVjdC5jYXN0U2hhZG93ICYmICggb2JqZWN0LmZydXN0dW1DdWxsZWQgPT09IGZhbHNlIHx8IF9mcnVzdHVtLmludGVyc2VjdHNPYmplY3QoIG9iamVjdCApID09PSB0cnVlICkgKSB7XG5cbiAgICBcdFx0XHRcdHZhciBtYXRlcmlhbCA9IG9iamVjdC5tYXRlcmlhbDtcblxuICAgIFx0XHRcdFx0aWYgKCBtYXRlcmlhbC52aXNpYmxlID09PSB0cnVlICkge1xuXG4gICAgXHRcdFx0XHRcdG9iamVjdC5tb2RlbFZpZXdNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggc2hhZG93Q2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSwgb2JqZWN0Lm1hdHJpeFdvcmxkICk7XG4gICAgXHRcdFx0XHRcdF9yZW5kZXJMaXN0LnB1c2goIG9iamVjdCApO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHZhciBjaGlsZHJlbiA9IG9iamVjdC5jaGlsZHJlbjtcblxuICAgIFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgXHRcdFx0cHJvamVjdE9iamVjdCggY2hpbGRyZW5bIGkgXSwgY2FtZXJhLCBzaGFkb3dDYW1lcmEgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdH1cblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIFJheSggb3JpZ2luLCBkaXJlY3Rpb24gKSB7XG5cbiAgICBcdHRoaXMub3JpZ2luID0gKCBvcmlnaW4gIT09IHVuZGVmaW5lZCApID8gb3JpZ2luIDogbmV3IFZlY3RvcjMoKTtcbiAgICBcdHRoaXMuZGlyZWN0aW9uID0gKCBkaXJlY3Rpb24gIT09IHVuZGVmaW5lZCApID8gZGlyZWN0aW9uIDogbmV3IFZlY3RvcjMoKTtcblxuICAgIH1cblxuICAgIFJheS5wcm90b3R5cGUgPSB7XG5cbiAgICBcdGNvbnN0cnVjdG9yOiBSYXksXG5cbiAgICBcdHNldDogZnVuY3Rpb24gKCBvcmlnaW4sIGRpcmVjdGlvbiApIHtcblxuICAgIFx0XHR0aGlzLm9yaWdpbi5jb3B5KCBvcmlnaW4gKTtcbiAgICBcdFx0dGhpcy5kaXJlY3Rpb24uY29weSggZGlyZWN0aW9uICk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRjb3B5OiBmdW5jdGlvbiAoIHJheSApIHtcblxuICAgIFx0XHR0aGlzLm9yaWdpbi5jb3B5KCByYXkub3JpZ2luICk7XG4gICAgXHRcdHRoaXMuZGlyZWN0aW9uLmNvcHkoIHJheS5kaXJlY3Rpb24gKTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0YXQ6IGZ1bmN0aW9uICggdCwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICBcdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XG5cbiAgICBcdFx0cmV0dXJuIHJlc3VsdC5jb3B5KCB0aGlzLmRpcmVjdGlvbiApLm11bHRpcGx5U2NhbGFyKCB0ICkuYWRkKCB0aGlzLm9yaWdpbiApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRsb29rQXQ6IGZ1bmN0aW9uICggdiApIHtcblxuICAgIFx0XHR0aGlzLmRpcmVjdGlvbi5jb3B5KCB2ICkuc3ViKCB0aGlzLm9yaWdpbiApLm5vcm1hbGl6ZSgpO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRyZWNhc3Q6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR2YXIgdjEgPSBuZXcgVmVjdG9yMygpO1xuXG4gICAgXHRcdHJldHVybiBmdW5jdGlvbiByZWNhc3QoIHQgKSB7XG5cbiAgICBcdFx0XHR0aGlzLm9yaWdpbi5jb3B5KCB0aGlzLmF0KCB0LCB2MSApICk7XG5cbiAgICBcdFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0XHR9O1xuXG4gICAgXHR9KCksXG5cbiAgICBcdGNsb3Nlc3RQb2ludFRvUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgXHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMygpO1xuICAgIFx0XHRyZXN1bHQuc3ViVmVjdG9ycyggcG9pbnQsIHRoaXMub3JpZ2luICk7XG4gICAgXHRcdHZhciBkaXJlY3Rpb25EaXN0YW5jZSA9IHJlc3VsdC5kb3QoIHRoaXMuZGlyZWN0aW9uICk7XG5cbiAgICBcdFx0aWYgKCBkaXJlY3Rpb25EaXN0YW5jZSA8IDAgKSB7XG5cbiAgICBcdFx0XHRyZXR1cm4gcmVzdWx0LmNvcHkoIHRoaXMub3JpZ2luICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiByZXN1bHQuY29weSggdGhpcy5kaXJlY3Rpb24gKS5tdWx0aXBseVNjYWxhciggZGlyZWN0aW9uRGlzdGFuY2UgKS5hZGQoIHRoaXMub3JpZ2luICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGRpc3RhbmNlVG9Qb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcblxuICAgIFx0XHRyZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLmRpc3RhbmNlU3FUb1BvaW50KCBwb2ludCApICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGRpc3RhbmNlU3FUb1BvaW50OiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoKTtcblxuICAgIFx0XHRyZXR1cm4gZnVuY3Rpb24gZGlzdGFuY2VTcVRvUG9pbnQoIHBvaW50ICkge1xuXG4gICAgXHRcdFx0dmFyIGRpcmVjdGlvbkRpc3RhbmNlID0gdjEuc3ViVmVjdG9ycyggcG9pbnQsIHRoaXMub3JpZ2luICkuZG90KCB0aGlzLmRpcmVjdGlvbiApO1xuXG4gICAgXHRcdFx0Ly8gcG9pbnQgYmVoaW5kIHRoZSByYXlcblxuICAgIFx0XHRcdGlmICggZGlyZWN0aW9uRGlzdGFuY2UgPCAwICkge1xuXG4gICAgXHRcdFx0XHRyZXR1cm4gdGhpcy5vcmlnaW4uZGlzdGFuY2VUb1NxdWFyZWQoIHBvaW50ICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHR2MS5jb3B5KCB0aGlzLmRpcmVjdGlvbiApLm11bHRpcGx5U2NhbGFyKCBkaXJlY3Rpb25EaXN0YW5jZSApLmFkZCggdGhpcy5vcmlnaW4gKTtcblxuICAgIFx0XHRcdHJldHVybiB2MS5kaXN0YW5jZVRvU3F1YXJlZCggcG9pbnQgKTtcblxuICAgIFx0XHR9O1xuXG4gICAgXHR9KCksXG5cbiAgICBcdGRpc3RhbmNlU3FUb1NlZ21lbnQ6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR2YXIgc2VnQ2VudGVyID0gbmV3IFZlY3RvcjMoKTtcbiAgICBcdFx0dmFyIHNlZ0RpciA9IG5ldyBWZWN0b3IzKCk7XG4gICAgXHRcdHZhciBkaWZmID0gbmV3IFZlY3RvcjMoKTtcblxuICAgIFx0XHRyZXR1cm4gZnVuY3Rpb24gZGlzdGFuY2VTcVRvU2VnbWVudCggdjAsIHYxLCBvcHRpb25hbFBvaW50T25SYXksIG9wdGlvbmFsUG9pbnRPblNlZ21lbnQgKSB7XG5cbiAgICBcdFx0XHQvLyBmcm9tIGh0dHA6Ly93d3cuZ2VvbWV0cmljdG9vbHMuY29tL0dURW5naW5lL0luY2x1ZGUvTWF0aGVtYXRpY3MvR3RlRGlzdFJheVNlZ21lbnQuaFxuICAgIFx0XHRcdC8vIEl0IHJldHVybnMgdGhlIG1pbiBkaXN0YW5jZSBiZXR3ZWVuIHRoZSByYXkgYW5kIHRoZSBzZWdtZW50XG4gICAgXHRcdFx0Ly8gZGVmaW5lZCBieSB2MCBhbmQgdjFcbiAgICBcdFx0XHQvLyBJdCBjYW4gYWxzbyBzZXQgdHdvIG9wdGlvbmFsIHRhcmdldHMgOlxuICAgIFx0XHRcdC8vIC0gVGhlIGNsb3Nlc3QgcG9pbnQgb24gdGhlIHJheVxuICAgIFx0XHRcdC8vIC0gVGhlIGNsb3Nlc3QgcG9pbnQgb24gdGhlIHNlZ21lbnRcblxuICAgIFx0XHRcdHNlZ0NlbnRlci5jb3B5KCB2MCApLmFkZCggdjEgKS5tdWx0aXBseVNjYWxhciggMC41ICk7XG4gICAgXHRcdFx0c2VnRGlyLmNvcHkoIHYxICkuc3ViKCB2MCApLm5vcm1hbGl6ZSgpO1xuICAgIFx0XHRcdGRpZmYuY29weSggdGhpcy5vcmlnaW4gKS5zdWIoIHNlZ0NlbnRlciApO1xuXG4gICAgXHRcdFx0dmFyIHNlZ0V4dGVudCA9IHYwLmRpc3RhbmNlVG8oIHYxICkgKiAwLjU7XG4gICAgXHRcdFx0dmFyIGEwMSA9IC0gdGhpcy5kaXJlY3Rpb24uZG90KCBzZWdEaXIgKTtcbiAgICBcdFx0XHR2YXIgYjAgPSBkaWZmLmRvdCggdGhpcy5kaXJlY3Rpb24gKTtcbiAgICBcdFx0XHR2YXIgYjEgPSAtIGRpZmYuZG90KCBzZWdEaXIgKTtcbiAgICBcdFx0XHR2YXIgYyA9IGRpZmYubGVuZ3RoU3EoKTtcbiAgICBcdFx0XHR2YXIgZGV0ID0gTWF0aC5hYnMoIDEgLSBhMDEgKiBhMDEgKTtcbiAgICBcdFx0XHR2YXIgczAsIHMxLCBzcXJEaXN0LCBleHREZXQ7XG5cbiAgICBcdFx0XHRpZiAoIGRldCA+IDAgKSB7XG5cbiAgICBcdFx0XHRcdC8vIFRoZSByYXkgYW5kIHNlZ21lbnQgYXJlIG5vdCBwYXJhbGxlbC5cblxuICAgIFx0XHRcdFx0czAgPSBhMDEgKiBiMSAtIGIwO1xuICAgIFx0XHRcdFx0czEgPSBhMDEgKiBiMCAtIGIxO1xuICAgIFx0XHRcdFx0ZXh0RGV0ID0gc2VnRXh0ZW50ICogZGV0O1xuXG4gICAgXHRcdFx0XHRpZiAoIHMwID49IDAgKSB7XG5cbiAgICBcdFx0XHRcdFx0aWYgKCBzMSA+PSAtIGV4dERldCApIHtcblxuICAgIFx0XHRcdFx0XHRcdGlmICggczEgPD0gZXh0RGV0ICkge1xuXG4gICAgXHRcdFx0XHRcdFx0XHQvLyByZWdpb24gMFxuICAgIFx0XHRcdFx0XHRcdFx0Ly8gTWluaW11bSBhdCBpbnRlcmlvciBwb2ludHMgb2YgcmF5IGFuZCBzZWdtZW50LlxuXG4gICAgXHRcdFx0XHRcdFx0XHR2YXIgaW52RGV0ID0gMSAvIGRldDtcbiAgICBcdFx0XHRcdFx0XHRcdHMwICo9IGludkRldDtcbiAgICBcdFx0XHRcdFx0XHRcdHMxICo9IGludkRldDtcbiAgICBcdFx0XHRcdFx0XHRcdHNxckRpc3QgPSBzMCAqICggczAgKyBhMDEgKiBzMSArIDIgKiBiMCApICsgczEgKiAoIGEwMSAqIHMwICsgczEgKyAyICogYjEgKSArIGM7XG5cbiAgICBcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRcdFx0XHQvLyByZWdpb24gMVxuXG4gICAgXHRcdFx0XHRcdFx0XHRzMSA9IHNlZ0V4dGVudDtcbiAgICBcdFx0XHRcdFx0XHRcdHMwID0gTWF0aC5tYXgoIDAsIC0gKCBhMDEgKiBzMSArIGIwICkgKTtcbiAgICBcdFx0XHRcdFx0XHRcdHNxckRpc3QgPSAtIHMwICogczAgKyBzMSAqICggczEgKyAyICogYjEgKSArIGM7XG5cbiAgICBcdFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0XHRcdC8vIHJlZ2lvbiA1XG5cbiAgICBcdFx0XHRcdFx0XHRzMSA9IC0gc2VnRXh0ZW50O1xuICAgIFx0XHRcdFx0XHRcdHMwID0gTWF0aC5tYXgoIDAsIC0gKCBhMDEgKiBzMSArIGIwICkgKTtcbiAgICBcdFx0XHRcdFx0XHRzcXJEaXN0ID0gLSBzMCAqIHMwICsgczEgKiAoIHMxICsgMiAqIGIxICkgKyBjO1xuXG4gICAgXHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0XHRpZiAoIHMxIDw9IC0gZXh0RGV0ICkge1xuXG4gICAgXHRcdFx0XHRcdFx0Ly8gcmVnaW9uIDRcblxuICAgIFx0XHRcdFx0XHRcdHMwID0gTWF0aC5tYXgoIDAsIC0gKCAtIGEwMSAqIHNlZ0V4dGVudCArIGIwICkgKTtcbiAgICBcdFx0XHRcdFx0XHRzMSA9ICggczAgPiAwICkgPyAtIHNlZ0V4dGVudCA6IE1hdGgubWluKCBNYXRoLm1heCggLSBzZWdFeHRlbnQsIC0gYjEgKSwgc2VnRXh0ZW50ICk7XG4gICAgXHRcdFx0XHRcdFx0c3FyRGlzdCA9IC0gczAgKiBzMCArIHMxICogKCBzMSArIDIgKiBiMSApICsgYztcblxuICAgIFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBzMSA8PSBleHREZXQgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHQvLyByZWdpb24gM1xuXG4gICAgXHRcdFx0XHRcdFx0czAgPSAwO1xuICAgIFx0XHRcdFx0XHRcdHMxID0gTWF0aC5taW4oIE1hdGgubWF4KCAtIHNlZ0V4dGVudCwgLSBiMSApLCBzZWdFeHRlbnQgKTtcbiAgICBcdFx0XHRcdFx0XHRzcXJEaXN0ID0gczEgKiAoIHMxICsgMiAqIGIxICkgKyBjO1xuXG4gICAgXHRcdFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdFx0XHQvLyByZWdpb24gMlxuXG4gICAgXHRcdFx0XHRcdFx0czAgPSBNYXRoLm1heCggMCwgLSAoIGEwMSAqIHNlZ0V4dGVudCArIGIwICkgKTtcbiAgICBcdFx0XHRcdFx0XHRzMSA9ICggczAgPiAwICkgPyBzZWdFeHRlbnQgOiBNYXRoLm1pbiggTWF0aC5tYXgoIC0gc2VnRXh0ZW50LCAtIGIxICksIHNlZ0V4dGVudCApO1xuICAgIFx0XHRcdFx0XHRcdHNxckRpc3QgPSAtIHMwICogczAgKyBzMSAqICggczEgKyAyICogYjEgKSArIGM7XG5cbiAgICBcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHQvLyBSYXkgYW5kIHNlZ21lbnQgYXJlIHBhcmFsbGVsLlxuXG4gICAgXHRcdFx0XHRzMSA9ICggYTAxID4gMCApID8gLSBzZWdFeHRlbnQgOiBzZWdFeHRlbnQ7XG4gICAgXHRcdFx0XHRzMCA9IE1hdGgubWF4KCAwLCAtICggYTAxICogczEgKyBiMCApICk7XG4gICAgXHRcdFx0XHRzcXJEaXN0ID0gLSBzMCAqIHMwICsgczEgKiAoIHMxICsgMiAqIGIxICkgKyBjO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0aWYgKCBvcHRpb25hbFBvaW50T25SYXkgKSB7XG5cbiAgICBcdFx0XHRcdG9wdGlvbmFsUG9pbnRPblJheS5jb3B5KCB0aGlzLmRpcmVjdGlvbiApLm11bHRpcGx5U2NhbGFyKCBzMCApLmFkZCggdGhpcy5vcmlnaW4gKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGlmICggb3B0aW9uYWxQb2ludE9uU2VnbWVudCApIHtcblxuICAgIFx0XHRcdFx0b3B0aW9uYWxQb2ludE9uU2VnbWVudC5jb3B5KCBzZWdEaXIgKS5tdWx0aXBseVNjYWxhciggczEgKS5hZGQoIHNlZ0NlbnRlciApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0cmV0dXJuIHNxckRpc3Q7XG5cbiAgICBcdFx0fTtcblxuICAgIFx0fSgpLFxuXG4gICAgXHRpbnRlcnNlY3RTcGhlcmU6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR2YXIgdjEgPSBuZXcgVmVjdG9yMygpO1xuXG4gICAgXHRcdHJldHVybiBmdW5jdGlvbiBpbnRlcnNlY3RTcGhlcmUoIHNwaGVyZSwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICBcdFx0XHR2MS5zdWJWZWN0b3JzKCBzcGhlcmUuY2VudGVyLCB0aGlzLm9yaWdpbiApO1xuICAgIFx0XHRcdHZhciB0Y2EgPSB2MS5kb3QoIHRoaXMuZGlyZWN0aW9uICk7XG4gICAgXHRcdFx0dmFyIGQyID0gdjEuZG90KCB2MSApIC0gdGNhICogdGNhO1xuICAgIFx0XHRcdHZhciByYWRpdXMyID0gc3BoZXJlLnJhZGl1cyAqIHNwaGVyZS5yYWRpdXM7XG5cbiAgICBcdFx0XHRpZiAoIGQyID4gcmFkaXVzMiApIHJldHVybiBudWxsO1xuXG4gICAgXHRcdFx0dmFyIHRoYyA9IE1hdGguc3FydCggcmFkaXVzMiAtIGQyICk7XG5cbiAgICBcdFx0XHQvLyB0MCA9IGZpcnN0IGludGVyc2VjdCBwb2ludCAtIGVudHJhbmNlIG9uIGZyb250IG9mIHNwaGVyZVxuICAgIFx0XHRcdHZhciB0MCA9IHRjYSAtIHRoYztcblxuICAgIFx0XHRcdC8vIHQxID0gc2Vjb25kIGludGVyc2VjdCBwb2ludCAtIGV4aXQgcG9pbnQgb24gYmFjayBvZiBzcGhlcmVcbiAgICBcdFx0XHR2YXIgdDEgPSB0Y2EgKyB0aGM7XG5cbiAgICBcdFx0XHQvLyB0ZXN0IHRvIHNlZSBpZiBib3RoIHQwIGFuZCB0MSBhcmUgYmVoaW5kIHRoZSByYXkgLSBpZiBzbywgcmV0dXJuIG51bGxcbiAgICBcdFx0XHRpZiAoIHQwIDwgMCAmJiB0MSA8IDAgKSByZXR1cm4gbnVsbDtcblxuICAgIFx0XHRcdC8vIHRlc3QgdG8gc2VlIGlmIHQwIGlzIGJlaGluZCB0aGUgcmF5OlxuICAgIFx0XHRcdC8vIGlmIGl0IGlzLCB0aGUgcmF5IGlzIGluc2lkZSB0aGUgc3BoZXJlLCBzbyByZXR1cm4gdGhlIHNlY29uZCBleGl0IHBvaW50IHNjYWxlZCBieSB0MSxcbiAgICBcdFx0XHQvLyBpbiBvcmRlciB0byBhbHdheXMgcmV0dXJuIGFuIGludGVyc2VjdCBwb2ludCB0aGF0IGlzIGluIGZyb250IG9mIHRoZSByYXkuXG4gICAgXHRcdFx0aWYgKCB0MCA8IDAgKSByZXR1cm4gdGhpcy5hdCggdDEsIG9wdGlvbmFsVGFyZ2V0ICk7XG5cbiAgICBcdFx0XHQvLyBlbHNlIHQwIGlzIGluIGZyb250IG9mIHRoZSByYXksIHNvIHJldHVybiB0aGUgZmlyc3QgY29sbGlzaW9uIHBvaW50IHNjYWxlZCBieSB0MFxuICAgIFx0XHRcdHJldHVybiB0aGlzLmF0KCB0MCwgb3B0aW9uYWxUYXJnZXQgKTtcblxuICAgIFx0XHR9O1xuXG4gICAgXHR9KCksXG5cbiAgICBcdGludGVyc2VjdHNTcGhlcmU6IGZ1bmN0aW9uICggc3BoZXJlICkge1xuXG4gICAgXHRcdHJldHVybiB0aGlzLmRpc3RhbmNlVG9Qb2ludCggc3BoZXJlLmNlbnRlciApIDw9IHNwaGVyZS5yYWRpdXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGRpc3RhbmNlVG9QbGFuZTogZnVuY3Rpb24gKCBwbGFuZSApIHtcblxuICAgIFx0XHR2YXIgZGVub21pbmF0b3IgPSBwbGFuZS5ub3JtYWwuZG90KCB0aGlzLmRpcmVjdGlvbiApO1xuXG4gICAgXHRcdGlmICggZGVub21pbmF0b3IgPT09IDAgKSB7XG5cbiAgICBcdFx0XHQvLyBsaW5lIGlzIGNvcGxhbmFyLCByZXR1cm4gb3JpZ2luXG4gICAgXHRcdFx0aWYgKCBwbGFuZS5kaXN0YW5jZVRvUG9pbnQoIHRoaXMub3JpZ2luICkgPT09IDAgKSB7XG5cbiAgICBcdFx0XHRcdHJldHVybiAwO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0Ly8gTnVsbCBpcyBwcmVmZXJhYmxlIHRvIHVuZGVmaW5lZCBzaW5jZSB1bmRlZmluZWQgbWVhbnMuLi4uIGl0IGlzIHVuZGVmaW5lZFxuXG4gICAgXHRcdFx0cmV0dXJuIG51bGw7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHZhciB0ID0gLSAoIHRoaXMub3JpZ2luLmRvdCggcGxhbmUubm9ybWFsICkgKyBwbGFuZS5jb25zdGFudCApIC8gZGVub21pbmF0b3I7XG5cbiAgICBcdFx0Ly8gUmV0dXJuIGlmIHRoZSByYXkgbmV2ZXIgaW50ZXJzZWN0cyB0aGUgcGxhbmVcblxuICAgIFx0XHRyZXR1cm4gdCA+PSAwID8gdCA6ICBudWxsO1xuXG4gICAgXHR9LFxuXG4gICAgXHRpbnRlcnNlY3RQbGFuZTogZnVuY3Rpb24gKCBwbGFuZSwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICBcdFx0dmFyIHQgPSB0aGlzLmRpc3RhbmNlVG9QbGFuZSggcGxhbmUgKTtcblxuICAgIFx0XHRpZiAoIHQgPT09IG51bGwgKSB7XG5cbiAgICBcdFx0XHRyZXR1cm4gbnVsbDtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMuYXQoIHQsIG9wdGlvbmFsVGFyZ2V0ICk7XG5cbiAgICBcdH0sXG5cblxuXG4gICAgXHRpbnRlcnNlY3RzUGxhbmU6IGZ1bmN0aW9uICggcGxhbmUgKSB7XG5cbiAgICBcdFx0Ly8gY2hlY2sgaWYgdGhlIHJheSBsaWVzIG9uIHRoZSBwbGFuZSBmaXJzdFxuXG4gICAgXHRcdHZhciBkaXN0VG9Qb2ludCA9IHBsYW5lLmRpc3RhbmNlVG9Qb2ludCggdGhpcy5vcmlnaW4gKTtcblxuICAgIFx0XHRpZiAoIGRpc3RUb1BvaW50ID09PSAwICkge1xuXG4gICAgXHRcdFx0cmV0dXJuIHRydWU7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHZhciBkZW5vbWluYXRvciA9IHBsYW5lLm5vcm1hbC5kb3QoIHRoaXMuZGlyZWN0aW9uICk7XG5cbiAgICBcdFx0aWYgKCBkZW5vbWluYXRvciAqIGRpc3RUb1BvaW50IDwgMCApIHtcblxuICAgIFx0XHRcdHJldHVybiB0cnVlO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHQvLyByYXkgb3JpZ2luIGlzIGJlaGluZCB0aGUgcGxhbmUgKGFuZCBpcyBwb2ludGluZyBiZWhpbmQgaXQpXG5cbiAgICBcdFx0cmV0dXJuIGZhbHNlO1xuXG4gICAgXHR9LFxuXG4gICAgXHRpbnRlcnNlY3RCb3g6IGZ1bmN0aW9uICggYm94LCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgIFx0XHR2YXIgdG1pbiwgdG1heCwgdHltaW4sIHR5bWF4LCB0em1pbiwgdHptYXg7XG5cbiAgICBcdFx0dmFyIGludmRpcnggPSAxIC8gdGhpcy5kaXJlY3Rpb24ueCxcbiAgICBcdFx0XHRpbnZkaXJ5ID0gMSAvIHRoaXMuZGlyZWN0aW9uLnksXG4gICAgXHRcdFx0aW52ZGlyeiA9IDEgLyB0aGlzLmRpcmVjdGlvbi56O1xuXG4gICAgXHRcdHZhciBvcmlnaW4gPSB0aGlzLm9yaWdpbjtcblxuICAgIFx0XHRpZiAoIGludmRpcnggPj0gMCApIHtcblxuICAgIFx0XHRcdHRtaW4gPSAoIGJveC5taW4ueCAtIG9yaWdpbi54ICkgKiBpbnZkaXJ4O1xuICAgIFx0XHRcdHRtYXggPSAoIGJveC5tYXgueCAtIG9yaWdpbi54ICkgKiBpbnZkaXJ4O1xuXG4gICAgXHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHR0bWluID0gKCBib3gubWF4LnggLSBvcmlnaW4ueCApICogaW52ZGlyeDtcbiAgICBcdFx0XHR0bWF4ID0gKCBib3gubWluLnggLSBvcmlnaW4ueCApICogaW52ZGlyeDtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKCBpbnZkaXJ5ID49IDAgKSB7XG5cbiAgICBcdFx0XHR0eW1pbiA9ICggYm94Lm1pbi55IC0gb3JpZ2luLnkgKSAqIGludmRpcnk7XG4gICAgXHRcdFx0dHltYXggPSAoIGJveC5tYXgueSAtIG9yaWdpbi55ICkgKiBpbnZkaXJ5O1xuXG4gICAgXHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHR0eW1pbiA9ICggYm94Lm1heC55IC0gb3JpZ2luLnkgKSAqIGludmRpcnk7XG4gICAgXHRcdFx0dHltYXggPSAoIGJveC5taW4ueSAtIG9yaWdpbi55ICkgKiBpbnZkaXJ5O1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoICggdG1pbiA+IHR5bWF4ICkgfHwgKCB0eW1pbiA+IHRtYXggKSApIHJldHVybiBudWxsO1xuXG4gICAgXHRcdC8vIFRoZXNlIGxpbmVzIGFsc28gaGFuZGxlIHRoZSBjYXNlIHdoZXJlIHRtaW4gb3IgdG1heCBpcyBOYU5cbiAgICBcdFx0Ly8gKHJlc3VsdCBvZiAwICogSW5maW5pdHkpLiB4ICE9PSB4IHJldHVybnMgdHJ1ZSBpZiB4IGlzIE5hTlxuXG4gICAgXHRcdGlmICggdHltaW4gPiB0bWluIHx8IHRtaW4gIT09IHRtaW4gKSB0bWluID0gdHltaW47XG5cbiAgICBcdFx0aWYgKCB0eW1heCA8IHRtYXggfHwgdG1heCAhPT0gdG1heCApIHRtYXggPSB0eW1heDtcblxuICAgIFx0XHRpZiAoIGludmRpcnogPj0gMCApIHtcblxuICAgIFx0XHRcdHR6bWluID0gKCBib3gubWluLnogLSBvcmlnaW4ueiApICogaW52ZGlyejtcbiAgICBcdFx0XHR0em1heCA9ICggYm94Lm1heC56IC0gb3JpZ2luLnogKSAqIGludmRpcno7XG5cbiAgICBcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdHR6bWluID0gKCBib3gubWF4LnogLSBvcmlnaW4ueiApICogaW52ZGlyejtcbiAgICBcdFx0XHR0em1heCA9ICggYm94Lm1pbi56IC0gb3JpZ2luLnogKSAqIGludmRpcno7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGlmICggKCB0bWluID4gdHptYXggKSB8fCAoIHR6bWluID4gdG1heCApICkgcmV0dXJuIG51bGw7XG5cbiAgICBcdFx0aWYgKCB0em1pbiA+IHRtaW4gfHwgdG1pbiAhPT0gdG1pbiApIHRtaW4gPSB0em1pbjtcblxuICAgIFx0XHRpZiAoIHR6bWF4IDwgdG1heCB8fCB0bWF4ICE9PSB0bWF4ICkgdG1heCA9IHR6bWF4O1xuXG4gICAgXHRcdC8vcmV0dXJuIHBvaW50IGNsb3Nlc3QgdG8gdGhlIHJheSAocG9zaXRpdmUgc2lkZSlcblxuICAgIFx0XHRpZiAoIHRtYXggPCAwICkgcmV0dXJuIG51bGw7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMuYXQoIHRtaW4gPj0gMCA/IHRtaW4gOiB0bWF4LCBvcHRpb25hbFRhcmdldCApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRpbnRlcnNlY3RzQm94OiAoIGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR2YXIgdiA9IG5ldyBWZWN0b3IzKCk7XG5cbiAgICBcdFx0cmV0dXJuIGZ1bmN0aW9uIGludGVyc2VjdHNCb3goIGJveCApIHtcblxuICAgIFx0XHRcdHJldHVybiB0aGlzLmludGVyc2VjdEJveCggYm94LCB2ICkgIT09IG51bGw7XG5cbiAgICBcdFx0fTtcblxuICAgIFx0fSApKCksXG5cbiAgICBcdGludGVyc2VjdFRyaWFuZ2xlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0Ly8gQ29tcHV0ZSB0aGUgb2Zmc2V0IG9yaWdpbiwgZWRnZXMsIGFuZCBub3JtYWwuXG4gICAgXHRcdHZhciBkaWZmID0gbmV3IFZlY3RvcjMoKTtcbiAgICBcdFx0dmFyIGVkZ2UxID0gbmV3IFZlY3RvcjMoKTtcbiAgICBcdFx0dmFyIGVkZ2UyID0gbmV3IFZlY3RvcjMoKTtcbiAgICBcdFx0dmFyIG5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XG5cbiAgICBcdFx0cmV0dXJuIGZ1bmN0aW9uIGludGVyc2VjdFRyaWFuZ2xlKCBhLCBiLCBjLCBiYWNrZmFjZUN1bGxpbmcsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgXHRcdFx0Ly8gZnJvbSBodHRwOi8vd3d3Lmdlb21ldHJpY3Rvb2xzLmNvbS9HVEVuZ2luZS9JbmNsdWRlL01hdGhlbWF0aWNzL0d0ZUludHJSYXkzVHJpYW5nbGUzLmhcblxuICAgIFx0XHRcdGVkZ2UxLnN1YlZlY3RvcnMoIGIsIGEgKTtcbiAgICBcdFx0XHRlZGdlMi5zdWJWZWN0b3JzKCBjLCBhICk7XG4gICAgXHRcdFx0bm9ybWFsLmNyb3NzVmVjdG9ycyggZWRnZTEsIGVkZ2UyICk7XG5cbiAgICBcdFx0XHQvLyBTb2x2ZSBRICsgdCpEID0gYjEqRTEgKyBiMipFMiAoUSA9IGtEaWZmLCBEID0gcmF5IGRpcmVjdGlvbixcbiAgICBcdFx0XHQvLyBFMSA9IGtFZGdlMSwgRTIgPSBrRWRnZTIsIE4gPSBDcm9zcyhFMSxFMikpIGJ5XG4gICAgXHRcdFx0Ly8gICB8RG90KEQsTil8KmIxID0gc2lnbihEb3QoRCxOKSkqRG90KEQsQ3Jvc3MoUSxFMikpXG4gICAgXHRcdFx0Ly8gICB8RG90KEQsTil8KmIyID0gc2lnbihEb3QoRCxOKSkqRG90KEQsQ3Jvc3MoRTEsUSkpXG4gICAgXHRcdFx0Ly8gICB8RG90KEQsTil8KnQgPSAtc2lnbihEb3QoRCxOKSkqRG90KFEsTilcbiAgICBcdFx0XHR2YXIgRGROID0gdGhpcy5kaXJlY3Rpb24uZG90KCBub3JtYWwgKTtcbiAgICBcdFx0XHR2YXIgc2lnbjtcblxuICAgIFx0XHRcdGlmICggRGROID4gMCApIHtcblxuICAgIFx0XHRcdFx0aWYgKCBiYWNrZmFjZUN1bGxpbmcgKSByZXR1cm4gbnVsbDtcbiAgICBcdFx0XHRcdHNpZ24gPSAxO1xuXG4gICAgXHRcdFx0fSBlbHNlIGlmICggRGROIDwgMCApIHtcblxuICAgIFx0XHRcdFx0c2lnbiA9IC0gMTtcbiAgICBcdFx0XHRcdERkTiA9IC0gRGROO1xuXG4gICAgXHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRkaWZmLnN1YlZlY3RvcnMoIHRoaXMub3JpZ2luLCBhICk7XG4gICAgXHRcdFx0dmFyIERkUXhFMiA9IHNpZ24gKiB0aGlzLmRpcmVjdGlvbi5kb3QoIGVkZ2UyLmNyb3NzVmVjdG9ycyggZGlmZiwgZWRnZTIgKSApO1xuXG4gICAgXHRcdFx0Ly8gYjEgPCAwLCBubyBpbnRlcnNlY3Rpb25cbiAgICBcdFx0XHRpZiAoIERkUXhFMiA8IDAgKSB7XG5cbiAgICBcdFx0XHRcdHJldHVybiBudWxsO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0dmFyIERkRTF4USA9IHNpZ24gKiB0aGlzLmRpcmVjdGlvbi5kb3QoIGVkZ2UxLmNyb3NzKCBkaWZmICkgKTtcblxuICAgIFx0XHRcdC8vIGIyIDwgMCwgbm8gaW50ZXJzZWN0aW9uXG4gICAgXHRcdFx0aWYgKCBEZEUxeFEgPCAwICkge1xuXG4gICAgXHRcdFx0XHRyZXR1cm4gbnVsbDtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdC8vIGIxK2IyID4gMSwgbm8gaW50ZXJzZWN0aW9uXG4gICAgXHRcdFx0aWYgKCBEZFF4RTIgKyBEZEUxeFEgPiBEZE4gKSB7XG5cbiAgICBcdFx0XHRcdHJldHVybiBudWxsO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0Ly8gTGluZSBpbnRlcnNlY3RzIHRyaWFuZ2xlLCBjaGVjayBpZiByYXkgZG9lcy5cbiAgICBcdFx0XHR2YXIgUWROID0gLSBzaWduICogZGlmZi5kb3QoIG5vcm1hbCApO1xuXG4gICAgXHRcdFx0Ly8gdCA8IDAsIG5vIGludGVyc2VjdGlvblxuICAgIFx0XHRcdGlmICggUWROIDwgMCApIHtcblxuICAgIFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHQvLyBSYXkgaW50ZXJzZWN0cyB0cmlhbmdsZS5cbiAgICBcdFx0XHRyZXR1cm4gdGhpcy5hdCggUWROIC8gRGROLCBvcHRpb25hbFRhcmdldCApO1xuXG4gICAgXHRcdH07XG5cbiAgICBcdH0oKSxcblxuICAgIFx0YXBwbHlNYXRyaXg0OiBmdW5jdGlvbiAoIG1hdHJpeDQgKSB7XG5cbiAgICBcdFx0dGhpcy5kaXJlY3Rpb24uYWRkKCB0aGlzLm9yaWdpbiApLmFwcGx5TWF0cml4NCggbWF0cml4NCApO1xuICAgIFx0XHR0aGlzLm9yaWdpbi5hcHBseU1hdHJpeDQoIG1hdHJpeDQgKTtcbiAgICBcdFx0dGhpcy5kaXJlY3Rpb24uc3ViKCB0aGlzLm9yaWdpbiApO1xuICAgIFx0XHR0aGlzLmRpcmVjdGlvbi5ub3JtYWxpemUoKTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0ZXF1YWxzOiBmdW5jdGlvbiAoIHJheSApIHtcblxuICAgIFx0XHRyZXR1cm4gcmF5Lm9yaWdpbi5lcXVhbHMoIHRoaXMub3JpZ2luICkgJiYgcmF5LmRpcmVjdGlvbi5lcXVhbHMoIHRoaXMuZGlyZWN0aW9uICk7XG5cbiAgICBcdH1cblxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICAgICAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuICAgICAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIEV1bGVyKCB4LCB5LCB6LCBvcmRlciApIHtcblxuICAgIFx0dGhpcy5feCA9IHggfHwgMDtcbiAgICBcdHRoaXMuX3kgPSB5IHx8IDA7XG4gICAgXHR0aGlzLl96ID0geiB8fCAwO1xuICAgIFx0dGhpcy5fb3JkZXIgPSBvcmRlciB8fCBFdWxlci5EZWZhdWx0T3JkZXI7XG5cbiAgICB9XG5cbiAgICBFdWxlci5Sb3RhdGlvbk9yZGVycyA9IFsgJ1hZWicsICdZWlgnLCAnWlhZJywgJ1haWScsICdZWFonLCAnWllYJyBdO1xuXG4gICAgRXVsZXIuRGVmYXVsdE9yZGVyID0gJ1hZWic7XG5cbiAgICBFdWxlci5wcm90b3R5cGUgPSB7XG5cbiAgICBcdGNvbnN0cnVjdG9yOiBFdWxlcixcblxuICAgIFx0aXNFdWxlcjogdHJ1ZSxcblxuICAgIFx0Z2V0IHggKCkge1xuXG4gICAgXHRcdHJldHVybiB0aGlzLl94O1xuXG4gICAgXHR9LFxuXG4gICAgXHRzZXQgeCAoIHZhbHVlICkge1xuXG4gICAgXHRcdHRoaXMuX3ggPSB2YWx1ZTtcbiAgICBcdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGdldCB5ICgpIHtcblxuICAgIFx0XHRyZXR1cm4gdGhpcy5feTtcblxuICAgIFx0fSxcblxuICAgIFx0c2V0IHkgKCB2YWx1ZSApIHtcblxuICAgIFx0XHR0aGlzLl95ID0gdmFsdWU7XG4gICAgXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG4gICAgXHR9LFxuXG4gICAgXHRnZXQgeiAoKSB7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMuX3o7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldCB6ICggdmFsdWUgKSB7XG5cbiAgICBcdFx0dGhpcy5feiA9IHZhbHVlO1xuICAgIFx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuICAgIFx0fSxcblxuICAgIFx0Z2V0IG9yZGVyICgpIHtcblxuICAgIFx0XHRyZXR1cm4gdGhpcy5fb3JkZXI7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldCBvcmRlciAoIHZhbHVlICkge1xuXG4gICAgXHRcdHRoaXMuX29yZGVyID0gdmFsdWU7XG4gICAgXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzZXQ6IGZ1bmN0aW9uICggeCwgeSwgeiwgb3JkZXIgKSB7XG5cbiAgICBcdFx0dGhpcy5feCA9IHg7XG4gICAgXHRcdHRoaXMuX3kgPSB5O1xuICAgIFx0XHR0aGlzLl96ID0gejtcbiAgICBcdFx0dGhpcy5fb3JkZXIgPSBvcmRlciB8fCB0aGlzLl9vcmRlcjtcblxuICAgIFx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMuX3gsIHRoaXMuX3ksIHRoaXMuX3osIHRoaXMuX29yZGVyICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGNvcHk6IGZ1bmN0aW9uICggZXVsZXIgKSB7XG5cbiAgICBcdFx0dGhpcy5feCA9IGV1bGVyLl94O1xuICAgIFx0XHR0aGlzLl95ID0gZXVsZXIuX3k7XG4gICAgXHRcdHRoaXMuX3ogPSBldWxlci5fejtcbiAgICBcdFx0dGhpcy5fb3JkZXIgPSBldWxlci5fb3JkZXI7XG5cbiAgICBcdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldEZyb21Sb3RhdGlvbk1hdHJpeDogZnVuY3Rpb24gKCBtLCBvcmRlciwgdXBkYXRlICkge1xuXG4gICAgXHRcdHZhciBjbGFtcCA9IGV4cG9ydHMuTWF0aC5jbGFtcDtcblxuICAgIFx0XHQvLyBhc3N1bWVzIHRoZSB1cHBlciAzeDMgb2YgbSBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUsIHVuc2NhbGVkKVxuXG4gICAgXHRcdHZhciB0ZSA9IG0uZWxlbWVudHM7XG4gICAgXHRcdHZhciBtMTEgPSB0ZVsgMCBdLCBtMTIgPSB0ZVsgNCBdLCBtMTMgPSB0ZVsgOCBdO1xuICAgIFx0XHR2YXIgbTIxID0gdGVbIDEgXSwgbTIyID0gdGVbIDUgXSwgbTIzID0gdGVbIDkgXTtcbiAgICBcdFx0dmFyIG0zMSA9IHRlWyAyIF0sIG0zMiA9IHRlWyA2IF0sIG0zMyA9IHRlWyAxMCBdO1xuXG4gICAgXHRcdG9yZGVyID0gb3JkZXIgfHwgdGhpcy5fb3JkZXI7XG5cbiAgICBcdFx0aWYgKCBvcmRlciA9PT0gJ1hZWicgKSB7XG5cbiAgICBcdFx0XHR0aGlzLl95ID0gTWF0aC5hc2luKCBjbGFtcCggbTEzLCAtIDEsIDEgKSApO1xuXG4gICAgXHRcdFx0aWYgKCBNYXRoLmFicyggbTEzICkgPCAwLjk5OTk5ICkge1xuXG4gICAgXHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hdGFuMiggLSBtMjMsIG0zMyApO1xuICAgIFx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXRhbjIoIC0gbTEyLCBtMTEgKTtcblxuICAgIFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdHRoaXMuX3ggPSBNYXRoLmF0YW4yKCBtMzIsIG0yMiApO1xuICAgIFx0XHRcdFx0dGhpcy5feiA9IDA7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdZWFonICkge1xuXG4gICAgXHRcdFx0dGhpcy5feCA9IE1hdGguYXNpbiggLSBjbGFtcCggbTIzLCAtIDEsIDEgKSApO1xuXG4gICAgXHRcdFx0aWYgKCBNYXRoLmFicyggbTIzICkgPCAwLjk5OTk5ICkge1xuXG4gICAgXHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hdGFuMiggbTEzLCBtMzMgKTtcbiAgICBcdFx0XHRcdHRoaXMuX3ogPSBNYXRoLmF0YW4yKCBtMjEsIG0yMiApO1xuXG4gICAgXHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIoIC0gbTMxLCBtMTEgKTtcbiAgICBcdFx0XHRcdHRoaXMuX3ogPSAwO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWlhZJyApIHtcblxuICAgIFx0XHRcdHRoaXMuX3ggPSBNYXRoLmFzaW4oIGNsYW1wKCBtMzIsIC0gMSwgMSApICk7XG5cbiAgICBcdFx0XHRpZiAoIE1hdGguYWJzKCBtMzIgKSA8IDAuOTk5OTkgKSB7XG5cbiAgICBcdFx0XHRcdHRoaXMuX3kgPSBNYXRoLmF0YW4yKCAtIG0zMSwgbTMzICk7XG4gICAgXHRcdFx0XHR0aGlzLl96ID0gTWF0aC5hdGFuMiggLSBtMTIsIG0yMiApO1xuXG4gICAgXHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0dGhpcy5feSA9IDA7XG4gICAgXHRcdFx0XHR0aGlzLl96ID0gTWF0aC5hdGFuMiggbTIxLCBtMTEgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1pZWCcgKSB7XG5cbiAgICBcdFx0XHR0aGlzLl95ID0gTWF0aC5hc2luKCAtIGNsYW1wKCBtMzEsIC0gMSwgMSApICk7XG5cbiAgICBcdFx0XHRpZiAoIE1hdGguYWJzKCBtMzEgKSA8IDAuOTk5OTkgKSB7XG5cbiAgICBcdFx0XHRcdHRoaXMuX3ggPSBNYXRoLmF0YW4yKCBtMzIsIG0zMyApO1xuICAgIFx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXRhbjIoIG0yMSwgbTExICk7XG5cbiAgICBcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHR0aGlzLl94ID0gMDtcbiAgICBcdFx0XHRcdHRoaXMuX3ogPSBNYXRoLmF0YW4yKCAtIG0xMiwgbTIyICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdZWlgnICkge1xuXG4gICAgXHRcdFx0dGhpcy5feiA9IE1hdGguYXNpbiggY2xhbXAoIG0yMSwgLSAxLCAxICkgKTtcblxuICAgIFx0XHRcdGlmICggTWF0aC5hYnMoIG0yMSApIDwgMC45OTk5OSApIHtcblxuICAgIFx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXRhbjIoIC0gbTIzLCBtMjIgKTtcbiAgICBcdFx0XHRcdHRoaXMuX3kgPSBNYXRoLmF0YW4yKCAtIG0zMSwgbTExICk7XG5cbiAgICBcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHR0aGlzLl94ID0gMDtcbiAgICBcdFx0XHRcdHRoaXMuX3kgPSBNYXRoLmF0YW4yKCBtMTMsIG0zMyApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWFpZJyApIHtcblxuICAgIFx0XHRcdHRoaXMuX3ogPSBNYXRoLmFzaW4oIC0gY2xhbXAoIG0xMiwgLSAxLCAxICkgKTtcblxuICAgIFx0XHRcdGlmICggTWF0aC5hYnMoIG0xMiApIDwgMC45OTk5OSApIHtcblxuICAgIFx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXRhbjIoIG0zMiwgbTIyICk7XG4gICAgXHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hdGFuMiggbTEzLCBtMTEgKTtcblxuICAgIFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdHRoaXMuX3ggPSBNYXRoLmF0YW4yKCAtIG0yMywgbTMzICk7XG4gICAgXHRcdFx0XHR0aGlzLl95ID0gMDtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuRXVsZXI6IC5zZXRGcm9tUm90YXRpb25NYXRyaXgoKSBnaXZlbiB1bnN1cHBvcnRlZCBvcmRlcjogJyArIG9yZGVyICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHRoaXMuX29yZGVyID0gb3JkZXI7XG5cbiAgICBcdFx0aWYgKCB1cGRhdGUgIT09IGZhbHNlICkgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldEZyb21RdWF0ZXJuaW9uOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dmFyIG1hdHJpeDtcblxuICAgIFx0XHRyZXR1cm4gZnVuY3Rpb24gc2V0RnJvbVF1YXRlcm5pb24oIHEsIG9yZGVyLCB1cGRhdGUgKSB7XG5cbiAgICBcdFx0XHRpZiAoIG1hdHJpeCA9PT0gdW5kZWZpbmVkICkgbWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcblxuICAgIFx0XHRcdG1hdHJpeC5tYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbiggcSApO1xuXG4gICAgXHRcdFx0cmV0dXJuIHRoaXMuc2V0RnJvbVJvdGF0aW9uTWF0cml4KCBtYXRyaXgsIG9yZGVyLCB1cGRhdGUgKTtcblxuICAgIFx0XHR9O1xuXG4gICAgXHR9KCksXG5cbiAgICBcdHNldEZyb21WZWN0b3IzOiBmdW5jdGlvbiAoIHYsIG9yZGVyICkge1xuXG4gICAgXHRcdHJldHVybiB0aGlzLnNldCggdi54LCB2LnksIHYueiwgb3JkZXIgfHwgdGhpcy5fb3JkZXIgKTtcblxuICAgIFx0fSxcblxuICAgIFx0cmVvcmRlcjogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdC8vIFdBUk5JTkc6IHRoaXMgZGlzY2FyZHMgcmV2b2x1dGlvbiBpbmZvcm1hdGlvbiAtYmhvdXN0b25cblxuICAgIFx0XHR2YXIgcSA9IG5ldyBRdWF0ZXJuaW9uKCk7XG5cbiAgICBcdFx0cmV0dXJuIGZ1bmN0aW9uIHJlb3JkZXIoIG5ld09yZGVyICkge1xuXG4gICAgXHRcdFx0cS5zZXRGcm9tRXVsZXIoIHRoaXMgKTtcblxuICAgIFx0XHRcdHJldHVybiB0aGlzLnNldEZyb21RdWF0ZXJuaW9uKCBxLCBuZXdPcmRlciApO1xuXG4gICAgXHRcdH07XG5cbiAgICBcdH0oKSxcblxuICAgIFx0ZXF1YWxzOiBmdW5jdGlvbiAoIGV1bGVyICkge1xuXG4gICAgXHRcdHJldHVybiAoIGV1bGVyLl94ID09PSB0aGlzLl94ICkgJiYgKCBldWxlci5feSA9PT0gdGhpcy5feSApICYmICggZXVsZXIuX3ogPT09IHRoaXMuX3ogKSAmJiAoIGV1bGVyLl9vcmRlciA9PT0gdGhpcy5fb3JkZXIgKTtcblxuICAgIFx0fSxcblxuICAgIFx0ZnJvbUFycmF5OiBmdW5jdGlvbiAoIGFycmF5ICkge1xuXG4gICAgXHRcdHRoaXMuX3ggPSBhcnJheVsgMCBdO1xuICAgIFx0XHR0aGlzLl95ID0gYXJyYXlbIDEgXTtcbiAgICBcdFx0dGhpcy5feiA9IGFycmF5WyAyIF07XG4gICAgXHRcdGlmICggYXJyYXlbIDMgXSAhPT0gdW5kZWZpbmVkICkgdGhpcy5fb3JkZXIgPSBhcnJheVsgMyBdO1xuXG4gICAgXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHR0b0FycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XG5cbiAgICBcdFx0aWYgKCBhcnJheSA9PT0gdW5kZWZpbmVkICkgYXJyYXkgPSBbXTtcbiAgICBcdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cbiAgICBcdFx0YXJyYXlbIG9mZnNldCBdID0gdGhpcy5feDtcbiAgICBcdFx0YXJyYXlbIG9mZnNldCArIDEgXSA9IHRoaXMuX3k7XG4gICAgXHRcdGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0aGlzLl96O1xuICAgIFx0XHRhcnJheVsgb2Zmc2V0ICsgMyBdID0gdGhpcy5fb3JkZXI7XG5cbiAgICBcdFx0cmV0dXJuIGFycmF5O1xuXG4gICAgXHR9LFxuXG4gICAgXHR0b1ZlY3RvcjM6IGZ1bmN0aW9uICggb3B0aW9uYWxSZXN1bHQgKSB7XG5cbiAgICBcdFx0aWYgKCBvcHRpb25hbFJlc3VsdCApIHtcblxuICAgIFx0XHRcdHJldHVybiBvcHRpb25hbFJlc3VsdC5zZXQoIHRoaXMuX3gsIHRoaXMuX3ksIHRoaXMuX3ogKTtcblxuICAgIFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0cmV0dXJuIG5ldyBWZWN0b3IzKCB0aGlzLl94LCB0aGlzLl95LCB0aGlzLl96ICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9LFxuXG4gICAgXHRvbkNoYW5nZTogZnVuY3Rpb24gKCBjYWxsYmFjayApIHtcblxuICAgIFx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2sgPSBjYWxsYmFjaztcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0b25DaGFuZ2VDYWxsYmFjazogZnVuY3Rpb24gKCkge31cblxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gTGF5ZXJzKCkge1xuXG4gICAgXHR0aGlzLm1hc2sgPSAxO1xuXG4gICAgfVxuXG4gICAgTGF5ZXJzLnByb3RvdHlwZSA9IHtcblxuICAgIFx0Y29uc3RydWN0b3I6IExheWVycyxcblxuICAgIFx0c2V0OiBmdW5jdGlvbiAoIGNoYW5uZWwgKSB7XG5cbiAgICBcdFx0dGhpcy5tYXNrID0gMSA8PCBjaGFubmVsO1xuXG4gICAgXHR9LFxuXG4gICAgXHRlbmFibGU6IGZ1bmN0aW9uICggY2hhbm5lbCApIHtcblxuICAgIFx0XHR0aGlzLm1hc2sgfD0gMSA8PCBjaGFubmVsO1xuXG4gICAgXHR9LFxuXG4gICAgXHR0b2dnbGU6IGZ1bmN0aW9uICggY2hhbm5lbCApIHtcblxuICAgIFx0XHR0aGlzLm1hc2sgXj0gMSA8PCBjaGFubmVsO1xuXG4gICAgXHR9LFxuXG4gICAgXHRkaXNhYmxlOiBmdW5jdGlvbiAoIGNoYW5uZWwgKSB7XG5cbiAgICBcdFx0dGhpcy5tYXNrICY9IH4gKCAxIDw8IGNoYW5uZWwgKTtcblxuICAgIFx0fSxcblxuICAgIFx0dGVzdDogZnVuY3Rpb24gKCBsYXllcnMgKSB7XG5cbiAgICBcdFx0cmV0dXJuICggdGhpcy5tYXNrICYgbGF5ZXJzLm1hc2sgKSAhPT0gMDtcblxuICAgIFx0fVxuXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gICAgICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAgICAgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICAgICAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuICAgICAqIEBhdXRob3IgZWxlcGhhbnRhdHdvcmsgLyB3d3cuZWxlcGhhbnRhdHdvcmsuY2hcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIE9iamVjdDNEKCkge1xuXG4gICAgXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsICdpZCcsIHsgdmFsdWU6IE9iamVjdDNESWRDb3VudCgpIH0gKTtcblxuICAgIFx0dGhpcy51dWlkID0gZXhwb3J0cy5NYXRoLmdlbmVyYXRlVVVJRCgpO1xuXG4gICAgXHR0aGlzLm5hbWUgPSAnJztcbiAgICBcdHRoaXMudHlwZSA9ICdPYmplY3QzRCc7XG5cbiAgICBcdHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICBcdHRoaXMuY2hpbGRyZW4gPSBbXTtcblxuICAgIFx0dGhpcy51cCA9IE9iamVjdDNELkRlZmF1bHRVcC5jbG9uZSgpO1xuXG4gICAgXHR2YXIgcG9zaXRpb24gPSBuZXcgVmVjdG9yMygpO1xuICAgIFx0dmFyIHJvdGF0aW9uID0gbmV3IEV1bGVyKCk7XG4gICAgXHR2YXIgcXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG4gICAgXHR2YXIgc2NhbGUgPSBuZXcgVmVjdG9yMyggMSwgMSwgMSApO1xuXG4gICAgXHRmdW5jdGlvbiBvblJvdGF0aW9uQ2hhbmdlKCkge1xuXG4gICAgXHRcdHF1YXRlcm5pb24uc2V0RnJvbUV1bGVyKCByb3RhdGlvbiwgZmFsc2UgKTtcblxuICAgIFx0fVxuXG4gICAgXHRmdW5jdGlvbiBvblF1YXRlcm5pb25DaGFuZ2UoKSB7XG5cbiAgICBcdFx0cm90YXRpb24uc2V0RnJvbVF1YXRlcm5pb24oIHF1YXRlcm5pb24sIHVuZGVmaW5lZCwgZmFsc2UgKTtcblxuICAgIFx0fVxuXG4gICAgXHRyb3RhdGlvbi5vbkNoYW5nZSggb25Sb3RhdGlvbkNoYW5nZSApO1xuICAgIFx0cXVhdGVybmlvbi5vbkNoYW5nZSggb25RdWF0ZXJuaW9uQ2hhbmdlICk7XG5cbiAgICBcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCB0aGlzLCB7XG4gICAgXHRcdHBvc2l0aW9uOiB7XG4gICAgXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBcdFx0XHR2YWx1ZTogcG9zaXRpb25cbiAgICBcdFx0fSxcbiAgICBcdFx0cm90YXRpb246IHtcbiAgICBcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuICAgIFx0XHRcdHZhbHVlOiByb3RhdGlvblxuICAgIFx0XHR9LFxuICAgIFx0XHRxdWF0ZXJuaW9uOiB7XG4gICAgXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBcdFx0XHR2YWx1ZTogcXVhdGVybmlvblxuICAgIFx0XHR9LFxuICAgIFx0XHRzY2FsZToge1xuICAgIFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gICAgXHRcdFx0dmFsdWU6IHNjYWxlXG4gICAgXHRcdH0sXG4gICAgXHRcdG1vZGVsVmlld01hdHJpeDoge1xuICAgIFx0XHRcdHZhbHVlOiBuZXcgTWF0cml4NCgpXG4gICAgXHRcdH0sXG4gICAgXHRcdG5vcm1hbE1hdHJpeDoge1xuICAgIFx0XHRcdHZhbHVlOiBuZXcgTWF0cml4MygpXG4gICAgXHRcdH1cbiAgICBcdH0gKTtcblxuICAgIFx0dGhpcy5tYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuICAgIFx0dGhpcy5tYXRyaXhXb3JsZCA9IG5ldyBNYXRyaXg0KCk7XG5cbiAgICBcdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IE9iamVjdDNELkRlZmF1bHRNYXRyaXhBdXRvVXBkYXRlO1xuICAgIFx0dGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gZmFsc2U7XG5cbiAgICBcdHRoaXMubGF5ZXJzID0gbmV3IExheWVycygpO1xuICAgIFx0dGhpcy52aXNpYmxlID0gdHJ1ZTtcblxuICAgIFx0dGhpcy5jYXN0U2hhZG93ID0gZmFsc2U7XG4gICAgXHR0aGlzLnJlY2VpdmVTaGFkb3cgPSBmYWxzZTtcblxuICAgIFx0dGhpcy5mcnVzdHVtQ3VsbGVkID0gdHJ1ZTtcbiAgICBcdHRoaXMucmVuZGVyT3JkZXIgPSAwO1xuXG4gICAgXHR0aGlzLnVzZXJEYXRhID0ge307XG5cbiAgICBcdHRoaXMub25CZWZvcmVSZW5kZXIgPSBudWxsO1xuXG4gICAgfVxuXG4gICAgT2JqZWN0M0QuRGVmYXVsdFVwID0gbmV3IFZlY3RvcjMoIDAsIDEsIDAgKTtcbiAgICBPYmplY3QzRC5EZWZhdWx0TWF0cml4QXV0b1VwZGF0ZSA9IHRydWU7XG5cbiAgICBPYmplY3QuYXNzaWduKCBPYmplY3QzRC5wcm90b3R5cGUsIEV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUsIHtcblxuICAgIFx0aXNPYmplY3QzRDogdHJ1ZSxcblxuICAgIFx0YXBwbHlNYXRyaXg6IGZ1bmN0aW9uICggbWF0cml4ICkge1xuXG4gICAgXHRcdHRoaXMubWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIG1hdHJpeCwgdGhpcy5tYXRyaXggKTtcblxuICAgIFx0XHR0aGlzLm1hdHJpeC5kZWNvbXBvc2UoIHRoaXMucG9zaXRpb24sIHRoaXMucXVhdGVybmlvbiwgdGhpcy5zY2FsZSApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzZXRSb3RhdGlvbkZyb21BeGlzQW5nbGU6IGZ1bmN0aW9uICggYXhpcywgYW5nbGUgKSB7XG5cbiAgICBcdFx0Ly8gYXNzdW1lcyBheGlzIGlzIG5vcm1hbGl6ZWRcblxuICAgIFx0XHR0aGlzLnF1YXRlcm5pb24uc2V0RnJvbUF4aXNBbmdsZSggYXhpcywgYW5nbGUgKTtcblxuICAgIFx0fSxcblxuICAgIFx0c2V0Um90YXRpb25Gcm9tRXVsZXI6IGZ1bmN0aW9uICggZXVsZXIgKSB7XG5cbiAgICBcdFx0dGhpcy5xdWF0ZXJuaW9uLnNldEZyb21FdWxlciggZXVsZXIsIHRydWUgKTtcblxuICAgIFx0fSxcblxuICAgIFx0c2V0Um90YXRpb25Gcm9tTWF0cml4OiBmdW5jdGlvbiAoIG0gKSB7XG5cbiAgICBcdFx0Ly8gYXNzdW1lcyB0aGUgdXBwZXIgM3gzIG9mIG0gaXMgYSBwdXJlIHJvdGF0aW9uIG1hdHJpeCAoaS5lLCB1bnNjYWxlZClcblxuICAgIFx0XHR0aGlzLnF1YXRlcm5pb24uc2V0RnJvbVJvdGF0aW9uTWF0cml4KCBtICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldFJvdGF0aW9uRnJvbVF1YXRlcm5pb246IGZ1bmN0aW9uICggcSApIHtcblxuICAgIFx0XHQvLyBhc3N1bWVzIHEgaXMgbm9ybWFsaXplZFxuXG4gICAgXHRcdHRoaXMucXVhdGVybmlvbi5jb3B5KCBxICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdHJvdGF0ZU9uQXhpczogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdC8vIHJvdGF0ZSBvYmplY3Qgb24gYXhpcyBpbiBvYmplY3Qgc3BhY2VcbiAgICBcdFx0Ly8gYXhpcyBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWRcblxuICAgIFx0XHR2YXIgcTEgPSBuZXcgUXVhdGVybmlvbigpO1xuXG4gICAgXHRcdHJldHVybiBmdW5jdGlvbiByb3RhdGVPbkF4aXMoIGF4aXMsIGFuZ2xlICkge1xuXG4gICAgXHRcdFx0cTEuc2V0RnJvbUF4aXNBbmdsZSggYXhpcywgYW5nbGUgKTtcblxuICAgIFx0XHRcdHRoaXMucXVhdGVybmlvbi5tdWx0aXBseSggcTEgKTtcblxuICAgIFx0XHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHRcdH07XG5cbiAgICBcdH0oKSxcblxuICAgIFx0cm90YXRlWDogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCAxLCAwLCAwICk7XG5cbiAgICBcdFx0cmV0dXJuIGZ1bmN0aW9uIHJvdGF0ZVgoIGFuZ2xlICkge1xuXG4gICAgXHRcdFx0cmV0dXJuIHRoaXMucm90YXRlT25BeGlzKCB2MSwgYW5nbGUgKTtcblxuICAgIFx0XHR9O1xuXG4gICAgXHR9KCksXG5cbiAgICBcdHJvdGF0ZVk6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR2YXIgdjEgPSBuZXcgVmVjdG9yMyggMCwgMSwgMCApO1xuXG4gICAgXHRcdHJldHVybiBmdW5jdGlvbiByb3RhdGVZKCBhbmdsZSApIHtcblxuICAgIFx0XHRcdHJldHVybiB0aGlzLnJvdGF0ZU9uQXhpcyggdjEsIGFuZ2xlICk7XG5cbiAgICBcdFx0fTtcblxuICAgIFx0fSgpLFxuXG4gICAgXHRyb3RhdGVaOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoIDAsIDAsIDEgKTtcblxuICAgIFx0XHRyZXR1cm4gZnVuY3Rpb24gcm90YXRlWiggYW5nbGUgKSB7XG5cbiAgICBcdFx0XHRyZXR1cm4gdGhpcy5yb3RhdGVPbkF4aXMoIHYxLCBhbmdsZSApO1xuXG4gICAgXHRcdH07XG5cbiAgICBcdH0oKSxcblxuICAgIFx0dHJhbnNsYXRlT25BeGlzOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0Ly8gdHJhbnNsYXRlIG9iamVjdCBieSBkaXN0YW5jZSBhbG9uZyBheGlzIGluIG9iamVjdCBzcGFjZVxuICAgIFx0XHQvLyBheGlzIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZFxuXG4gICAgXHRcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XG5cbiAgICBcdFx0cmV0dXJuIGZ1bmN0aW9uIHRyYW5zbGF0ZU9uQXhpcyggYXhpcywgZGlzdGFuY2UgKSB7XG5cbiAgICBcdFx0XHR2MS5jb3B5KCBheGlzICkuYXBwbHlRdWF0ZXJuaW9uKCB0aGlzLnF1YXRlcm5pb24gKTtcblxuICAgIFx0XHRcdHRoaXMucG9zaXRpb24uYWRkKCB2MS5tdWx0aXBseVNjYWxhciggZGlzdGFuY2UgKSApO1xuXG4gICAgXHRcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdFx0fTtcblxuICAgIFx0fSgpLFxuXG4gICAgXHR0cmFuc2xhdGVYOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoIDEsIDAsIDAgKTtcblxuICAgIFx0XHRyZXR1cm4gZnVuY3Rpb24gdHJhbnNsYXRlWCggZGlzdGFuY2UgKSB7XG5cbiAgICBcdFx0XHRyZXR1cm4gdGhpcy50cmFuc2xhdGVPbkF4aXMoIHYxLCBkaXN0YW5jZSApO1xuXG4gICAgXHRcdH07XG5cbiAgICBcdH0oKSxcblxuICAgIFx0dHJhbnNsYXRlWTogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCAwLCAxLCAwICk7XG5cbiAgICBcdFx0cmV0dXJuIGZ1bmN0aW9uIHRyYW5zbGF0ZVkoIGRpc3RhbmNlICkge1xuXG4gICAgXHRcdFx0cmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKCB2MSwgZGlzdGFuY2UgKTtcblxuICAgIFx0XHR9O1xuXG4gICAgXHR9KCksXG5cbiAgICBcdHRyYW5zbGF0ZVo6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR2YXIgdjEgPSBuZXcgVmVjdG9yMyggMCwgMCwgMSApO1xuXG4gICAgXHRcdHJldHVybiBmdW5jdGlvbiB0cmFuc2xhdGVaKCBkaXN0YW5jZSApIHtcblxuICAgIFx0XHRcdHJldHVybiB0aGlzLnRyYW5zbGF0ZU9uQXhpcyggdjEsIGRpc3RhbmNlICk7XG5cbiAgICBcdFx0fTtcblxuICAgIFx0fSgpLFxuXG4gICAgXHRsb2NhbFRvV29ybGQ6IGZ1bmN0aW9uICggdmVjdG9yICkge1xuXG4gICAgXHRcdHJldHVybiB2ZWN0b3IuYXBwbHlNYXRyaXg0KCB0aGlzLm1hdHJpeFdvcmxkICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdHdvcmxkVG9Mb2NhbDogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHZhciBtMSA9IG5ldyBNYXRyaXg0KCk7XG5cbiAgICBcdFx0cmV0dXJuIGZ1bmN0aW9uIHdvcmxkVG9Mb2NhbCggdmVjdG9yICkge1xuXG4gICAgXHRcdFx0cmV0dXJuIHZlY3Rvci5hcHBseU1hdHJpeDQoIG0xLmdldEludmVyc2UoIHRoaXMubWF0cml4V29ybGQgKSApO1xuXG4gICAgXHRcdH07XG5cbiAgICBcdH0oKSxcblxuICAgIFx0bG9va0F0OiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0Ly8gVGhpcyByb3V0aW5lIGRvZXMgbm90IHN1cHBvcnQgb2JqZWN0cyB3aXRoIHJvdGF0ZWQgYW5kL29yIHRyYW5zbGF0ZWQgcGFyZW50KHMpXG5cbiAgICBcdFx0dmFyIG0xID0gbmV3IE1hdHJpeDQoKTtcblxuICAgIFx0XHRyZXR1cm4gZnVuY3Rpb24gbG9va0F0KCB2ZWN0b3IgKSB7XG5cbiAgICBcdFx0XHRtMS5sb29rQXQoIHZlY3RvciwgdGhpcy5wb3NpdGlvbiwgdGhpcy51cCApO1xuXG4gICAgXHRcdFx0dGhpcy5xdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeCggbTEgKTtcblxuICAgIFx0XHR9O1xuXG4gICAgXHR9KCksXG5cbiAgICBcdGFkZDogZnVuY3Rpb24gKCBvYmplY3QgKSB7XG5cbiAgICBcdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID4gMSApIHtcblxuICAgIFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkgKysgKSB7XG5cbiAgICBcdFx0XHRcdHRoaXMuYWRkKCBhcmd1bWVudHNbIGkgXSApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGlmICggb2JqZWN0ID09PSB0aGlzICkge1xuXG4gICAgXHRcdFx0Y29uc29sZS5lcnJvciggXCJUSFJFRS5PYmplY3QzRC5hZGQ6IG9iamVjdCBjYW4ndCBiZSBhZGRlZCBhcyBhIGNoaWxkIG9mIGl0c2VsZi5cIiwgb2JqZWN0ICk7XG4gICAgXHRcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGlmICggKG9iamVjdCAmJiBvYmplY3QuaXNPYmplY3QzRCkgKSB7XG5cbiAgICBcdFx0XHRpZiAoIG9iamVjdC5wYXJlbnQgIT09IG51bGwgKSB7XG5cbiAgICBcdFx0XHRcdG9iamVjdC5wYXJlbnQucmVtb3ZlKCBvYmplY3QgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdG9iamVjdC5wYXJlbnQgPSB0aGlzO1xuICAgIFx0XHRcdG9iamVjdC5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdhZGRlZCcgfSApO1xuXG4gICAgXHRcdFx0dGhpcy5jaGlsZHJlbi5wdXNoKCBvYmplY3QgKTtcblxuICAgIFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0Y29uc29sZS5lcnJvciggXCJUSFJFRS5PYmplY3QzRC5hZGQ6IG9iamVjdCBub3QgYW4gaW5zdGFuY2Ugb2YgVEhSRUUuT2JqZWN0M0QuXCIsIG9iamVjdCApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0cmVtb3ZlOiBmdW5jdGlvbiAoIG9iamVjdCApIHtcblxuICAgIFx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPiAxICkge1xuXG4gICAgXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSArKyApIHtcblxuICAgIFx0XHRcdFx0dGhpcy5yZW1vdmUoIGFyZ3VtZW50c1sgaSBdICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHZhciBpbmRleCA9IHRoaXMuY2hpbGRyZW4uaW5kZXhPZiggb2JqZWN0ICk7XG5cbiAgICBcdFx0aWYgKCBpbmRleCAhPT0gLSAxICkge1xuXG4gICAgXHRcdFx0b2JqZWN0LnBhcmVudCA9IG51bGw7XG5cbiAgICBcdFx0XHRvYmplY3QuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAncmVtb3ZlZCcgfSApO1xuXG4gICAgXHRcdFx0dGhpcy5jaGlsZHJlbi5zcGxpY2UoIGluZGV4LCAxICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9LFxuXG4gICAgXHRnZXRPYmplY3RCeUlkOiBmdW5jdGlvbiAoIGlkICkge1xuXG4gICAgXHRcdHJldHVybiB0aGlzLmdldE9iamVjdEJ5UHJvcGVydHkoICdpZCcsIGlkICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGdldE9iamVjdEJ5TmFtZTogZnVuY3Rpb24gKCBuYW1lICkge1xuXG4gICAgXHRcdHJldHVybiB0aGlzLmdldE9iamVjdEJ5UHJvcGVydHkoICduYW1lJywgbmFtZSApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRnZXRPYmplY3RCeVByb3BlcnR5OiBmdW5jdGlvbiAoIG5hbWUsIHZhbHVlICkge1xuXG4gICAgXHRcdGlmICggdGhpc1sgbmFtZSBdID09PSB2YWx1ZSApIHJldHVybiB0aGlzO1xuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgIFx0XHRcdHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5bIGkgXTtcbiAgICBcdFx0XHR2YXIgb2JqZWN0ID0gY2hpbGQuZ2V0T2JqZWN0QnlQcm9wZXJ0eSggbmFtZSwgdmFsdWUgKTtcblxuICAgIFx0XHRcdGlmICggb2JqZWN0ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRcdHJldHVybiBvYmplY3Q7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiB1bmRlZmluZWQ7XG5cbiAgICBcdH0sXG5cbiAgICBcdGdldFdvcmxkUG9zaXRpb246IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICBcdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XG5cbiAgICBcdFx0dGhpcy51cGRhdGVNYXRyaXhXb3JsZCggdHJ1ZSApO1xuXG4gICAgXHRcdHJldHVybiByZXN1bHQuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLm1hdHJpeFdvcmxkICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGdldFdvcmxkUXVhdGVybmlvbjogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHZhciBwb3NpdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG4gICAgXHRcdHZhciBzY2FsZSA9IG5ldyBWZWN0b3IzKCk7XG5cbiAgICBcdFx0cmV0dXJuIGZ1bmN0aW9uIGdldFdvcmxkUXVhdGVybmlvbiggb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICBcdFx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFF1YXRlcm5pb24oKTtcblxuICAgIFx0XHRcdHRoaXMudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcblxuICAgIFx0XHRcdHRoaXMubWF0cml4V29ybGQuZGVjb21wb3NlKCBwb3NpdGlvbiwgcmVzdWx0LCBzY2FsZSApO1xuXG4gICAgXHRcdFx0cmV0dXJuIHJlc3VsdDtcblxuICAgIFx0XHR9O1xuXG4gICAgXHR9KCksXG5cbiAgICBcdGdldFdvcmxkUm90YXRpb246IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR2YXIgcXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG5cbiAgICBcdFx0cmV0dXJuIGZ1bmN0aW9uIGdldFdvcmxkUm90YXRpb24oIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgXHRcdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBFdWxlcigpO1xuXG4gICAgXHRcdFx0dGhpcy5nZXRXb3JsZFF1YXRlcm5pb24oIHF1YXRlcm5pb24gKTtcblxuICAgIFx0XHRcdHJldHVybiByZXN1bHQuc2V0RnJvbVF1YXRlcm5pb24oIHF1YXRlcm5pb24sIHRoaXMucm90YXRpb24ub3JkZXIsIGZhbHNlICk7XG5cbiAgICBcdFx0fTtcblxuICAgIFx0fSgpLFxuXG4gICAgXHRnZXRXb3JsZFNjYWxlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dmFyIHBvc2l0aW9uID0gbmV3IFZlY3RvcjMoKTtcbiAgICBcdFx0dmFyIHF1YXRlcm5pb24gPSBuZXcgUXVhdGVybmlvbigpO1xuXG4gICAgXHRcdHJldHVybiBmdW5jdGlvbiBnZXRXb3JsZFNjYWxlKCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgIFx0XHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMygpO1xuXG4gICAgXHRcdFx0dGhpcy51cGRhdGVNYXRyaXhXb3JsZCggdHJ1ZSApO1xuXG4gICAgXHRcdFx0dGhpcy5tYXRyaXhXb3JsZC5kZWNvbXBvc2UoIHBvc2l0aW9uLCBxdWF0ZXJuaW9uLCByZXN1bHQgKTtcblxuICAgIFx0XHRcdHJldHVybiByZXN1bHQ7XG5cbiAgICBcdFx0fTtcblxuICAgIFx0fSgpLFxuXG4gICAgXHRnZXRXb3JsZERpcmVjdGlvbjogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHZhciBxdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKTtcblxuICAgIFx0XHRyZXR1cm4gZnVuY3Rpb24gZ2V0V29ybGREaXJlY3Rpb24oIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgXHRcdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XG5cbiAgICBcdFx0XHR0aGlzLmdldFdvcmxkUXVhdGVybmlvbiggcXVhdGVybmlvbiApO1xuXG4gICAgXHRcdFx0cmV0dXJuIHJlc3VsdC5zZXQoIDAsIDAsIDEgKS5hcHBseVF1YXRlcm5pb24oIHF1YXRlcm5pb24gKTtcblxuICAgIFx0XHR9O1xuXG4gICAgXHR9KCksXG5cbiAgICBcdHJheWNhc3Q6IGZ1bmN0aW9uICgpIHt9LFxuXG4gICAgXHR0cmF2ZXJzZTogZnVuY3Rpb24gKCBjYWxsYmFjayApIHtcblxuICAgIFx0XHRjYWxsYmFjayggdGhpcyApO1xuXG4gICAgXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG5cbiAgICBcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgIFx0XHRcdGNoaWxkcmVuWyBpIF0udHJhdmVyc2UoIGNhbGxiYWNrICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9LFxuXG4gICAgXHR0cmF2ZXJzZVZpc2libGU6IGZ1bmN0aW9uICggY2FsbGJhY2sgKSB7XG5cbiAgICBcdFx0aWYgKCB0aGlzLnZpc2libGUgPT09IGZhbHNlICkgcmV0dXJuO1xuXG4gICAgXHRcdGNhbGxiYWNrKCB0aGlzICk7XG5cbiAgICBcdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcblxuICAgIFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgXHRcdFx0Y2hpbGRyZW5bIGkgXS50cmF2ZXJzZVZpc2libGUoIGNhbGxiYWNrICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9LFxuXG4gICAgXHR0cmF2ZXJzZUFuY2VzdG9yczogZnVuY3Rpb24gKCBjYWxsYmFjayApIHtcblxuICAgIFx0XHR2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XG5cbiAgICBcdFx0aWYgKCBwYXJlbnQgIT09IG51bGwgKSB7XG5cbiAgICBcdFx0XHRjYWxsYmFjayggcGFyZW50ICk7XG5cbiAgICBcdFx0XHRwYXJlbnQudHJhdmVyc2VBbmNlc3RvcnMoIGNhbGxiYWNrICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9LFxuXG4gICAgXHR1cGRhdGVNYXRyaXg6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR0aGlzLm1hdHJpeC5jb21wb3NlKCB0aGlzLnBvc2l0aW9uLCB0aGlzLnF1YXRlcm5pb24sIHRoaXMuc2NhbGUgKTtcblxuICAgIFx0XHR0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgXHR9LFxuXG4gICAgXHR1cGRhdGVNYXRyaXhXb3JsZDogZnVuY3Rpb24gKCBmb3JjZSApIHtcblxuICAgIFx0XHRpZiAoIHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9PT0gdHJ1ZSApIHRoaXMudXBkYXRlTWF0cml4KCk7XG5cbiAgICBcdFx0aWYgKCB0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPT09IHRydWUgfHwgZm9yY2UgPT09IHRydWUgKSB7XG5cbiAgICBcdFx0XHRpZiAoIHRoaXMucGFyZW50ID09PSBudWxsICkge1xuXG4gICAgXHRcdFx0XHR0aGlzLm1hdHJpeFdvcmxkLmNvcHkoIHRoaXMubWF0cml4ICk7XG5cbiAgICBcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHR0aGlzLm1hdHJpeFdvcmxkLm11bHRpcGx5TWF0cmljZXMoIHRoaXMucGFyZW50Lm1hdHJpeFdvcmxkLCB0aGlzLm1hdHJpeCApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0dGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gZmFsc2U7XG5cbiAgICBcdFx0XHRmb3JjZSA9IHRydWU7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdC8vIHVwZGF0ZSBjaGlsZHJlblxuXG4gICAgXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG5cbiAgICBcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgIFx0XHRcdGNoaWxkcmVuWyBpIF0udXBkYXRlTWF0cml4V29ybGQoIGZvcmNlICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9LFxuXG4gICAgXHR0b0pTT046IGZ1bmN0aW9uICggbWV0YSApIHtcblxuICAgIFx0XHQvLyBtZXRhIGlzICcnIHdoZW4gY2FsbGVkIGZyb20gSlNPTi5zdHJpbmdpZnlcbiAgICBcdFx0dmFyIGlzUm9vdE9iamVjdCA9ICggbWV0YSA9PT0gdW5kZWZpbmVkIHx8IG1ldGEgPT09ICcnICk7XG5cbiAgICBcdFx0dmFyIG91dHB1dCA9IHt9O1xuXG4gICAgXHRcdC8vIG1ldGEgaXMgYSBoYXNoIHVzZWQgdG8gY29sbGVjdCBnZW9tZXRyaWVzLCBtYXRlcmlhbHMuXG4gICAgXHRcdC8vIG5vdCBwcm92aWRpbmcgaXQgaW1wbGllcyB0aGF0IHRoaXMgaXMgdGhlIHJvb3Qgb2JqZWN0XG4gICAgXHRcdC8vIGJlaW5nIHNlcmlhbGl6ZWQuXG4gICAgXHRcdGlmICggaXNSb290T2JqZWN0ICkge1xuXG4gICAgXHRcdFx0Ly8gaW5pdGlhbGl6ZSBtZXRhIG9ialxuICAgIFx0XHRcdG1ldGEgPSB7XG4gICAgXHRcdFx0XHRnZW9tZXRyaWVzOiB7fSxcbiAgICBcdFx0XHRcdG1hdGVyaWFsczoge30sXG4gICAgXHRcdFx0XHR0ZXh0dXJlczoge30sXG4gICAgXHRcdFx0XHRpbWFnZXM6IHt9XG4gICAgXHRcdFx0fTtcblxuICAgIFx0XHRcdG91dHB1dC5tZXRhZGF0YSA9IHtcbiAgICBcdFx0XHRcdHZlcnNpb246IDQuNCxcbiAgICBcdFx0XHRcdHR5cGU6ICdPYmplY3QnLFxuICAgIFx0XHRcdFx0Z2VuZXJhdG9yOiAnT2JqZWN0M0QudG9KU09OJ1xuICAgIFx0XHRcdH07XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdC8vIHN0YW5kYXJkIE9iamVjdDNEIHNlcmlhbGl6YXRpb25cblxuICAgIFx0XHR2YXIgb2JqZWN0ID0ge307XG5cbiAgICBcdFx0b2JqZWN0LnV1aWQgPSB0aGlzLnV1aWQ7XG4gICAgXHRcdG9iamVjdC50eXBlID0gdGhpcy50eXBlO1xuXG4gICAgXHRcdGlmICggdGhpcy5uYW1lICE9PSAnJyApIG9iamVjdC5uYW1lID0gdGhpcy5uYW1lO1xuICAgIFx0XHRpZiAoIEpTT04uc3RyaW5naWZ5KCB0aGlzLnVzZXJEYXRhICkgIT09ICd7fScgKSBvYmplY3QudXNlckRhdGEgPSB0aGlzLnVzZXJEYXRhO1xuICAgIFx0XHRpZiAoIHRoaXMuY2FzdFNoYWRvdyA9PT0gdHJ1ZSApIG9iamVjdC5jYXN0U2hhZG93ID0gdHJ1ZTtcbiAgICBcdFx0aWYgKCB0aGlzLnJlY2VpdmVTaGFkb3cgPT09IHRydWUgKSBvYmplY3QucmVjZWl2ZVNoYWRvdyA9IHRydWU7XG4gICAgXHRcdGlmICggdGhpcy52aXNpYmxlID09PSBmYWxzZSApIG9iamVjdC52aXNpYmxlID0gZmFsc2U7XG5cbiAgICBcdFx0b2JqZWN0Lm1hdHJpeCA9IHRoaXMubWF0cml4LnRvQXJyYXkoKTtcblxuICAgIFx0XHQvL1xuXG4gICAgXHRcdGlmICggdGhpcy5nZW9tZXRyeSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0aWYgKCBtZXRhLmdlb21ldHJpZXNbIHRoaXMuZ2VvbWV0cnkudXVpZCBdID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRcdG1ldGEuZ2VvbWV0cmllc1sgdGhpcy5nZW9tZXRyeS51dWlkIF0gPSB0aGlzLmdlb21ldHJ5LnRvSlNPTiggbWV0YSApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0b2JqZWN0Lmdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeS51dWlkO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoIHRoaXMubWF0ZXJpYWwgIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdGlmICggbWV0YS5tYXRlcmlhbHNbIHRoaXMubWF0ZXJpYWwudXVpZCBdID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRcdG1ldGEubWF0ZXJpYWxzWyB0aGlzLm1hdGVyaWFsLnV1aWQgXSA9IHRoaXMubWF0ZXJpYWwudG9KU09OKCBtZXRhICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRvYmplY3QubWF0ZXJpYWwgPSB0aGlzLm1hdGVyaWFsLnV1aWQ7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdC8vXG5cbiAgICBcdFx0aWYgKCB0aGlzLmNoaWxkcmVuLmxlbmd0aCA+IDAgKSB7XG5cbiAgICBcdFx0XHRvYmplY3QuY2hpbGRyZW4gPSBbXTtcblxuICAgIFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpICsrICkge1xuXG4gICAgXHRcdFx0XHRvYmplY3QuY2hpbGRyZW4ucHVzaCggdGhpcy5jaGlsZHJlblsgaSBdLnRvSlNPTiggbWV0YSApLm9iamVjdCApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoIGlzUm9vdE9iamVjdCApIHtcblxuICAgIFx0XHRcdHZhciBnZW9tZXRyaWVzID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS5nZW9tZXRyaWVzICk7XG4gICAgXHRcdFx0dmFyIG1hdGVyaWFscyA9IGV4dHJhY3RGcm9tQ2FjaGUoIG1ldGEubWF0ZXJpYWxzICk7XG4gICAgXHRcdFx0dmFyIHRleHR1cmVzID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS50ZXh0dXJlcyApO1xuICAgIFx0XHRcdHZhciBpbWFnZXMgPSBleHRyYWN0RnJvbUNhY2hlKCBtZXRhLmltYWdlcyApO1xuXG4gICAgXHRcdFx0aWYgKCBnZW9tZXRyaWVzLmxlbmd0aCA+IDAgKSBvdXRwdXQuZ2VvbWV0cmllcyA9IGdlb21ldHJpZXM7XG4gICAgXHRcdFx0aWYgKCBtYXRlcmlhbHMubGVuZ3RoID4gMCApIG91dHB1dC5tYXRlcmlhbHMgPSBtYXRlcmlhbHM7XG4gICAgXHRcdFx0aWYgKCB0ZXh0dXJlcy5sZW5ndGggPiAwICkgb3V0cHV0LnRleHR1cmVzID0gdGV4dHVyZXM7XG4gICAgXHRcdFx0aWYgKCBpbWFnZXMubGVuZ3RoID4gMCApIG91dHB1dC5pbWFnZXMgPSBpbWFnZXM7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdG91dHB1dC5vYmplY3QgPSBvYmplY3Q7XG5cbiAgICBcdFx0cmV0dXJuIG91dHB1dDtcblxuICAgIFx0XHQvLyBleHRyYWN0IGRhdGEgZnJvbSB0aGUgY2FjaGUgaGFzaFxuICAgIFx0XHQvLyByZW1vdmUgbWV0YWRhdGEgb24gZWFjaCBpdGVtXG4gICAgXHRcdC8vIGFuZCByZXR1cm4gYXMgYXJyYXlcbiAgICBcdFx0ZnVuY3Rpb24gZXh0cmFjdEZyb21DYWNoZSggY2FjaGUgKSB7XG5cbiAgICBcdFx0XHR2YXIgdmFsdWVzID0gW107XG4gICAgXHRcdFx0Zm9yICggdmFyIGtleSBpbiBjYWNoZSApIHtcblxuICAgIFx0XHRcdFx0dmFyIGRhdGEgPSBjYWNoZVsga2V5IF07XG4gICAgXHRcdFx0XHRkZWxldGUgZGF0YS5tZXRhZGF0YTtcbiAgICBcdFx0XHRcdHZhbHVlcy5wdXNoKCBkYXRhICk7XG5cbiAgICBcdFx0XHR9XG4gICAgXHRcdFx0cmV0dXJuIHZhbHVlcztcblxuICAgIFx0XHR9XG5cbiAgICBcdH0sXG5cbiAgICBcdGNsb25lOiBmdW5jdGlvbiAoIHJlY3Vyc2l2ZSApIHtcblxuICAgIFx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzLCByZWN1cnNpdmUgKTtcblxuICAgIFx0fSxcblxuICAgIFx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UsIHJlY3Vyc2l2ZSApIHtcblxuICAgIFx0XHRpZiAoIHJlY3Vyc2l2ZSA9PT0gdW5kZWZpbmVkICkgcmVjdXJzaXZlID0gdHJ1ZTtcblxuICAgIFx0XHR0aGlzLm5hbWUgPSBzb3VyY2UubmFtZTtcblxuICAgIFx0XHR0aGlzLnVwLmNvcHkoIHNvdXJjZS51cCApO1xuXG4gICAgXHRcdHRoaXMucG9zaXRpb24uY29weSggc291cmNlLnBvc2l0aW9uICk7XG4gICAgXHRcdHRoaXMucXVhdGVybmlvbi5jb3B5KCBzb3VyY2UucXVhdGVybmlvbiApO1xuICAgIFx0XHR0aGlzLnNjYWxlLmNvcHkoIHNvdXJjZS5zY2FsZSApO1xuXG4gICAgXHRcdHRoaXMubWF0cml4LmNvcHkoIHNvdXJjZS5tYXRyaXggKTtcbiAgICBcdFx0dGhpcy5tYXRyaXhXb3JsZC5jb3B5KCBzb3VyY2UubWF0cml4V29ybGQgKTtcblxuICAgIFx0XHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBzb3VyY2UubWF0cml4QXV0b1VwZGF0ZTtcbiAgICBcdFx0dGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gc291cmNlLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGU7XG5cbiAgICBcdFx0dGhpcy52aXNpYmxlID0gc291cmNlLnZpc2libGU7XG5cbiAgICBcdFx0dGhpcy5jYXN0U2hhZG93ID0gc291cmNlLmNhc3RTaGFkb3c7XG4gICAgXHRcdHRoaXMucmVjZWl2ZVNoYWRvdyA9IHNvdXJjZS5yZWNlaXZlU2hhZG93O1xuXG4gICAgXHRcdHRoaXMuZnJ1c3R1bUN1bGxlZCA9IHNvdXJjZS5mcnVzdHVtQ3VsbGVkO1xuICAgIFx0XHR0aGlzLnJlbmRlck9yZGVyID0gc291cmNlLnJlbmRlck9yZGVyO1xuXG4gICAgXHRcdHRoaXMudXNlckRhdGEgPSBKU09OLnBhcnNlKCBKU09OLnN0cmluZ2lmeSggc291cmNlLnVzZXJEYXRhICkgKTtcblxuICAgIFx0XHRpZiAoIHJlY3Vyc2l2ZSA9PT0gdHJ1ZSApIHtcblxuICAgIFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHNvdXJjZS5jaGlsZHJlbi5sZW5ndGg7IGkgKysgKSB7XG5cbiAgICBcdFx0XHRcdHZhciBjaGlsZCA9IHNvdXJjZS5jaGlsZHJlblsgaSBdO1xuICAgIFx0XHRcdFx0dGhpcy5hZGQoIGNoaWxkLmNsb25lKCkgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH1cblxuICAgIH0gKTtcblxuICAgIHZhciBjb3VudCQyID0gMDtcbiAgICBmdW5jdGlvbiBPYmplY3QzRElkQ291bnQoKSB7IHJldHVybiBjb3VudCQyKys7IH07XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBMaW5lMyggc3RhcnQsIGVuZCApIHtcblxuICAgIFx0dGhpcy5zdGFydCA9ICggc3RhcnQgIT09IHVuZGVmaW5lZCApID8gc3RhcnQgOiBuZXcgVmVjdG9yMygpO1xuICAgIFx0dGhpcy5lbmQgPSAoIGVuZCAhPT0gdW5kZWZpbmVkICkgPyBlbmQgOiBuZXcgVmVjdG9yMygpO1xuXG4gICAgfVxuXG4gICAgTGluZTMucHJvdG90eXBlID0ge1xuXG4gICAgXHRjb25zdHJ1Y3RvcjogTGluZTMsXG5cbiAgICBcdHNldDogZnVuY3Rpb24gKCBzdGFydCwgZW5kICkge1xuXG4gICAgXHRcdHRoaXMuc3RhcnQuY29weSggc3RhcnQgKTtcbiAgICBcdFx0dGhpcy5lbmQuY29weSggZW5kICk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRjb3B5OiBmdW5jdGlvbiAoIGxpbmUgKSB7XG5cbiAgICBcdFx0dGhpcy5zdGFydC5jb3B5KCBsaW5lLnN0YXJ0ICk7XG4gICAgXHRcdHRoaXMuZW5kLmNvcHkoIGxpbmUuZW5kICk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGdldENlbnRlcjogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgIFx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjMoKTtcbiAgICBcdFx0cmV0dXJuIHJlc3VsdC5hZGRWZWN0b3JzKCB0aGlzLnN0YXJ0LCB0aGlzLmVuZCApLm11bHRpcGx5U2NhbGFyKCAwLjUgKTtcblxuICAgIFx0fSxcblxuICAgIFx0ZGVsdGE6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICBcdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XG4gICAgXHRcdHJldHVybiByZXN1bHQuc3ViVmVjdG9ycyggdGhpcy5lbmQsIHRoaXMuc3RhcnQgKTtcblxuICAgIFx0fSxcblxuICAgIFx0ZGlzdGFuY2VTcTogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHJldHVybiB0aGlzLnN0YXJ0LmRpc3RhbmNlVG9TcXVhcmVkKCB0aGlzLmVuZCApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRkaXN0YW5jZTogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHJldHVybiB0aGlzLnN0YXJ0LmRpc3RhbmNlVG8oIHRoaXMuZW5kICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGF0OiBmdW5jdGlvbiAoIHQsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgXHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMygpO1xuXG4gICAgXHRcdHJldHVybiB0aGlzLmRlbHRhKCByZXN1bHQgKS5tdWx0aXBseVNjYWxhciggdCApLmFkZCggdGhpcy5zdGFydCApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRjbG9zZXN0UG9pbnRUb1BvaW50UGFyYW1ldGVyOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dmFyIHN0YXJ0UCA9IG5ldyBWZWN0b3IzKCk7XG4gICAgXHRcdHZhciBzdGFydEVuZCA9IG5ldyBWZWN0b3IzKCk7XG5cbiAgICBcdFx0cmV0dXJuIGZ1bmN0aW9uIGNsb3Nlc3RQb2ludFRvUG9pbnRQYXJhbWV0ZXIoIHBvaW50LCBjbGFtcFRvTGluZSApIHtcblxuICAgIFx0XHRcdHN0YXJ0UC5zdWJWZWN0b3JzKCBwb2ludCwgdGhpcy5zdGFydCApO1xuICAgIFx0XHRcdHN0YXJ0RW5kLnN1YlZlY3RvcnMoIHRoaXMuZW5kLCB0aGlzLnN0YXJ0ICk7XG5cbiAgICBcdFx0XHR2YXIgc3RhcnRFbmQyID0gc3RhcnRFbmQuZG90KCBzdGFydEVuZCApO1xuICAgIFx0XHRcdHZhciBzdGFydEVuZF9zdGFydFAgPSBzdGFydEVuZC5kb3QoIHN0YXJ0UCApO1xuXG4gICAgXHRcdFx0dmFyIHQgPSBzdGFydEVuZF9zdGFydFAgLyBzdGFydEVuZDI7XG5cbiAgICBcdFx0XHRpZiAoIGNsYW1wVG9MaW5lICkge1xuXG4gICAgXHRcdFx0XHR0ID0gZXhwb3J0cy5NYXRoLmNsYW1wKCB0LCAwLCAxICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRyZXR1cm4gdDtcblxuICAgIFx0XHR9O1xuXG4gICAgXHR9KCksXG5cbiAgICBcdGNsb3Nlc3RQb2ludFRvUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQsIGNsYW1wVG9MaW5lLCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgIFx0XHR2YXIgdCA9IHRoaXMuY2xvc2VzdFBvaW50VG9Qb2ludFBhcmFtZXRlciggcG9pbnQsIGNsYW1wVG9MaW5lICk7XG5cbiAgICBcdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMuZGVsdGEoIHJlc3VsdCApLm11bHRpcGx5U2NhbGFyKCB0ICkuYWRkKCB0aGlzLnN0YXJ0ICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGFwcGx5TWF0cml4NDogZnVuY3Rpb24gKCBtYXRyaXggKSB7XG5cbiAgICBcdFx0dGhpcy5zdGFydC5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xuICAgIFx0XHR0aGlzLmVuZC5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRlcXVhbHM6IGZ1bmN0aW9uICggbGluZSApIHtcblxuICAgIFx0XHRyZXR1cm4gbGluZS5zdGFydC5lcXVhbHMoIHRoaXMuc3RhcnQgKSAmJiBsaW5lLmVuZC5lcXVhbHMoIHRoaXMuZW5kICk7XG5cbiAgICBcdH1cblxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXG4gICAgICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIFRyaWFuZ2xlKCBhLCBiLCBjICkge1xuXG4gICAgXHR0aGlzLmEgPSAoIGEgIT09IHVuZGVmaW5lZCApID8gYSA6IG5ldyBWZWN0b3IzKCk7XG4gICAgXHR0aGlzLmIgPSAoIGIgIT09IHVuZGVmaW5lZCApID8gYiA6IG5ldyBWZWN0b3IzKCk7XG4gICAgXHR0aGlzLmMgPSAoIGMgIT09IHVuZGVmaW5lZCApID8gYyA6IG5ldyBWZWN0b3IzKCk7XG5cbiAgICB9XG5cbiAgICBUcmlhbmdsZS5ub3JtYWwgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdHZhciB2MCA9IG5ldyBWZWN0b3IzKCk7XG5cbiAgICBcdHJldHVybiBmdW5jdGlvbiBub3JtYWwoIGEsIGIsIGMsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgXHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMygpO1xuXG4gICAgXHRcdHJlc3VsdC5zdWJWZWN0b3JzKCBjLCBiICk7XG4gICAgXHRcdHYwLnN1YlZlY3RvcnMoIGEsIGIgKTtcbiAgICBcdFx0cmVzdWx0LmNyb3NzKCB2MCApO1xuXG4gICAgXHRcdHZhciByZXN1bHRMZW5ndGhTcSA9IHJlc3VsdC5sZW5ndGhTcSgpO1xuICAgIFx0XHRpZiAoIHJlc3VsdExlbmd0aFNxID4gMCApIHtcblxuICAgIFx0XHRcdHJldHVybiByZXN1bHQubXVsdGlwbHlTY2FsYXIoIDEgLyBNYXRoLnNxcnQoIHJlc3VsdExlbmd0aFNxICkgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIHJlc3VsdC5zZXQoIDAsIDAsIDAgKTtcblxuICAgIFx0fTtcblxuICAgIH0oKTtcblxuICAgIC8vIHN0YXRpYy9pbnN0YW5jZSBtZXRob2QgdG8gY2FsY3VsYXRlIGJhcnljZW50cmljIGNvb3JkaW5hdGVzXG4gICAgLy8gYmFzZWQgb246IGh0dHA6Ly93d3cuYmxhY2twYXduLmNvbS90ZXh0cy9wb2ludGlucG9seS9kZWZhdWx0Lmh0bWxcbiAgICBUcmlhbmdsZS5iYXJ5Y29vcmRGcm9tUG9pbnQgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdHZhciB2MCA9IG5ldyBWZWN0b3IzKCk7XG4gICAgXHR2YXIgdjEgPSBuZXcgVmVjdG9yMygpO1xuICAgIFx0dmFyIHYyID0gbmV3IFZlY3RvcjMoKTtcblxuICAgIFx0cmV0dXJuIGZ1bmN0aW9uIGJhcnljb29yZEZyb21Qb2ludCggcG9pbnQsIGEsIGIsIGMsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgXHRcdHYwLnN1YlZlY3RvcnMoIGMsIGEgKTtcbiAgICBcdFx0djEuc3ViVmVjdG9ycyggYiwgYSApO1xuICAgIFx0XHR2Mi5zdWJWZWN0b3JzKCBwb2ludCwgYSApO1xuXG4gICAgXHRcdHZhciBkb3QwMCA9IHYwLmRvdCggdjAgKTtcbiAgICBcdFx0dmFyIGRvdDAxID0gdjAuZG90KCB2MSApO1xuICAgIFx0XHR2YXIgZG90MDIgPSB2MC5kb3QoIHYyICk7XG4gICAgXHRcdHZhciBkb3QxMSA9IHYxLmRvdCggdjEgKTtcbiAgICBcdFx0dmFyIGRvdDEyID0gdjEuZG90KCB2MiApO1xuXG4gICAgXHRcdHZhciBkZW5vbSA9ICggZG90MDAgKiBkb3QxMSAtIGRvdDAxICogZG90MDEgKTtcblxuICAgIFx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjMoKTtcblxuICAgIFx0XHQvLyBjb2xsaW5lYXIgb3Igc2luZ3VsYXIgdHJpYW5nbGVcbiAgICBcdFx0aWYgKCBkZW5vbSA9PT0gMCApIHtcblxuICAgIFx0XHRcdC8vIGFyYml0cmFyeSBsb2NhdGlvbiBvdXRzaWRlIG9mIHRyaWFuZ2xlP1xuICAgIFx0XHRcdC8vIG5vdCBzdXJlIGlmIHRoaXMgaXMgdGhlIGJlc3QgaWRlYSwgbWF5YmUgc2hvdWxkIGJlIHJldHVybmluZyB1bmRlZmluZWRcbiAgICBcdFx0XHRyZXR1cm4gcmVzdWx0LnNldCggLSAyLCAtIDEsIC0gMSApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHR2YXIgaW52RGVub20gPSAxIC8gZGVub207XG4gICAgXHRcdHZhciB1ID0gKCBkb3QxMSAqIGRvdDAyIC0gZG90MDEgKiBkb3QxMiApICogaW52RGVub207XG4gICAgXHRcdHZhciB2ID0gKCBkb3QwMCAqIGRvdDEyIC0gZG90MDEgKiBkb3QwMiApICogaW52RGVub207XG5cbiAgICBcdFx0Ly8gYmFyeWNlbnRyaWMgY29vcmRpbmF0ZXMgbXVzdCBhbHdheXMgc3VtIHRvIDFcbiAgICBcdFx0cmV0dXJuIHJlc3VsdC5zZXQoIDEgLSB1IC0gdiwgdiwgdSApO1xuXG4gICAgXHR9O1xuXG4gICAgfSgpO1xuXG4gICAgVHJpYW5nbGUuY29udGFpbnNQb2ludCA9IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoKTtcblxuICAgIFx0cmV0dXJuIGZ1bmN0aW9uIGNvbnRhaW5zUG9pbnQoIHBvaW50LCBhLCBiLCBjICkge1xuXG4gICAgXHRcdHZhciByZXN1bHQgPSBUcmlhbmdsZS5iYXJ5Y29vcmRGcm9tUG9pbnQoIHBvaW50LCBhLCBiLCBjLCB2MSApO1xuXG4gICAgXHRcdHJldHVybiAoIHJlc3VsdC54ID49IDAgKSAmJiAoIHJlc3VsdC55ID49IDAgKSAmJiAoICggcmVzdWx0LnggKyByZXN1bHQueSApIDw9IDEgKTtcblxuICAgIFx0fTtcblxuICAgIH0oKTtcblxuICAgIFRyaWFuZ2xlLnByb3RvdHlwZSA9IHtcblxuICAgIFx0Y29uc3RydWN0b3I6IFRyaWFuZ2xlLFxuXG4gICAgXHRzZXQ6IGZ1bmN0aW9uICggYSwgYiwgYyApIHtcblxuICAgIFx0XHR0aGlzLmEuY29weSggYSApO1xuICAgIFx0XHR0aGlzLmIuY29weSggYiApO1xuICAgIFx0XHR0aGlzLmMuY29weSggYyApO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzZXRGcm9tUG9pbnRzQW5kSW5kaWNlczogZnVuY3Rpb24gKCBwb2ludHMsIGkwLCBpMSwgaTIgKSB7XG5cbiAgICBcdFx0dGhpcy5hLmNvcHkoIHBvaW50c1sgaTAgXSApO1xuICAgIFx0XHR0aGlzLmIuY29weSggcG9pbnRzWyBpMSBdICk7XG4gICAgXHRcdHRoaXMuYy5jb3B5KCBwb2ludHNbIGkyIF0gKTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGNvcHk6IGZ1bmN0aW9uICggdHJpYW5nbGUgKSB7XG5cbiAgICBcdFx0dGhpcy5hLmNvcHkoIHRyaWFuZ2xlLmEgKTtcbiAgICBcdFx0dGhpcy5iLmNvcHkoIHRyaWFuZ2xlLmIgKTtcbiAgICBcdFx0dGhpcy5jLmNvcHkoIHRyaWFuZ2xlLmMgKTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0YXJlYTogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHZhciB2MCA9IG5ldyBWZWN0b3IzKCk7XG4gICAgXHRcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XG5cbiAgICBcdFx0cmV0dXJuIGZ1bmN0aW9uIGFyZWEoKSB7XG5cbiAgICBcdFx0XHR2MC5zdWJWZWN0b3JzKCB0aGlzLmMsIHRoaXMuYiApO1xuICAgIFx0XHRcdHYxLnN1YlZlY3RvcnMoIHRoaXMuYSwgdGhpcy5iICk7XG5cbiAgICBcdFx0XHRyZXR1cm4gdjAuY3Jvc3MoIHYxICkubGVuZ3RoKCkgKiAwLjU7XG5cbiAgICBcdFx0fTtcblxuICAgIFx0fSgpLFxuXG4gICAgXHRtaWRwb2ludDogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgIFx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjMoKTtcbiAgICBcdFx0cmV0dXJuIHJlc3VsdC5hZGRWZWN0b3JzKCB0aGlzLmEsIHRoaXMuYiApLmFkZCggdGhpcy5jICkubXVsdGlwbHlTY2FsYXIoIDEgLyAzICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdG5vcm1hbDogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgIFx0XHRyZXR1cm4gVHJpYW5nbGUubm9ybWFsKCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5jLCBvcHRpb25hbFRhcmdldCApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRwbGFuZTogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgIFx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFBsYW5lKCk7XG5cbiAgICBcdFx0cmV0dXJuIHJlc3VsdC5zZXRGcm9tQ29wbGFuYXJQb2ludHMoIHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMgKTtcblxuICAgIFx0fSxcblxuICAgIFx0YmFyeWNvb3JkRnJvbVBvaW50OiBmdW5jdGlvbiAoIHBvaW50LCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgIFx0XHRyZXR1cm4gVHJpYW5nbGUuYmFyeWNvb3JkRnJvbVBvaW50KCBwb2ludCwgdGhpcy5hLCB0aGlzLmIsIHRoaXMuYywgb3B0aW9uYWxUYXJnZXQgKTtcblxuICAgIFx0fSxcblxuICAgIFx0Y29udGFpbnNQb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcblxuICAgIFx0XHRyZXR1cm4gVHJpYW5nbGUuY29udGFpbnNQb2ludCggcG9pbnQsIHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMgKTtcblxuICAgIFx0fSxcblxuICAgIFx0Y2xvc2VzdFBvaW50VG9Qb2ludDogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHZhciBwbGFuZSwgZWRnZUxpc3QsIHByb2plY3RlZFBvaW50LCBjbG9zZXN0UG9pbnQ7XG5cbiAgICBcdFx0cmV0dXJuIGZ1bmN0aW9uIGNsb3Nlc3RQb2ludFRvUG9pbnQoIHBvaW50LCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgIFx0XHRcdGlmICggcGxhbmUgPT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0cGxhbmUgPSBuZXcgUGxhbmUoKTtcbiAgICBcdFx0XHRcdGVkZ2VMaXN0ID0gWyBuZXcgTGluZTMoKSwgbmV3IExpbmUzKCksIG5ldyBMaW5lMygpIF07XG4gICAgXHRcdFx0XHRwcm9qZWN0ZWRQb2ludCA9IG5ldyBWZWN0b3IzKCk7XG4gICAgXHRcdFx0XHRjbG9zZXN0UG9pbnQgPSBuZXcgVmVjdG9yMygpO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XG4gICAgXHRcdFx0dmFyIG1pbkRpc3RhbmNlID0gSW5maW5pdHk7XG5cbiAgICBcdFx0XHQvLyBwcm9qZWN0IHRoZSBwb2ludCBvbnRvIHRoZSBwbGFuZSBvZiB0aGUgdHJpYW5nbGVcblxuICAgIFx0XHRcdHBsYW5lLnNldEZyb21Db3BsYW5hclBvaW50cyggdGhpcy5hLCB0aGlzLmIsIHRoaXMuYyApO1xuICAgIFx0XHRcdHBsYW5lLnByb2plY3RQb2ludCggcG9pbnQsIHByb2plY3RlZFBvaW50ICk7XG5cbiAgICBcdFx0XHQvLyBjaGVjayBpZiB0aGUgcHJvamVjdGlvbiBsaWVzIHdpdGhpbiB0aGUgdHJpYW5nbGVcblxuICAgIFx0XHRcdGlmKCB0aGlzLmNvbnRhaW5zUG9pbnQoIHByb2plY3RlZFBvaW50ICkgPT09IHRydWUgKSB7XG5cbiAgICBcdFx0XHRcdC8vIGlmIHNvLCB0aGlzIGlzIHRoZSBjbG9zZXN0IHBvaW50XG5cbiAgICBcdFx0XHRcdHJlc3VsdC5jb3B5KCBwcm9qZWN0ZWRQb2ludCApO1xuXG4gICAgXHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0Ly8gaWYgbm90LCB0aGUgcG9pbnQgZmFsbHMgb3V0c2lkZSB0aGUgdHJpYW5nbGUuIHRoZSByZXN1bHQgaXMgdGhlIGNsb3Nlc3QgcG9pbnQgdG8gdGhlIHRyaWFuZ2xlJ3MgZWRnZXMgb3IgdmVydGljZXNcblxuICAgIFx0XHRcdFx0ZWRnZUxpc3RbIDAgXS5zZXQoIHRoaXMuYSwgdGhpcy5iICk7XG4gICAgXHRcdFx0XHRlZGdlTGlzdFsgMSBdLnNldCggdGhpcy5iLCB0aGlzLmMgKTtcbiAgICBcdFx0XHRcdGVkZ2VMaXN0WyAyIF0uc2V0KCB0aGlzLmMsIHRoaXMuYSApO1xuXG4gICAgXHRcdFx0XHRmb3IoIHZhciBpID0gMDsgaSA8IGVkZ2VMaXN0Lmxlbmd0aDsgaSArKyApIHtcblxuICAgIFx0XHRcdFx0XHRlZGdlTGlzdFsgaSBdLmNsb3Nlc3RQb2ludFRvUG9pbnQoIHByb2plY3RlZFBvaW50LCB0cnVlLCBjbG9zZXN0UG9pbnQgKTtcblxuICAgIFx0XHRcdFx0XHR2YXIgZGlzdGFuY2UgPSBwcm9qZWN0ZWRQb2ludC5kaXN0YW5jZVRvU3F1YXJlZCggY2xvc2VzdFBvaW50ICk7XG5cbiAgICBcdFx0XHRcdFx0aWYoIGRpc3RhbmNlIDwgbWluRGlzdGFuY2UgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHRtaW5EaXN0YW5jZSA9IGRpc3RhbmNlO1xuXG4gICAgXHRcdFx0XHRcdFx0cmVzdWx0LmNvcHkoIGNsb3Nlc3RQb2ludCApO1xuXG4gICAgXHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0cmV0dXJuIHJlc3VsdDtcblxuICAgIFx0XHR9O1xuXG4gICAgXHR9KCksXG5cbiAgICBcdGVxdWFsczogZnVuY3Rpb24gKCB0cmlhbmdsZSApIHtcblxuICAgIFx0XHRyZXR1cm4gdHJpYW5nbGUuYS5lcXVhbHMoIHRoaXMuYSApICYmIHRyaWFuZ2xlLmIuZXF1YWxzKCB0aGlzLmIgKSAmJiB0cmlhbmdsZS5jLmVxdWFscyggdGhpcy5jICk7XG5cbiAgICBcdH1cblxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICAgICAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBGYWNlMyggYSwgYiwgYywgbm9ybWFsLCBjb2xvciwgbWF0ZXJpYWxJbmRleCApIHtcblxuICAgIFx0dGhpcy5hID0gYTtcbiAgICBcdHRoaXMuYiA9IGI7XG4gICAgXHR0aGlzLmMgPSBjO1xuXG4gICAgXHR0aGlzLm5vcm1hbCA9IChub3JtYWwgJiYgbm9ybWFsLmlzVmVjdG9yMykgPyBub3JtYWwgOiBuZXcgVmVjdG9yMygpO1xuICAgIFx0dGhpcy52ZXJ0ZXhOb3JtYWxzID0gQXJyYXkuaXNBcnJheSggbm9ybWFsICkgPyBub3JtYWwgOiBbXTtcblxuICAgIFx0dGhpcy5jb2xvciA9IChjb2xvciAmJiBjb2xvci5pc0NvbG9yKSA/IGNvbG9yIDogbmV3IENvbG9yKCk7XG4gICAgXHR0aGlzLnZlcnRleENvbG9ycyA9IEFycmF5LmlzQXJyYXkoIGNvbG9yICkgPyBjb2xvciA6IFtdO1xuXG4gICAgXHR0aGlzLm1hdGVyaWFsSW5kZXggPSBtYXRlcmlhbEluZGV4ICE9PSB1bmRlZmluZWQgPyBtYXRlcmlhbEluZGV4IDogMDtcblxuICAgIH1cblxuICAgIEZhY2UzLnByb3RvdHlwZSA9IHtcblxuICAgIFx0Y29uc3RydWN0b3I6IEZhY2UzLFxuXG4gICAgXHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuICAgIFx0fSxcblxuICAgIFx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cbiAgICBcdFx0dGhpcy5hID0gc291cmNlLmE7XG4gICAgXHRcdHRoaXMuYiA9IHNvdXJjZS5iO1xuICAgIFx0XHR0aGlzLmMgPSBzb3VyY2UuYztcblxuICAgIFx0XHR0aGlzLm5vcm1hbC5jb3B5KCBzb3VyY2Uubm9ybWFsICk7XG4gICAgXHRcdHRoaXMuY29sb3IuY29weSggc291cmNlLmNvbG9yICk7XG5cbiAgICBcdFx0dGhpcy5tYXRlcmlhbEluZGV4ID0gc291cmNlLm1hdGVyaWFsSW5kZXg7XG5cbiAgICBcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHNvdXJjZS52ZXJ0ZXhOb3JtYWxzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgXHRcdFx0dGhpcy52ZXJ0ZXhOb3JtYWxzWyBpIF0gPSBzb3VyY2UudmVydGV4Tm9ybWFsc1sgaSBdLmNsb25lKCk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBzb3VyY2UudmVydGV4Q29sb3JzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgXHRcdFx0dGhpcy52ZXJ0ZXhDb2xvcnNbIGkgXSA9IHNvdXJjZS52ZXJ0ZXhDb2xvcnNbIGkgXS5jbG9uZSgpO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fVxuXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gICAgICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAgICAgKlxuICAgICAqIHBhcmFtZXRlcnMgPSB7XG4gICAgICogIGNvbG9yOiA8aGV4PixcbiAgICAgKiAgb3BhY2l0eTogPGZsb2F0PixcbiAgICAgKiAgbWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICAgICAqXG4gICAgICogIGFvTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICAgICAqICBhb01hcEludGVuc2l0eTogPGZsb2F0PlxuICAgICAqXG4gICAgICogIHNwZWN1bGFyTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICAgICAqXG4gICAgICogIGFscGhhTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICAgICAqXG4gICAgICogIGVudk1hcDogbmV3IFRIUkVFLlRleHR1cmVDdWJlKCBbcG9zeCwgbmVneCwgcG9zeSwgbmVneSwgcG9zeiwgbmVnel0gKSxcbiAgICAgKiAgY29tYmluZTogVEhSRUUuTXVsdGlwbHksXG4gICAgICogIHJlZmxlY3Rpdml0eTogPGZsb2F0PixcbiAgICAgKiAgcmVmcmFjdGlvblJhdGlvOiA8ZmxvYXQ+LFxuICAgICAqXG4gICAgICogIHNoYWRpbmc6IFRIUkVFLlNtb290aFNoYWRpbmcsXG4gICAgICogIGRlcHRoVGVzdDogPGJvb2w+LFxuICAgICAqICBkZXB0aFdyaXRlOiA8Ym9vbD4sXG4gICAgICpcbiAgICAgKiAgd2lyZWZyYW1lOiA8Ym9vbGVhbj4sXG4gICAgICogIHdpcmVmcmFtZUxpbmV3aWR0aDogPGZsb2F0PixcbiAgICAgKlxuICAgICAqICBza2lubmluZzogPGJvb2w+LFxuICAgICAqICBtb3JwaFRhcmdldHM6IDxib29sPlxuICAgICAqIH1cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIE1lc2hCYXNpY01hdGVyaWFsKCBwYXJhbWV0ZXJzICkge1xuXG4gICAgXHRNYXRlcmlhbC5jYWxsKCB0aGlzICk7XG5cbiAgICBcdHRoaXMudHlwZSA9ICdNZXNoQmFzaWNNYXRlcmlhbCc7XG5cbiAgICBcdHRoaXMuY29sb3IgPSBuZXcgQ29sb3IoIDB4ZmZmZmZmICk7IC8vIGVtaXNzaXZlXG5cbiAgICBcdHRoaXMubWFwID0gbnVsbDtcblxuICAgIFx0dGhpcy5hb01hcCA9IG51bGw7XG4gICAgXHR0aGlzLmFvTWFwSW50ZW5zaXR5ID0gMS4wO1xuXG4gICAgXHR0aGlzLnNwZWN1bGFyTWFwID0gbnVsbDtcblxuICAgIFx0dGhpcy5hbHBoYU1hcCA9IG51bGw7XG5cbiAgICBcdHRoaXMuZW52TWFwID0gbnVsbDtcbiAgICBcdHRoaXMuY29tYmluZSA9IE11bHRpcGx5T3BlcmF0aW9uO1xuICAgIFx0dGhpcy5yZWZsZWN0aXZpdHkgPSAxO1xuICAgIFx0dGhpcy5yZWZyYWN0aW9uUmF0aW8gPSAwLjk4O1xuXG4gICAgXHR0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xuICAgIFx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSAxO1xuICAgIFx0dGhpcy53aXJlZnJhbWVMaW5lY2FwID0gJ3JvdW5kJztcbiAgICBcdHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSAncm91bmQnO1xuXG4gICAgXHR0aGlzLnNraW5uaW5nID0gZmFsc2U7XG4gICAgXHR0aGlzLm1vcnBoVGFyZ2V0cyA9IGZhbHNlO1xuXG4gICAgXHR0aGlzLmxpZ2h0cyA9IGZhbHNlO1xuXG4gICAgXHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xuXG4gICAgfVxuXG4gICAgTWVzaEJhc2ljTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTWF0ZXJpYWwucHJvdG90eXBlICk7XG4gICAgTWVzaEJhc2ljTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWVzaEJhc2ljTWF0ZXJpYWw7XG5cbiAgICBNZXNoQmFzaWNNYXRlcmlhbC5wcm90b3R5cGUuaXNNZXNoQmFzaWNNYXRlcmlhbCA9IHRydWU7XG5cbiAgICBNZXNoQmFzaWNNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xuXG4gICAgXHRNYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuICAgIFx0dGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcblxuICAgIFx0dGhpcy5tYXAgPSBzb3VyY2UubWFwO1xuXG4gICAgXHR0aGlzLmFvTWFwID0gc291cmNlLmFvTWFwO1xuICAgIFx0dGhpcy5hb01hcEludGVuc2l0eSA9IHNvdXJjZS5hb01hcEludGVuc2l0eTtcblxuICAgIFx0dGhpcy5zcGVjdWxhck1hcCA9IHNvdXJjZS5zcGVjdWxhck1hcDtcblxuICAgIFx0dGhpcy5hbHBoYU1hcCA9IHNvdXJjZS5hbHBoYU1hcDtcblxuICAgIFx0dGhpcy5lbnZNYXAgPSBzb3VyY2UuZW52TWFwO1xuICAgIFx0dGhpcy5jb21iaW5lID0gc291cmNlLmNvbWJpbmU7XG4gICAgXHR0aGlzLnJlZmxlY3Rpdml0eSA9IHNvdXJjZS5yZWZsZWN0aXZpdHk7XG4gICAgXHR0aGlzLnJlZnJhY3Rpb25SYXRpbyA9IHNvdXJjZS5yZWZyYWN0aW9uUmF0aW87XG5cbiAgICBcdHRoaXMud2lyZWZyYW1lID0gc291cmNlLndpcmVmcmFtZTtcbiAgICBcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gc291cmNlLndpcmVmcmFtZUxpbmV3aWR0aDtcbiAgICBcdHRoaXMud2lyZWZyYW1lTGluZWNhcCA9IHNvdXJjZS53aXJlZnJhbWVMaW5lY2FwO1xuICAgIFx0dGhpcy53aXJlZnJhbWVMaW5lam9pbiA9IHNvdXJjZS53aXJlZnJhbWVMaW5lam9pbjtcblxuICAgIFx0dGhpcy5za2lubmluZyA9IHNvdXJjZS5za2lubmluZztcbiAgICBcdHRoaXMubW9ycGhUYXJnZXRzID0gc291cmNlLm1vcnBoVGFyZ2V0cztcblxuICAgIFx0cmV0dXJuIHRoaXM7XG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIEJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkICkge1xuXG4gICAgXHRpZiAoIEFycmF5LmlzQXJyYXkoIGFycmF5ICkgKSB7XG5cbiAgICBcdFx0dGhyb3cgbmV3IFR5cGVFcnJvciggJ1RIUkVFLkJ1ZmZlckF0dHJpYnV0ZTogYXJyYXkgc2hvdWxkIGJlIGEgVHlwZWQgQXJyYXkuJyApO1xuXG4gICAgXHR9XG5cbiAgICBcdHRoaXMudXVpZCA9IGV4cG9ydHMuTWF0aC5nZW5lcmF0ZVVVSUQoKTtcblxuICAgIFx0dGhpcy5hcnJheSA9IGFycmF5O1xuICAgIFx0dGhpcy5pdGVtU2l6ZSA9IGl0ZW1TaXplO1xuICAgIFx0dGhpcy5jb3VudCA9IGFycmF5ICE9PSB1bmRlZmluZWQgPyBhcnJheS5sZW5ndGggLyBpdGVtU2l6ZSA6IDA7XG4gICAgXHR0aGlzLm5vcm1hbGl6ZWQgPSBub3JtYWxpemVkID09PSB0cnVlO1xuXG4gICAgXHR0aGlzLmR5bmFtaWMgPSBmYWxzZTtcbiAgICBcdHRoaXMudXBkYXRlUmFuZ2UgPSB7IG9mZnNldDogMCwgY291bnQ6IC0gMSB9O1xuXG4gICAgXHR0aGlzLnZlcnNpb24gPSAwO1xuXG4gICAgfVxuXG4gICAgQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSA9IHtcblxuICAgIFx0Y29uc3RydWN0b3I6IEJ1ZmZlckF0dHJpYnV0ZSxcblxuICAgIFx0aXNCdWZmZXJBdHRyaWJ1dGU6IHRydWUsXG5cbiAgICBcdHNldCBuZWVkc1VwZGF0ZSggdmFsdWUgKSB7XG5cbiAgICBcdFx0aWYgKCB2YWx1ZSA9PT0gdHJ1ZSApIHRoaXMudmVyc2lvbiArKztcblxuICAgIFx0fSxcblxuICAgIFx0c2V0RHluYW1pYzogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuICAgIFx0XHR0aGlzLmR5bmFtaWMgPSB2YWx1ZTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cbiAgICBcdFx0dGhpcy5hcnJheSA9IG5ldyBzb3VyY2UuYXJyYXkuY29uc3RydWN0b3IoIHNvdXJjZS5hcnJheSApO1xuICAgIFx0XHR0aGlzLml0ZW1TaXplID0gc291cmNlLml0ZW1TaXplO1xuICAgIFx0XHR0aGlzLmNvdW50ID0gc291cmNlLmNvdW50O1xuICAgIFx0XHR0aGlzLm5vcm1hbGl6ZWQgPSBzb3VyY2Uubm9ybWFsaXplZDtcblxuICAgIFx0XHR0aGlzLmR5bmFtaWMgPSBzb3VyY2UuZHluYW1pYztcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0Y29weUF0OiBmdW5jdGlvbiAoIGluZGV4MSwgYXR0cmlidXRlLCBpbmRleDIgKSB7XG5cbiAgICBcdFx0aW5kZXgxICo9IHRoaXMuaXRlbVNpemU7XG4gICAgXHRcdGluZGV4MiAqPSBhdHRyaWJ1dGUuaXRlbVNpemU7XG5cbiAgICBcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy5pdGVtU2l6ZTsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICBcdFx0XHR0aGlzLmFycmF5WyBpbmRleDEgKyBpIF0gPSBhdHRyaWJ1dGUuYXJyYXlbIGluZGV4MiArIGkgXTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGNvcHlBcnJheTogZnVuY3Rpb24gKCBhcnJheSApIHtcblxuICAgIFx0XHR0aGlzLmFycmF5LnNldCggYXJyYXkgKTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0Y29weUNvbG9yc0FycmF5OiBmdW5jdGlvbiAoIGNvbG9ycyApIHtcblxuICAgIFx0XHR2YXIgYXJyYXkgPSB0aGlzLmFycmF5LCBvZmZzZXQgPSAwO1xuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGNvbG9ycy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgXHRcdFx0dmFyIGNvbG9yID0gY29sb3JzWyBpIF07XG5cbiAgICBcdFx0XHRpZiAoIGNvbG9yID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckF0dHJpYnV0ZS5jb3B5Q29sb3JzQXJyYXkoKTogY29sb3IgaXMgdW5kZWZpbmVkJywgaSApO1xuICAgIFx0XHRcdFx0Y29sb3IgPSBuZXcgQ29sb3IoKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGFycmF5WyBvZmZzZXQgKysgXSA9IGNvbG9yLnI7XG4gICAgXHRcdFx0YXJyYXlbIG9mZnNldCArKyBdID0gY29sb3IuZztcbiAgICBcdFx0XHRhcnJheVsgb2Zmc2V0ICsrIF0gPSBjb2xvci5iO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0Y29weUluZGljZXNBcnJheTogZnVuY3Rpb24gKCBpbmRpY2VzICkge1xuXG4gICAgXHRcdHZhciBhcnJheSA9IHRoaXMuYXJyYXksIG9mZnNldCA9IDA7XG5cbiAgICBcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gaW5kaWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgXHRcdFx0dmFyIGluZGV4ID0gaW5kaWNlc1sgaSBdO1xuXG4gICAgXHRcdFx0YXJyYXlbIG9mZnNldCArKyBdID0gaW5kZXguYTtcbiAgICBcdFx0XHRhcnJheVsgb2Zmc2V0ICsrIF0gPSBpbmRleC5iO1xuICAgIFx0XHRcdGFycmF5WyBvZmZzZXQgKysgXSA9IGluZGV4LmM7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRjb3B5VmVjdG9yMnNBcnJheTogZnVuY3Rpb24gKCB2ZWN0b3JzICkge1xuXG4gICAgXHRcdHZhciBhcnJheSA9IHRoaXMuYXJyYXksIG9mZnNldCA9IDA7XG5cbiAgICBcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gdmVjdG9ycy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgXHRcdFx0dmFyIHZlY3RvciA9IHZlY3RvcnNbIGkgXTtcblxuICAgIFx0XHRcdGlmICggdmVjdG9yID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckF0dHJpYnV0ZS5jb3B5VmVjdG9yMnNBcnJheSgpOiB2ZWN0b3IgaXMgdW5kZWZpbmVkJywgaSApO1xuICAgIFx0XHRcdFx0dmVjdG9yID0gbmV3IFZlY3RvcjIoKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGFycmF5WyBvZmZzZXQgKysgXSA9IHZlY3Rvci54O1xuICAgIFx0XHRcdGFycmF5WyBvZmZzZXQgKysgXSA9IHZlY3Rvci55O1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0Y29weVZlY3RvcjNzQXJyYXk6IGZ1bmN0aW9uICggdmVjdG9ycyApIHtcblxuICAgIFx0XHR2YXIgYXJyYXkgPSB0aGlzLmFycmF5LCBvZmZzZXQgPSAwO1xuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHZlY3RvcnMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgIFx0XHRcdHZhciB2ZWN0b3IgPSB2ZWN0b3JzWyBpIF07XG5cbiAgICBcdFx0XHRpZiAoIHZlY3RvciA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJBdHRyaWJ1dGUuY29weVZlY3RvcjNzQXJyYXkoKTogdmVjdG9yIGlzIHVuZGVmaW5lZCcsIGkgKTtcbiAgICBcdFx0XHRcdHZlY3RvciA9IG5ldyBWZWN0b3IzKCk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRhcnJheVsgb2Zmc2V0ICsrIF0gPSB2ZWN0b3IueDtcbiAgICBcdFx0XHRhcnJheVsgb2Zmc2V0ICsrIF0gPSB2ZWN0b3IueTtcbiAgICBcdFx0XHRhcnJheVsgb2Zmc2V0ICsrIF0gPSB2ZWN0b3IuejtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGNvcHlWZWN0b3I0c0FycmF5OiBmdW5jdGlvbiAoIHZlY3RvcnMgKSB7XG5cbiAgICBcdFx0dmFyIGFycmF5ID0gdGhpcy5hcnJheSwgb2Zmc2V0ID0gMDtcblxuICAgIFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB2ZWN0b3JzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICBcdFx0XHR2YXIgdmVjdG9yID0gdmVjdG9yc1sgaSBdO1xuXG4gICAgXHRcdFx0aWYgKCB2ZWN0b3IgPT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyQXR0cmlidXRlLmNvcHlWZWN0b3I0c0FycmF5KCk6IHZlY3RvciBpcyB1bmRlZmluZWQnLCBpICk7XG4gICAgXHRcdFx0XHR2ZWN0b3IgPSBuZXcgVmVjdG9yNCgpO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0YXJyYXlbIG9mZnNldCArKyBdID0gdmVjdG9yLng7XG4gICAgXHRcdFx0YXJyYXlbIG9mZnNldCArKyBdID0gdmVjdG9yLnk7XG4gICAgXHRcdFx0YXJyYXlbIG9mZnNldCArKyBdID0gdmVjdG9yLno7XG4gICAgXHRcdFx0YXJyYXlbIG9mZnNldCArKyBdID0gdmVjdG9yLnc7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUsIG9mZnNldCApIHtcblxuICAgIFx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuICAgIFx0XHR0aGlzLmFycmF5LnNldCggdmFsdWUsIG9mZnNldCApO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRnZXRYOiBmdW5jdGlvbiAoIGluZGV4ICkge1xuXG4gICAgXHRcdHJldHVybiB0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgXTtcblxuICAgIFx0fSxcblxuICAgIFx0c2V0WDogZnVuY3Rpb24gKCBpbmRleCwgeCApIHtcblxuICAgIFx0XHR0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgXSA9IHg7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGdldFk6IGZ1bmN0aW9uICggaW5kZXggKSB7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDEgXTtcblxuICAgIFx0fSxcblxuICAgIFx0c2V0WTogZnVuY3Rpb24gKCBpbmRleCwgeSApIHtcblxuICAgIFx0XHR0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAxIF0gPSB5O1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRnZXRaOiBmdW5jdGlvbiAoIGluZGV4ICkge1xuXG4gICAgXHRcdHJldHVybiB0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAyIF07XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldFo6IGZ1bmN0aW9uICggaW5kZXgsIHogKSB7XG5cbiAgICBcdFx0dGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMiBdID0gejtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0Z2V0VzogZnVuY3Rpb24gKCBpbmRleCApIHtcblxuICAgIFx0XHRyZXR1cm4gdGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMyBdO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzZXRXOiBmdW5jdGlvbiAoIGluZGV4LCB3ICkge1xuXG4gICAgXHRcdHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDMgXSA9IHc7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldFhZOiBmdW5jdGlvbiAoIGluZGV4LCB4LCB5ICkge1xuXG4gICAgXHRcdGluZGV4ICo9IHRoaXMuaXRlbVNpemU7XG5cbiAgICBcdFx0dGhpcy5hcnJheVsgaW5kZXggKyAwIF0gPSB4O1xuICAgIFx0XHR0aGlzLmFycmF5WyBpbmRleCArIDEgXSA9IHk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldFhZWjogZnVuY3Rpb24gKCBpbmRleCwgeCwgeSwgeiApIHtcblxuICAgIFx0XHRpbmRleCAqPSB0aGlzLml0ZW1TaXplO1xuXG4gICAgXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMCBdID0geDtcbiAgICBcdFx0dGhpcy5hcnJheVsgaW5kZXggKyAxIF0gPSB5O1xuICAgIFx0XHR0aGlzLmFycmF5WyBpbmRleCArIDIgXSA9IHo7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldFhZWlc6IGZ1bmN0aW9uICggaW5kZXgsIHgsIHksIHosIHcgKSB7XG5cbiAgICBcdFx0aW5kZXggKj0gdGhpcy5pdGVtU2l6ZTtcblxuICAgIFx0XHR0aGlzLmFycmF5WyBpbmRleCArIDAgXSA9IHg7XG4gICAgXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMSBdID0geTtcbiAgICBcdFx0dGhpcy5hcnJheVsgaW5kZXggKyAyIF0gPSB6O1xuICAgIFx0XHR0aGlzLmFycmF5WyBpbmRleCArIDMgXSA9IHc7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG4gICAgXHR9XG5cbiAgICB9O1xuXG4gICAgLy9cblxuICAgIGZ1bmN0aW9uIEludDhBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSApIHtcblxuICAgIFx0cmV0dXJuIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIG5ldyBJbnQ4QXJyYXkoIGFycmF5ICksIGl0ZW1TaXplICk7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBVaW50OEF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplICkge1xuXG4gICAgXHRyZXR1cm4gbmV3IEJ1ZmZlckF0dHJpYnV0ZSggbmV3IFVpbnQ4QXJyYXkoIGFycmF5ICksIGl0ZW1TaXplICk7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBVaW50OENsYW1wZWRBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSApIHtcblxuICAgIFx0cmV0dXJuIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIG5ldyBVaW50OENsYW1wZWRBcnJheSggYXJyYXkgKSwgaXRlbVNpemUgKTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIEludDE2QXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKSB7XG5cbiAgICBcdHJldHVybiBuZXcgQnVmZmVyQXR0cmlidXRlKCBuZXcgSW50MTZBcnJheSggYXJyYXkgKSwgaXRlbVNpemUgKTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIFVpbnQxNkF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplICkge1xuXG4gICAgXHRyZXR1cm4gbmV3IEJ1ZmZlckF0dHJpYnV0ZSggbmV3IFVpbnQxNkFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSApO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gSW50MzJBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSApIHtcblxuICAgIFx0cmV0dXJuIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIG5ldyBJbnQzMkFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSApO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gVWludDMyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKSB7XG5cbiAgICBcdHJldHVybiBuZXcgQnVmZmVyQXR0cmlidXRlKCBuZXcgVWludDMyQXJyYXkoIGFycmF5ICksIGl0ZW1TaXplICk7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBGbG9hdDMyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKSB7XG5cbiAgICBcdHJldHVybiBuZXcgQnVmZmVyQXR0cmlidXRlKCBuZXcgRmxvYXQzMkFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSApO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gRmxvYXQ2NEF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplICkge1xuXG4gICAgXHRyZXR1cm4gbmV3IEJ1ZmZlckF0dHJpYnV0ZSggbmV3IEZsb2F0NjRBcnJheSggYXJyYXkgKSwgaXRlbVNpemUgKTtcblxuICAgIH1cblxuICAgIC8vIERlcHJlY2F0ZWRcblxuICAgIGZ1bmN0aW9uIER5bmFtaWNCdWZmZXJBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSApIHtcblxuICAgIFx0Y29uc29sZS53YXJuKCAnVEhSRUUuRHluYW1pY0J1ZmZlckF0dHJpYnV0ZSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSgpLnNldER5bmFtaWMoIHRydWUgKSBpbnN0ZWFkLicgKTtcbiAgICBcdHJldHVybiBuZXcgQnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKS5zZXREeW5hbWljKCB0cnVlICk7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICAgICAqIEBhdXRob3Iga2lsZSAvIGh0dHA6Ly9raWxlLnN0cmF2YWdhbnphLm9yZy9cbiAgICAgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICAgICAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gICAgICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xuICAgICAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIEdlb21ldHJ5KCkge1xuXG4gICAgXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsICdpZCcsIHsgdmFsdWU6IEdlb21ldHJ5SWRDb3VudCgpIH0gKTtcblxuICAgIFx0dGhpcy51dWlkID0gZXhwb3J0cy5NYXRoLmdlbmVyYXRlVVVJRCgpO1xuXG4gICAgXHR0aGlzLm5hbWUgPSAnJztcbiAgICBcdHRoaXMudHlwZSA9ICdHZW9tZXRyeSc7XG5cbiAgICBcdHRoaXMudmVydGljZXMgPSBbXTtcbiAgICBcdHRoaXMuY29sb3JzID0gW107XG4gICAgXHR0aGlzLmZhY2VzID0gW107XG4gICAgXHR0aGlzLmZhY2VWZXJ0ZXhVdnMgPSBbIFtdIF07XG5cbiAgICBcdHRoaXMubW9ycGhUYXJnZXRzID0gW107XG4gICAgXHR0aGlzLm1vcnBoTm9ybWFscyA9IFtdO1xuXG4gICAgXHR0aGlzLnNraW5XZWlnaHRzID0gW107XG4gICAgXHR0aGlzLnNraW5JbmRpY2VzID0gW107XG5cbiAgICBcdHRoaXMubGluZURpc3RhbmNlcyA9IFtdO1xuXG4gICAgXHR0aGlzLmJvdW5kaW5nQm94ID0gbnVsbDtcbiAgICBcdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBudWxsO1xuXG4gICAgXHQvLyB1cGRhdGUgZmxhZ3NcblxuICAgIFx0dGhpcy5lbGVtZW50c05lZWRVcGRhdGUgPSBmYWxzZTtcbiAgICBcdHRoaXMudmVydGljZXNOZWVkVXBkYXRlID0gZmFsc2U7XG4gICAgXHR0aGlzLnV2c05lZWRVcGRhdGUgPSBmYWxzZTtcbiAgICBcdHRoaXMubm9ybWFsc05lZWRVcGRhdGUgPSBmYWxzZTtcbiAgICBcdHRoaXMuY29sb3JzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuICAgIFx0dGhpcy5saW5lRGlzdGFuY2VzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuICAgIFx0dGhpcy5ncm91cHNOZWVkVXBkYXRlID0gZmFsc2U7XG5cbiAgICB9XG5cbiAgICBPYmplY3QuYXNzaWduKCBHZW9tZXRyeS5wcm90b3R5cGUsIEV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUsIHtcblxuICAgIFx0aXNHZW9tZXRyeTogdHJ1ZSxcblxuICAgIFx0YXBwbHlNYXRyaXg6IGZ1bmN0aW9uICggbWF0cml4ICkge1xuXG4gICAgXHRcdHZhciBub3JtYWxNYXRyaXggPSBuZXcgTWF0cml4MygpLmdldE5vcm1hbE1hdHJpeCggbWF0cml4ICk7XG5cbiAgICBcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHRoaXMudmVydGljZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICBcdFx0XHR2YXIgdmVydGV4ID0gdGhpcy52ZXJ0aWNlc1sgaSBdO1xuICAgIFx0XHRcdHZlcnRleC5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgIFx0XHRcdHZhciBmYWNlID0gdGhpcy5mYWNlc1sgaSBdO1xuICAgIFx0XHRcdGZhY2Uubm9ybWFsLmFwcGx5TWF0cml4Myggbm9ybWFsTWF0cml4ICkubm9ybWFsaXplKCk7XG5cbiAgICBcdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gZmFjZS52ZXJ0ZXhOb3JtYWxzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG4gICAgXHRcdFx0XHRmYWNlLnZlcnRleE5vcm1hbHNbIGogXS5hcHBseU1hdHJpeDMoIG5vcm1hbE1hdHJpeCApLm5vcm1hbGl6ZSgpO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoIHRoaXMuYm91bmRpbmdCb3ggIT09IG51bGwgKSB7XG5cbiAgICBcdFx0XHR0aGlzLmNvbXB1dGVCb3VuZGluZ0JveCgpO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoIHRoaXMuYm91bmRpbmdTcGhlcmUgIT09IG51bGwgKSB7XG5cbiAgICBcdFx0XHR0aGlzLmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHR0aGlzLnZlcnRpY2VzTmVlZFVwZGF0ZSA9IHRydWU7XG4gICAgXHRcdHRoaXMubm9ybWFsc05lZWRVcGRhdGUgPSB0cnVlO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRyb3RhdGVYOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0Ly8gcm90YXRlIGdlb21ldHJ5IGFyb3VuZCB3b3JsZCB4LWF4aXNcblxuICAgIFx0XHR2YXIgbTE7XG5cbiAgICBcdFx0cmV0dXJuIGZ1bmN0aW9uIHJvdGF0ZVgoIGFuZ2xlICkge1xuXG4gICAgXHRcdFx0aWYgKCBtMSA9PT0gdW5kZWZpbmVkICkgbTEgPSBuZXcgTWF0cml4NCgpO1xuXG4gICAgXHRcdFx0bTEubWFrZVJvdGF0aW9uWCggYW5nbGUgKTtcblxuICAgIFx0XHRcdHRoaXMuYXBwbHlNYXRyaXgoIG0xICk7XG5cbiAgICBcdFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0XHR9O1xuXG4gICAgXHR9KCksXG5cbiAgICBcdHJvdGF0ZVk6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHQvLyByb3RhdGUgZ2VvbWV0cnkgYXJvdW5kIHdvcmxkIHktYXhpc1xuXG4gICAgXHRcdHZhciBtMTtcblxuICAgIFx0XHRyZXR1cm4gZnVuY3Rpb24gcm90YXRlWSggYW5nbGUgKSB7XG5cbiAgICBcdFx0XHRpZiAoIG0xID09PSB1bmRlZmluZWQgKSBtMSA9IG5ldyBNYXRyaXg0KCk7XG5cbiAgICBcdFx0XHRtMS5tYWtlUm90YXRpb25ZKCBhbmdsZSApO1xuXG4gICAgXHRcdFx0dGhpcy5hcHBseU1hdHJpeCggbTEgKTtcblxuICAgIFx0XHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHRcdH07XG5cbiAgICBcdH0oKSxcblxuICAgIFx0cm90YXRlWjogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdC8vIHJvdGF0ZSBnZW9tZXRyeSBhcm91bmQgd29ybGQgei1heGlzXG5cbiAgICBcdFx0dmFyIG0xO1xuXG4gICAgXHRcdHJldHVybiBmdW5jdGlvbiByb3RhdGVaKCBhbmdsZSApIHtcblxuICAgIFx0XHRcdGlmICggbTEgPT09IHVuZGVmaW5lZCApIG0xID0gbmV3IE1hdHJpeDQoKTtcblxuICAgIFx0XHRcdG0xLm1ha2VSb3RhdGlvblooIGFuZ2xlICk7XG5cbiAgICBcdFx0XHR0aGlzLmFwcGx5TWF0cml4KCBtMSApO1xuXG4gICAgXHRcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdFx0fTtcblxuICAgIFx0fSgpLFxuXG4gICAgXHR0cmFuc2xhdGU6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHQvLyB0cmFuc2xhdGUgZ2VvbWV0cnlcblxuICAgIFx0XHR2YXIgbTE7XG5cbiAgICBcdFx0cmV0dXJuIGZ1bmN0aW9uIHRyYW5zbGF0ZSggeCwgeSwgeiApIHtcblxuICAgIFx0XHRcdGlmICggbTEgPT09IHVuZGVmaW5lZCApIG0xID0gbmV3IE1hdHJpeDQoKTtcblxuICAgIFx0XHRcdG0xLm1ha2VUcmFuc2xhdGlvbiggeCwgeSwgeiApO1xuXG4gICAgXHRcdFx0dGhpcy5hcHBseU1hdHJpeCggbTEgKTtcblxuICAgIFx0XHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHRcdH07XG5cbiAgICBcdH0oKSxcblxuICAgIFx0c2NhbGU6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHQvLyBzY2FsZSBnZW9tZXRyeVxuXG4gICAgXHRcdHZhciBtMTtcblxuICAgIFx0XHRyZXR1cm4gZnVuY3Rpb24gc2NhbGUoIHgsIHksIHogKSB7XG5cbiAgICBcdFx0XHRpZiAoIG0xID09PSB1bmRlZmluZWQgKSBtMSA9IG5ldyBNYXRyaXg0KCk7XG5cbiAgICBcdFx0XHRtMS5tYWtlU2NhbGUoIHgsIHksIHogKTtcblxuICAgIFx0XHRcdHRoaXMuYXBwbHlNYXRyaXgoIG0xICk7XG5cbiAgICBcdFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0XHR9O1xuXG4gICAgXHR9KCksXG5cbiAgICBcdGxvb2tBdDogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHZhciBvYmo7XG5cbiAgICBcdFx0cmV0dXJuIGZ1bmN0aW9uIGxvb2tBdCggdmVjdG9yICkge1xuXG4gICAgXHRcdFx0aWYgKCBvYmogPT09IHVuZGVmaW5lZCApIG9iaiA9IG5ldyBPYmplY3QzRCgpO1xuXG4gICAgXHRcdFx0b2JqLmxvb2tBdCggdmVjdG9yICk7XG5cbiAgICBcdFx0XHRvYmoudXBkYXRlTWF0cml4KCk7XG5cbiAgICBcdFx0XHR0aGlzLmFwcGx5TWF0cml4KCBvYmoubWF0cml4ICk7XG5cbiAgICBcdFx0fTtcblxuICAgIFx0fSgpLFxuXG4gICAgXHRmcm9tQnVmZmVyR2VvbWV0cnk6IGZ1bmN0aW9uICggZ2VvbWV0cnkgKSB7XG5cbiAgICBcdFx0dmFyIHNjb3BlID0gdGhpcztcblxuICAgIFx0XHR2YXIgaW5kaWNlcyA9IGdlb21ldHJ5LmluZGV4ICE9PSBudWxsID8gZ2VvbWV0cnkuaW5kZXguYXJyYXkgOiB1bmRlZmluZWQ7XG4gICAgXHRcdHZhciBhdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcblxuICAgIFx0XHR2YXIgcG9zaXRpb25zID0gYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcbiAgICBcdFx0dmFyIG5vcm1hbHMgPSBhdHRyaWJ1dGVzLm5vcm1hbCAhPT0gdW5kZWZpbmVkID8gYXR0cmlidXRlcy5ub3JtYWwuYXJyYXkgOiB1bmRlZmluZWQ7XG4gICAgXHRcdHZhciBjb2xvcnMgPSBhdHRyaWJ1dGVzLmNvbG9yICE9PSB1bmRlZmluZWQgPyBhdHRyaWJ1dGVzLmNvbG9yLmFycmF5IDogdW5kZWZpbmVkO1xuICAgIFx0XHR2YXIgdXZzID0gYXR0cmlidXRlcy51diAhPT0gdW5kZWZpbmVkID8gYXR0cmlidXRlcy51di5hcnJheSA6IHVuZGVmaW5lZDtcbiAgICBcdFx0dmFyIHV2czIgPSBhdHRyaWJ1dGVzLnV2MiAhPT0gdW5kZWZpbmVkID8gYXR0cmlidXRlcy51djIuYXJyYXkgOiB1bmRlZmluZWQ7XG5cbiAgICBcdFx0aWYgKCB1dnMyICE9PSB1bmRlZmluZWQgKSB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDEgXSA9IFtdO1xuXG4gICAgXHRcdHZhciB0ZW1wTm9ybWFscyA9IFtdO1xuICAgIFx0XHR2YXIgdGVtcFVWcyA9IFtdO1xuICAgIFx0XHR2YXIgdGVtcFVWczIgPSBbXTtcblxuICAgIFx0XHRmb3IgKCB2YXIgaSA9IDAsIGogPSAwOyBpIDwgcG9zaXRpb25zLmxlbmd0aDsgaSArPSAzLCBqICs9IDIgKSB7XG5cbiAgICBcdFx0XHRzY29wZS52ZXJ0aWNlcy5wdXNoKCBuZXcgVmVjdG9yMyggcG9zaXRpb25zWyBpIF0sIHBvc2l0aW9uc1sgaSArIDEgXSwgcG9zaXRpb25zWyBpICsgMiBdICkgKTtcblxuICAgIFx0XHRcdGlmICggbm9ybWFscyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0XHR0ZW1wTm9ybWFscy5wdXNoKCBuZXcgVmVjdG9yMyggbm9ybWFsc1sgaSBdLCBub3JtYWxzWyBpICsgMSBdLCBub3JtYWxzWyBpICsgMiBdICkgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGlmICggY29sb3JzICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRcdHNjb3BlLmNvbG9ycy5wdXNoKCBuZXcgQ29sb3IoIGNvbG9yc1sgaSBdLCBjb2xvcnNbIGkgKyAxIF0sIGNvbG9yc1sgaSArIDIgXSApICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRpZiAoIHV2cyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0XHR0ZW1wVVZzLnB1c2goIG5ldyBWZWN0b3IyKCB1dnNbIGogXSwgdXZzWyBqICsgMSBdICkgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGlmICggdXZzMiAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0XHR0ZW1wVVZzMi5wdXNoKCBuZXcgVmVjdG9yMiggdXZzMlsgaiBdLCB1dnMyWyBqICsgMSBdICkgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdFx0ZnVuY3Rpb24gYWRkRmFjZSggYSwgYiwgYywgbWF0ZXJpYWxJbmRleCApIHtcblxuICAgIFx0XHRcdHZhciB2ZXJ0ZXhOb3JtYWxzID0gbm9ybWFscyAhPT0gdW5kZWZpbmVkID8gWyB0ZW1wTm9ybWFsc1sgYSBdLmNsb25lKCksIHRlbXBOb3JtYWxzWyBiIF0uY2xvbmUoKSwgdGVtcE5vcm1hbHNbIGMgXS5jbG9uZSgpIF0gOiBbXTtcbiAgICBcdFx0XHR2YXIgdmVydGV4Q29sb3JzID0gY29sb3JzICE9PSB1bmRlZmluZWQgPyBbIHNjb3BlLmNvbG9yc1sgYSBdLmNsb25lKCksIHNjb3BlLmNvbG9yc1sgYiBdLmNsb25lKCksIHNjb3BlLmNvbG9yc1sgYyBdLmNsb25lKCkgXSA6IFtdO1xuXG4gICAgXHRcdFx0dmFyIGZhY2UgPSBuZXcgRmFjZTMoIGEsIGIsIGMsIHZlcnRleE5vcm1hbHMsIHZlcnRleENvbG9ycywgbWF0ZXJpYWxJbmRleCApO1xuXG4gICAgXHRcdFx0c2NvcGUuZmFjZXMucHVzaCggZmFjZSApO1xuXG4gICAgXHRcdFx0aWYgKCB1dnMgIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0c2NvcGUuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdGVtcFVWc1sgYSBdLmNsb25lKCksIHRlbXBVVnNbIGIgXS5jbG9uZSgpLCB0ZW1wVVZzWyBjIF0uY2xvbmUoKSBdICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRpZiAoIHV2czIgIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0c2NvcGUuZmFjZVZlcnRleFV2c1sgMSBdLnB1c2goIFsgdGVtcFVWczJbIGEgXS5jbG9uZSgpLCB0ZW1wVVZzMlsgYiBdLmNsb25lKCksIHRlbXBVVnMyWyBjIF0uY2xvbmUoKSBdICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGlmICggaW5kaWNlcyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0dmFyIGdyb3VwcyA9IGdlb21ldHJ5Lmdyb3VwcztcblxuICAgIFx0XHRcdGlmICggZ3JvdXBzLmxlbmd0aCA+IDAgKSB7XG5cbiAgICBcdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGdyb3Vwcy5sZW5ndGg7IGkgKysgKSB7XG5cbiAgICBcdFx0XHRcdFx0dmFyIGdyb3VwID0gZ3JvdXBzWyBpIF07XG5cbiAgICBcdFx0XHRcdFx0dmFyIHN0YXJ0ID0gZ3JvdXAuc3RhcnQ7XG4gICAgXHRcdFx0XHRcdHZhciBjb3VudCA9IGdyb3VwLmNvdW50O1xuXG4gICAgXHRcdFx0XHRcdGZvciAoIHZhciBqID0gc3RhcnQsIGpsID0gc3RhcnQgKyBjb3VudDsgaiA8IGpsOyBqICs9IDMgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHRhZGRGYWNlKCBpbmRpY2VzWyBqIF0sIGluZGljZXNbIGogKyAxIF0sIGluZGljZXNbIGogKyAyIF0sIGdyb3VwLm1hdGVyaWFsSW5kZXggICk7XG5cbiAgICBcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBpbmRpY2VzLmxlbmd0aDsgaSArPSAzICkge1xuXG4gICAgXHRcdFx0XHRcdGFkZEZhY2UoIGluZGljZXNbIGkgXSwgaW5kaWNlc1sgaSArIDEgXSwgaW5kaWNlc1sgaSArIDIgXSApO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHBvc2l0aW9ucy5sZW5ndGggLyAzOyBpICs9IDMgKSB7XG5cbiAgICBcdFx0XHRcdGFkZEZhY2UoIGksIGkgKyAxLCBpICsgMiApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHR0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xuXG4gICAgXHRcdGlmICggZ2VvbWV0cnkuYm91bmRpbmdCb3ggIT09IG51bGwgKSB7XG5cbiAgICBcdFx0XHR0aGlzLmJvdW5kaW5nQm94ID0gZ2VvbWV0cnkuYm91bmRpbmdCb3guY2xvbmUoKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSAhPT0gbnVsbCApIHtcblxuICAgIFx0XHRcdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZS5jbG9uZSgpO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0Y2VudGVyOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dGhpcy5jb21wdXRlQm91bmRpbmdCb3goKTtcblxuICAgIFx0XHR2YXIgb2Zmc2V0ID0gdGhpcy5ib3VuZGluZ0JveC5nZXRDZW50ZXIoKS5uZWdhdGUoKTtcblxuICAgIFx0XHR0aGlzLnRyYW5zbGF0ZSggb2Zmc2V0LngsIG9mZnNldC55LCBvZmZzZXQueiApO1xuXG4gICAgXHRcdHJldHVybiBvZmZzZXQ7XG5cbiAgICBcdH0sXG5cbiAgICBcdG5vcm1hbGl6ZTogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHRoaXMuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cbiAgICBcdFx0dmFyIGNlbnRlciA9IHRoaXMuYm91bmRpbmdTcGhlcmUuY2VudGVyO1xuICAgIFx0XHR2YXIgcmFkaXVzID0gdGhpcy5ib3VuZGluZ1NwaGVyZS5yYWRpdXM7XG5cbiAgICBcdFx0dmFyIHMgPSByYWRpdXMgPT09IDAgPyAxIDogMS4wIC8gcmFkaXVzO1xuXG4gICAgXHRcdHZhciBtYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuICAgIFx0XHRtYXRyaXguc2V0KFxuICAgIFx0XHRcdHMsIDAsIDAsIC0gcyAqIGNlbnRlci54LFxuICAgIFx0XHRcdDAsIHMsIDAsIC0gcyAqIGNlbnRlci55LFxuICAgIFx0XHRcdDAsIDAsIHMsIC0gcyAqIGNlbnRlci56LFxuICAgIFx0XHRcdDAsIDAsIDAsIDFcbiAgICBcdFx0KTtcblxuICAgIFx0XHR0aGlzLmFwcGx5TWF0cml4KCBtYXRyaXggKTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0Y29tcHV0ZUZhY2VOb3JtYWxzOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dmFyIGNiID0gbmV3IFZlY3RvcjMoKSwgYWIgPSBuZXcgVmVjdG9yMygpO1xuXG4gICAgXHRcdGZvciAoIHZhciBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xuXG4gICAgXHRcdFx0dmFyIGZhY2UgPSB0aGlzLmZhY2VzWyBmIF07XG5cbiAgICBcdFx0XHR2YXIgdkEgPSB0aGlzLnZlcnRpY2VzWyBmYWNlLmEgXTtcbiAgICBcdFx0XHR2YXIgdkIgPSB0aGlzLnZlcnRpY2VzWyBmYWNlLmIgXTtcbiAgICBcdFx0XHR2YXIgdkMgPSB0aGlzLnZlcnRpY2VzWyBmYWNlLmMgXTtcblxuICAgIFx0XHRcdGNiLnN1YlZlY3RvcnMoIHZDLCB2QiApO1xuICAgIFx0XHRcdGFiLnN1YlZlY3RvcnMoIHZBLCB2QiApO1xuICAgIFx0XHRcdGNiLmNyb3NzKCBhYiApO1xuXG4gICAgXHRcdFx0Y2Iubm9ybWFsaXplKCk7XG5cbiAgICBcdFx0XHRmYWNlLm5vcm1hbC5jb3B5KCBjYiApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0fSxcblxuICAgIFx0Y29tcHV0ZVZlcnRleE5vcm1hbHM6IGZ1bmN0aW9uICggYXJlYVdlaWdodGVkICkge1xuXG4gICAgXHRcdGlmICggYXJlYVdlaWdodGVkID09PSB1bmRlZmluZWQgKSBhcmVhV2VpZ2h0ZWQgPSB0cnVlO1xuXG4gICAgXHRcdHZhciB2LCB2bCwgZiwgZmwsIGZhY2UsIHZlcnRpY2VzO1xuXG4gICAgXHRcdHZlcnRpY2VzID0gbmV3IEFycmF5KCB0aGlzLnZlcnRpY2VzLmxlbmd0aCApO1xuXG4gICAgXHRcdGZvciAoIHYgPSAwLCB2bCA9IHRoaXMudmVydGljZXMubGVuZ3RoOyB2IDwgdmw7IHYgKysgKSB7XG5cbiAgICBcdFx0XHR2ZXJ0aWNlc1sgdiBdID0gbmV3IFZlY3RvcjMoKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKCBhcmVhV2VpZ2h0ZWQgKSB7XG5cbiAgICBcdFx0XHQvLyB2ZXJ0ZXggbm9ybWFscyB3ZWlnaHRlZCBieSB0cmlhbmdsZSBhcmVhc1xuICAgIFx0XHRcdC8vIGh0dHA6Ly93d3cuaXF1aWxlemxlcy5vcmcvd3d3L2FydGljbGVzL25vcm1hbHMvbm9ybWFscy5odG1cblxuICAgIFx0XHRcdHZhciB2QSwgdkIsIHZDO1xuICAgIFx0XHRcdHZhciBjYiA9IG5ldyBWZWN0b3IzKCksIGFiID0gbmV3IFZlY3RvcjMoKTtcblxuICAgIFx0XHRcdGZvciAoIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XG5cbiAgICBcdFx0XHRcdGZhY2UgPSB0aGlzLmZhY2VzWyBmIF07XG5cbiAgICBcdFx0XHRcdHZBID0gdGhpcy52ZXJ0aWNlc1sgZmFjZS5hIF07XG4gICAgXHRcdFx0XHR2QiA9IHRoaXMudmVydGljZXNbIGZhY2UuYiBdO1xuICAgIFx0XHRcdFx0dkMgPSB0aGlzLnZlcnRpY2VzWyBmYWNlLmMgXTtcblxuICAgIFx0XHRcdFx0Y2Iuc3ViVmVjdG9ycyggdkMsIHZCICk7XG4gICAgXHRcdFx0XHRhYi5zdWJWZWN0b3JzKCB2QSwgdkIgKTtcbiAgICBcdFx0XHRcdGNiLmNyb3NzKCBhYiApO1xuXG4gICAgXHRcdFx0XHR2ZXJ0aWNlc1sgZmFjZS5hIF0uYWRkKCBjYiApO1xuICAgIFx0XHRcdFx0dmVydGljZXNbIGZhY2UuYiBdLmFkZCggY2IgKTtcbiAgICBcdFx0XHRcdHZlcnRpY2VzWyBmYWNlLmMgXS5hZGQoIGNiICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdGZvciAoIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XG5cbiAgICBcdFx0XHRcdGZhY2UgPSB0aGlzLmZhY2VzWyBmIF07XG5cbiAgICBcdFx0XHRcdHZlcnRpY2VzWyBmYWNlLmEgXS5hZGQoIGZhY2Uubm9ybWFsICk7XG4gICAgXHRcdFx0XHR2ZXJ0aWNlc1sgZmFjZS5iIF0uYWRkKCBmYWNlLm5vcm1hbCApO1xuICAgIFx0XHRcdFx0dmVydGljZXNbIGZhY2UuYyBdLmFkZCggZmFjZS5ub3JtYWwgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdFx0Zm9yICggdiA9IDAsIHZsID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IHYgPCB2bDsgdiArKyApIHtcblxuICAgIFx0XHRcdHZlcnRpY2VzWyB2IF0ubm9ybWFsaXplKCk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGZvciAoIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XG5cbiAgICBcdFx0XHRmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xuXG4gICAgXHRcdFx0dmFyIHZlcnRleE5vcm1hbHMgPSBmYWNlLnZlcnRleE5vcm1hbHM7XG5cbiAgICBcdFx0XHRpZiAoIHZlcnRleE5vcm1hbHMubGVuZ3RoID09PSAzICkge1xuXG4gICAgXHRcdFx0XHR2ZXJ0ZXhOb3JtYWxzWyAwIF0uY29weSggdmVydGljZXNbIGZhY2UuYSBdICk7XG4gICAgXHRcdFx0XHR2ZXJ0ZXhOb3JtYWxzWyAxIF0uY29weSggdmVydGljZXNbIGZhY2UuYiBdICk7XG4gICAgXHRcdFx0XHR2ZXJ0ZXhOb3JtYWxzWyAyIF0uY29weSggdmVydGljZXNbIGZhY2UuYyBdICk7XG5cbiAgICBcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHR2ZXJ0ZXhOb3JtYWxzWyAwIF0gPSB2ZXJ0aWNlc1sgZmFjZS5hIF0uY2xvbmUoKTtcbiAgICBcdFx0XHRcdHZlcnRleE5vcm1hbHNbIDEgXSA9IHZlcnRpY2VzWyBmYWNlLmIgXS5jbG9uZSgpO1xuICAgIFx0XHRcdFx0dmVydGV4Tm9ybWFsc1sgMiBdID0gdmVydGljZXNbIGZhY2UuYyBdLmNsb25lKCk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGlmICggdGhpcy5mYWNlcy5sZW5ndGggPiAwICkge1xuXG4gICAgXHRcdFx0dGhpcy5ub3JtYWxzTmVlZFVwZGF0ZSA9IHRydWU7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9LFxuXG4gICAgXHRjb21wdXRlTW9ycGhOb3JtYWxzOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dmFyIGksIGlsLCBmLCBmbCwgZmFjZTtcblxuICAgIFx0XHQvLyBzYXZlIG9yaWdpbmFsIG5vcm1hbHNcbiAgICBcdFx0Ly8gLSBjcmVhdGUgdGVtcCB2YXJpYWJsZXMgb24gZmlyc3QgYWNjZXNzXG4gICAgXHRcdC8vICAgb3RoZXJ3aXNlIGp1c3QgY29weSAoZm9yIGZhc3RlciByZXBlYXRlZCBjYWxscylcblxuICAgIFx0XHRmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xuXG4gICAgXHRcdFx0ZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcblxuICAgIFx0XHRcdGlmICggISBmYWNlLl9fb3JpZ2luYWxGYWNlTm9ybWFsICkge1xuXG4gICAgXHRcdFx0XHRmYWNlLl9fb3JpZ2luYWxGYWNlTm9ybWFsID0gZmFjZS5ub3JtYWwuY2xvbmUoKTtcblxuICAgIFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdGZhY2UuX19vcmlnaW5hbEZhY2VOb3JtYWwuY29weSggZmFjZS5ub3JtYWwgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGlmICggISBmYWNlLl9fb3JpZ2luYWxWZXJ0ZXhOb3JtYWxzICkgZmFjZS5fX29yaWdpbmFsVmVydGV4Tm9ybWFscyA9IFtdO1xuXG4gICAgXHRcdFx0Zm9yICggaSA9IDAsIGlsID0gZmFjZS52ZXJ0ZXhOb3JtYWxzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgXHRcdFx0XHRpZiAoICEgZmFjZS5fX29yaWdpbmFsVmVydGV4Tm9ybWFsc1sgaSBdICkge1xuXG4gICAgXHRcdFx0XHRcdGZhY2UuX19vcmlnaW5hbFZlcnRleE5vcm1hbHNbIGkgXSA9IGZhY2UudmVydGV4Tm9ybWFsc1sgaSBdLmNsb25lKCk7XG5cbiAgICBcdFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdFx0ZmFjZS5fX29yaWdpbmFsVmVydGV4Tm9ybWFsc1sgaSBdLmNvcHkoIGZhY2UudmVydGV4Tm9ybWFsc1sgaSBdICk7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdFx0Ly8gdXNlIHRlbXAgZ2VvbWV0cnkgdG8gY29tcHV0ZSBmYWNlIGFuZCB2ZXJ0ZXggbm9ybWFscyBmb3IgZWFjaCBtb3JwaFxuXG4gICAgXHRcdHZhciB0bXBHZW8gPSBuZXcgR2VvbWV0cnkoKTtcbiAgICBcdFx0dG1wR2VvLmZhY2VzID0gdGhpcy5mYWNlcztcblxuICAgIFx0XHRmb3IgKCBpID0gMCwgaWwgPSB0aGlzLm1vcnBoVGFyZ2V0cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgIFx0XHRcdC8vIGNyZWF0ZSBvbiBmaXJzdCBhY2Nlc3NcblxuICAgIFx0XHRcdGlmICggISB0aGlzLm1vcnBoTm9ybWFsc1sgaSBdICkge1xuXG4gICAgXHRcdFx0XHR0aGlzLm1vcnBoTm9ybWFsc1sgaSBdID0ge307XG4gICAgXHRcdFx0XHR0aGlzLm1vcnBoTm9ybWFsc1sgaSBdLmZhY2VOb3JtYWxzID0gW107XG4gICAgXHRcdFx0XHR0aGlzLm1vcnBoTm9ybWFsc1sgaSBdLnZlcnRleE5vcm1hbHMgPSBbXTtcblxuICAgIFx0XHRcdFx0dmFyIGRzdE5vcm1hbHNGYWNlID0gdGhpcy5tb3JwaE5vcm1hbHNbIGkgXS5mYWNlTm9ybWFscztcbiAgICBcdFx0XHRcdHZhciBkc3ROb3JtYWxzVmVydGV4ID0gdGhpcy5tb3JwaE5vcm1hbHNbIGkgXS52ZXJ0ZXhOb3JtYWxzO1xuXG4gICAgXHRcdFx0XHR2YXIgZmFjZU5vcm1hbCwgdmVydGV4Tm9ybWFscztcblxuICAgIFx0XHRcdFx0Zm9yICggZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcblxuICAgIFx0XHRcdFx0XHRmYWNlTm9ybWFsID0gbmV3IFZlY3RvcjMoKTtcbiAgICBcdFx0XHRcdFx0dmVydGV4Tm9ybWFscyA9IHsgYTogbmV3IFZlY3RvcjMoKSwgYjogbmV3IFZlY3RvcjMoKSwgYzogbmV3IFZlY3RvcjMoKSB9O1xuXG4gICAgXHRcdFx0XHRcdGRzdE5vcm1hbHNGYWNlLnB1c2goIGZhY2VOb3JtYWwgKTtcbiAgICBcdFx0XHRcdFx0ZHN0Tm9ybWFsc1ZlcnRleC5wdXNoKCB2ZXJ0ZXhOb3JtYWxzICk7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdHZhciBtb3JwaE5vcm1hbHMgPSB0aGlzLm1vcnBoTm9ybWFsc1sgaSBdO1xuXG4gICAgXHRcdFx0Ly8gc2V0IHZlcnRpY2VzIHRvIG1vcnBoIHRhcmdldFxuXG4gICAgXHRcdFx0dG1wR2VvLnZlcnRpY2VzID0gdGhpcy5tb3JwaFRhcmdldHNbIGkgXS52ZXJ0aWNlcztcblxuICAgIFx0XHRcdC8vIGNvbXB1dGUgbW9ycGggbm9ybWFsc1xuXG4gICAgXHRcdFx0dG1wR2VvLmNvbXB1dGVGYWNlTm9ybWFscygpO1xuICAgIFx0XHRcdHRtcEdlby5jb21wdXRlVmVydGV4Tm9ybWFscygpO1xuXG4gICAgXHRcdFx0Ly8gc3RvcmUgbW9ycGggbm9ybWFsc1xuXG4gICAgXHRcdFx0dmFyIGZhY2VOb3JtYWwsIHZlcnRleE5vcm1hbHM7XG5cbiAgICBcdFx0XHRmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xuXG4gICAgXHRcdFx0XHRmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xuXG4gICAgXHRcdFx0XHRmYWNlTm9ybWFsID0gbW9ycGhOb3JtYWxzLmZhY2VOb3JtYWxzWyBmIF07XG4gICAgXHRcdFx0XHR2ZXJ0ZXhOb3JtYWxzID0gbW9ycGhOb3JtYWxzLnZlcnRleE5vcm1hbHNbIGYgXTtcblxuICAgIFx0XHRcdFx0ZmFjZU5vcm1hbC5jb3B5KCBmYWNlLm5vcm1hbCApO1xuXG4gICAgXHRcdFx0XHR2ZXJ0ZXhOb3JtYWxzLmEuY29weSggZmFjZS52ZXJ0ZXhOb3JtYWxzWyAwIF0gKTtcbiAgICBcdFx0XHRcdHZlcnRleE5vcm1hbHMuYi5jb3B5KCBmYWNlLnZlcnRleE5vcm1hbHNbIDEgXSApO1xuICAgIFx0XHRcdFx0dmVydGV4Tm9ybWFscy5jLmNvcHkoIGZhY2UudmVydGV4Tm9ybWFsc1sgMiBdICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdC8vIHJlc3RvcmUgb3JpZ2luYWwgbm9ybWFsc1xuXG4gICAgXHRcdGZvciAoIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XG5cbiAgICBcdFx0XHRmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xuXG4gICAgXHRcdFx0ZmFjZS5ub3JtYWwgPSBmYWNlLl9fb3JpZ2luYWxGYWNlTm9ybWFsO1xuICAgIFx0XHRcdGZhY2UudmVydGV4Tm9ybWFscyA9IGZhY2UuX19vcmlnaW5hbFZlcnRleE5vcm1hbHM7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9LFxuXG4gICAgXHRjb21wdXRlVGFuZ2VudHM6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5HZW9tZXRyeTogLmNvbXB1dGVUYW5nZW50cygpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRjb21wdXRlTGluZURpc3RhbmNlczogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHZhciBkID0gMDtcbiAgICBcdFx0dmFyIHZlcnRpY2VzID0gdGhpcy52ZXJ0aWNlcztcblxuICAgIFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gdmVydGljZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICBcdFx0XHRpZiAoIGkgPiAwICkge1xuXG4gICAgXHRcdFx0XHRkICs9IHZlcnRpY2VzWyBpIF0uZGlzdGFuY2VUbyggdmVydGljZXNbIGkgLSAxIF0gKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdHRoaXMubGluZURpc3RhbmNlc1sgaSBdID0gZDtcblxuICAgIFx0XHR9XG5cbiAgICBcdH0sXG5cbiAgICBcdGNvbXB1dGVCb3VuZGluZ0JveDogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdGlmICggdGhpcy5ib3VuZGluZ0JveCA9PT0gbnVsbCApIHtcblxuICAgIFx0XHRcdHRoaXMuYm91bmRpbmdCb3ggPSBuZXcgQm94MygpO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHR0aGlzLmJvdW5kaW5nQm94LnNldEZyb21Qb2ludHMoIHRoaXMudmVydGljZXMgKTtcblxuICAgIFx0fSxcblxuICAgIFx0Y29tcHV0ZUJvdW5kaW5nU3BoZXJlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0aWYgKCB0aGlzLmJvdW5kaW5nU3BoZXJlID09PSBudWxsICkge1xuXG4gICAgXHRcdFx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG5ldyBTcGhlcmUoKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0dGhpcy5ib3VuZGluZ1NwaGVyZS5zZXRGcm9tUG9pbnRzKCB0aGlzLnZlcnRpY2VzICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdG1lcmdlOiBmdW5jdGlvbiAoIGdlb21ldHJ5LCBtYXRyaXgsIG1hdGVyaWFsSW5kZXhPZmZzZXQgKSB7XG5cbiAgICBcdFx0aWYgKCAoZ2VvbWV0cnkgJiYgZ2VvbWV0cnkuaXNHZW9tZXRyeSkgPT09IGZhbHNlICkge1xuXG4gICAgXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkdlb21ldHJ5Lm1lcmdlKCk6IGdlb21ldHJ5IG5vdCBhbiBpbnN0YW5jZSBvZiBUSFJFRS5HZW9tZXRyeS4nLCBnZW9tZXRyeSApO1xuICAgIFx0XHRcdHJldHVybjtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0dmFyIG5vcm1hbE1hdHJpeCxcbiAgICBcdFx0dmVydGV4T2Zmc2V0ID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGgsXG4gICAgXHRcdHZlcnRpY2VzMSA9IHRoaXMudmVydGljZXMsXG4gICAgXHRcdHZlcnRpY2VzMiA9IGdlb21ldHJ5LnZlcnRpY2VzLFxuICAgIFx0XHRmYWNlczEgPSB0aGlzLmZhY2VzLFxuICAgIFx0XHRmYWNlczIgPSBnZW9tZXRyeS5mYWNlcyxcbiAgICBcdFx0dXZzMSA9IHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLFxuICAgIFx0XHR1dnMyID0gZ2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgMCBdLFxuICAgIFx0XHRjb2xvcnMxID0gdGhpcy5jb2xvcnMsXG4gICAgXHRcdGNvbG9yczIgPSBnZW9tZXRyeS5jb2xvcnM7XG5cbiAgICBcdFx0aWYgKCBtYXRlcmlhbEluZGV4T2Zmc2V0ID09PSB1bmRlZmluZWQgKSBtYXRlcmlhbEluZGV4T2Zmc2V0ID0gMDtcblxuICAgIFx0XHRpZiAoIG1hdHJpeCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0bm9ybWFsTWF0cml4ID0gbmV3IE1hdHJpeDMoKS5nZXROb3JtYWxNYXRyaXgoIG1hdHJpeCApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHQvLyB2ZXJ0aWNlc1xuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSB2ZXJ0aWNlczIubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICBcdFx0XHR2YXIgdmVydGV4ID0gdmVydGljZXMyWyBpIF07XG5cbiAgICBcdFx0XHR2YXIgdmVydGV4Q29weSA9IHZlcnRleC5jbG9uZSgpO1xuXG4gICAgXHRcdFx0aWYgKCBtYXRyaXggIT09IHVuZGVmaW5lZCApIHZlcnRleENvcHkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcblxuICAgIFx0XHRcdHZlcnRpY2VzMS5wdXNoKCB2ZXJ0ZXhDb3B5ICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdC8vIGNvbG9yc1xuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBjb2xvcnMyLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgXHRcdFx0Y29sb3JzMS5wdXNoKCBjb2xvcnMyWyBpIF0uY2xvbmUoKSApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHQvLyBmYWNlc1xuXG4gICAgXHRcdGZvciAoIGkgPSAwLCBpbCA9IGZhY2VzMi5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgIFx0XHRcdHZhciBmYWNlID0gZmFjZXMyWyBpIF0sIGZhY2VDb3B5LCBub3JtYWwsIGNvbG9yLFxuICAgIFx0XHRcdGZhY2VWZXJ0ZXhOb3JtYWxzID0gZmFjZS52ZXJ0ZXhOb3JtYWxzLFxuICAgIFx0XHRcdGZhY2VWZXJ0ZXhDb2xvcnMgPSBmYWNlLnZlcnRleENvbG9ycztcblxuICAgIFx0XHRcdGZhY2VDb3B5ID0gbmV3IEZhY2UzKCBmYWNlLmEgKyB2ZXJ0ZXhPZmZzZXQsIGZhY2UuYiArIHZlcnRleE9mZnNldCwgZmFjZS5jICsgdmVydGV4T2Zmc2V0ICk7XG4gICAgXHRcdFx0ZmFjZUNvcHkubm9ybWFsLmNvcHkoIGZhY2Uubm9ybWFsICk7XG5cbiAgICBcdFx0XHRpZiAoIG5vcm1hbE1hdHJpeCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0XHRmYWNlQ29weS5ub3JtYWwuYXBwbHlNYXRyaXgzKCBub3JtYWxNYXRyaXggKS5ub3JtYWxpemUoKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBmYWNlVmVydGV4Tm9ybWFscy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuICAgIFx0XHRcdFx0bm9ybWFsID0gZmFjZVZlcnRleE5vcm1hbHNbIGogXS5jbG9uZSgpO1xuXG4gICAgXHRcdFx0XHRpZiAoIG5vcm1hbE1hdHJpeCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0XHRcdG5vcm1hbC5hcHBseU1hdHJpeDMoIG5vcm1hbE1hdHJpeCApLm5vcm1hbGl6ZSgpO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdGZhY2VDb3B5LnZlcnRleE5vcm1hbHMucHVzaCggbm9ybWFsICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRmYWNlQ29weS5jb2xvci5jb3B5KCBmYWNlLmNvbG9yICk7XG5cbiAgICBcdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gZmFjZVZlcnRleENvbG9ycy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuICAgIFx0XHRcdFx0Y29sb3IgPSBmYWNlVmVydGV4Q29sb3JzWyBqIF07XG4gICAgXHRcdFx0XHRmYWNlQ29weS52ZXJ0ZXhDb2xvcnMucHVzaCggY29sb3IuY2xvbmUoKSApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0ZmFjZUNvcHkubWF0ZXJpYWxJbmRleCA9IGZhY2UubWF0ZXJpYWxJbmRleCArIG1hdGVyaWFsSW5kZXhPZmZzZXQ7XG5cbiAgICBcdFx0XHRmYWNlczEucHVzaCggZmFjZUNvcHkgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0Ly8gdXZzXG5cbiAgICBcdFx0Zm9yICggaSA9IDAsIGlsID0gdXZzMi5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgIFx0XHRcdHZhciB1diA9IHV2czJbIGkgXSwgdXZDb3B5ID0gW107XG5cbiAgICBcdFx0XHRpZiAoIHV2ID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRcdGNvbnRpbnVlO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IHV2Lmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG4gICAgXHRcdFx0XHR1dkNvcHkucHVzaCggdXZbIGogXS5jbG9uZSgpICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHR1dnMxLnB1c2goIHV2Q29weSApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0fSxcblxuICAgIFx0bWVyZ2VNZXNoOiBmdW5jdGlvbiAoIG1lc2ggKSB7XG5cbiAgICBcdFx0aWYgKCAobWVzaCAmJiBtZXNoLmlzTWVzaCkgPT09IGZhbHNlICkge1xuXG4gICAgXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkdlb21ldHJ5Lm1lcmdlTWVzaCgpOiBtZXNoIG5vdCBhbiBpbnN0YW5jZSBvZiBUSFJFRS5NZXNoLicsIG1lc2ggKTtcbiAgICBcdFx0XHRyZXR1cm47XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdG1lc2gubWF0cml4QXV0b1VwZGF0ZSAmJiBtZXNoLnVwZGF0ZU1hdHJpeCgpO1xuXG4gICAgXHRcdHRoaXMubWVyZ2UoIG1lc2guZ2VvbWV0cnksIG1lc2gubWF0cml4ICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdC8qXG4gICAgXHQgKiBDaGVja3MgZm9yIGR1cGxpY2F0ZSB2ZXJ0aWNlcyB3aXRoIGhhc2htYXAuXG4gICAgXHQgKiBEdXBsaWNhdGVkIHZlcnRpY2VzIGFyZSByZW1vdmVkXG4gICAgXHQgKiBhbmQgZmFjZXMnIHZlcnRpY2VzIGFyZSB1cGRhdGVkLlxuICAgIFx0ICovXG5cbiAgICBcdG1lcmdlVmVydGljZXM6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR2YXIgdmVydGljZXNNYXAgPSB7fTsgLy8gSGFzaG1hcCBmb3IgbG9va2luZyB1cCB2ZXJ0aWNlcyBieSBwb3NpdGlvbiBjb29yZGluYXRlcyAoYW5kIG1ha2luZyBzdXJlIHRoZXkgYXJlIHVuaXF1ZSlcbiAgICBcdFx0dmFyIHVuaXF1ZSA9IFtdLCBjaGFuZ2VzID0gW107XG5cbiAgICBcdFx0dmFyIHYsIGtleTtcbiAgICBcdFx0dmFyIHByZWNpc2lvblBvaW50cyA9IDQ7IC8vIG51bWJlciBvZiBkZWNpbWFsIHBvaW50cywgZS5nLiA0IGZvciBlcHNpbG9uIG9mIDAuMDAwMVxuICAgIFx0XHR2YXIgcHJlY2lzaW9uID0gTWF0aC5wb3coIDEwLCBwcmVjaXNpb25Qb2ludHMgKTtcbiAgICBcdFx0dmFyIGksIGlsLCBmYWNlO1xuICAgIFx0XHR2YXIgaW5kaWNlcywgaiwgamw7XG5cbiAgICBcdFx0Zm9yICggaSA9IDAsIGlsID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgIFx0XHRcdHYgPSB0aGlzLnZlcnRpY2VzWyBpIF07XG4gICAgXHRcdFx0a2V5ID0gTWF0aC5yb3VuZCggdi54ICogcHJlY2lzaW9uICkgKyAnXycgKyBNYXRoLnJvdW5kKCB2LnkgKiBwcmVjaXNpb24gKSArICdfJyArIE1hdGgucm91bmQoIHYueiAqIHByZWNpc2lvbiApO1xuXG4gICAgXHRcdFx0aWYgKCB2ZXJ0aWNlc01hcFsga2V5IF0gPT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0dmVydGljZXNNYXBbIGtleSBdID0gaTtcbiAgICBcdFx0XHRcdHVuaXF1ZS5wdXNoKCB0aGlzLnZlcnRpY2VzWyBpIF0gKTtcbiAgICBcdFx0XHRcdGNoYW5nZXNbIGkgXSA9IHVuaXF1ZS5sZW5ndGggLSAxO1xuXG4gICAgXHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0Ly9jb25zb2xlLmxvZygnRHVwbGljYXRlIHZlcnRleCBmb3VuZC4gJywgaSwgJyBjb3VsZCBiZSB1c2luZyAnLCB2ZXJ0aWNlc01hcFtrZXldKTtcbiAgICBcdFx0XHRcdGNoYW5nZXNbIGkgXSA9IGNoYW5nZXNbIHZlcnRpY2VzTWFwWyBrZXkgXSBdO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuXG4gICAgXHRcdC8vIGlmIGZhY2VzIGFyZSBjb21wbGV0ZWx5IGRlZ2VuZXJhdGUgYWZ0ZXIgbWVyZ2luZyB2ZXJ0aWNlcywgd2VcbiAgICBcdFx0Ly8gaGF2ZSB0byByZW1vdmUgdGhlbSBmcm9tIHRoZSBnZW9tZXRyeS5cbiAgICBcdFx0dmFyIGZhY2VJbmRpY2VzVG9SZW1vdmUgPSBbXTtcblxuICAgIFx0XHRmb3IgKCBpID0gMCwgaWwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgXHRcdFx0ZmFjZSA9IHRoaXMuZmFjZXNbIGkgXTtcblxuICAgIFx0XHRcdGZhY2UuYSA9IGNoYW5nZXNbIGZhY2UuYSBdO1xuICAgIFx0XHRcdGZhY2UuYiA9IGNoYW5nZXNbIGZhY2UuYiBdO1xuICAgIFx0XHRcdGZhY2UuYyA9IGNoYW5nZXNbIGZhY2UuYyBdO1xuXG4gICAgXHRcdFx0aW5kaWNlcyA9IFsgZmFjZS5hLCBmYWNlLmIsIGZhY2UuYyBdO1xuXG4gICAgXHRcdFx0dmFyIGR1cEluZGV4ID0gLSAxO1xuXG4gICAgXHRcdFx0Ly8gaWYgYW55IGR1cGxpY2F0ZSB2ZXJ0aWNlcyBhcmUgZm91bmQgaW4gYSBGYWNlM1xuICAgIFx0XHRcdC8vIHdlIGhhdmUgdG8gcmVtb3ZlIHRoZSBmYWNlIGFzIG5vdGhpbmcgY2FuIGJlIHNhdmVkXG4gICAgXHRcdFx0Zm9yICggdmFyIG4gPSAwOyBuIDwgMzsgbiArKyApIHtcblxuICAgIFx0XHRcdFx0aWYgKCBpbmRpY2VzWyBuIF0gPT09IGluZGljZXNbICggbiArIDEgKSAlIDMgXSApIHtcblxuICAgIFx0XHRcdFx0XHRkdXBJbmRleCA9IG47XG4gICAgXHRcdFx0XHRcdGZhY2VJbmRpY2VzVG9SZW1vdmUucHVzaCggaSApO1xuICAgIFx0XHRcdFx0XHRicmVhaztcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHRmb3IgKCBpID0gZmFjZUluZGljZXNUb1JlbW92ZS5sZW5ndGggLSAxOyBpID49IDA7IGkgLS0gKSB7XG5cbiAgICBcdFx0XHR2YXIgaWR4ID0gZmFjZUluZGljZXNUb1JlbW92ZVsgaSBdO1xuXG4gICAgXHRcdFx0dGhpcy5mYWNlcy5zcGxpY2UoIGlkeCwgMSApO1xuXG4gICAgXHRcdFx0Zm9yICggaiA9IDAsIGpsID0gdGhpcy5mYWNlVmVydGV4VXZzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG4gICAgXHRcdFx0XHR0aGlzLmZhY2VWZXJ0ZXhVdnNbIGogXS5zcGxpY2UoIGlkeCwgMSApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHQvLyBVc2UgdW5pcXVlIHNldCBvZiB2ZXJ0aWNlc1xuXG4gICAgXHRcdHZhciBkaWZmID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGggLSB1bmlxdWUubGVuZ3RoO1xuICAgIFx0XHR0aGlzLnZlcnRpY2VzID0gdW5pcXVlO1xuICAgIFx0XHRyZXR1cm4gZGlmZjtcblxuICAgIFx0fSxcblxuICAgIFx0c29ydEZhY2VzQnlNYXRlcmlhbEluZGV4OiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dmFyIGZhY2VzID0gdGhpcy5mYWNlcztcbiAgICBcdFx0dmFyIGxlbmd0aCA9IGZhY2VzLmxlbmd0aDtcblxuICAgIFx0XHQvLyB0YWcgZmFjZXNcblxuICAgIFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKysgKSB7XG5cbiAgICBcdFx0XHRmYWNlc1sgaSBdLl9pZCA9IGk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdC8vIHNvcnQgZmFjZXNcblxuICAgIFx0XHRmdW5jdGlvbiBtYXRlcmlhbEluZGV4U29ydCggYSwgYiApIHtcblxuICAgIFx0XHRcdHJldHVybiBhLm1hdGVyaWFsSW5kZXggLSBiLm1hdGVyaWFsSW5kZXg7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGZhY2VzLnNvcnQoIG1hdGVyaWFsSW5kZXhTb3J0ICk7XG5cbiAgICBcdFx0Ly8gc29ydCB1dnNcblxuICAgIFx0XHR2YXIgdXZzMSA9IHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdO1xuICAgIFx0XHR2YXIgdXZzMiA9IHRoaXMuZmFjZVZlcnRleFV2c1sgMSBdO1xuXG4gICAgXHRcdHZhciBuZXdVdnMxLCBuZXdVdnMyO1xuXG4gICAgXHRcdGlmICggdXZzMSAmJiB1dnMxLmxlbmd0aCA9PT0gbGVuZ3RoICkgbmV3VXZzMSA9IFtdO1xuICAgIFx0XHRpZiAoIHV2czIgJiYgdXZzMi5sZW5ndGggPT09IGxlbmd0aCApIG5ld1V2czIgPSBbXTtcblxuICAgIFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKysgKSB7XG5cbiAgICBcdFx0XHR2YXIgaWQgPSBmYWNlc1sgaSBdLl9pZDtcblxuICAgIFx0XHRcdGlmICggbmV3VXZzMSApIG5ld1V2czEucHVzaCggdXZzMVsgaWQgXSApO1xuICAgIFx0XHRcdGlmICggbmV3VXZzMiApIG5ld1V2czIucHVzaCggdXZzMlsgaWQgXSApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoIG5ld1V2czEgKSB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXSA9IG5ld1V2czE7XG4gICAgXHRcdGlmICggbmV3VXZzMiApIHRoaXMuZmFjZVZlcnRleFV2c1sgMSBdID0gbmV3VXZzMjtcblxuICAgIFx0fSxcblxuICAgIFx0dG9KU09OOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dmFyIGRhdGEgPSB7XG4gICAgXHRcdFx0bWV0YWRhdGE6IHtcbiAgICBcdFx0XHRcdHZlcnNpb246IDQuNCxcbiAgICBcdFx0XHRcdHR5cGU6ICdHZW9tZXRyeScsXG4gICAgXHRcdFx0XHRnZW5lcmF0b3I6ICdHZW9tZXRyeS50b0pTT04nXG4gICAgXHRcdFx0fVxuICAgIFx0XHR9O1xuXG4gICAgXHRcdC8vIHN0YW5kYXJkIEdlb21ldHJ5IHNlcmlhbGl6YXRpb25cblxuICAgIFx0XHRkYXRhLnV1aWQgPSB0aGlzLnV1aWQ7XG4gICAgXHRcdGRhdGEudHlwZSA9IHRoaXMudHlwZTtcbiAgICBcdFx0aWYgKCB0aGlzLm5hbWUgIT09ICcnICkgZGF0YS5uYW1lID0gdGhpcy5uYW1lO1xuXG4gICAgXHRcdGlmICggdGhpcy5wYXJhbWV0ZXJzICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHR2YXIgcGFyYW1ldGVycyA9IHRoaXMucGFyYW1ldGVycztcblxuICAgIFx0XHRcdGZvciAoIHZhciBrZXkgaW4gcGFyYW1ldGVycyApIHtcblxuICAgIFx0XHRcdFx0aWYgKCBwYXJhbWV0ZXJzWyBrZXkgXSAhPT0gdW5kZWZpbmVkICkgZGF0YVsga2V5IF0gPSBwYXJhbWV0ZXJzWyBrZXkgXTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdHJldHVybiBkYXRhO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHR2YXIgdmVydGljZXMgPSBbXTtcblxuICAgIFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgaSArKyApIHtcblxuICAgIFx0XHRcdHZhciB2ZXJ0ZXggPSB0aGlzLnZlcnRpY2VzWyBpIF07XG4gICAgXHRcdFx0dmVydGljZXMucHVzaCggdmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueiApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHR2YXIgZmFjZXMgPSBbXTtcbiAgICBcdFx0dmFyIG5vcm1hbHMgPSBbXTtcbiAgICBcdFx0dmFyIG5vcm1hbHNIYXNoID0ge307XG4gICAgXHRcdHZhciBjb2xvcnMgPSBbXTtcbiAgICBcdFx0dmFyIGNvbG9yc0hhc2ggPSB7fTtcbiAgICBcdFx0dmFyIHV2cyA9IFtdO1xuICAgIFx0XHR2YXIgdXZzSGFzaCA9IHt9O1xuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMuZmFjZXMubGVuZ3RoOyBpICsrICkge1xuXG4gICAgXHRcdFx0dmFyIGZhY2UgPSB0aGlzLmZhY2VzWyBpIF07XG5cbiAgICBcdFx0XHR2YXIgaGFzTWF0ZXJpYWwgPSB0cnVlO1xuICAgIFx0XHRcdHZhciBoYXNGYWNlVXYgPSBmYWxzZTsgLy8gZGVwcmVjYXRlZFxuICAgIFx0XHRcdHZhciBoYXNGYWNlVmVydGV4VXYgPSB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXVsgaSBdICE9PSB1bmRlZmluZWQ7XG4gICAgXHRcdFx0dmFyIGhhc0ZhY2VOb3JtYWwgPSBmYWNlLm5vcm1hbC5sZW5ndGgoKSA+IDA7XG4gICAgXHRcdFx0dmFyIGhhc0ZhY2VWZXJ0ZXhOb3JtYWwgPSBmYWNlLnZlcnRleE5vcm1hbHMubGVuZ3RoID4gMDtcbiAgICBcdFx0XHR2YXIgaGFzRmFjZUNvbG9yID0gZmFjZS5jb2xvci5yICE9PSAxIHx8IGZhY2UuY29sb3IuZyAhPT0gMSB8fCBmYWNlLmNvbG9yLmIgIT09IDE7XG4gICAgXHRcdFx0dmFyIGhhc0ZhY2VWZXJ0ZXhDb2xvciA9IGZhY2UudmVydGV4Q29sb3JzLmxlbmd0aCA+IDA7XG5cbiAgICBcdFx0XHR2YXIgZmFjZVR5cGUgPSAwO1xuXG4gICAgXHRcdFx0ZmFjZVR5cGUgPSBzZXRCaXQoIGZhY2VUeXBlLCAwLCAwICk7IC8vIGlzUXVhZFxuICAgIFx0XHRcdGZhY2VUeXBlID0gc2V0Qml0KCBmYWNlVHlwZSwgMSwgaGFzTWF0ZXJpYWwgKTtcbiAgICBcdFx0XHRmYWNlVHlwZSA9IHNldEJpdCggZmFjZVR5cGUsIDIsIGhhc0ZhY2VVdiApO1xuICAgIFx0XHRcdGZhY2VUeXBlID0gc2V0Qml0KCBmYWNlVHlwZSwgMywgaGFzRmFjZVZlcnRleFV2ICk7XG4gICAgXHRcdFx0ZmFjZVR5cGUgPSBzZXRCaXQoIGZhY2VUeXBlLCA0LCBoYXNGYWNlTm9ybWFsICk7XG4gICAgXHRcdFx0ZmFjZVR5cGUgPSBzZXRCaXQoIGZhY2VUeXBlLCA1LCBoYXNGYWNlVmVydGV4Tm9ybWFsICk7XG4gICAgXHRcdFx0ZmFjZVR5cGUgPSBzZXRCaXQoIGZhY2VUeXBlLCA2LCBoYXNGYWNlQ29sb3IgKTtcbiAgICBcdFx0XHRmYWNlVHlwZSA9IHNldEJpdCggZmFjZVR5cGUsIDcsIGhhc0ZhY2VWZXJ0ZXhDb2xvciApO1xuXG4gICAgXHRcdFx0ZmFjZXMucHVzaCggZmFjZVR5cGUgKTtcbiAgICBcdFx0XHRmYWNlcy5wdXNoKCBmYWNlLmEsIGZhY2UuYiwgZmFjZS5jICk7XG4gICAgXHRcdFx0ZmFjZXMucHVzaCggZmFjZS5tYXRlcmlhbEluZGV4ICk7XG5cbiAgICBcdFx0XHRpZiAoIGhhc0ZhY2VWZXJ0ZXhVdiApIHtcblxuICAgIFx0XHRcdFx0dmFyIGZhY2VWZXJ0ZXhVdnMgPSB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXVsgaSBdO1xuXG4gICAgXHRcdFx0XHRmYWNlcy5wdXNoKFxuICAgIFx0XHRcdFx0XHRnZXRVdkluZGV4KCBmYWNlVmVydGV4VXZzWyAwIF0gKSxcbiAgICBcdFx0XHRcdFx0Z2V0VXZJbmRleCggZmFjZVZlcnRleFV2c1sgMSBdICksXG4gICAgXHRcdFx0XHRcdGdldFV2SW5kZXgoIGZhY2VWZXJ0ZXhVdnNbIDIgXSApXG4gICAgXHRcdFx0XHQpO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0aWYgKCBoYXNGYWNlTm9ybWFsICkge1xuXG4gICAgXHRcdFx0XHRmYWNlcy5wdXNoKCBnZXROb3JtYWxJbmRleCggZmFjZS5ub3JtYWwgKSApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0aWYgKCBoYXNGYWNlVmVydGV4Tm9ybWFsICkge1xuXG4gICAgXHRcdFx0XHR2YXIgdmVydGV4Tm9ybWFscyA9IGZhY2UudmVydGV4Tm9ybWFscztcblxuICAgIFx0XHRcdFx0ZmFjZXMucHVzaChcbiAgICBcdFx0XHRcdFx0Z2V0Tm9ybWFsSW5kZXgoIHZlcnRleE5vcm1hbHNbIDAgXSApLFxuICAgIFx0XHRcdFx0XHRnZXROb3JtYWxJbmRleCggdmVydGV4Tm9ybWFsc1sgMSBdICksXG4gICAgXHRcdFx0XHRcdGdldE5vcm1hbEluZGV4KCB2ZXJ0ZXhOb3JtYWxzWyAyIF0gKVxuICAgIFx0XHRcdFx0KTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGlmICggaGFzRmFjZUNvbG9yICkge1xuXG4gICAgXHRcdFx0XHRmYWNlcy5wdXNoKCBnZXRDb2xvckluZGV4KCBmYWNlLmNvbG9yICkgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGlmICggaGFzRmFjZVZlcnRleENvbG9yICkge1xuXG4gICAgXHRcdFx0XHR2YXIgdmVydGV4Q29sb3JzID0gZmFjZS52ZXJ0ZXhDb2xvcnM7XG5cbiAgICBcdFx0XHRcdGZhY2VzLnB1c2goXG4gICAgXHRcdFx0XHRcdGdldENvbG9ySW5kZXgoIHZlcnRleENvbG9yc1sgMCBdICksXG4gICAgXHRcdFx0XHRcdGdldENvbG9ySW5kZXgoIHZlcnRleENvbG9yc1sgMSBdICksXG4gICAgXHRcdFx0XHRcdGdldENvbG9ySW5kZXgoIHZlcnRleENvbG9yc1sgMiBdIClcbiAgICBcdFx0XHRcdCk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGZ1bmN0aW9uIHNldEJpdCggdmFsdWUsIHBvc2l0aW9uLCBlbmFibGVkICkge1xuXG4gICAgXHRcdFx0cmV0dXJuIGVuYWJsZWQgPyB2YWx1ZSB8ICggMSA8PCBwb3NpdGlvbiApIDogdmFsdWUgJiAoIH4gKCAxIDw8IHBvc2l0aW9uICkgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0ZnVuY3Rpb24gZ2V0Tm9ybWFsSW5kZXgoIG5vcm1hbCApIHtcblxuICAgIFx0XHRcdHZhciBoYXNoID0gbm9ybWFsLngudG9TdHJpbmcoKSArIG5vcm1hbC55LnRvU3RyaW5nKCkgKyBub3JtYWwuei50b1N0cmluZygpO1xuXG4gICAgXHRcdFx0aWYgKCBub3JtYWxzSGFzaFsgaGFzaCBdICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRcdHJldHVybiBub3JtYWxzSGFzaFsgaGFzaCBdO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0bm9ybWFsc0hhc2hbIGhhc2ggXSA9IG5vcm1hbHMubGVuZ3RoIC8gMztcbiAgICBcdFx0XHRub3JtYWxzLnB1c2goIG5vcm1hbC54LCBub3JtYWwueSwgbm9ybWFsLnogKTtcblxuICAgIFx0XHRcdHJldHVybiBub3JtYWxzSGFzaFsgaGFzaCBdO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRmdW5jdGlvbiBnZXRDb2xvckluZGV4KCBjb2xvciApIHtcblxuICAgIFx0XHRcdHZhciBoYXNoID0gY29sb3Iuci50b1N0cmluZygpICsgY29sb3IuZy50b1N0cmluZygpICsgY29sb3IuYi50b1N0cmluZygpO1xuXG4gICAgXHRcdFx0aWYgKCBjb2xvcnNIYXNoWyBoYXNoIF0gIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0cmV0dXJuIGNvbG9yc0hhc2hbIGhhc2ggXTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGNvbG9yc0hhc2hbIGhhc2ggXSA9IGNvbG9ycy5sZW5ndGg7XG4gICAgXHRcdFx0Y29sb3JzLnB1c2goIGNvbG9yLmdldEhleCgpICk7XG5cbiAgICBcdFx0XHRyZXR1cm4gY29sb3JzSGFzaFsgaGFzaCBdO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRmdW5jdGlvbiBnZXRVdkluZGV4KCB1diApIHtcblxuICAgIFx0XHRcdHZhciBoYXNoID0gdXYueC50b1N0cmluZygpICsgdXYueS50b1N0cmluZygpO1xuXG4gICAgXHRcdFx0aWYgKCB1dnNIYXNoWyBoYXNoIF0gIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0cmV0dXJuIHV2c0hhc2hbIGhhc2ggXTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdHV2c0hhc2hbIGhhc2ggXSA9IHV2cy5sZW5ndGggLyAyO1xuICAgIFx0XHRcdHV2cy5wdXNoKCB1di54LCB1di55ICk7XG5cbiAgICBcdFx0XHRyZXR1cm4gdXZzSGFzaFsgaGFzaCBdO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRkYXRhLmRhdGEgPSB7fTtcblxuICAgIFx0XHRkYXRhLmRhdGEudmVydGljZXMgPSB2ZXJ0aWNlcztcbiAgICBcdFx0ZGF0YS5kYXRhLm5vcm1hbHMgPSBub3JtYWxzO1xuICAgIFx0XHRpZiAoIGNvbG9ycy5sZW5ndGggPiAwICkgZGF0YS5kYXRhLmNvbG9ycyA9IGNvbG9ycztcbiAgICBcdFx0aWYgKCB1dnMubGVuZ3RoID4gMCApIGRhdGEuZGF0YS51dnMgPSBbIHV2cyBdOyAvLyB0ZW1wb3JhbCBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gICAgXHRcdGRhdGEuZGF0YS5mYWNlcyA9IGZhY2VzO1xuXG4gICAgXHRcdHJldHVybiBkYXRhO1xuXG4gICAgXHR9LFxuXG4gICAgXHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdC8qXG4gICAgXHRcdC8vIEhhbmRsZSBwcmltaXRpdmVzXG5cbiAgICBcdFx0dmFyIHBhcmFtZXRlcnMgPSB0aGlzLnBhcmFtZXRlcnM7XG5cbiAgICBcdFx0aWYgKCBwYXJhbWV0ZXJzICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHR2YXIgdmFsdWVzID0gW107XG5cbiAgICBcdFx0XHRmb3IgKCB2YXIga2V5IGluIHBhcmFtZXRlcnMgKSB7XG5cbiAgICBcdFx0XHRcdHZhbHVlcy5wdXNoKCBwYXJhbWV0ZXJzWyBrZXkgXSApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0dmFyIGdlb21ldHJ5ID0gT2JqZWN0LmNyZWF0ZSggdGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgKTtcbiAgICBcdFx0XHR0aGlzLmNvbnN0cnVjdG9yLmFwcGx5KCBnZW9tZXRyeSwgdmFsdWVzICk7XG4gICAgXHRcdFx0cmV0dXJuIGdlb21ldHJ5O1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG4gICAgXHRcdCovXG5cbiAgICBcdFx0cmV0dXJuIG5ldyBHZW9tZXRyeSgpLmNvcHkoIHRoaXMgKTtcblxuICAgIFx0fSxcblxuICAgIFx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cbiAgICBcdFx0dGhpcy52ZXJ0aWNlcyA9IFtdO1xuICAgIFx0XHR0aGlzLmZhY2VzID0gW107XG4gICAgXHRcdHRoaXMuZmFjZVZlcnRleFV2cyA9IFsgW10gXTtcbiAgICBcdFx0dGhpcy5jb2xvcnMgPSBbXTtcblxuICAgIFx0XHR2YXIgdmVydGljZXMgPSBzb3VyY2UudmVydGljZXM7XG5cbiAgICBcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHZlcnRpY2VzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgXHRcdFx0dGhpcy52ZXJ0aWNlcy5wdXNoKCB2ZXJ0aWNlc1sgaSBdLmNsb25lKCkgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0dmFyIGNvbG9ycyA9IHNvdXJjZS5jb2xvcnM7XG5cbiAgICBcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IGNvbG9ycy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgIFx0XHRcdHRoaXMuY29sb3JzLnB1c2goIGNvbG9yc1sgaSBdLmNsb25lKCkgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0dmFyIGZhY2VzID0gc291cmNlLmZhY2VzO1xuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBmYWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgIFx0XHRcdHRoaXMuZmFjZXMucHVzaCggZmFjZXNbIGkgXS5jbG9uZSgpICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBzb3VyY2UuZmFjZVZlcnRleFV2cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgIFx0XHRcdHZhciBmYWNlVmVydGV4VXZzID0gc291cmNlLmZhY2VWZXJ0ZXhVdnNbIGkgXTtcblxuICAgIFx0XHRcdGlmICggdGhpcy5mYWNlVmVydGV4VXZzWyBpIF0gPT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0dGhpcy5mYWNlVmVydGV4VXZzWyBpIF0gPSBbXTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBmYWNlVmVydGV4VXZzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG4gICAgXHRcdFx0XHR2YXIgdXZzID0gZmFjZVZlcnRleFV2c1sgaiBdLCB1dnNDb3B5ID0gW107XG5cbiAgICBcdFx0XHRcdGZvciAoIHZhciBrID0gMCwga2wgPSB1dnMubGVuZ3RoOyBrIDwga2w7IGsgKysgKSB7XG5cbiAgICBcdFx0XHRcdFx0dmFyIHV2ID0gdXZzWyBrIF07XG5cbiAgICBcdFx0XHRcdFx0dXZzQ29weS5wdXNoKCB1di5jbG9uZSgpICk7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0dGhpcy5mYWNlVmVydGV4VXZzWyBpIF0ucHVzaCggdXZzQ29weSApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0ZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHRoaXMuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAnZGlzcG9zZScgfSApO1xuXG4gICAgXHR9XG5cbiAgICB9ICk7XG5cbiAgICB2YXIgY291bnQkMyA9IDA7XG4gICAgZnVuY3Rpb24gR2VvbWV0cnlJZENvdW50KCkgeyByZXR1cm4gY291bnQkMysrOyB9O1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIERpcmVjdEdlb21ldHJ5KCkge1xuXG4gICAgXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsICdpZCcsIHsgdmFsdWU6IEdlb21ldHJ5SWRDb3VudCgpIH0gKTtcblxuICAgIFx0dGhpcy51dWlkID0gZXhwb3J0cy5NYXRoLmdlbmVyYXRlVVVJRCgpO1xuXG4gICAgXHR0aGlzLm5hbWUgPSAnJztcbiAgICBcdHRoaXMudHlwZSA9ICdEaXJlY3RHZW9tZXRyeSc7XG5cbiAgICBcdHRoaXMuaW5kaWNlcyA9IFtdO1xuICAgIFx0dGhpcy52ZXJ0aWNlcyA9IFtdO1xuICAgIFx0dGhpcy5ub3JtYWxzID0gW107XG4gICAgXHR0aGlzLmNvbG9ycyA9IFtdO1xuICAgIFx0dGhpcy51dnMgPSBbXTtcbiAgICBcdHRoaXMudXZzMiA9IFtdO1xuXG4gICAgXHR0aGlzLmdyb3VwcyA9IFtdO1xuXG4gICAgXHR0aGlzLm1vcnBoVGFyZ2V0cyA9IHt9O1xuXG4gICAgXHR0aGlzLnNraW5XZWlnaHRzID0gW107XG4gICAgXHR0aGlzLnNraW5JbmRpY2VzID0gW107XG5cbiAgICBcdC8vIHRoaXMubGluZURpc3RhbmNlcyA9IFtdO1xuXG4gICAgXHR0aGlzLmJvdW5kaW5nQm94ID0gbnVsbDtcbiAgICBcdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBudWxsO1xuXG4gICAgXHQvLyB1cGRhdGUgZmxhZ3NcblxuICAgIFx0dGhpcy52ZXJ0aWNlc05lZWRVcGRhdGUgPSBmYWxzZTtcbiAgICBcdHRoaXMubm9ybWFsc05lZWRVcGRhdGUgPSBmYWxzZTtcbiAgICBcdHRoaXMuY29sb3JzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuICAgIFx0dGhpcy51dnNOZWVkVXBkYXRlID0gZmFsc2U7XG4gICAgXHR0aGlzLmdyb3Vwc05lZWRVcGRhdGUgPSBmYWxzZTtcblxuICAgIH1cblxuICAgIE9iamVjdC5hc3NpZ24oIERpcmVjdEdlb21ldHJ5LnByb3RvdHlwZSwgRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZSwge1xuXG4gICAgXHRjb21wdXRlQm91bmRpbmdCb3g6IEdlb21ldHJ5LnByb3RvdHlwZS5jb21wdXRlQm91bmRpbmdCb3gsXG4gICAgXHRjb21wdXRlQm91bmRpbmdTcGhlcmU6IEdlb21ldHJ5LnByb3RvdHlwZS5jb21wdXRlQm91bmRpbmdTcGhlcmUsXG5cbiAgICBcdGNvbXB1dGVGYWNlTm9ybWFsczogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkRpcmVjdEdlb21ldHJ5OiBjb21wdXRlRmFjZU5vcm1hbHMoKSBpcyBub3QgYSBtZXRob2Qgb2YgdGhpcyB0eXBlIG9mIGdlb21ldHJ5LicgKTtcblxuICAgIFx0fSxcblxuICAgIFx0Y29tcHV0ZVZlcnRleE5vcm1hbHM6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5EaXJlY3RHZW9tZXRyeTogY29tcHV0ZVZlcnRleE5vcm1hbHMoKSBpcyBub3QgYSBtZXRob2Qgb2YgdGhpcyB0eXBlIG9mIGdlb21ldHJ5LicgKTtcblxuICAgIFx0fSxcblxuICAgIFx0Y29tcHV0ZUdyb3VwczogZnVuY3Rpb24gKCBnZW9tZXRyeSApIHtcblxuICAgIFx0XHR2YXIgZ3JvdXA7XG4gICAgXHRcdHZhciBncm91cHMgPSBbXTtcbiAgICBcdFx0dmFyIG1hdGVyaWFsSW5kZXg7XG5cbiAgICBcdFx0dmFyIGZhY2VzID0gZ2VvbWV0cnkuZmFjZXM7XG5cbiAgICBcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZmFjZXMubGVuZ3RoOyBpICsrICkge1xuXG4gICAgXHRcdFx0dmFyIGZhY2UgPSBmYWNlc1sgaSBdO1xuXG4gICAgXHRcdFx0Ly8gbWF0ZXJpYWxzXG5cbiAgICBcdFx0XHRpZiAoIGZhY2UubWF0ZXJpYWxJbmRleCAhPT0gbWF0ZXJpYWxJbmRleCApIHtcblxuICAgIFx0XHRcdFx0bWF0ZXJpYWxJbmRleCA9IGZhY2UubWF0ZXJpYWxJbmRleDtcblxuICAgIFx0XHRcdFx0aWYgKCBncm91cCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0XHRcdGdyb3VwLmNvdW50ID0gKCBpICogMyApIC0gZ3JvdXAuc3RhcnQ7XG4gICAgXHRcdFx0XHRcdGdyb3Vwcy5wdXNoKCBncm91cCApO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdGdyb3VwID0ge1xuICAgIFx0XHRcdFx0XHRzdGFydDogaSAqIDMsXG4gICAgXHRcdFx0XHRcdG1hdGVyaWFsSW5kZXg6IG1hdGVyaWFsSW5kZXhcbiAgICBcdFx0XHRcdH07XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGlmICggZ3JvdXAgIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdGdyb3VwLmNvdW50ID0gKCBpICogMyApIC0gZ3JvdXAuc3RhcnQ7XG4gICAgXHRcdFx0Z3JvdXBzLnB1c2goIGdyb3VwICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHRoaXMuZ3JvdXBzID0gZ3JvdXBzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRmcm9tR2VvbWV0cnk6IGZ1bmN0aW9uICggZ2VvbWV0cnkgKSB7XG5cbiAgICBcdFx0dmFyIGZhY2VzID0gZ2VvbWV0cnkuZmFjZXM7XG4gICAgXHRcdHZhciB2ZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzO1xuICAgIFx0XHR2YXIgZmFjZVZlcnRleFV2cyA9IGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnM7XG5cbiAgICBcdFx0dmFyIGhhc0ZhY2VWZXJ0ZXhVdiA9IGZhY2VWZXJ0ZXhVdnNbIDAgXSAmJiBmYWNlVmVydGV4VXZzWyAwIF0ubGVuZ3RoID4gMDtcbiAgICBcdFx0dmFyIGhhc0ZhY2VWZXJ0ZXhVdjIgPSBmYWNlVmVydGV4VXZzWyAxIF0gJiYgZmFjZVZlcnRleFV2c1sgMSBdLmxlbmd0aCA+IDA7XG5cbiAgICBcdFx0Ly8gbW9ycGhzXG5cbiAgICBcdFx0dmFyIG1vcnBoVGFyZ2V0cyA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0cztcbiAgICBcdFx0dmFyIG1vcnBoVGFyZ2V0c0xlbmd0aCA9IG1vcnBoVGFyZ2V0cy5sZW5ndGg7XG5cbiAgICBcdFx0dmFyIG1vcnBoVGFyZ2V0c1Bvc2l0aW9uO1xuXG4gICAgXHRcdGlmICggbW9ycGhUYXJnZXRzTGVuZ3RoID4gMCApIHtcblxuICAgIFx0XHRcdG1vcnBoVGFyZ2V0c1Bvc2l0aW9uID0gW107XG5cbiAgICBcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBtb3JwaFRhcmdldHNMZW5ndGg7IGkgKysgKSB7XG5cbiAgICBcdFx0XHRcdG1vcnBoVGFyZ2V0c1Bvc2l0aW9uWyBpIF0gPSBbXTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdHRoaXMubW9ycGhUYXJnZXRzLnBvc2l0aW9uID0gbW9ycGhUYXJnZXRzUG9zaXRpb247XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHZhciBtb3JwaE5vcm1hbHMgPSBnZW9tZXRyeS5tb3JwaE5vcm1hbHM7XG4gICAgXHRcdHZhciBtb3JwaE5vcm1hbHNMZW5ndGggPSBtb3JwaE5vcm1hbHMubGVuZ3RoO1xuXG4gICAgXHRcdHZhciBtb3JwaFRhcmdldHNOb3JtYWw7XG5cbiAgICBcdFx0aWYgKCBtb3JwaE5vcm1hbHNMZW5ndGggPiAwICkge1xuXG4gICAgXHRcdFx0bW9ycGhUYXJnZXRzTm9ybWFsID0gW107XG5cbiAgICBcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBtb3JwaE5vcm1hbHNMZW5ndGg7IGkgKysgKSB7XG5cbiAgICBcdFx0XHRcdG1vcnBoVGFyZ2V0c05vcm1hbFsgaSBdID0gW107XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHR0aGlzLm1vcnBoVGFyZ2V0cy5ub3JtYWwgPSBtb3JwaFRhcmdldHNOb3JtYWw7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdC8vIHNraW5zXG5cbiAgICBcdFx0dmFyIHNraW5JbmRpY2VzID0gZ2VvbWV0cnkuc2tpbkluZGljZXM7XG4gICAgXHRcdHZhciBza2luV2VpZ2h0cyA9IGdlb21ldHJ5LnNraW5XZWlnaHRzO1xuXG4gICAgXHRcdHZhciBoYXNTa2luSW5kaWNlcyA9IHNraW5JbmRpY2VzLmxlbmd0aCA9PT0gdmVydGljZXMubGVuZ3RoO1xuICAgIFx0XHR2YXIgaGFzU2tpbldlaWdodHMgPSBza2luV2VpZ2h0cy5sZW5ndGggPT09IHZlcnRpY2VzLmxlbmd0aDtcblxuICAgIFx0XHQvL1xuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGZhY2VzLmxlbmd0aDsgaSArKyApIHtcblxuICAgIFx0XHRcdHZhciBmYWNlID0gZmFjZXNbIGkgXTtcblxuICAgIFx0XHRcdHRoaXMudmVydGljZXMucHVzaCggdmVydGljZXNbIGZhY2UuYSBdLCB2ZXJ0aWNlc1sgZmFjZS5iIF0sIHZlcnRpY2VzWyBmYWNlLmMgXSApO1xuXG4gICAgXHRcdFx0dmFyIHZlcnRleE5vcm1hbHMgPSBmYWNlLnZlcnRleE5vcm1hbHM7XG5cbiAgICBcdFx0XHRpZiAoIHZlcnRleE5vcm1hbHMubGVuZ3RoID09PSAzICkge1xuXG4gICAgXHRcdFx0XHR0aGlzLm5vcm1hbHMucHVzaCggdmVydGV4Tm9ybWFsc1sgMCBdLCB2ZXJ0ZXhOb3JtYWxzWyAxIF0sIHZlcnRleE5vcm1hbHNbIDIgXSApO1xuXG4gICAgXHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0dmFyIG5vcm1hbCA9IGZhY2Uubm9ybWFsO1xuXG4gICAgXHRcdFx0XHR0aGlzLm5vcm1hbHMucHVzaCggbm9ybWFsLCBub3JtYWwsIG5vcm1hbCApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0dmFyIHZlcnRleENvbG9ycyA9IGZhY2UudmVydGV4Q29sb3JzO1xuXG4gICAgXHRcdFx0aWYgKCB2ZXJ0ZXhDb2xvcnMubGVuZ3RoID09PSAzICkge1xuXG4gICAgXHRcdFx0XHR0aGlzLmNvbG9ycy5wdXNoKCB2ZXJ0ZXhDb2xvcnNbIDAgXSwgdmVydGV4Q29sb3JzWyAxIF0sIHZlcnRleENvbG9yc1sgMiBdICk7XG5cbiAgICBcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHR2YXIgY29sb3IgPSBmYWNlLmNvbG9yO1xuXG4gICAgXHRcdFx0XHR0aGlzLmNvbG9ycy5wdXNoKCBjb2xvciwgY29sb3IsIGNvbG9yICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRpZiAoIGhhc0ZhY2VWZXJ0ZXhVdiA9PT0gdHJ1ZSApIHtcblxuICAgIFx0XHRcdFx0dmFyIHZlcnRleFV2cyA9IGZhY2VWZXJ0ZXhVdnNbIDAgXVsgaSBdO1xuXG4gICAgXHRcdFx0XHRpZiAoIHZlcnRleFV2cyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0XHRcdHRoaXMudXZzLnB1c2goIHZlcnRleFV2c1sgMCBdLCB2ZXJ0ZXhVdnNbIDEgXSwgdmVydGV4VXZzWyAyIF0gKTtcblxuICAgIFx0XHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5EaXJlY3RHZW9tZXRyeS5mcm9tR2VvbWV0cnkoKTogVW5kZWZpbmVkIHZlcnRleFV2ICcsIGkgKTtcblxuICAgIFx0XHRcdFx0XHR0aGlzLnV2cy5wdXNoKCBuZXcgVmVjdG9yMigpLCBuZXcgVmVjdG9yMigpLCBuZXcgVmVjdG9yMigpICk7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGlmICggaGFzRmFjZVZlcnRleFV2MiA9PT0gdHJ1ZSApIHtcblxuICAgIFx0XHRcdFx0dmFyIHZlcnRleFV2cyA9IGZhY2VWZXJ0ZXhVdnNbIDEgXVsgaSBdO1xuXG4gICAgXHRcdFx0XHRpZiAoIHZlcnRleFV2cyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0XHRcdHRoaXMudXZzMi5wdXNoKCB2ZXJ0ZXhVdnNbIDAgXSwgdmVydGV4VXZzWyAxIF0sIHZlcnRleFV2c1sgMiBdICk7XG5cbiAgICBcdFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuRGlyZWN0R2VvbWV0cnkuZnJvbUdlb21ldHJ5KCk6IFVuZGVmaW5lZCB2ZXJ0ZXhVdjIgJywgaSApO1xuXG4gICAgXHRcdFx0XHRcdHRoaXMudXZzMi5wdXNoKCBuZXcgVmVjdG9yMigpLCBuZXcgVmVjdG9yMigpLCBuZXcgVmVjdG9yMigpICk7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdC8vIG1vcnBoc1xuXG4gICAgXHRcdFx0Zm9yICggdmFyIGogPSAwOyBqIDwgbW9ycGhUYXJnZXRzTGVuZ3RoOyBqICsrICkge1xuXG4gICAgXHRcdFx0XHR2YXIgbW9ycGhUYXJnZXQgPSBtb3JwaFRhcmdldHNbIGogXS52ZXJ0aWNlcztcblxuICAgIFx0XHRcdFx0bW9ycGhUYXJnZXRzUG9zaXRpb25bIGogXS5wdXNoKCBtb3JwaFRhcmdldFsgZmFjZS5hIF0sIG1vcnBoVGFyZ2V0WyBmYWNlLmIgXSwgbW9ycGhUYXJnZXRbIGZhY2UuYyBdICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCBtb3JwaE5vcm1hbHNMZW5ndGg7IGogKysgKSB7XG5cbiAgICBcdFx0XHRcdHZhciBtb3JwaE5vcm1hbCA9IG1vcnBoTm9ybWFsc1sgaiBdLnZlcnRleE5vcm1hbHNbIGkgXTtcblxuICAgIFx0XHRcdFx0bW9ycGhUYXJnZXRzTm9ybWFsWyBqIF0ucHVzaCggbW9ycGhOb3JtYWwuYSwgbW9ycGhOb3JtYWwuYiwgbW9ycGhOb3JtYWwuYyApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0Ly8gc2tpbnNcblxuICAgIFx0XHRcdGlmICggaGFzU2tpbkluZGljZXMgKSB7XG5cbiAgICBcdFx0XHRcdHRoaXMuc2tpbkluZGljZXMucHVzaCggc2tpbkluZGljZXNbIGZhY2UuYSBdLCBza2luSW5kaWNlc1sgZmFjZS5iIF0sIHNraW5JbmRpY2VzWyBmYWNlLmMgXSApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0aWYgKCBoYXNTa2luV2VpZ2h0cyApIHtcblxuICAgIFx0XHRcdFx0dGhpcy5za2luV2VpZ2h0cy5wdXNoKCBza2luV2VpZ2h0c1sgZmFjZS5hIF0sIHNraW5XZWlnaHRzWyBmYWNlLmIgXSwgc2tpbldlaWdodHNbIGZhY2UuYyBdICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHRoaXMuY29tcHV0ZUdyb3VwcyggZ2VvbWV0cnkgKTtcblxuICAgIFx0XHR0aGlzLnZlcnRpY2VzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZTtcbiAgICBcdFx0dGhpcy5ub3JtYWxzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5Lm5vcm1hbHNOZWVkVXBkYXRlO1xuICAgIFx0XHR0aGlzLmNvbG9yc05lZWRVcGRhdGUgPSBnZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlO1xuICAgIFx0XHR0aGlzLnV2c05lZWRVcGRhdGUgPSBnZW9tZXRyeS51dnNOZWVkVXBkYXRlO1xuICAgIFx0XHR0aGlzLmdyb3Vwc05lZWRVcGRhdGUgPSBnZW9tZXRyeS5ncm91cHNOZWVkVXBkYXRlO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dGhpcy5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdkaXNwb3NlJyB9ICk7XG5cbiAgICBcdH1cblxuICAgIH0gKTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gICAgICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIEJ1ZmZlckdlb21ldHJ5KCkge1xuXG4gICAgXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsICdpZCcsIHsgdmFsdWU6IEdlb21ldHJ5SWRDb3VudCgpIH0gKTtcblxuICAgIFx0dGhpcy51dWlkID0gZXhwb3J0cy5NYXRoLmdlbmVyYXRlVVVJRCgpO1xuXG4gICAgXHR0aGlzLm5hbWUgPSAnJztcbiAgICBcdHRoaXMudHlwZSA9ICdCdWZmZXJHZW9tZXRyeSc7XG5cbiAgICBcdHRoaXMuaW5kZXggPSBudWxsO1xuICAgIFx0dGhpcy5hdHRyaWJ1dGVzID0ge307XG5cbiAgICBcdHRoaXMubW9ycGhBdHRyaWJ1dGVzID0ge307XG5cbiAgICBcdHRoaXMuZ3JvdXBzID0gW107XG5cbiAgICBcdHRoaXMuYm91bmRpbmdCb3ggPSBudWxsO1xuICAgIFx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG51bGw7XG5cbiAgICBcdHRoaXMuZHJhd1JhbmdlID0geyBzdGFydDogMCwgY291bnQ6IEluZmluaXR5IH07XG5cbiAgICB9XG5cbiAgICBPYmplY3QuYXNzaWduKCBCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUsIEV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUsIHtcblxuICAgIFx0aXNCdWZmZXJHZW9tZXRyeTogdHJ1ZSxcblxuICAgIFx0Z2V0SW5kZXg6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHRyZXR1cm4gdGhpcy5pbmRleDtcblxuICAgIFx0fSxcblxuICAgIFx0c2V0SW5kZXg6IGZ1bmN0aW9uICggaW5kZXggKSB7XG5cbiAgICBcdFx0dGhpcy5pbmRleCA9IGluZGV4O1xuXG4gICAgXHR9LFxuXG4gICAgXHRhZGRBdHRyaWJ1dGU6IGZ1bmN0aW9uICggbmFtZSwgYXR0cmlidXRlICkge1xuXG4gICAgXHRcdGlmICggKGF0dHJpYnV0ZSAmJiBhdHRyaWJ1dGUuaXNCdWZmZXJBdHRyaWJ1dGUpID09PSBmYWxzZSAmJiAoYXR0cmlidXRlICYmIGF0dHJpYnV0ZS5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlKSA9PT0gZmFsc2UgKSB7XG5cbiAgICBcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmFkZEF0dHJpYnV0ZSgpIG5vdyBleHBlY3RzICggbmFtZSwgYXR0cmlidXRlICkuJyApO1xuXG4gICAgXHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGUoIG5hbWUsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIGFyZ3VtZW50c1sgMSBdLCBhcmd1bWVudHNbIDIgXSApICk7XG5cbiAgICBcdFx0XHRyZXR1cm47XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGlmICggbmFtZSA9PT0gJ2luZGV4JyApIHtcblxuICAgIFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5LmFkZEF0dHJpYnV0ZTogVXNlIC5zZXRJbmRleCgpIGZvciBpbmRleCBhdHRyaWJ1dGUuJyApO1xuICAgIFx0XHRcdHRoaXMuc2V0SW5kZXgoIGF0dHJpYnV0ZSApO1xuXG4gICAgXHRcdFx0cmV0dXJuO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHR0aGlzLmF0dHJpYnV0ZXNbIG5hbWUgXSA9IGF0dHJpYnV0ZTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0Z2V0QXR0cmlidXRlOiBmdW5jdGlvbiAoIG5hbWUgKSB7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMuYXR0cmlidXRlc1sgbmFtZSBdO1xuXG4gICAgXHR9LFxuXG4gICAgXHRyZW1vdmVBdHRyaWJ1dGU6IGZ1bmN0aW9uICggbmFtZSApIHtcblxuICAgIFx0XHRkZWxldGUgdGhpcy5hdHRyaWJ1dGVzWyBuYW1lIF07XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGFkZEdyb3VwOiBmdW5jdGlvbiAoIHN0YXJ0LCBjb3VudCwgbWF0ZXJpYWxJbmRleCApIHtcblxuICAgIFx0XHR0aGlzLmdyb3Vwcy5wdXNoKCB7XG5cbiAgICBcdFx0XHRzdGFydDogc3RhcnQsXG4gICAgXHRcdFx0Y291bnQ6IGNvdW50LFxuICAgIFx0XHRcdG1hdGVyaWFsSW5kZXg6IG1hdGVyaWFsSW5kZXggIT09IHVuZGVmaW5lZCA/IG1hdGVyaWFsSW5kZXggOiAwXG5cbiAgICBcdFx0fSApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRjbGVhckdyb3VwczogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHRoaXMuZ3JvdXBzID0gW107XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldERyYXdSYW5nZTogZnVuY3Rpb24gKCBzdGFydCwgY291bnQgKSB7XG5cbiAgICBcdFx0dGhpcy5kcmF3UmFuZ2Uuc3RhcnQgPSBzdGFydDtcbiAgICBcdFx0dGhpcy5kcmF3UmFuZ2UuY291bnQgPSBjb3VudDtcblxuICAgIFx0fSxcblxuICAgIFx0YXBwbHlNYXRyaXg6IGZ1bmN0aW9uICggbWF0cml4ICkge1xuXG4gICAgXHRcdHZhciBwb3NpdGlvbiA9IHRoaXMuYXR0cmlidXRlcy5wb3NpdGlvbjtcblxuICAgIFx0XHRpZiAoIHBvc2l0aW9uICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRtYXRyaXguYXBwbHlUb1ZlY3RvcjNBcnJheSggcG9zaXRpb24uYXJyYXkgKTtcbiAgICBcdFx0XHRwb3NpdGlvbi5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHZhciBub3JtYWwgPSB0aGlzLmF0dHJpYnV0ZXMubm9ybWFsO1xuXG4gICAgXHRcdGlmICggbm9ybWFsICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHR2YXIgbm9ybWFsTWF0cml4ID0gbmV3IE1hdHJpeDMoKS5nZXROb3JtYWxNYXRyaXgoIG1hdHJpeCApO1xuXG4gICAgXHRcdFx0bm9ybWFsTWF0cml4LmFwcGx5VG9WZWN0b3IzQXJyYXkoIG5vcm1hbC5hcnJheSApO1xuICAgIFx0XHRcdG5vcm1hbC5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGlmICggdGhpcy5ib3VuZGluZ0JveCAhPT0gbnVsbCApIHtcblxuICAgIFx0XHRcdHRoaXMuY29tcHV0ZUJvdW5kaW5nQm94KCk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGlmICggdGhpcy5ib3VuZGluZ1NwaGVyZSAhPT0gbnVsbCApIHtcblxuICAgIFx0XHRcdHRoaXMuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRyb3RhdGVYOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0Ly8gcm90YXRlIGdlb21ldHJ5IGFyb3VuZCB3b3JsZCB4LWF4aXNcblxuICAgIFx0XHR2YXIgbTE7XG5cbiAgICBcdFx0cmV0dXJuIGZ1bmN0aW9uIHJvdGF0ZVgoIGFuZ2xlICkge1xuXG4gICAgXHRcdFx0aWYgKCBtMSA9PT0gdW5kZWZpbmVkICkgbTEgPSBuZXcgTWF0cml4NCgpO1xuXG4gICAgXHRcdFx0bTEubWFrZVJvdGF0aW9uWCggYW5nbGUgKTtcblxuICAgIFx0XHRcdHRoaXMuYXBwbHlNYXRyaXgoIG0xICk7XG5cbiAgICBcdFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0XHR9O1xuXG4gICAgXHR9KCksXG5cbiAgICBcdHJvdGF0ZVk6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHQvLyByb3RhdGUgZ2VvbWV0cnkgYXJvdW5kIHdvcmxkIHktYXhpc1xuXG4gICAgXHRcdHZhciBtMTtcblxuICAgIFx0XHRyZXR1cm4gZnVuY3Rpb24gcm90YXRlWSggYW5nbGUgKSB7XG5cbiAgICBcdFx0XHRpZiAoIG0xID09PSB1bmRlZmluZWQgKSBtMSA9IG5ldyBNYXRyaXg0KCk7XG5cbiAgICBcdFx0XHRtMS5tYWtlUm90YXRpb25ZKCBhbmdsZSApO1xuXG4gICAgXHRcdFx0dGhpcy5hcHBseU1hdHJpeCggbTEgKTtcblxuICAgIFx0XHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHRcdH07XG5cbiAgICBcdH0oKSxcblxuICAgIFx0cm90YXRlWjogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdC8vIHJvdGF0ZSBnZW9tZXRyeSBhcm91bmQgd29ybGQgei1heGlzXG5cbiAgICBcdFx0dmFyIG0xO1xuXG4gICAgXHRcdHJldHVybiBmdW5jdGlvbiByb3RhdGVaKCBhbmdsZSApIHtcblxuICAgIFx0XHRcdGlmICggbTEgPT09IHVuZGVmaW5lZCApIG0xID0gbmV3IE1hdHJpeDQoKTtcblxuICAgIFx0XHRcdG0xLm1ha2VSb3RhdGlvblooIGFuZ2xlICk7XG5cbiAgICBcdFx0XHR0aGlzLmFwcGx5TWF0cml4KCBtMSApO1xuXG4gICAgXHRcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdFx0fTtcblxuICAgIFx0fSgpLFxuXG4gICAgXHR0cmFuc2xhdGU6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHQvLyB0cmFuc2xhdGUgZ2VvbWV0cnlcblxuICAgIFx0XHR2YXIgbTE7XG5cbiAgICBcdFx0cmV0dXJuIGZ1bmN0aW9uIHRyYW5zbGF0ZSggeCwgeSwgeiApIHtcblxuICAgIFx0XHRcdGlmICggbTEgPT09IHVuZGVmaW5lZCApIG0xID0gbmV3IE1hdHJpeDQoKTtcblxuICAgIFx0XHRcdG0xLm1ha2VUcmFuc2xhdGlvbiggeCwgeSwgeiApO1xuXG4gICAgXHRcdFx0dGhpcy5hcHBseU1hdHJpeCggbTEgKTtcblxuICAgIFx0XHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHRcdH07XG5cbiAgICBcdH0oKSxcblxuICAgIFx0c2NhbGU6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHQvLyBzY2FsZSBnZW9tZXRyeVxuXG4gICAgXHRcdHZhciBtMTtcblxuICAgIFx0XHRyZXR1cm4gZnVuY3Rpb24gc2NhbGUoIHgsIHksIHogKSB7XG5cbiAgICBcdFx0XHRpZiAoIG0xID09PSB1bmRlZmluZWQgKSBtMSA9IG5ldyBNYXRyaXg0KCk7XG5cbiAgICBcdFx0XHRtMS5tYWtlU2NhbGUoIHgsIHksIHogKTtcblxuICAgIFx0XHRcdHRoaXMuYXBwbHlNYXRyaXgoIG0xICk7XG5cbiAgICBcdFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0XHR9O1xuXG4gICAgXHR9KCksXG5cbiAgICBcdGxvb2tBdDogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHZhciBvYmo7XG5cbiAgICBcdFx0cmV0dXJuIGZ1bmN0aW9uIGxvb2tBdCggdmVjdG9yICkge1xuXG4gICAgXHRcdFx0aWYgKCBvYmogPT09IHVuZGVmaW5lZCApIG9iaiA9IG5ldyBPYmplY3QzRCgpO1xuXG4gICAgXHRcdFx0b2JqLmxvb2tBdCggdmVjdG9yICk7XG5cbiAgICBcdFx0XHRvYmoudXBkYXRlTWF0cml4KCk7XG5cbiAgICBcdFx0XHR0aGlzLmFwcGx5TWF0cml4KCBvYmoubWF0cml4ICk7XG5cbiAgICBcdFx0fTtcblxuICAgIFx0fSgpLFxuXG4gICAgXHRjZW50ZXI6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR0aGlzLmNvbXB1dGVCb3VuZGluZ0JveCgpO1xuXG4gICAgXHRcdHZhciBvZmZzZXQgPSB0aGlzLmJvdW5kaW5nQm94LmdldENlbnRlcigpLm5lZ2F0ZSgpO1xuXG4gICAgXHRcdHRoaXMudHJhbnNsYXRlKCBvZmZzZXQueCwgb2Zmc2V0LnksIG9mZnNldC56ICk7XG5cbiAgICBcdFx0cmV0dXJuIG9mZnNldDtcblxuICAgIFx0fSxcblxuICAgIFx0c2V0RnJvbU9iamVjdDogZnVuY3Rpb24gKCBvYmplY3QgKSB7XG5cbiAgICBcdFx0Ly8gY29uc29sZS5sb2coICdUSFJFRS5CdWZmZXJHZW9tZXRyeS5zZXRGcm9tT2JqZWN0KCkuIENvbnZlcnRpbmcnLCBvYmplY3QsIHRoaXMgKTtcblxuICAgIFx0XHR2YXIgZ2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnk7XG5cbiAgICBcdFx0aWYgKCAob2JqZWN0ICYmIG9iamVjdC5pc1BvaW50cykgfHwgKG9iamVjdCAmJiBvYmplY3QuaXNMaW5lKSApIHtcblxuICAgIFx0XHRcdHZhciBwb3NpdGlvbnMgPSBuZXcgRmxvYXQzMkF0dHJpYnV0ZSggZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoICogMywgMyApO1xuICAgIFx0XHRcdHZhciBjb2xvcnMgPSBuZXcgRmxvYXQzMkF0dHJpYnV0ZSggZ2VvbWV0cnkuY29sb3JzLmxlbmd0aCAqIDMsIDMgKTtcblxuICAgIFx0XHRcdHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBwb3NpdGlvbnMuY29weVZlY3RvcjNzQXJyYXkoIGdlb21ldHJ5LnZlcnRpY2VzICkgKTtcbiAgICBcdFx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ2NvbG9yJywgY29sb3JzLmNvcHlDb2xvcnNBcnJheSggZ2VvbWV0cnkuY29sb3JzICkgKTtcblxuICAgIFx0XHRcdGlmICggZ2VvbWV0cnkubGluZURpc3RhbmNlcyAmJiBnZW9tZXRyeS5saW5lRGlzdGFuY2VzLmxlbmd0aCA9PT0gZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoICkge1xuXG4gICAgXHRcdFx0XHR2YXIgbGluZURpc3RhbmNlcyA9IG5ldyBGbG9hdDMyQXR0cmlidXRlKCBnZW9tZXRyeS5saW5lRGlzdGFuY2VzLmxlbmd0aCwgMSApO1xuXG4gICAgXHRcdFx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ2xpbmVEaXN0YW5jZScsIGxpbmVEaXN0YW5jZXMuY29weUFycmF5KCBnZW9tZXRyeS5saW5lRGlzdGFuY2VzICkgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGlmICggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgIT09IG51bGwgKSB7XG5cbiAgICBcdFx0XHRcdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZS5jbG9uZSgpO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ0JveCAhPT0gbnVsbCApIHtcblxuICAgIFx0XHRcdFx0dGhpcy5ib3VuZGluZ0JveCA9IGdlb21ldHJ5LmJvdW5kaW5nQm94LmNsb25lKCk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fSBlbHNlIGlmICggKG9iamVjdCAmJiBvYmplY3QuaXNNZXNoKSApIHtcblxuICAgIFx0XHRcdGlmICggKGdlb21ldHJ5ICYmIGdlb21ldHJ5LmlzR2VvbWV0cnkpICkge1xuXG4gICAgXHRcdFx0XHR0aGlzLmZyb21HZW9tZXRyeSggZ2VvbWV0cnkgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdHVwZGF0ZUZyb21PYmplY3Q6IGZ1bmN0aW9uICggb2JqZWN0ICkge1xuXG4gICAgXHRcdHZhciBnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeTtcblxuICAgIFx0XHRpZiAoIChvYmplY3QgJiYgb2JqZWN0LmlzTWVzaCkgKSB7XG5cbiAgICBcdFx0XHR2YXIgZGlyZWN0ID0gZ2VvbWV0cnkuX19kaXJlY3RHZW9tZXRyeTtcblxuICAgIFx0XHRcdGlmICggZ2VvbWV0cnkuZWxlbWVudHNOZWVkVXBkYXRlID09PSB0cnVlICkge1xuXG4gICAgXHRcdFx0XHRkaXJlY3QgPSB1bmRlZmluZWQ7XG4gICAgXHRcdFx0XHRnZW9tZXRyeS5lbGVtZW50c05lZWRVcGRhdGUgPSBmYWxzZTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGlmICggZGlyZWN0ID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRcdHJldHVybiB0aGlzLmZyb21HZW9tZXRyeSggZ2VvbWV0cnkgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGRpcmVjdC52ZXJ0aWNlc05lZWRVcGRhdGUgPSBnZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGU7XG4gICAgXHRcdFx0ZGlyZWN0Lm5vcm1hbHNOZWVkVXBkYXRlID0gZ2VvbWV0cnkubm9ybWFsc05lZWRVcGRhdGU7XG4gICAgXHRcdFx0ZGlyZWN0LmNvbG9yc05lZWRVcGRhdGUgPSBnZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlO1xuICAgIFx0XHRcdGRpcmVjdC51dnNOZWVkVXBkYXRlID0gZ2VvbWV0cnkudXZzTmVlZFVwZGF0ZTtcbiAgICBcdFx0XHRkaXJlY3QuZ3JvdXBzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5Lmdyb3Vwc05lZWRVcGRhdGU7XG5cbiAgICBcdFx0XHRnZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgPSBmYWxzZTtcbiAgICBcdFx0XHRnZW9tZXRyeS5ub3JtYWxzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuICAgIFx0XHRcdGdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGUgPSBmYWxzZTtcbiAgICBcdFx0XHRnZW9tZXRyeS51dnNOZWVkVXBkYXRlID0gZmFsc2U7XG4gICAgXHRcdFx0Z2VvbWV0cnkuZ3JvdXBzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuXG4gICAgXHRcdFx0Z2VvbWV0cnkgPSBkaXJlY3Q7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHZhciBhdHRyaWJ1dGU7XG5cbiAgICBcdFx0aWYgKCBnZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgPT09IHRydWUgKSB7XG5cbiAgICBcdFx0XHRhdHRyaWJ1dGUgPSB0aGlzLmF0dHJpYnV0ZXMucG9zaXRpb247XG5cbiAgICBcdFx0XHRpZiAoIGF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0XHRhdHRyaWJ1dGUuY29weVZlY3RvcjNzQXJyYXkoIGdlb21ldHJ5LnZlcnRpY2VzICk7XG4gICAgXHRcdFx0XHRhdHRyaWJ1dGUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0Z2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlID0gZmFsc2U7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGlmICggZ2VvbWV0cnkubm9ybWFsc05lZWRVcGRhdGUgPT09IHRydWUgKSB7XG5cbiAgICBcdFx0XHRhdHRyaWJ1dGUgPSB0aGlzLmF0dHJpYnV0ZXMubm9ybWFsO1xuXG4gICAgXHRcdFx0aWYgKCBhdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0YXR0cmlidXRlLmNvcHlWZWN0b3Izc0FycmF5KCBnZW9tZXRyeS5ub3JtYWxzICk7XG4gICAgXHRcdFx0XHRhdHRyaWJ1dGUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0Z2VvbWV0cnkubm9ybWFsc05lZWRVcGRhdGUgPSBmYWxzZTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKCBnZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlID09PSB0cnVlICkge1xuXG4gICAgXHRcdFx0YXR0cmlidXRlID0gdGhpcy5hdHRyaWJ1dGVzLmNvbG9yO1xuXG4gICAgXHRcdFx0aWYgKCBhdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0YXR0cmlidXRlLmNvcHlDb2xvcnNBcnJheSggZ2VvbWV0cnkuY29sb3JzICk7XG4gICAgXHRcdFx0XHRhdHRyaWJ1dGUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0Z2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoIGdlb21ldHJ5LnV2c05lZWRVcGRhdGUgKSB7XG5cbiAgICBcdFx0XHRhdHRyaWJ1dGUgPSB0aGlzLmF0dHJpYnV0ZXMudXY7XG5cbiAgICBcdFx0XHRpZiAoIGF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0XHRhdHRyaWJ1dGUuY29weVZlY3RvcjJzQXJyYXkoIGdlb21ldHJ5LnV2cyApO1xuICAgIFx0XHRcdFx0YXR0cmlidXRlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGdlb21ldHJ5LnV2c05lZWRVcGRhdGUgPSBmYWxzZTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKCBnZW9tZXRyeS5saW5lRGlzdGFuY2VzTmVlZFVwZGF0ZSApIHtcblxuICAgIFx0XHRcdGF0dHJpYnV0ZSA9IHRoaXMuYXR0cmlidXRlcy5saW5lRGlzdGFuY2U7XG5cbiAgICBcdFx0XHRpZiAoIGF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0XHRhdHRyaWJ1dGUuY29weUFycmF5KCBnZW9tZXRyeS5saW5lRGlzdGFuY2VzICk7XG4gICAgXHRcdFx0XHRhdHRyaWJ1dGUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0Z2VvbWV0cnkubGluZURpc3RhbmNlc05lZWRVcGRhdGUgPSBmYWxzZTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKCBnZW9tZXRyeS5ncm91cHNOZWVkVXBkYXRlICkge1xuXG4gICAgXHRcdFx0Z2VvbWV0cnkuY29tcHV0ZUdyb3Vwcyggb2JqZWN0Lmdlb21ldHJ5ICk7XG4gICAgXHRcdFx0dGhpcy5ncm91cHMgPSBnZW9tZXRyeS5ncm91cHM7XG5cbiAgICBcdFx0XHRnZW9tZXRyeS5ncm91cHNOZWVkVXBkYXRlID0gZmFsc2U7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRmcm9tR2VvbWV0cnk6IGZ1bmN0aW9uICggZ2VvbWV0cnkgKSB7XG5cbiAgICBcdFx0Z2VvbWV0cnkuX19kaXJlY3RHZW9tZXRyeSA9IG5ldyBEaXJlY3RHZW9tZXRyeSgpLmZyb21HZW9tZXRyeSggZ2VvbWV0cnkgKTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcy5mcm9tRGlyZWN0R2VvbWV0cnkoIGdlb21ldHJ5Ll9fZGlyZWN0R2VvbWV0cnkgKTtcblxuICAgIFx0fSxcblxuICAgIFx0ZnJvbURpcmVjdEdlb21ldHJ5OiBmdW5jdGlvbiAoIGdlb21ldHJ5ICkge1xuXG4gICAgXHRcdHZhciBwb3NpdGlvbnMgPSBuZXcgRmxvYXQzMkFycmF5KCBnZW9tZXRyeS52ZXJ0aWNlcy5sZW5ndGggKiAzICk7XG4gICAgXHRcdHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbnMsIDMgKS5jb3B5VmVjdG9yM3NBcnJheSggZ2VvbWV0cnkudmVydGljZXMgKSApO1xuXG4gICAgXHRcdGlmICggZ2VvbWV0cnkubm9ybWFscy5sZW5ndGggPiAwICkge1xuXG4gICAgXHRcdFx0dmFyIG5vcm1hbHMgPSBuZXcgRmxvYXQzMkFycmF5KCBnZW9tZXRyeS5ub3JtYWxzLmxlbmd0aCAqIDMgKTtcbiAgICBcdFx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKS5jb3B5VmVjdG9yM3NBcnJheSggZ2VvbWV0cnkubm9ybWFscyApICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGlmICggZ2VvbWV0cnkuY29sb3JzLmxlbmd0aCA+IDAgKSB7XG5cbiAgICBcdFx0XHR2YXIgY29sb3JzID0gbmV3IEZsb2F0MzJBcnJheSggZ2VvbWV0cnkuY29sb3JzLmxlbmd0aCAqIDMgKTtcbiAgICBcdFx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ2NvbG9yJywgbmV3IEJ1ZmZlckF0dHJpYnV0ZSggY29sb3JzLCAzICkuY29weUNvbG9yc0FycmF5KCBnZW9tZXRyeS5jb2xvcnMgKSApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoIGdlb21ldHJ5LnV2cy5sZW5ndGggPiAwICkge1xuXG4gICAgXHRcdFx0dmFyIHV2cyA9IG5ldyBGbG9hdDMyQXJyYXkoIGdlb21ldHJ5LnV2cy5sZW5ndGggKiAyICk7XG4gICAgXHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICd1dicsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIHV2cywgMiApLmNvcHlWZWN0b3Iyc0FycmF5KCBnZW9tZXRyeS51dnMgKSApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoIGdlb21ldHJ5LnV2czIubGVuZ3RoID4gMCApIHtcblxuICAgIFx0XHRcdHZhciB1dnMyID0gbmV3IEZsb2F0MzJBcnJheSggZ2VvbWV0cnkudXZzMi5sZW5ndGggKiAyICk7XG4gICAgXHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICd1djInLCBuZXcgQnVmZmVyQXR0cmlidXRlKCB1dnMyLCAyICkuY29weVZlY3RvcjJzQXJyYXkoIGdlb21ldHJ5LnV2czIgKSApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoIGdlb21ldHJ5LmluZGljZXMubGVuZ3RoID4gMCApIHtcblxuICAgIFx0XHRcdHZhciBUeXBlQXJyYXkgPSBnZW9tZXRyeS52ZXJ0aWNlcy5sZW5ndGggPiA2NTUzNSA/IFVpbnQzMkFycmF5IDogVWludDE2QXJyYXk7XG4gICAgXHRcdFx0dmFyIGluZGljZXMgPSBuZXcgVHlwZUFycmF5KCBnZW9tZXRyeS5pbmRpY2VzLmxlbmd0aCAqIDMgKTtcbiAgICBcdFx0XHR0aGlzLnNldEluZGV4KCBuZXcgQnVmZmVyQXR0cmlidXRlKCBpbmRpY2VzLCAxICkuY29weUluZGljZXNBcnJheSggZ2VvbWV0cnkuaW5kaWNlcyApICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdC8vIGdyb3Vwc1xuXG4gICAgXHRcdHRoaXMuZ3JvdXBzID0gZ2VvbWV0cnkuZ3JvdXBzO1xuXG4gICAgXHRcdC8vIG1vcnBoc1xuXG4gICAgXHRcdGZvciAoIHZhciBuYW1lIGluIGdlb21ldHJ5Lm1vcnBoVGFyZ2V0cyApIHtcblxuICAgIFx0XHRcdHZhciBhcnJheSA9IFtdO1xuICAgIFx0XHRcdHZhciBtb3JwaFRhcmdldHMgPSBnZW9tZXRyeS5tb3JwaFRhcmdldHNbIG5hbWUgXTtcblxuICAgIFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IG1vcnBoVGFyZ2V0cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgXHRcdFx0XHR2YXIgbW9ycGhUYXJnZXQgPSBtb3JwaFRhcmdldHNbIGkgXTtcblxuICAgIFx0XHRcdFx0dmFyIGF0dHJpYnV0ZSA9IG5ldyBGbG9hdDMyQXR0cmlidXRlKCBtb3JwaFRhcmdldC5sZW5ndGggKiAzLCAzICk7XG5cbiAgICBcdFx0XHRcdGFycmF5LnB1c2goIGF0dHJpYnV0ZS5jb3B5VmVjdG9yM3NBcnJheSggbW9ycGhUYXJnZXQgKSApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0dGhpcy5tb3JwaEF0dHJpYnV0ZXNbIG5hbWUgXSA9IGFycmF5O1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHQvLyBza2lubmluZ1xuXG4gICAgXHRcdGlmICggZ2VvbWV0cnkuc2tpbkluZGljZXMubGVuZ3RoID4gMCApIHtcblxuICAgIFx0XHRcdHZhciBza2luSW5kaWNlcyA9IG5ldyBGbG9hdDMyQXR0cmlidXRlKCBnZW9tZXRyeS5za2luSW5kaWNlcy5sZW5ndGggKiA0LCA0ICk7XG4gICAgXHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdza2luSW5kZXgnLCBza2luSW5kaWNlcy5jb3B5VmVjdG9yNHNBcnJheSggZ2VvbWV0cnkuc2tpbkluZGljZXMgKSApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoIGdlb21ldHJ5LnNraW5XZWlnaHRzLmxlbmd0aCA+IDAgKSB7XG5cbiAgICBcdFx0XHR2YXIgc2tpbldlaWdodHMgPSBuZXcgRmxvYXQzMkF0dHJpYnV0ZSggZ2VvbWV0cnkuc2tpbldlaWdodHMubGVuZ3RoICogNCwgNCApO1xuICAgIFx0XHRcdHRoaXMuYWRkQXR0cmlidXRlKCAnc2tpbldlaWdodCcsIHNraW5XZWlnaHRzLmNvcHlWZWN0b3I0c0FycmF5KCBnZW9tZXRyeS5za2luV2VpZ2h0cyApICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdC8vXG5cbiAgICBcdFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSAhPT0gbnVsbCApIHtcblxuICAgIFx0XHRcdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZS5jbG9uZSgpO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nQm94ICE9PSBudWxsICkge1xuXG4gICAgXHRcdFx0dGhpcy5ib3VuZGluZ0JveCA9IGdlb21ldHJ5LmJvdW5kaW5nQm94LmNsb25lKCk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRjb21wdXRlQm91bmRpbmdCb3g6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHRpZiAoIHRoaXMuYm91bmRpbmdCb3ggPT09IG51bGwgKSB7XG5cbiAgICBcdFx0XHR0aGlzLmJvdW5kaW5nQm94ID0gbmV3IEJveDMoKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0dmFyIHBvc2l0aW9ucyA9IHRoaXMuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcblxuICAgIFx0XHRpZiAoIHBvc2l0aW9ucyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0dGhpcy5ib3VuZGluZ0JveC5zZXRGcm9tQXJyYXkoIHBvc2l0aW9ucyApO1xuXG4gICAgXHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHR0aGlzLmJvdW5kaW5nQm94Lm1ha2VFbXB0eSgpO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoIGlzTmFOKCB0aGlzLmJvdW5kaW5nQm94Lm1pbi54ICkgfHwgaXNOYU4oIHRoaXMuYm91bmRpbmdCb3gubWluLnkgKSB8fCBpc05hTiggdGhpcy5ib3VuZGluZ0JveC5taW4ueiApICkge1xuXG4gICAgXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ0JveDogQ29tcHV0ZWQgbWluL21heCBoYXZlIE5hTiB2YWx1ZXMuIFRoZSBcInBvc2l0aW9uXCIgYXR0cmlidXRlIGlzIGxpa2VseSB0byBoYXZlIE5hTiB2YWx1ZXMuJywgdGhpcyApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0fSxcblxuICAgIFx0Y29tcHV0ZUJvdW5kaW5nU3BoZXJlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dmFyIGJveCA9IG5ldyBCb3gzKCk7XG4gICAgXHRcdHZhciB2ZWN0b3IgPSBuZXcgVmVjdG9yMygpO1xuXG4gICAgXHRcdHJldHVybiBmdW5jdGlvbiBjb21wdXRlQm91bmRpbmdTcGhlcmUoKSB7XG5cbiAgICBcdFx0XHRpZiAoIHRoaXMuYm91bmRpbmdTcGhlcmUgPT09IG51bGwgKSB7XG5cbiAgICBcdFx0XHRcdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgU3BoZXJlKCk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHR2YXIgcG9zaXRpb25zID0gdGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXG4gICAgXHRcdFx0aWYgKCBwb3NpdGlvbnMgKSB7XG5cbiAgICBcdFx0XHRcdHZhciBhcnJheSA9IHBvc2l0aW9ucy5hcnJheTtcbiAgICBcdFx0XHRcdHZhciBjZW50ZXIgPSB0aGlzLmJvdW5kaW5nU3BoZXJlLmNlbnRlcjtcblxuICAgIFx0XHRcdFx0Ym94LnNldEZyb21BcnJheSggYXJyYXkgKTtcbiAgICBcdFx0XHRcdGJveC5nZXRDZW50ZXIoIGNlbnRlciApO1xuXG4gICAgXHRcdFx0XHQvLyBob3BpbmcgdG8gZmluZCBhIGJvdW5kaW5nU3BoZXJlIHdpdGggYSByYWRpdXMgc21hbGxlciB0aGFuIHRoZVxuICAgIFx0XHRcdFx0Ly8gYm91bmRpbmdTcGhlcmUgb2YgdGhlIGJvdW5kaW5nQm94OiBzcXJ0KDMpIHNtYWxsZXIgaW4gdGhlIGJlc3QgY2FzZVxuXG4gICAgXHRcdFx0XHR2YXIgbWF4UmFkaXVzU3EgPSAwO1xuXG4gICAgXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gYXJyYXkubGVuZ3RoOyBpIDwgaWw7IGkgKz0gMyApIHtcblxuICAgIFx0XHRcdFx0XHR2ZWN0b3IuZnJvbUFycmF5KCBhcnJheSwgaSApO1xuICAgIFx0XHRcdFx0XHRtYXhSYWRpdXNTcSA9IE1hdGgubWF4KCBtYXhSYWRpdXNTcSwgY2VudGVyLmRpc3RhbmNlVG9TcXVhcmVkKCB2ZWN0b3IgKSApO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdHRoaXMuYm91bmRpbmdTcGhlcmUucmFkaXVzID0gTWF0aC5zcXJ0KCBtYXhSYWRpdXNTcSApO1xuXG4gICAgXHRcdFx0XHRpZiAoIGlzTmFOKCB0aGlzLmJvdW5kaW5nU3BoZXJlLnJhZGl1cyApICkge1xuXG4gICAgXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5CdWZmZXJHZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTogQ29tcHV0ZWQgcmFkaXVzIGlzIE5hTi4gVGhlIFwicG9zaXRpb25cIiBhdHRyaWJ1dGUgaXMgbGlrZWx5IHRvIGhhdmUgTmFOIHZhbHVlcy4nLCB0aGlzICk7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9O1xuXG4gICAgXHR9KCksXG5cbiAgICBcdGNvbXB1dGVGYWNlTm9ybWFsczogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cbiAgICBcdH0sXG5cbiAgICBcdGNvbXB1dGVWZXJ0ZXhOb3JtYWxzOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dmFyIGluZGV4ID0gdGhpcy5pbmRleDtcbiAgICBcdFx0dmFyIGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXM7XG4gICAgXHRcdHZhciBncm91cHMgPSB0aGlzLmdyb3VwcztcblxuICAgIFx0XHRpZiAoIGF0dHJpYnV0ZXMucG9zaXRpb24gKSB7XG5cbiAgICBcdFx0XHR2YXIgcG9zaXRpb25zID0gYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcblxuICAgIFx0XHRcdGlmICggYXR0cmlidXRlcy5ub3JtYWwgPT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgQnVmZmVyQXR0cmlidXRlKCBuZXcgRmxvYXQzMkFycmF5KCBwb3NpdGlvbnMubGVuZ3RoICksIDMgKSApO1xuXG4gICAgXHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0Ly8gcmVzZXQgZXhpc3Rpbmcgbm9ybWFscyB0byB6ZXJvXG5cbiAgICBcdFx0XHRcdHZhciBhcnJheSA9IGF0dHJpYnV0ZXMubm9ybWFsLmFycmF5O1xuXG4gICAgXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gYXJyYXkubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICBcdFx0XHRcdFx0YXJyYXlbIGkgXSA9IDA7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdHZhciBub3JtYWxzID0gYXR0cmlidXRlcy5ub3JtYWwuYXJyYXk7XG5cbiAgICBcdFx0XHR2YXIgdkEsIHZCLCB2QyxcblxuICAgIFx0XHRcdHBBID0gbmV3IFZlY3RvcjMoKSxcbiAgICBcdFx0XHRwQiA9IG5ldyBWZWN0b3IzKCksXG4gICAgXHRcdFx0cEMgPSBuZXcgVmVjdG9yMygpLFxuXG4gICAgXHRcdFx0Y2IgPSBuZXcgVmVjdG9yMygpLFxuICAgIFx0XHRcdGFiID0gbmV3IFZlY3RvcjMoKTtcblxuICAgIFx0XHRcdC8vIGluZGV4ZWQgZWxlbWVudHNcblxuICAgIFx0XHRcdGlmICggaW5kZXggKSB7XG5cbiAgICBcdFx0XHRcdHZhciBpbmRpY2VzID0gaW5kZXguYXJyYXk7XG5cbiAgICBcdFx0XHRcdGlmICggZ3JvdXBzLmxlbmd0aCA9PT0gMCApIHtcblxuICAgIFx0XHRcdFx0XHR0aGlzLmFkZEdyb3VwKCAwLCBpbmRpY2VzLmxlbmd0aCApO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBncm91cHMubGVuZ3RoOyBqIDwgamw7ICsrIGogKSB7XG5cbiAgICBcdFx0XHRcdFx0dmFyIGdyb3VwID0gZ3JvdXBzWyBqIF07XG5cbiAgICBcdFx0XHRcdFx0dmFyIHN0YXJ0ID0gZ3JvdXAuc3RhcnQ7XG4gICAgXHRcdFx0XHRcdHZhciBjb3VudCA9IGdyb3VwLmNvdW50O1xuXG4gICAgXHRcdFx0XHRcdGZvciAoIHZhciBpID0gc3RhcnQsIGlsID0gc3RhcnQgKyBjb3VudDsgaSA8IGlsOyBpICs9IDMgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHR2QSA9IGluZGljZXNbIGkgKyAwIF0gKiAzO1xuICAgIFx0XHRcdFx0XHRcdHZCID0gaW5kaWNlc1sgaSArIDEgXSAqIDM7XG4gICAgXHRcdFx0XHRcdFx0dkMgPSBpbmRpY2VzWyBpICsgMiBdICogMztcblxuICAgIFx0XHRcdFx0XHRcdHBBLmZyb21BcnJheSggcG9zaXRpb25zLCB2QSApO1xuICAgIFx0XHRcdFx0XHRcdHBCLmZyb21BcnJheSggcG9zaXRpb25zLCB2QiApO1xuICAgIFx0XHRcdFx0XHRcdHBDLmZyb21BcnJheSggcG9zaXRpb25zLCB2QyApO1xuXG4gICAgXHRcdFx0XHRcdFx0Y2Iuc3ViVmVjdG9ycyggcEMsIHBCICk7XG4gICAgXHRcdFx0XHRcdFx0YWIuc3ViVmVjdG9ycyggcEEsIHBCICk7XG4gICAgXHRcdFx0XHRcdFx0Y2IuY3Jvc3MoIGFiICk7XG5cbiAgICBcdFx0XHRcdFx0XHRub3JtYWxzWyB2QSBdICs9IGNiLng7XG4gICAgXHRcdFx0XHRcdFx0bm9ybWFsc1sgdkEgKyAxIF0gKz0gY2IueTtcbiAgICBcdFx0XHRcdFx0XHRub3JtYWxzWyB2QSArIDIgXSArPSBjYi56O1xuXG4gICAgXHRcdFx0XHRcdFx0bm9ybWFsc1sgdkIgXSArPSBjYi54O1xuICAgIFx0XHRcdFx0XHRcdG5vcm1hbHNbIHZCICsgMSBdICs9IGNiLnk7XG4gICAgXHRcdFx0XHRcdFx0bm9ybWFsc1sgdkIgKyAyIF0gKz0gY2IuejtcblxuICAgIFx0XHRcdFx0XHRcdG5vcm1hbHNbIHZDIF0gKz0gY2IueDtcbiAgICBcdFx0XHRcdFx0XHRub3JtYWxzWyB2QyArIDEgXSArPSBjYi55O1xuICAgIFx0XHRcdFx0XHRcdG5vcm1hbHNbIHZDICsgMiBdICs9IGNiLno7XG5cbiAgICBcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHQvLyBub24taW5kZXhlZCBlbGVtZW50cyAodW5jb25uZWN0ZWQgdHJpYW5nbGUgc291cClcblxuICAgIFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHBvc2l0aW9ucy5sZW5ndGg7IGkgPCBpbDsgaSArPSA5ICkge1xuXG4gICAgXHRcdFx0XHRcdHBBLmZyb21BcnJheSggcG9zaXRpb25zLCBpICk7XG4gICAgXHRcdFx0XHRcdHBCLmZyb21BcnJheSggcG9zaXRpb25zLCBpICsgMyApO1xuICAgIFx0XHRcdFx0XHRwQy5mcm9tQXJyYXkoIHBvc2l0aW9ucywgaSArIDYgKTtcblxuICAgIFx0XHRcdFx0XHRjYi5zdWJWZWN0b3JzKCBwQywgcEIgKTtcbiAgICBcdFx0XHRcdFx0YWIuc3ViVmVjdG9ycyggcEEsIHBCICk7XG4gICAgXHRcdFx0XHRcdGNiLmNyb3NzKCBhYiApO1xuXG4gICAgXHRcdFx0XHRcdG5vcm1hbHNbIGkgXSA9IGNiLng7XG4gICAgXHRcdFx0XHRcdG5vcm1hbHNbIGkgKyAxIF0gPSBjYi55O1xuICAgIFx0XHRcdFx0XHRub3JtYWxzWyBpICsgMiBdID0gY2IuejtcblxuICAgIFx0XHRcdFx0XHRub3JtYWxzWyBpICsgMyBdID0gY2IueDtcbiAgICBcdFx0XHRcdFx0bm9ybWFsc1sgaSArIDQgXSA9IGNiLnk7XG4gICAgXHRcdFx0XHRcdG5vcm1hbHNbIGkgKyA1IF0gPSBjYi56O1xuXG4gICAgXHRcdFx0XHRcdG5vcm1hbHNbIGkgKyA2IF0gPSBjYi54O1xuICAgIFx0XHRcdFx0XHRub3JtYWxzWyBpICsgNyBdID0gY2IueTtcbiAgICBcdFx0XHRcdFx0bm9ybWFsc1sgaSArIDggXSA9IGNiLno7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdHRoaXMubm9ybWFsaXplTm9ybWFscygpO1xuXG4gICAgXHRcdFx0YXR0cmlidXRlcy5ub3JtYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgXHRcdH1cblxuICAgIFx0fSxcblxuICAgIFx0bWVyZ2U6IGZ1bmN0aW9uICggZ2VvbWV0cnksIG9mZnNldCApIHtcblxuICAgIFx0XHRpZiAoIChnZW9tZXRyeSAmJiBnZW9tZXRyeS5pc0J1ZmZlckdlb21ldHJ5KSA9PT0gZmFsc2UgKSB7XG5cbiAgICBcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnkubWVyZ2UoKTogZ2VvbWV0cnkgbm90IGFuIGluc3RhbmNlIG9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5LicsIGdlb21ldHJ5ICk7XG4gICAgXHRcdFx0cmV0dXJuO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuICAgIFx0XHR2YXIgYXR0cmlidXRlcyA9IHRoaXMuYXR0cmlidXRlcztcblxuICAgIFx0XHRmb3IgKCB2YXIga2V5IGluIGF0dHJpYnV0ZXMgKSB7XG5cbiAgICBcdFx0XHRpZiAoIGdlb21ldHJ5LmF0dHJpYnV0ZXNbIGtleSBdID09PSB1bmRlZmluZWQgKSBjb250aW51ZTtcblxuICAgIFx0XHRcdHZhciBhdHRyaWJ1dGUxID0gYXR0cmlidXRlc1sga2V5IF07XG4gICAgXHRcdFx0dmFyIGF0dHJpYnV0ZUFycmF5MSA9IGF0dHJpYnV0ZTEuYXJyYXk7XG5cbiAgICBcdFx0XHR2YXIgYXR0cmlidXRlMiA9IGdlb21ldHJ5LmF0dHJpYnV0ZXNbIGtleSBdO1xuICAgIFx0XHRcdHZhciBhdHRyaWJ1dGVBcnJheTIgPSBhdHRyaWJ1dGUyLmFycmF5O1xuXG4gICAgXHRcdFx0dmFyIGF0dHJpYnV0ZVNpemUgPSBhdHRyaWJ1dGUyLml0ZW1TaXplO1xuXG4gICAgXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBqID0gYXR0cmlidXRlU2l6ZSAqIG9mZnNldDsgaSA8IGF0dHJpYnV0ZUFycmF5Mi5sZW5ndGg7IGkgKyssIGogKysgKSB7XG5cbiAgICBcdFx0XHRcdGF0dHJpYnV0ZUFycmF5MVsgaiBdID0gYXR0cmlidXRlQXJyYXkyWyBpIF07XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRub3JtYWxpemVOb3JtYWxzOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dmFyIG5vcm1hbHMgPSB0aGlzLmF0dHJpYnV0ZXMubm9ybWFsLmFycmF5O1xuXG4gICAgXHRcdHZhciB4LCB5LCB6LCBuO1xuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBub3JtYWxzLmxlbmd0aDsgaSA8IGlsOyBpICs9IDMgKSB7XG5cbiAgICBcdFx0XHR4ID0gbm9ybWFsc1sgaSBdO1xuICAgIFx0XHRcdHkgPSBub3JtYWxzWyBpICsgMSBdO1xuICAgIFx0XHRcdHogPSBub3JtYWxzWyBpICsgMiBdO1xuXG4gICAgXHRcdFx0biA9IDEuMCAvIE1hdGguc3FydCggeCAqIHggKyB5ICogeSArIHogKiB6ICk7XG5cbiAgICBcdFx0XHRub3JtYWxzWyBpIF0gKj0gbjtcbiAgICBcdFx0XHRub3JtYWxzWyBpICsgMSBdICo9IG47XG4gICAgXHRcdFx0bm9ybWFsc1sgaSArIDIgXSAqPSBuO1xuXG4gICAgXHRcdH1cblxuICAgIFx0fSxcblxuICAgIFx0dG9Ob25JbmRleGVkOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0aWYgKCB0aGlzLmluZGV4ID09PSBudWxsICkge1xuXG4gICAgXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnkudG9Ob25JbmRleGVkKCk6IEdlb21ldHJ5IGlzIGFscmVhZHkgbm9uLWluZGV4ZWQuJyApO1xuICAgIFx0XHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHR2YXIgZ2VvbWV0cnkyID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cbiAgICBcdFx0dmFyIGluZGljZXMgPSB0aGlzLmluZGV4LmFycmF5O1xuICAgIFx0XHR2YXIgYXR0cmlidXRlcyA9IHRoaXMuYXR0cmlidXRlcztcblxuICAgIFx0XHRmb3IgKCB2YXIgbmFtZSBpbiBhdHRyaWJ1dGVzICkge1xuXG4gICAgXHRcdFx0dmFyIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbIG5hbWUgXTtcblxuICAgIFx0XHRcdHZhciBhcnJheSA9IGF0dHJpYnV0ZS5hcnJheTtcbiAgICBcdFx0XHR2YXIgaXRlbVNpemUgPSBhdHRyaWJ1dGUuaXRlbVNpemU7XG5cbiAgICBcdFx0XHR2YXIgYXJyYXkyID0gbmV3IGFycmF5LmNvbnN0cnVjdG9yKCBpbmRpY2VzLmxlbmd0aCAqIGl0ZW1TaXplICk7XG5cbiAgICBcdFx0XHR2YXIgaW5kZXggPSAwLCBpbmRleDIgPSAwO1xuXG4gICAgXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gaW5kaWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgXHRcdFx0XHRpbmRleCA9IGluZGljZXNbIGkgXSAqIGl0ZW1TaXplO1xuXG4gICAgXHRcdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCBpdGVtU2l6ZTsgaiArKyApIHtcblxuICAgIFx0XHRcdFx0XHRhcnJheTJbIGluZGV4MiArKyBdID0gYXJyYXlbIGluZGV4ICsrIF07XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGdlb21ldHJ5Mi5hZGRBdHRyaWJ1dGUoIG5hbWUsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIGFycmF5MiwgaXRlbVNpemUgKSApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gZ2VvbWV0cnkyO1xuXG4gICAgXHR9LFxuXG4gICAgXHR0b0pTT046IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR2YXIgZGF0YSA9IHtcbiAgICBcdFx0XHRtZXRhZGF0YToge1xuICAgIFx0XHRcdFx0dmVyc2lvbjogNC40LFxuICAgIFx0XHRcdFx0dHlwZTogJ0J1ZmZlckdlb21ldHJ5JyxcbiAgICBcdFx0XHRcdGdlbmVyYXRvcjogJ0J1ZmZlckdlb21ldHJ5LnRvSlNPTidcbiAgICBcdFx0XHR9XG4gICAgXHRcdH07XG5cbiAgICBcdFx0Ly8gc3RhbmRhcmQgQnVmZmVyR2VvbWV0cnkgc2VyaWFsaXphdGlvblxuXG4gICAgXHRcdGRhdGEudXVpZCA9IHRoaXMudXVpZDtcbiAgICBcdFx0ZGF0YS50eXBlID0gdGhpcy50eXBlO1xuICAgIFx0XHRpZiAoIHRoaXMubmFtZSAhPT0gJycgKSBkYXRhLm5hbWUgPSB0aGlzLm5hbWU7XG5cbiAgICBcdFx0aWYgKCB0aGlzLnBhcmFtZXRlcnMgIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdHZhciBwYXJhbWV0ZXJzID0gdGhpcy5wYXJhbWV0ZXJzO1xuXG4gICAgXHRcdFx0Zm9yICggdmFyIGtleSBpbiBwYXJhbWV0ZXJzICkge1xuXG4gICAgXHRcdFx0XHRpZiAoIHBhcmFtZXRlcnNbIGtleSBdICE9PSB1bmRlZmluZWQgKSBkYXRhWyBrZXkgXSA9IHBhcmFtZXRlcnNbIGtleSBdO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0cmV0dXJuIGRhdGE7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGRhdGEuZGF0YSA9IHsgYXR0cmlidXRlczoge30gfTtcblxuICAgIFx0XHR2YXIgaW5kZXggPSB0aGlzLmluZGV4O1xuXG4gICAgXHRcdGlmICggaW5kZXggIT09IG51bGwgKSB7XG5cbiAgICBcdFx0XHR2YXIgYXJyYXkgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggaW5kZXguYXJyYXkgKTtcblxuICAgIFx0XHRcdGRhdGEuZGF0YS5pbmRleCA9IHtcbiAgICBcdFx0XHRcdHR5cGU6IGluZGV4LmFycmF5LmNvbnN0cnVjdG9yLm5hbWUsXG4gICAgXHRcdFx0XHRhcnJheTogYXJyYXlcbiAgICBcdFx0XHR9O1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHR2YXIgYXR0cmlidXRlcyA9IHRoaXMuYXR0cmlidXRlcztcblxuICAgIFx0XHRmb3IgKCB2YXIga2V5IGluIGF0dHJpYnV0ZXMgKSB7XG5cbiAgICBcdFx0XHR2YXIgYXR0cmlidXRlID0gYXR0cmlidXRlc1sga2V5IF07XG5cbiAgICBcdFx0XHR2YXIgYXJyYXkgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggYXR0cmlidXRlLmFycmF5ICk7XG5cbiAgICBcdFx0XHRkYXRhLmRhdGEuYXR0cmlidXRlc1sga2V5IF0gPSB7XG4gICAgXHRcdFx0XHRpdGVtU2l6ZTogYXR0cmlidXRlLml0ZW1TaXplLFxuICAgIFx0XHRcdFx0dHlwZTogYXR0cmlidXRlLmFycmF5LmNvbnN0cnVjdG9yLm5hbWUsXG4gICAgXHRcdFx0XHRhcnJheTogYXJyYXksXG4gICAgXHRcdFx0XHRub3JtYWxpemVkOiBhdHRyaWJ1dGUubm9ybWFsaXplZFxuICAgIFx0XHRcdH07XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHZhciBncm91cHMgPSB0aGlzLmdyb3VwcztcblxuICAgIFx0XHRpZiAoIGdyb3Vwcy5sZW5ndGggPiAwICkge1xuXG4gICAgXHRcdFx0ZGF0YS5kYXRhLmdyb3VwcyA9IEpTT04ucGFyc2UoIEpTT04uc3RyaW5naWZ5KCBncm91cHMgKSApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHR2YXIgYm91bmRpbmdTcGhlcmUgPSB0aGlzLmJvdW5kaW5nU3BoZXJlO1xuXG4gICAgXHRcdGlmICggYm91bmRpbmdTcGhlcmUgIT09IG51bGwgKSB7XG5cbiAgICBcdFx0XHRkYXRhLmRhdGEuYm91bmRpbmdTcGhlcmUgPSB7XG4gICAgXHRcdFx0XHRjZW50ZXI6IGJvdW5kaW5nU3BoZXJlLmNlbnRlci50b0FycmF5KCksXG4gICAgXHRcdFx0XHRyYWRpdXM6IGJvdW5kaW5nU3BoZXJlLnJhZGl1c1xuICAgIFx0XHRcdH07XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiBkYXRhO1xuXG4gICAgXHR9LFxuXG4gICAgXHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdC8qXG4gICAgXHRcdC8vIEhhbmRsZSBwcmltaXRpdmVzXG5cbiAgICBcdFx0dmFyIHBhcmFtZXRlcnMgPSB0aGlzLnBhcmFtZXRlcnM7XG5cbiAgICBcdFx0aWYgKCBwYXJhbWV0ZXJzICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHR2YXIgdmFsdWVzID0gW107XG5cbiAgICBcdFx0XHRmb3IgKCB2YXIga2V5IGluIHBhcmFtZXRlcnMgKSB7XG5cbiAgICBcdFx0XHRcdHZhbHVlcy5wdXNoKCBwYXJhbWV0ZXJzWyBrZXkgXSApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0dmFyIGdlb21ldHJ5ID0gT2JqZWN0LmNyZWF0ZSggdGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgKTtcbiAgICBcdFx0XHR0aGlzLmNvbnN0cnVjdG9yLmFwcGx5KCBnZW9tZXRyeSwgdmFsdWVzICk7XG4gICAgXHRcdFx0cmV0dXJuIGdlb21ldHJ5O1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG4gICAgXHRcdCovXG5cbiAgICBcdFx0cmV0dXJuIG5ldyBCdWZmZXJHZW9tZXRyeSgpLmNvcHkoIHRoaXMgKTtcblxuICAgIFx0fSxcblxuICAgIFx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cbiAgICBcdFx0dmFyIGluZGV4ID0gc291cmNlLmluZGV4O1xuXG4gICAgXHRcdGlmICggaW5kZXggIT09IG51bGwgKSB7XG5cbiAgICBcdFx0XHR0aGlzLnNldEluZGV4KCBpbmRleC5jbG9uZSgpICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHZhciBhdHRyaWJ1dGVzID0gc291cmNlLmF0dHJpYnV0ZXM7XG5cbiAgICBcdFx0Zm9yICggdmFyIG5hbWUgaW4gYXR0cmlidXRlcyApIHtcblxuICAgIFx0XHRcdHZhciBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzWyBuYW1lIF07XG4gICAgXHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGUoIG5hbWUsIGF0dHJpYnV0ZS5jbG9uZSgpICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHZhciBncm91cHMgPSBzb3VyY2UuZ3JvdXBzO1xuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgXHRcdFx0dmFyIGdyb3VwID0gZ3JvdXBzWyBpIF07XG4gICAgXHRcdFx0dGhpcy5hZGRHcm91cCggZ3JvdXAuc3RhcnQsIGdyb3VwLmNvdW50LCBncm91cC5tYXRlcmlhbEluZGV4ICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dGhpcy5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdkaXNwb3NlJyB9ICk7XG5cbiAgICBcdH1cblxuICAgIH0gKTtcblxuICAgIEJ1ZmZlckdlb21ldHJ5Lk1heEluZGV4ID0gNjU1MzU7XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICAgICAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gICAgICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAgICAgKiBAYXV0aG9yIGpvbm9icjEgLyBodHRwOi8vam9ub2JyMS5jb20vXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBNZXNoKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKSB7XG5cbiAgICBcdE9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuICAgIFx0dGhpcy50eXBlID0gJ01lc2gnO1xuXG4gICAgXHR0aGlzLmdlb21ldHJ5ID0gZ2VvbWV0cnkgIT09IHVuZGVmaW5lZCA/IGdlb21ldHJ5IDogbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG4gICAgXHR0aGlzLm1hdGVyaWFsID0gbWF0ZXJpYWwgIT09IHVuZGVmaW5lZCA/IG1hdGVyaWFsIDogbmV3IE1lc2hCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmYgfSApO1xuXG4gICAgXHR0aGlzLmRyYXdNb2RlID0gVHJpYW5nbGVzRHJhd01vZGU7XG5cbiAgICBcdHRoaXMudXBkYXRlTW9ycGhUYXJnZXRzKCk7XG5cbiAgICB9XG5cbiAgICBNZXNoLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIE9iamVjdDNELnByb3RvdHlwZSApLCB7XG5cbiAgICBcdGNvbnN0cnVjdG9yOiBNZXNoLFxuXG4gICAgXHRpc01lc2g6IHRydWUsXG5cbiAgICBcdHNldERyYXdNb2RlOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG4gICAgXHRcdHRoaXMuZHJhd01vZGUgPSB2YWx1ZTtcblxuICAgIFx0fSxcblxuICAgIFx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cbiAgICBcdFx0T2JqZWN0M0QucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cbiAgICBcdFx0dGhpcy5kcmF3TW9kZSA9IHNvdXJjZS5kcmF3TW9kZTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0dXBkYXRlTW9ycGhUYXJnZXRzOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dmFyIG1vcnBoVGFyZ2V0cyA9IHRoaXMuZ2VvbWV0cnkubW9ycGhUYXJnZXRzO1xuXG4gICAgXHRcdGlmICggbW9ycGhUYXJnZXRzICE9PSB1bmRlZmluZWQgJiYgbW9ycGhUYXJnZXRzLmxlbmd0aCA+IDAgKSB7XG5cbiAgICBcdFx0XHR0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcyA9IFtdO1xuICAgIFx0XHRcdHRoaXMubW9ycGhUYXJnZXREaWN0aW9uYXJ5ID0ge307XG5cbiAgICBcdFx0XHRmb3IgKCB2YXIgbSA9IDAsIG1sID0gbW9ycGhUYXJnZXRzLmxlbmd0aDsgbSA8IG1sOyBtICsrICkge1xuXG4gICAgXHRcdFx0XHR0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcy5wdXNoKCAwICk7XG4gICAgXHRcdFx0XHR0aGlzLm1vcnBoVGFyZ2V0RGljdGlvbmFyeVsgbW9ycGhUYXJnZXRzWyBtIF0ubmFtZSBdID0gbTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdH0sXG5cbiAgICBcdHJheWNhc3Q6ICggZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHZhciBpbnZlcnNlTWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcbiAgICBcdFx0dmFyIHJheSA9IG5ldyBSYXkoKTtcbiAgICBcdFx0dmFyIHNwaGVyZSA9IG5ldyBTcGhlcmUoKTtcblxuICAgIFx0XHR2YXIgdkEgPSBuZXcgVmVjdG9yMygpO1xuICAgIFx0XHR2YXIgdkIgPSBuZXcgVmVjdG9yMygpO1xuICAgIFx0XHR2YXIgdkMgPSBuZXcgVmVjdG9yMygpO1xuXG4gICAgXHRcdHZhciB0ZW1wQSA9IG5ldyBWZWN0b3IzKCk7XG4gICAgXHRcdHZhciB0ZW1wQiA9IG5ldyBWZWN0b3IzKCk7XG4gICAgXHRcdHZhciB0ZW1wQyA9IG5ldyBWZWN0b3IzKCk7XG5cbiAgICBcdFx0dmFyIHV2QSA9IG5ldyBWZWN0b3IyKCk7XG4gICAgXHRcdHZhciB1dkIgPSBuZXcgVmVjdG9yMigpO1xuICAgIFx0XHR2YXIgdXZDID0gbmV3IFZlY3RvcjIoKTtcblxuICAgIFx0XHR2YXIgYmFyeWNvb3JkID0gbmV3IFZlY3RvcjMoKTtcblxuICAgIFx0XHR2YXIgaW50ZXJzZWN0aW9uUG9pbnQgPSBuZXcgVmVjdG9yMygpO1xuICAgIFx0XHR2YXIgaW50ZXJzZWN0aW9uUG9pbnRXb3JsZCA9IG5ldyBWZWN0b3IzKCk7XG5cbiAgICBcdFx0ZnVuY3Rpb24gdXZJbnRlcnNlY3Rpb24oIHBvaW50LCBwMSwgcDIsIHAzLCB1djEsIHV2MiwgdXYzICkge1xuXG4gICAgXHRcdFx0VHJpYW5nbGUuYmFyeWNvb3JkRnJvbVBvaW50KCBwb2ludCwgcDEsIHAyLCBwMywgYmFyeWNvb3JkICk7XG5cbiAgICBcdFx0XHR1djEubXVsdGlwbHlTY2FsYXIoIGJhcnljb29yZC54ICk7XG4gICAgXHRcdFx0dXYyLm11bHRpcGx5U2NhbGFyKCBiYXJ5Y29vcmQueSApO1xuICAgIFx0XHRcdHV2My5tdWx0aXBseVNjYWxhciggYmFyeWNvb3JkLnogKTtcblxuICAgIFx0XHRcdHV2MS5hZGQoIHV2MiApLmFkZCggdXYzICk7XG5cbiAgICBcdFx0XHRyZXR1cm4gdXYxLmNsb25lKCk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGZ1bmN0aW9uIGNoZWNrSW50ZXJzZWN0aW9uKCBvYmplY3QsIHJheWNhc3RlciwgcmF5LCBwQSwgcEIsIHBDLCBwb2ludCApIHtcblxuICAgIFx0XHRcdHZhciBpbnRlcnNlY3Q7XG4gICAgXHRcdFx0dmFyIG1hdGVyaWFsID0gb2JqZWN0Lm1hdGVyaWFsO1xuXG4gICAgXHRcdFx0aWYgKCBtYXRlcmlhbC5zaWRlID09PSBCYWNrU2lkZSApIHtcblxuICAgIFx0XHRcdFx0aW50ZXJzZWN0ID0gcmF5LmludGVyc2VjdFRyaWFuZ2xlKCBwQywgcEIsIHBBLCB0cnVlLCBwb2ludCApO1xuXG4gICAgXHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0aW50ZXJzZWN0ID0gcmF5LmludGVyc2VjdFRyaWFuZ2xlKCBwQSwgcEIsIHBDLCBtYXRlcmlhbC5zaWRlICE9PSBEb3VibGVTaWRlLCBwb2ludCApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0aWYgKCBpbnRlcnNlY3QgPT09IG51bGwgKSByZXR1cm4gbnVsbDtcblxuICAgIFx0XHRcdGludGVyc2VjdGlvblBvaW50V29ybGQuY29weSggcG9pbnQgKTtcbiAgICBcdFx0XHRpbnRlcnNlY3Rpb25Qb2ludFdvcmxkLmFwcGx5TWF0cml4NCggb2JqZWN0Lm1hdHJpeFdvcmxkICk7XG5cbiAgICBcdFx0XHR2YXIgZGlzdGFuY2UgPSByYXljYXN0ZXIucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKCBpbnRlcnNlY3Rpb25Qb2ludFdvcmxkICk7XG5cbiAgICBcdFx0XHRpZiAoIGRpc3RhbmNlIDwgcmF5Y2FzdGVyLm5lYXIgfHwgZGlzdGFuY2UgPiByYXljYXN0ZXIuZmFyICkgcmV0dXJuIG51bGw7XG5cbiAgICBcdFx0XHRyZXR1cm4ge1xuICAgIFx0XHRcdFx0ZGlzdGFuY2U6IGRpc3RhbmNlLFxuICAgIFx0XHRcdFx0cG9pbnQ6IGludGVyc2VjdGlvblBvaW50V29ybGQuY2xvbmUoKSxcbiAgICBcdFx0XHRcdG9iamVjdDogb2JqZWN0XG4gICAgXHRcdFx0fTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0ZnVuY3Rpb24gY2hlY2tCdWZmZXJHZW9tZXRyeUludGVyc2VjdGlvbiggb2JqZWN0LCByYXljYXN0ZXIsIHJheSwgcG9zaXRpb25zLCB1dnMsIGEsIGIsIGMgKSB7XG5cbiAgICBcdFx0XHR2QS5mcm9tQXJyYXkoIHBvc2l0aW9ucywgYSAqIDMgKTtcbiAgICBcdFx0XHR2Qi5mcm9tQXJyYXkoIHBvc2l0aW9ucywgYiAqIDMgKTtcbiAgICBcdFx0XHR2Qy5mcm9tQXJyYXkoIHBvc2l0aW9ucywgYyAqIDMgKTtcblxuICAgIFx0XHRcdHZhciBpbnRlcnNlY3Rpb24gPSBjaGVja0ludGVyc2VjdGlvbiggb2JqZWN0LCByYXljYXN0ZXIsIHJheSwgdkEsIHZCLCB2QywgaW50ZXJzZWN0aW9uUG9pbnQgKTtcblxuICAgIFx0XHRcdGlmICggaW50ZXJzZWN0aW9uICkge1xuXG4gICAgXHRcdFx0XHRpZiAoIHV2cyApIHtcblxuICAgIFx0XHRcdFx0XHR1dkEuZnJvbUFycmF5KCB1dnMsIGEgKiAyICk7XG4gICAgXHRcdFx0XHRcdHV2Qi5mcm9tQXJyYXkoIHV2cywgYiAqIDIgKTtcbiAgICBcdFx0XHRcdFx0dXZDLmZyb21BcnJheSggdXZzLCBjICogMiApO1xuXG4gICAgXHRcdFx0XHRcdGludGVyc2VjdGlvbi51diA9IHV2SW50ZXJzZWN0aW9uKCBpbnRlcnNlY3Rpb25Qb2ludCwgIHZBLCB2QiwgdkMsICB1dkEsIHV2QiwgdXZDICk7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0aW50ZXJzZWN0aW9uLmZhY2UgPSBuZXcgRmFjZTMoIGEsIGIsIGMsIFRyaWFuZ2xlLm5vcm1hbCggdkEsIHZCLCB2QyApICk7XG4gICAgXHRcdFx0XHRpbnRlcnNlY3Rpb24uZmFjZUluZGV4ID0gYTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdHJldHVybiBpbnRlcnNlY3Rpb247XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiBmdW5jdGlvbiByYXljYXN0KCByYXljYXN0ZXIsIGludGVyc2VjdHMgKSB7XG5cbiAgICBcdFx0XHR2YXIgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuICAgIFx0XHRcdHZhciBtYXRlcmlhbCA9IHRoaXMubWF0ZXJpYWw7XG4gICAgXHRcdFx0dmFyIG1hdHJpeFdvcmxkID0gdGhpcy5tYXRyaXhXb3JsZDtcblxuICAgIFx0XHRcdGlmICggbWF0ZXJpYWwgPT09IHVuZGVmaW5lZCApIHJldHVybjtcblxuICAgIFx0XHRcdC8vIENoZWNraW5nIGJvdW5kaW5nU3BoZXJlIGRpc3RhbmNlIHRvIHJheVxuXG4gICAgXHRcdFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApIGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuXG4gICAgXHRcdFx0c3BoZXJlLmNvcHkoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlICk7XG4gICAgXHRcdFx0c3BoZXJlLmFwcGx5TWF0cml4NCggbWF0cml4V29ybGQgKTtcblxuICAgIFx0XHRcdGlmICggcmF5Y2FzdGVyLnJheS5pbnRlcnNlY3RzU3BoZXJlKCBzcGhlcmUgKSA9PT0gZmFsc2UgKSByZXR1cm47XG5cbiAgICBcdFx0XHQvL1xuXG4gICAgXHRcdFx0aW52ZXJzZU1hdHJpeC5nZXRJbnZlcnNlKCBtYXRyaXhXb3JsZCApO1xuICAgIFx0XHRcdHJheS5jb3B5KCByYXljYXN0ZXIucmF5ICkuYXBwbHlNYXRyaXg0KCBpbnZlcnNlTWF0cml4ICk7XG5cbiAgICBcdFx0XHQvLyBDaGVjayBib3VuZGluZ0JveCBiZWZvcmUgY29udGludWluZ1xuXG4gICAgXHRcdFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ0JveCAhPT0gbnVsbCApIHtcblxuICAgIFx0XHRcdFx0aWYgKCByYXkuaW50ZXJzZWN0c0JveCggZ2VvbWV0cnkuYm91bmRpbmdCb3ggKSA9PT0gZmFsc2UgKSByZXR1cm47XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHR2YXIgdXZzLCBpbnRlcnNlY3Rpb247XG5cbiAgICBcdFx0XHRpZiAoIChnZW9tZXRyeSAmJiBnZW9tZXRyeS5pc0J1ZmZlckdlb21ldHJ5KSApIHtcblxuICAgIFx0XHRcdFx0dmFyIGEsIGIsIGM7XG4gICAgXHRcdFx0XHR2YXIgaW5kZXggPSBnZW9tZXRyeS5pbmRleDtcbiAgICBcdFx0XHRcdHZhciBhdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcbiAgICBcdFx0XHRcdHZhciBwb3NpdGlvbnMgPSBhdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xuXG4gICAgXHRcdFx0XHRpZiAoIGF0dHJpYnV0ZXMudXYgIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0XHR1dnMgPSBhdHRyaWJ1dGVzLnV2LmFycmF5O1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdGlmICggaW5kZXggIT09IG51bGwgKSB7XG5cbiAgICBcdFx0XHRcdFx0dmFyIGluZGljZXMgPSBpbmRleC5hcnJheTtcblxuICAgIFx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBpbmRpY2VzLmxlbmd0aDsgaSA8IGw7IGkgKz0gMyApIHtcblxuICAgIFx0XHRcdFx0XHRcdGEgPSBpbmRpY2VzWyBpIF07XG4gICAgXHRcdFx0XHRcdFx0YiA9IGluZGljZXNbIGkgKyAxIF07XG4gICAgXHRcdFx0XHRcdFx0YyA9IGluZGljZXNbIGkgKyAyIF07XG5cbiAgICBcdFx0XHRcdFx0XHRpbnRlcnNlY3Rpb24gPSBjaGVja0J1ZmZlckdlb21ldHJ5SW50ZXJzZWN0aW9uKCB0aGlzLCByYXljYXN0ZXIsIHJheSwgcG9zaXRpb25zLCB1dnMsIGEsIGIsIGMgKTtcblxuICAgIFx0XHRcdFx0XHRcdGlmICggaW50ZXJzZWN0aW9uICkge1xuXG4gICAgXHRcdFx0XHRcdFx0XHRpbnRlcnNlY3Rpb24uZmFjZUluZGV4ID0gTWF0aC5mbG9vciggaSAvIDMgKTsgLy8gdHJpYW5nbGUgbnVtYmVyIGluIGluZGljZXMgYnVmZmVyIHNlbWFudGljc1xuICAgIFx0XHRcdFx0XHRcdFx0aW50ZXJzZWN0cy5wdXNoKCBpbnRlcnNlY3Rpb24gKTtcblxuICAgIFx0XHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdH0gZWxzZSB7XG5cblxuICAgIFx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBwb3NpdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSArPSA5ICkge1xuXG4gICAgXHRcdFx0XHRcdFx0YSA9IGkgLyAzO1xuICAgIFx0XHRcdFx0XHRcdGIgPSBhICsgMTtcbiAgICBcdFx0XHRcdFx0XHRjID0gYSArIDI7XG5cbiAgICBcdFx0XHRcdFx0XHRpbnRlcnNlY3Rpb24gPSBjaGVja0J1ZmZlckdlb21ldHJ5SW50ZXJzZWN0aW9uKCB0aGlzLCByYXljYXN0ZXIsIHJheSwgcG9zaXRpb25zLCB1dnMsIGEsIGIsIGMgKTtcblxuICAgIFx0XHRcdFx0XHRcdGlmICggaW50ZXJzZWN0aW9uICkge1xuXG4gICAgXHRcdFx0XHRcdFx0XHRpbnRlcnNlY3Rpb24uaW5kZXggPSBhOyAvLyB0cmlhbmdsZSBudW1iZXIgaW4gcG9zaXRpb25zIGJ1ZmZlciBzZW1hbnRpY3NcbiAgICBcdFx0XHRcdFx0XHRcdGludGVyc2VjdHMucHVzaCggaW50ZXJzZWN0aW9uICk7XG5cbiAgICBcdFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9IGVsc2UgaWYgKCAoZ2VvbWV0cnkgJiYgZ2VvbWV0cnkuaXNHZW9tZXRyeSkgKSB7XG5cbiAgICBcdFx0XHRcdHZhciBmdkEsIGZ2QiwgZnZDO1xuICAgIFx0XHRcdFx0dmFyIGlzRmFjZU1hdGVyaWFsID0gKG1hdGVyaWFsICYmIG1hdGVyaWFsLmlzTXVsdGlNYXRlcmlhbCk7XG4gICAgXHRcdFx0XHR2YXIgbWF0ZXJpYWxzID0gaXNGYWNlTWF0ZXJpYWwgPT09IHRydWUgPyBtYXRlcmlhbC5tYXRlcmlhbHMgOiBudWxsO1xuXG4gICAgXHRcdFx0XHR2YXIgdmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcztcbiAgICBcdFx0XHRcdHZhciBmYWNlcyA9IGdlb21ldHJ5LmZhY2VzO1xuICAgIFx0XHRcdFx0dmFyIGZhY2VWZXJ0ZXhVdnMgPSBnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyAwIF07XG4gICAgXHRcdFx0XHRpZiAoIGZhY2VWZXJ0ZXhVdnMubGVuZ3RoID4gMCApIHV2cyA9IGZhY2VWZXJ0ZXhVdnM7XG5cbiAgICBcdFx0XHRcdGZvciAoIHZhciBmID0gMCwgZmwgPSBmYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcblxuICAgIFx0XHRcdFx0XHR2YXIgZmFjZSA9IGZhY2VzWyBmIF07XG4gICAgXHRcdFx0XHRcdHZhciBmYWNlTWF0ZXJpYWwgPSBpc0ZhY2VNYXRlcmlhbCA9PT0gdHJ1ZSA/IG1hdGVyaWFsc1sgZmFjZS5tYXRlcmlhbEluZGV4IF0gOiBtYXRlcmlhbDtcblxuICAgIFx0XHRcdFx0XHRpZiAoIGZhY2VNYXRlcmlhbCA9PT0gdW5kZWZpbmVkICkgY29udGludWU7XG5cbiAgICBcdFx0XHRcdFx0ZnZBID0gdmVydGljZXNbIGZhY2UuYSBdO1xuICAgIFx0XHRcdFx0XHRmdkIgPSB2ZXJ0aWNlc1sgZmFjZS5iIF07XG4gICAgXHRcdFx0XHRcdGZ2QyA9IHZlcnRpY2VzWyBmYWNlLmMgXTtcblxuICAgIFx0XHRcdFx0XHRpZiAoIGZhY2VNYXRlcmlhbC5tb3JwaFRhcmdldHMgPT09IHRydWUgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHR2YXIgbW9ycGhUYXJnZXRzID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzO1xuICAgIFx0XHRcdFx0XHRcdHZhciBtb3JwaEluZmx1ZW5jZXMgPSB0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcztcblxuICAgIFx0XHRcdFx0XHRcdHZBLnNldCggMCwgMCwgMCApO1xuICAgIFx0XHRcdFx0XHRcdHZCLnNldCggMCwgMCwgMCApO1xuICAgIFx0XHRcdFx0XHRcdHZDLnNldCggMCwgMCwgMCApO1xuXG4gICAgXHRcdFx0XHRcdFx0Zm9yICggdmFyIHQgPSAwLCB0bCA9IG1vcnBoVGFyZ2V0cy5sZW5ndGg7IHQgPCB0bDsgdCArKyApIHtcblxuICAgIFx0XHRcdFx0XHRcdFx0dmFyIGluZmx1ZW5jZSA9IG1vcnBoSW5mbHVlbmNlc1sgdCBdO1xuXG4gICAgXHRcdFx0XHRcdFx0XHRpZiAoIGluZmx1ZW5jZSA9PT0gMCApIGNvbnRpbnVlO1xuXG4gICAgXHRcdFx0XHRcdFx0XHR2YXIgdGFyZ2V0cyA9IG1vcnBoVGFyZ2V0c1sgdCBdLnZlcnRpY2VzO1xuXG4gICAgXHRcdFx0XHRcdFx0XHR2QS5hZGRTY2FsZWRWZWN0b3IoIHRlbXBBLnN1YlZlY3RvcnMoIHRhcmdldHNbIGZhY2UuYSBdLCBmdkEgKSwgaW5mbHVlbmNlICk7XG4gICAgXHRcdFx0XHRcdFx0XHR2Qi5hZGRTY2FsZWRWZWN0b3IoIHRlbXBCLnN1YlZlY3RvcnMoIHRhcmdldHNbIGZhY2UuYiBdLCBmdkIgKSwgaW5mbHVlbmNlICk7XG4gICAgXHRcdFx0XHRcdFx0XHR2Qy5hZGRTY2FsZWRWZWN0b3IoIHRlbXBDLnN1YlZlY3RvcnMoIHRhcmdldHNbIGZhY2UuYyBdLCBmdkMgKSwgaW5mbHVlbmNlICk7XG5cbiAgICBcdFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdFx0XHR2QS5hZGQoIGZ2QSApO1xuICAgIFx0XHRcdFx0XHRcdHZCLmFkZCggZnZCICk7XG4gICAgXHRcdFx0XHRcdFx0dkMuYWRkKCBmdkMgKTtcblxuICAgIFx0XHRcdFx0XHRcdGZ2QSA9IHZBO1xuICAgIFx0XHRcdFx0XHRcdGZ2QiA9IHZCO1xuICAgIFx0XHRcdFx0XHRcdGZ2QyA9IHZDO1xuXG4gICAgXHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0XHRpbnRlcnNlY3Rpb24gPSBjaGVja0ludGVyc2VjdGlvbiggdGhpcywgcmF5Y2FzdGVyLCByYXksIGZ2QSwgZnZCLCBmdkMsIGludGVyc2VjdGlvblBvaW50ICk7XG5cbiAgICBcdFx0XHRcdFx0aWYgKCBpbnRlcnNlY3Rpb24gKSB7XG5cbiAgICBcdFx0XHRcdFx0XHRpZiAoIHV2cyApIHtcblxuICAgIFx0XHRcdFx0XHRcdFx0dmFyIHV2c19mID0gdXZzWyBmIF07XG4gICAgXHRcdFx0XHRcdFx0XHR1dkEuY29weSggdXZzX2ZbIDAgXSApO1xuICAgIFx0XHRcdFx0XHRcdFx0dXZCLmNvcHkoIHV2c19mWyAxIF0gKTtcbiAgICBcdFx0XHRcdFx0XHRcdHV2Qy5jb3B5KCB1dnNfZlsgMiBdICk7XG5cbiAgICBcdFx0XHRcdFx0XHRcdGludGVyc2VjdGlvbi51diA9IHV2SW50ZXJzZWN0aW9uKCBpbnRlcnNlY3Rpb25Qb2ludCwgZnZBLCBmdkIsIGZ2QywgdXZBLCB1dkIsIHV2QyApO1xuXG4gICAgXHRcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRcdFx0aW50ZXJzZWN0aW9uLmZhY2UgPSBmYWNlO1xuICAgIFx0XHRcdFx0XHRcdGludGVyc2VjdGlvbi5mYWNlSW5kZXggPSBmO1xuICAgIFx0XHRcdFx0XHRcdGludGVyc2VjdHMucHVzaCggaW50ZXJzZWN0aW9uICk7XG5cbiAgICBcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fTtcblxuICAgIFx0fSgpICksXG5cbiAgICBcdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLmdlb21ldHJ5LCB0aGlzLm1hdGVyaWFsICkuY29weSggdGhpcyApO1xuXG4gICAgXHR9XG5cbiAgICB9ICk7XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIE11Z2VuODcgLyBodHRwczovL2dpdGh1Yi5jb20vTXVnZW44N1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gQm94QnVmZmVyR2VvbWV0cnkoIHdpZHRoLCBoZWlnaHQsIGRlcHRoLCB3aWR0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgZGVwdGhTZWdtZW50cyApIHtcblxuICAgIFx0QnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG4gICAgXHR0aGlzLnR5cGUgPSAnQm94QnVmZmVyR2VvbWV0cnknO1xuXG4gICAgXHR0aGlzLnBhcmFtZXRlcnMgPSB7XG4gICAgXHRcdHdpZHRoOiB3aWR0aCxcbiAgICBcdFx0aGVpZ2h0OiBoZWlnaHQsXG4gICAgXHRcdGRlcHRoOiBkZXB0aCxcbiAgICBcdFx0d2lkdGhTZWdtZW50czogd2lkdGhTZWdtZW50cyxcbiAgICBcdFx0aGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzLFxuICAgIFx0XHRkZXB0aFNlZ21lbnRzOiBkZXB0aFNlZ21lbnRzXG4gICAgXHR9O1xuXG4gICAgXHR2YXIgc2NvcGUgPSB0aGlzO1xuXG4gICAgXHQvLyBzZWdtZW50c1xuICAgIFx0d2lkdGhTZWdtZW50cyA9IE1hdGguZmxvb3IoIHdpZHRoU2VnbWVudHMgKSB8fCAxO1xuICAgIFx0aGVpZ2h0U2VnbWVudHMgPSBNYXRoLmZsb29yKCBoZWlnaHRTZWdtZW50cyApIHx8IDE7XG4gICAgXHRkZXB0aFNlZ21lbnRzID0gTWF0aC5mbG9vciggZGVwdGhTZWdtZW50cyApIHx8IDE7XG5cbiAgICBcdC8vIHRoZXNlIGFyZSB1c2VkIHRvIGNhbGN1bGF0ZSBidWZmZXIgbGVuZ3RoXG4gICAgXHR2YXIgdmVydGV4Q291bnQgPSBjYWxjdWxhdGVWZXJ0ZXhDb3VudCggd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIGRlcHRoU2VnbWVudHMgKTtcbiAgICBcdHZhciBpbmRleENvdW50ID0gY2FsY3VsYXRlSW5kZXhDb3VudCggd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIGRlcHRoU2VnbWVudHMgKTtcblxuICAgIFx0Ly8gYnVmZmVyc1xuICAgIFx0dmFyIGluZGljZXMgPSBuZXcgKCBpbmRleENvdW50ID4gNjU1MzUgPyBVaW50MzJBcnJheSA6IFVpbnQxNkFycmF5ICkoIGluZGV4Q291bnQgKTtcbiAgICBcdHZhciB2ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIHZlcnRleENvdW50ICogMyApO1xuICAgIFx0dmFyIG5vcm1hbHMgPSBuZXcgRmxvYXQzMkFycmF5KCB2ZXJ0ZXhDb3VudCAqIDMgKTtcbiAgICBcdHZhciB1dnMgPSBuZXcgRmxvYXQzMkFycmF5KCB2ZXJ0ZXhDb3VudCAqIDIgKTtcblxuICAgIFx0Ly8gb2Zmc2V0IHZhcmlhYmxlc1xuICAgIFx0dmFyIHZlcnRleEJ1ZmZlck9mZnNldCA9IDA7XG4gICAgXHR2YXIgdXZCdWZmZXJPZmZzZXQgPSAwO1xuICAgIFx0dmFyIGluZGV4QnVmZmVyT2Zmc2V0ID0gMDtcbiAgICBcdHZhciBudW1iZXJPZlZlcnRpY2VzID0gMDtcblxuICAgIFx0Ly8gZ3JvdXAgdmFyaWFibGVzXG4gICAgXHR2YXIgZ3JvdXBTdGFydCA9IDA7XG5cbiAgICBcdC8vIGJ1aWxkIGVhY2ggc2lkZSBvZiB0aGUgYm94IGdlb21ldHJ5XG4gICAgXHRidWlsZFBsYW5lKCAneicsICd5JywgJ3gnLCAtIDEsIC0gMSwgZGVwdGgsIGhlaWdodCwgICB3aWR0aCwgIGRlcHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCAwICk7IC8vIHB4XG4gICAgXHRidWlsZFBsYW5lKCAneicsICd5JywgJ3gnLCAgIDEsIC0gMSwgZGVwdGgsIGhlaWdodCwgLSB3aWR0aCwgIGRlcHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCAxICk7IC8vIG54XG4gICAgXHRidWlsZFBsYW5lKCAneCcsICd6JywgJ3knLCAgIDEsICAgMSwgd2lkdGgsIGRlcHRoLCAgICBoZWlnaHQsIHdpZHRoU2VnbWVudHMsIGRlcHRoU2VnbWVudHMsICAyICk7IC8vIHB5XG4gICAgXHRidWlsZFBsYW5lKCAneCcsICd6JywgJ3knLCAgIDEsIC0gMSwgd2lkdGgsIGRlcHRoLCAgLSBoZWlnaHQsIHdpZHRoU2VnbWVudHMsIGRlcHRoU2VnbWVudHMsICAzICk7IC8vIG55XG4gICAgXHRidWlsZFBsYW5lKCAneCcsICd5JywgJ3onLCAgIDEsIC0gMSwgd2lkdGgsIGhlaWdodCwgICBkZXB0aCwgIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCA0ICk7IC8vIHB6XG4gICAgXHRidWlsZFBsYW5lKCAneCcsICd5JywgJ3onLCAtIDEsIC0gMSwgd2lkdGgsIGhlaWdodCwgLSBkZXB0aCwgIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCA1ICk7IC8vIG56XG5cbiAgICBcdC8vIGJ1aWxkIGdlb21ldHJ5XG4gICAgXHR0aGlzLnNldEluZGV4KCBuZXcgQnVmZmVyQXR0cmlidXRlKCBpbmRpY2VzLCAxICkgKTtcbiAgICBcdHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XG4gICAgXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKSApO1xuICAgIFx0dGhpcy5hZGRBdHRyaWJ1dGUoICd1dicsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIHV2cywgMiApICk7XG5cbiAgICBcdC8vIGhlbHBlciBmdW5jdGlvbnNcblxuICAgIFx0ZnVuY3Rpb24gY2FsY3VsYXRlVmVydGV4Q291bnQoIHcsIGgsIGQgKSB7XG5cbiAgICBcdFx0dmFyIHZlcnRpY2VzID0gMDtcblxuICAgIFx0XHQvLyBjYWxjdWxhdGUgdGhlIGFtb3VudCBvZiB2ZXJ0aWNlcyBmb3IgZWFjaCBzaWRlIChwbGFuZSlcbiAgICBcdFx0dmVydGljZXMgKz0gKHcgKyAxKSAqIChoICsgMSkgKiAyOyAvLyB4eVxuICAgIFx0XHR2ZXJ0aWNlcyArPSAodyArIDEpICogKGQgKyAxKSAqIDI7IC8vIHh6XG4gICAgXHRcdHZlcnRpY2VzICs9IChkICsgMSkgKiAoaCArIDEpICogMjsgLy8genlcblxuICAgIFx0XHRyZXR1cm4gdmVydGljZXM7XG5cbiAgICBcdH1cblxuICAgIFx0ZnVuY3Rpb24gY2FsY3VsYXRlSW5kZXhDb3VudCggdywgaCwgZCApIHtcblxuICAgIFx0XHR2YXIgaW5kZXggPSAwO1xuXG4gICAgXHRcdC8vIGNhbGN1bGF0ZSB0aGUgYW1vdW50IG9mIHNxdWFyZXMgZm9yIGVhY2ggc2lkZVxuICAgIFx0XHRpbmRleCArPSB3ICogaCAqIDI7IC8vIHh5XG4gICAgXHRcdGluZGV4ICs9IHcgKiBkICogMjsgLy8geHpcbiAgICBcdFx0aW5kZXggKz0gZCAqIGggKiAyOyAvLyB6eVxuXG4gICAgXHRcdHJldHVybiBpbmRleCAqIDY7IC8vIHR3byB0cmlhbmdsZXMgcGVyIHNxdWFyZSA9PiBzaXggdmVydGljZXMgcGVyIHNxdWFyZVxuXG4gICAgXHR9XG5cbiAgICBcdGZ1bmN0aW9uIGJ1aWxkUGxhbmUoIHUsIHYsIHcsIHVkaXIsIHZkaXIsIHdpZHRoLCBoZWlnaHQsIGRlcHRoLCBncmlkWCwgZ3JpZFksIG1hdGVyaWFsSW5kZXggKSB7XG5cbiAgICBcdFx0dmFyIHNlZ21lbnRXaWR0aFx0PSB3aWR0aCAvIGdyaWRYO1xuICAgIFx0XHR2YXIgc2VnbWVudEhlaWdodCA9IGhlaWdodCAvIGdyaWRZO1xuXG4gICAgXHRcdHZhciB3aWR0aEhhbGYgPSB3aWR0aCAvIDI7XG4gICAgXHRcdHZhciBoZWlnaHRIYWxmID0gaGVpZ2h0IC8gMjtcbiAgICBcdFx0dmFyIGRlcHRoSGFsZiA9IGRlcHRoIC8gMjtcblxuICAgIFx0XHR2YXIgZ3JpZFgxID0gZ3JpZFggKyAxO1xuICAgIFx0XHR2YXIgZ3JpZFkxID0gZ3JpZFkgKyAxO1xuXG4gICAgXHRcdHZhciB2ZXJ0ZXhDb3VudGVyID0gMDtcbiAgICBcdFx0dmFyIGdyb3VwQ291bnQgPSAwO1xuXG4gICAgXHRcdHZhciB2ZWN0b3IgPSBuZXcgVmVjdG9yMygpO1xuXG4gICAgXHRcdC8vIGdlbmVyYXRlIHZlcnRpY2VzLCBub3JtYWxzIGFuZCB1dnNcblxuICAgIFx0XHRmb3IgKCB2YXIgaXkgPSAwOyBpeSA8IGdyaWRZMTsgaXkgKysgKSB7XG5cbiAgICBcdFx0XHR2YXIgeSA9IGl5ICogc2VnbWVudEhlaWdodCAtIGhlaWdodEhhbGY7XG5cbiAgICBcdFx0XHRmb3IgKCB2YXIgaXggPSAwOyBpeCA8IGdyaWRYMTsgaXggKysgKSB7XG5cbiAgICBcdFx0XHRcdHZhciB4ID0gaXggKiBzZWdtZW50V2lkdGggLSB3aWR0aEhhbGY7XG5cbiAgICBcdFx0XHRcdC8vIHNldCB2YWx1ZXMgdG8gY29ycmVjdCB2ZWN0b3IgY29tcG9uZW50XG4gICAgXHRcdFx0XHR2ZWN0b3JbIHUgXSA9IHggKiB1ZGlyO1xuICAgIFx0XHRcdFx0dmVjdG9yWyB2IF0gPSB5ICogdmRpcjtcbiAgICBcdFx0XHRcdHZlY3RvclsgdyBdID0gZGVwdGhIYWxmO1xuXG4gICAgXHRcdFx0XHQvLyBub3cgYXBwbHkgdmVjdG9yIHRvIHZlcnRleCBidWZmZXJcbiAgICBcdFx0XHRcdHZlcnRpY2VzWyB2ZXJ0ZXhCdWZmZXJPZmZzZXQgXSA9IHZlY3Rvci54O1xuICAgIFx0XHRcdFx0dmVydGljZXNbIHZlcnRleEJ1ZmZlck9mZnNldCArIDEgXSA9IHZlY3Rvci55O1xuICAgIFx0XHRcdFx0dmVydGljZXNbIHZlcnRleEJ1ZmZlck9mZnNldCArIDIgXSA9IHZlY3Rvci56O1xuXG4gICAgXHRcdFx0XHQvLyBzZXQgdmFsdWVzIHRvIGNvcnJlY3QgdmVjdG9yIGNvbXBvbmVudFxuICAgIFx0XHRcdFx0dmVjdG9yWyB1IF0gPSAwO1xuICAgIFx0XHRcdFx0dmVjdG9yWyB2IF0gPSAwO1xuICAgIFx0XHRcdFx0dmVjdG9yWyB3IF0gPSBkZXB0aCA+IDAgPyAxIDogLSAxO1xuXG4gICAgXHRcdFx0XHQvLyBub3cgYXBwbHkgdmVjdG9yIHRvIG5vcm1hbCBidWZmZXJcbiAgICBcdFx0XHRcdG5vcm1hbHNbIHZlcnRleEJ1ZmZlck9mZnNldCBdID0gdmVjdG9yLng7XG4gICAgXHRcdFx0XHRub3JtYWxzWyB2ZXJ0ZXhCdWZmZXJPZmZzZXQgKyAxIF0gPSB2ZWN0b3IueTtcbiAgICBcdFx0XHRcdG5vcm1hbHNbIHZlcnRleEJ1ZmZlck9mZnNldCArIDIgXSA9IHZlY3Rvci56O1xuXG4gICAgXHRcdFx0XHQvLyB1dnNcbiAgICBcdFx0XHRcdHV2c1sgdXZCdWZmZXJPZmZzZXQgXSA9IGl4IC8gZ3JpZFg7XG4gICAgXHRcdFx0XHR1dnNbIHV2QnVmZmVyT2Zmc2V0ICsgMSBdID0gMSAtICggaXkgLyBncmlkWSApO1xuXG4gICAgXHRcdFx0XHQvLyB1cGRhdGUgb2Zmc2V0cyBhbmQgY291bnRlcnNcbiAgICBcdFx0XHRcdHZlcnRleEJ1ZmZlck9mZnNldCArPSAzO1xuICAgIFx0XHRcdFx0dXZCdWZmZXJPZmZzZXQgKz0gMjtcbiAgICBcdFx0XHRcdHZlcnRleENvdW50ZXIgKz0gMTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdFx0Ly8gMS4geW91IG5lZWQgdGhyZWUgaW5kaWNlcyB0byBkcmF3IGEgc2luZ2xlIGZhY2VcbiAgICBcdFx0Ly8gMi4gYSBzaW5nbGUgc2VnbWVudCBjb25zaXN0cyBvZiB0d28gZmFjZXNcbiAgICBcdFx0Ly8gMy4gc28gd2UgbmVlZCB0byBnZW5lcmF0ZSBzaXggKDIqMykgaW5kaWNlcyBwZXIgc2VnbWVudFxuXG4gICAgXHRcdGZvciAoIGl5ID0gMDsgaXkgPCBncmlkWTsgaXkgKysgKSB7XG5cbiAgICBcdFx0XHRmb3IgKCBpeCA9IDA7IGl4IDwgZ3JpZFg7IGl4ICsrICkge1xuXG4gICAgXHRcdFx0XHQvLyBpbmRpY2VzXG4gICAgXHRcdFx0XHR2YXIgYSA9IG51bWJlck9mVmVydGljZXMgKyBpeCArIGdyaWRYMSAqIGl5O1xuICAgIFx0XHRcdFx0dmFyIGIgPSBudW1iZXJPZlZlcnRpY2VzICsgaXggKyBncmlkWDEgKiAoIGl5ICsgMSApO1xuICAgIFx0XHRcdFx0dmFyIGMgPSBudW1iZXJPZlZlcnRpY2VzICsgKCBpeCArIDEgKSArIGdyaWRYMSAqICggaXkgKyAxICk7XG4gICAgXHRcdFx0XHR2YXIgZCA9IG51bWJlck9mVmVydGljZXMgKyAoIGl4ICsgMSApICsgZ3JpZFgxICogaXk7XG5cbiAgICBcdFx0XHRcdC8vIGZhY2Ugb25lXG4gICAgXHRcdFx0XHRpbmRpY2VzWyBpbmRleEJ1ZmZlck9mZnNldCBdID0gYTtcbiAgICBcdFx0XHRcdGluZGljZXNbIGluZGV4QnVmZmVyT2Zmc2V0ICsgMSBdID0gYjtcbiAgICBcdFx0XHRcdGluZGljZXNbIGluZGV4QnVmZmVyT2Zmc2V0ICsgMiBdID0gZDtcblxuICAgIFx0XHRcdFx0Ly8gZmFjZSB0d29cbiAgICBcdFx0XHRcdGluZGljZXNbIGluZGV4QnVmZmVyT2Zmc2V0ICsgMyBdID0gYjtcbiAgICBcdFx0XHRcdGluZGljZXNbIGluZGV4QnVmZmVyT2Zmc2V0ICsgNCBdID0gYztcbiAgICBcdFx0XHRcdGluZGljZXNbIGluZGV4QnVmZmVyT2Zmc2V0ICsgNSBdID0gZDtcblxuICAgIFx0XHRcdFx0Ly8gdXBkYXRlIG9mZnNldHMgYW5kIGNvdW50ZXJzXG4gICAgXHRcdFx0XHRpbmRleEJ1ZmZlck9mZnNldCArPSA2O1xuICAgIFx0XHRcdFx0Z3JvdXBDb3VudCArPSA2O1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHQvLyBhZGQgYSBncm91cCB0byB0aGUgZ2VvbWV0cnkuIHRoaXMgd2lsbCBlbnN1cmUgbXVsdGkgbWF0ZXJpYWwgc3VwcG9ydFxuICAgIFx0XHRzY29wZS5hZGRHcm91cCggZ3JvdXBTdGFydCwgZ3JvdXBDb3VudCwgbWF0ZXJpYWxJbmRleCApO1xuXG4gICAgXHRcdC8vIGNhbGN1bGF0ZSBuZXcgc3RhcnQgdmFsdWUgZm9yIGdyb3Vwc1xuICAgIFx0XHRncm91cFN0YXJ0ICs9IGdyb3VwQ291bnQ7XG5cbiAgICBcdFx0Ly8gdXBkYXRlIHRvdGFsIG51bWJlciBvZiB2ZXJ0aWNlc1xuICAgIFx0XHRudW1iZXJPZlZlcnRpY2VzICs9IHZlcnRleENvdW50ZXI7XG5cbiAgICBcdH1cblxuICAgIH1cblxuICAgIEJveEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xuICAgIEJveEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEJveEJ1ZmZlckdlb21ldHJ5O1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAgICAgKiBiYXNlZCBvbiBodHRwOi8vcGFwZXJ2aXNpb24zZC5nb29nbGVjb2RlLmNvbS9zdm4vdHJ1bmsvYXMzL3RydW5rL3NyYy9vcmcvcGFwZXJ2aXNpb24zZC9vYmplY3RzL3ByaW1pdGl2ZXMvUGxhbmUuYXNcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIFBsYW5lQnVmZmVyR2VvbWV0cnkoIHdpZHRoLCBoZWlnaHQsIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzICkge1xuXG4gICAgXHRCdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cbiAgICBcdHRoaXMudHlwZSA9ICdQbGFuZUJ1ZmZlckdlb21ldHJ5JztcblxuICAgIFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuICAgIFx0XHR3aWR0aDogd2lkdGgsXG4gICAgXHRcdGhlaWdodDogaGVpZ2h0LFxuICAgIFx0XHR3aWR0aFNlZ21lbnRzOiB3aWR0aFNlZ21lbnRzLFxuICAgIFx0XHRoZWlnaHRTZWdtZW50czogaGVpZ2h0U2VnbWVudHNcbiAgICBcdH07XG5cbiAgICBcdHZhciB3aWR0aF9oYWxmID0gd2lkdGggLyAyO1xuICAgIFx0dmFyIGhlaWdodF9oYWxmID0gaGVpZ2h0IC8gMjtcblxuICAgIFx0dmFyIGdyaWRYID0gTWF0aC5mbG9vciggd2lkdGhTZWdtZW50cyApIHx8IDE7XG4gICAgXHR2YXIgZ3JpZFkgPSBNYXRoLmZsb29yKCBoZWlnaHRTZWdtZW50cyApIHx8IDE7XG5cbiAgICBcdHZhciBncmlkWDEgPSBncmlkWCArIDE7XG4gICAgXHR2YXIgZ3JpZFkxID0gZ3JpZFkgKyAxO1xuXG4gICAgXHR2YXIgc2VnbWVudF93aWR0aCA9IHdpZHRoIC8gZ3JpZFg7XG4gICAgXHR2YXIgc2VnbWVudF9oZWlnaHQgPSBoZWlnaHQgLyBncmlkWTtcblxuICAgIFx0dmFyIHZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheSggZ3JpZFgxICogZ3JpZFkxICogMyApO1xuICAgIFx0dmFyIG5vcm1hbHMgPSBuZXcgRmxvYXQzMkFycmF5KCBncmlkWDEgKiBncmlkWTEgKiAzICk7XG4gICAgXHR2YXIgdXZzID0gbmV3IEZsb2F0MzJBcnJheSggZ3JpZFgxICogZ3JpZFkxICogMiApO1xuXG4gICAgXHR2YXIgb2Zmc2V0ID0gMDtcbiAgICBcdHZhciBvZmZzZXQyID0gMDtcblxuICAgIFx0Zm9yICggdmFyIGl5ID0gMDsgaXkgPCBncmlkWTE7IGl5ICsrICkge1xuXG4gICAgXHRcdHZhciB5ID0gaXkgKiBzZWdtZW50X2hlaWdodCAtIGhlaWdodF9oYWxmO1xuXG4gICAgXHRcdGZvciAoIHZhciBpeCA9IDA7IGl4IDwgZ3JpZFgxOyBpeCArKyApIHtcblxuICAgIFx0XHRcdHZhciB4ID0gaXggKiBzZWdtZW50X3dpZHRoIC0gd2lkdGhfaGFsZjtcblxuICAgIFx0XHRcdHZlcnRpY2VzWyBvZmZzZXQgXSA9IHg7XG4gICAgXHRcdFx0dmVydGljZXNbIG9mZnNldCArIDEgXSA9IC0geTtcblxuICAgIFx0XHRcdG5vcm1hbHNbIG9mZnNldCArIDIgXSA9IDE7XG5cbiAgICBcdFx0XHR1dnNbIG9mZnNldDIgXSA9IGl4IC8gZ3JpZFg7XG4gICAgXHRcdFx0dXZzWyBvZmZzZXQyICsgMSBdID0gMSAtICggaXkgLyBncmlkWSApO1xuXG4gICAgXHRcdFx0b2Zmc2V0ICs9IDM7XG4gICAgXHRcdFx0b2Zmc2V0MiArPSAyO1xuXG4gICAgXHRcdH1cblxuICAgIFx0fVxuXG4gICAgXHRvZmZzZXQgPSAwO1xuXG4gICAgXHR2YXIgaW5kaWNlcyA9IG5ldyAoICggdmVydGljZXMubGVuZ3RoIC8gMyApID4gNjU1MzUgPyBVaW50MzJBcnJheSA6IFVpbnQxNkFycmF5ICkoIGdyaWRYICogZ3JpZFkgKiA2ICk7XG5cbiAgICBcdGZvciAoIHZhciBpeSA9IDA7IGl5IDwgZ3JpZFk7IGl5ICsrICkge1xuXG4gICAgXHRcdGZvciAoIHZhciBpeCA9IDA7IGl4IDwgZ3JpZFg7IGl4ICsrICkge1xuXG4gICAgXHRcdFx0dmFyIGEgPSBpeCArIGdyaWRYMSAqIGl5O1xuICAgIFx0XHRcdHZhciBiID0gaXggKyBncmlkWDEgKiAoIGl5ICsgMSApO1xuICAgIFx0XHRcdHZhciBjID0gKCBpeCArIDEgKSArIGdyaWRYMSAqICggaXkgKyAxICk7XG4gICAgXHRcdFx0dmFyIGQgPSAoIGl4ICsgMSApICsgZ3JpZFgxICogaXk7XG5cbiAgICBcdFx0XHRpbmRpY2VzWyBvZmZzZXQgXSA9IGE7XG4gICAgXHRcdFx0aW5kaWNlc1sgb2Zmc2V0ICsgMSBdID0gYjtcbiAgICBcdFx0XHRpbmRpY2VzWyBvZmZzZXQgKyAyIF0gPSBkO1xuXG4gICAgXHRcdFx0aW5kaWNlc1sgb2Zmc2V0ICsgMyBdID0gYjtcbiAgICBcdFx0XHRpbmRpY2VzWyBvZmZzZXQgKyA0IF0gPSBjO1xuICAgIFx0XHRcdGluZGljZXNbIG9mZnNldCArIDUgXSA9IGQ7XG5cbiAgICBcdFx0XHRvZmZzZXQgKz0gNjtcblxuICAgIFx0XHR9XG5cbiAgICBcdH1cblxuICAgIFx0dGhpcy5zZXRJbmRleCggbmV3IEJ1ZmZlckF0dHJpYnV0ZSggaW5kaWNlcywgMSApICk7XG4gICAgXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xuICAgIFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCAzICkgKTtcbiAgICBcdHRoaXMuYWRkQXR0cmlidXRlKCAndXYnLCBuZXcgQnVmZmVyQXR0cmlidXRlKCB1dnMsIDIgKSApO1xuXG4gICAgfVxuXG4gICAgUGxhbmVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcbiAgICBQbGFuZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBsYW5lQnVmZmVyR2VvbWV0cnk7XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICAgICAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gICAgICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4gICAgKi9cblxuICAgIGZ1bmN0aW9uIENhbWVyYSgpIHtcblxuICAgIFx0T2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG4gICAgXHR0aGlzLnR5cGUgPSAnQ2FtZXJhJztcblxuICAgIFx0dGhpcy5tYXRyaXhXb3JsZEludmVyc2UgPSBuZXcgTWF0cml4NCgpO1xuICAgIFx0dGhpcy5wcm9qZWN0aW9uTWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcblxuICAgIH1cblxuICAgIENhbWVyYS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBPYmplY3QzRC5wcm90b3R5cGUgKTtcbiAgICBDYW1lcmEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2FtZXJhO1xuXG4gICAgQ2FtZXJhLnByb3RvdHlwZS5pc0NhbWVyYSA9IHRydWU7XG5cbiAgICBDYW1lcmEucHJvdG90eXBlLmdldFdvcmxkRGlyZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuXG4gICAgXHR2YXIgcXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG5cbiAgICBcdHJldHVybiBmdW5jdGlvbiBnZXRXb3JsZERpcmVjdGlvbiggb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICBcdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XG5cbiAgICBcdFx0dGhpcy5nZXRXb3JsZFF1YXRlcm5pb24oIHF1YXRlcm5pb24gKTtcblxuICAgIFx0XHRyZXR1cm4gcmVzdWx0LnNldCggMCwgMCwgLSAxICkuYXBwbHlRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICk7XG5cbiAgICBcdH07XG5cbiAgICB9KCk7XG5cbiAgICBDYW1lcmEucHJvdG90eXBlLmxvb2tBdCA9IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0Ly8gVGhpcyByb3V0aW5lIGRvZXMgbm90IHN1cHBvcnQgY2FtZXJhcyB3aXRoIHJvdGF0ZWQgYW5kL29yIHRyYW5zbGF0ZWQgcGFyZW50KHMpXG5cbiAgICBcdHZhciBtMSA9IG5ldyBNYXRyaXg0KCk7XG5cbiAgICBcdHJldHVybiBmdW5jdGlvbiBsb29rQXQoIHZlY3RvciApIHtcblxuICAgIFx0XHRtMS5sb29rQXQoIHRoaXMucG9zaXRpb24sIHZlY3RvciwgdGhpcy51cCApO1xuXG4gICAgXHRcdHRoaXMucXVhdGVybmlvbi5zZXRGcm9tUm90YXRpb25NYXRyaXgoIG0xICk7XG5cbiAgICBcdH07XG5cbiAgICB9KCk7XG5cbiAgICBDYW1lcmEucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuXG4gICAgXHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cbiAgICB9O1xuXG4gICAgQ2FtZXJhLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cbiAgICBcdE9iamVjdDNELnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG4gICAgXHR0aGlzLm1hdHJpeFdvcmxkSW52ZXJzZS5jb3B5KCBzb3VyY2UubWF0cml4V29ybGRJbnZlcnNlICk7XG4gICAgXHR0aGlzLnByb2plY3Rpb25NYXRyaXguY29weSggc291cmNlLnByb2plY3Rpb25NYXRyaXggKTtcblxuICAgIFx0cmV0dXJuIHRoaXM7XG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAgICAgKiBAYXV0aG9yIGdyZWdnbWFuIC8gaHR0cDovL2dhbWVzLmdyZWdnbWFuLmNvbS9cbiAgICAgKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXG4gICAgICogQGF1dGhvciB0c2Nod1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gUGVyc3BlY3RpdmVDYW1lcmEoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKSB7XG5cbiAgICBcdENhbWVyYS5jYWxsKCB0aGlzICk7XG5cbiAgICBcdHRoaXMudHlwZSA9ICdQZXJzcGVjdGl2ZUNhbWVyYSc7XG5cbiAgICBcdHRoaXMuZm92ID0gZm92ICE9PSB1bmRlZmluZWQgPyBmb3YgOiA1MDtcbiAgICBcdHRoaXMuem9vbSA9IDE7XG5cbiAgICBcdHRoaXMubmVhciA9IG5lYXIgIT09IHVuZGVmaW5lZCA/IG5lYXIgOiAwLjE7XG4gICAgXHR0aGlzLmZhciA9IGZhciAhPT0gdW5kZWZpbmVkID8gZmFyIDogMjAwMDtcbiAgICBcdHRoaXMuZm9jdXMgPSAxMDtcblxuICAgIFx0dGhpcy5hc3BlY3QgPSBhc3BlY3QgIT09IHVuZGVmaW5lZCA/IGFzcGVjdCA6IDE7XG4gICAgXHR0aGlzLnZpZXcgPSBudWxsO1xuXG4gICAgXHR0aGlzLmZpbG1HYXVnZSA9IDM1O1x0Ly8gd2lkdGggb2YgdGhlIGZpbG0gKGRlZmF1bHQgaW4gbWlsbGltZXRlcnMpXG4gICAgXHR0aGlzLmZpbG1PZmZzZXQgPSAwO1x0Ly8gaG9yaXpvbnRhbCBmaWxtIG9mZnNldCAoc2FtZSB1bml0IGFzIGdhdWdlKVxuXG4gICAgXHR0aGlzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblxuICAgIH1cblxuICAgIFBlcnNwZWN0aXZlQ2FtZXJhLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIENhbWVyYS5wcm90b3R5cGUgKSwge1xuXG4gICAgXHRjb25zdHJ1Y3RvcjogUGVyc3BlY3RpdmVDYW1lcmEsXG5cbiAgICBcdGlzUGVyc3BlY3RpdmVDYW1lcmE6IHRydWUsXG5cbiAgICBcdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xuXG4gICAgXHRcdENhbWVyYS5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuICAgIFx0XHR0aGlzLmZvdiA9IHNvdXJjZS5mb3Y7XG4gICAgXHRcdHRoaXMuem9vbSA9IHNvdXJjZS56b29tO1xuXG4gICAgXHRcdHRoaXMubmVhciA9IHNvdXJjZS5uZWFyO1xuICAgIFx0XHR0aGlzLmZhciA9IHNvdXJjZS5mYXI7XG4gICAgXHRcdHRoaXMuZm9jdXMgPSBzb3VyY2UuZm9jdXM7XG5cbiAgICBcdFx0dGhpcy5hc3BlY3QgPSBzb3VyY2UuYXNwZWN0O1xuICAgIFx0XHR0aGlzLnZpZXcgPSBzb3VyY2UudmlldyA9PT0gbnVsbCA/IG51bGwgOiBPYmplY3QuYXNzaWduKCB7fSwgc291cmNlLnZpZXcgKTtcblxuICAgIFx0XHR0aGlzLmZpbG1HYXVnZSA9IHNvdXJjZS5maWxtR2F1Z2U7XG4gICAgXHRcdHRoaXMuZmlsbU9mZnNldCA9IHNvdXJjZS5maWxtT2Zmc2V0O1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHQvKipcbiAgICBcdCAqIFNldHMgdGhlIEZPViBieSBmb2NhbCBsZW5ndGggaW4gcmVzcGVjdCB0byB0aGUgY3VycmVudCAuZmlsbUdhdWdlLlxuICAgIFx0ICpcbiAgICBcdCAqIFRoZSBkZWZhdWx0IGZpbG0gZ2F1Z2UgaXMgMzUsIHNvIHRoYXQgdGhlIGZvY2FsIGxlbmd0aCBjYW4gYmUgc3BlY2lmaWVkIGZvclxuICAgIFx0ICogYSAzNW1tIChmdWxsIGZyYW1lKSBjYW1lcmEuXG4gICAgXHQgKlxuICAgIFx0ICogVmFsdWVzIGZvciBmb2NhbCBsZW5ndGggYW5kIGZpbG0gZ2F1Z2UgbXVzdCBoYXZlIHRoZSBzYW1lIHVuaXQuXG4gICAgXHQgKi9cbiAgICBcdHNldEZvY2FsTGVuZ3RoOiBmdW5jdGlvbiAoIGZvY2FsTGVuZ3RoICkge1xuXG4gICAgXHRcdC8vIHNlZSBodHRwOi8vd3d3LmJvYmF0a2lucy5jb20vcGhvdG9ncmFwaHkvdGVjaG5pY2FsL2ZpZWxkX29mX3ZpZXcuaHRtbFxuICAgIFx0XHR2YXIgdkV4dGVudFNsb3BlID0gMC41ICogdGhpcy5nZXRGaWxtSGVpZ2h0KCkgLyBmb2NhbExlbmd0aDtcblxuICAgIFx0XHR0aGlzLmZvdiA9IGV4cG9ydHMuTWF0aC5SQUQyREVHICogMiAqIE1hdGguYXRhbiggdkV4dGVudFNsb3BlICk7XG4gICAgXHRcdHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuXG4gICAgXHR9LFxuXG4gICAgXHQvKipcbiAgICBcdCAqIENhbGN1bGF0ZXMgdGhlIGZvY2FsIGxlbmd0aCBmcm9tIHRoZSBjdXJyZW50IC5mb3YgYW5kIC5maWxtR2F1Z2UuXG4gICAgXHQgKi9cbiAgICBcdGdldEZvY2FsTGVuZ3RoOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dmFyIHZFeHRlbnRTbG9wZSA9IE1hdGgudGFuKCBleHBvcnRzLk1hdGguREVHMlJBRCAqIDAuNSAqIHRoaXMuZm92ICk7XG5cbiAgICBcdFx0cmV0dXJuIDAuNSAqIHRoaXMuZ2V0RmlsbUhlaWdodCgpIC8gdkV4dGVudFNsb3BlO1xuXG4gICAgXHR9LFxuXG4gICAgXHRnZXRFZmZlY3RpdmVGT1Y6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHRyZXR1cm4gZXhwb3J0cy5NYXRoLlJBRDJERUcgKiAyICogTWF0aC5hdGFuKFxuICAgIFx0XHRcdFx0TWF0aC50YW4oIGV4cG9ydHMuTWF0aC5ERUcyUkFEICogMC41ICogdGhpcy5mb3YgKSAvIHRoaXMuem9vbSApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRnZXRGaWxtV2lkdGg6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHQvLyBmaWxtIG5vdCBjb21wbGV0ZWx5IGNvdmVyZWQgaW4gcG9ydHJhaXQgZm9ybWF0IChhc3BlY3QgPCAxKVxuICAgIFx0XHRyZXR1cm4gdGhpcy5maWxtR2F1Z2UgKiBNYXRoLm1pbiggdGhpcy5hc3BlY3QsIDEgKTtcblxuICAgIFx0fSxcblxuICAgIFx0Z2V0RmlsbUhlaWdodDogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdC8vIGZpbG0gbm90IGNvbXBsZXRlbHkgY292ZXJlZCBpbiBsYW5kc2NhcGUgZm9ybWF0IChhc3BlY3QgPiAxKVxuICAgIFx0XHRyZXR1cm4gdGhpcy5maWxtR2F1Z2UgLyBNYXRoLm1heCggdGhpcy5hc3BlY3QsIDEgKTtcblxuICAgIFx0fSxcblxuICAgIFx0LyoqXG4gICAgXHQgKiBTZXRzIGFuIG9mZnNldCBpbiBhIGxhcmdlciBmcnVzdHVtLiBUaGlzIGlzIHVzZWZ1bCBmb3IgbXVsdGktd2luZG93IG9yXG4gICAgXHQgKiBtdWx0aS1tb25pdG9yL211bHRpLW1hY2hpbmUgc2V0dXBzLlxuICAgIFx0ICpcbiAgICBcdCAqIEZvciBleGFtcGxlLCBpZiB5b3UgaGF2ZSAzeDIgbW9uaXRvcnMgYW5kIGVhY2ggbW9uaXRvciBpcyAxOTIweDEwODAgYW5kXG4gICAgXHQgKiB0aGUgbW9uaXRvcnMgYXJlIGluIGdyaWQgbGlrZSB0aGlzXG4gICAgXHQgKlxuICAgIFx0ICogICArLS0tKy0tLSstLS0rXG4gICAgXHQgKiAgIHwgQSB8IEIgfCBDIHxcbiAgICBcdCAqICAgKy0tLSstLS0rLS0tK1xuICAgIFx0ICogICB8IEQgfCBFIHwgRiB8XG4gICAgXHQgKiAgICstLS0rLS0tKy0tLStcbiAgICBcdCAqXG4gICAgXHQgKiB0aGVuIGZvciBlYWNoIG1vbml0b3IgeW91IHdvdWxkIGNhbGwgaXQgbGlrZSB0aGlzXG4gICAgXHQgKlxuICAgIFx0ICogICB2YXIgdyA9IDE5MjA7XG4gICAgXHQgKiAgIHZhciBoID0gMTA4MDtcbiAgICBcdCAqICAgdmFyIGZ1bGxXaWR0aCA9IHcgKiAzO1xuICAgIFx0ICogICB2YXIgZnVsbEhlaWdodCA9IGggKiAyO1xuICAgIFx0ICpcbiAgICBcdCAqICAgLS1BLS1cbiAgICBcdCAqICAgY2FtZXJhLnNldE9mZnNldCggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB3ICogMCwgaCAqIDAsIHcsIGggKTtcbiAgICBcdCAqICAgLS1CLS1cbiAgICBcdCAqICAgY2FtZXJhLnNldE9mZnNldCggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB3ICogMSwgaCAqIDAsIHcsIGggKTtcbiAgICBcdCAqICAgLS1DLS1cbiAgICBcdCAqICAgY2FtZXJhLnNldE9mZnNldCggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB3ICogMiwgaCAqIDAsIHcsIGggKTtcbiAgICBcdCAqICAgLS1ELS1cbiAgICBcdCAqICAgY2FtZXJhLnNldE9mZnNldCggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB3ICogMCwgaCAqIDEsIHcsIGggKTtcbiAgICBcdCAqICAgLS1FLS1cbiAgICBcdCAqICAgY2FtZXJhLnNldE9mZnNldCggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB3ICogMSwgaCAqIDEsIHcsIGggKTtcbiAgICBcdCAqICAgLS1GLS1cbiAgICBcdCAqICAgY2FtZXJhLnNldE9mZnNldCggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB3ICogMiwgaCAqIDEsIHcsIGggKTtcbiAgICBcdCAqXG4gICAgXHQgKiAgIE5vdGUgdGhlcmUgaXMgbm8gcmVhc29uIG1vbml0b3JzIGhhdmUgdG8gYmUgdGhlIHNhbWUgc2l6ZSBvciBpbiBhIGdyaWQuXG4gICAgXHQgKi9cbiAgICBcdHNldFZpZXdPZmZzZXQ6IGZ1bmN0aW9uICggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0ICkge1xuXG4gICAgXHRcdHRoaXMuYXNwZWN0ID0gZnVsbFdpZHRoIC8gZnVsbEhlaWdodDtcblxuICAgIFx0XHR0aGlzLnZpZXcgPSB7XG4gICAgXHRcdFx0ZnVsbFdpZHRoOiBmdWxsV2lkdGgsXG4gICAgXHRcdFx0ZnVsbEhlaWdodDogZnVsbEhlaWdodCxcbiAgICBcdFx0XHRvZmZzZXRYOiB4LFxuICAgIFx0XHRcdG9mZnNldFk6IHksXG4gICAgXHRcdFx0d2lkdGg6IHdpZHRoLFxuICAgIFx0XHRcdGhlaWdodDogaGVpZ2h0XG4gICAgXHRcdH07XG5cbiAgICBcdFx0dGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGNsZWFyVmlld09mZnNldDogZnVuY3Rpb24oKSB7XG5cbiAgICBcdFx0dGhpcy52aWV3ID0gbnVsbDtcbiAgICBcdFx0dGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG5cbiAgICBcdH0sXG5cbiAgICBcdHVwZGF0ZVByb2plY3Rpb25NYXRyaXg6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR2YXIgbmVhciA9IHRoaXMubmVhcixcbiAgICBcdFx0XHR0b3AgPSBuZWFyICogTWF0aC50YW4oXG4gICAgXHRcdFx0XHRcdGV4cG9ydHMuTWF0aC5ERUcyUkFEICogMC41ICogdGhpcy5mb3YgKSAvIHRoaXMuem9vbSxcbiAgICBcdFx0XHRoZWlnaHQgPSAyICogdG9wLFxuICAgIFx0XHRcdHdpZHRoID0gdGhpcy5hc3BlY3QgKiBoZWlnaHQsXG4gICAgXHRcdFx0bGVmdCA9IC0gMC41ICogd2lkdGgsXG4gICAgXHRcdFx0dmlldyA9IHRoaXMudmlldztcblxuICAgIFx0XHRpZiAoIHZpZXcgIT09IG51bGwgKSB7XG5cbiAgICBcdFx0XHR2YXIgZnVsbFdpZHRoID0gdmlldy5mdWxsV2lkdGgsXG4gICAgXHRcdFx0XHRmdWxsSGVpZ2h0ID0gdmlldy5mdWxsSGVpZ2h0O1xuXG4gICAgXHRcdFx0bGVmdCArPSB2aWV3Lm9mZnNldFggKiB3aWR0aCAvIGZ1bGxXaWR0aDtcbiAgICBcdFx0XHR0b3AgLT0gdmlldy5vZmZzZXRZICogaGVpZ2h0IC8gZnVsbEhlaWdodDtcbiAgICBcdFx0XHR3aWR0aCAqPSB2aWV3LndpZHRoIC8gZnVsbFdpZHRoO1xuICAgIFx0XHRcdGhlaWdodCAqPSB2aWV3LmhlaWdodCAvIGZ1bGxIZWlnaHQ7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHZhciBza2V3ID0gdGhpcy5maWxtT2Zmc2V0O1xuICAgIFx0XHRpZiAoIHNrZXcgIT09IDAgKSBsZWZ0ICs9IG5lYXIgKiBza2V3IC8gdGhpcy5nZXRGaWxtV2lkdGgoKTtcblxuICAgIFx0XHR0aGlzLnByb2plY3Rpb25NYXRyaXgubWFrZUZydXN0dW0oXG4gICAgXHRcdFx0XHRsZWZ0LCBsZWZ0ICsgd2lkdGgsIHRvcCAtIGhlaWdodCwgdG9wLCBuZWFyLCB0aGlzLmZhciApO1xuXG4gICAgXHR9LFxuXG4gICAgXHR0b0pTT046IGZ1bmN0aW9uICggbWV0YSApIHtcblxuICAgIFx0XHR2YXIgZGF0YSA9IE9iamVjdDNELnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcywgbWV0YSApO1xuXG4gICAgXHRcdGRhdGEub2JqZWN0LmZvdiA9IHRoaXMuZm92O1xuICAgIFx0XHRkYXRhLm9iamVjdC56b29tID0gdGhpcy56b29tO1xuXG4gICAgXHRcdGRhdGEub2JqZWN0Lm5lYXIgPSB0aGlzLm5lYXI7XG4gICAgXHRcdGRhdGEub2JqZWN0LmZhciA9IHRoaXMuZmFyO1xuICAgIFx0XHRkYXRhLm9iamVjdC5mb2N1cyA9IHRoaXMuZm9jdXM7XG5cbiAgICBcdFx0ZGF0YS5vYmplY3QuYXNwZWN0ID0gdGhpcy5hc3BlY3Q7XG5cbiAgICBcdFx0aWYgKCB0aGlzLnZpZXcgIT09IG51bGwgKSBkYXRhLm9iamVjdC52aWV3ID0gT2JqZWN0LmFzc2lnbigge30sIHRoaXMudmlldyApO1xuXG4gICAgXHRcdGRhdGEub2JqZWN0LmZpbG1HYXVnZSA9IHRoaXMuZmlsbUdhdWdlO1xuICAgIFx0XHRkYXRhLm9iamVjdC5maWxtT2Zmc2V0ID0gdGhpcy5maWxtT2Zmc2V0O1xuXG4gICAgXHRcdHJldHVybiBkYXRhO1xuXG4gICAgXHR9XG5cbiAgICB9ICk7XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICAgICAqIEBhdXRob3IgYXJvc2UgLyBodHRwOi8vZ2l0aHViLmNvbS9hcm9zZVxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gT3J0aG9ncmFwaGljQ2FtZXJhKCBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIG5lYXIsIGZhciApIHtcblxuICAgIFx0Q2FtZXJhLmNhbGwoIHRoaXMgKTtcblxuICAgIFx0dGhpcy50eXBlID0gJ09ydGhvZ3JhcGhpY0NhbWVyYSc7XG5cbiAgICBcdHRoaXMuem9vbSA9IDE7XG4gICAgXHR0aGlzLnZpZXcgPSBudWxsO1xuXG4gICAgXHR0aGlzLmxlZnQgPSBsZWZ0O1xuICAgIFx0dGhpcy5yaWdodCA9IHJpZ2h0O1xuICAgIFx0dGhpcy50b3AgPSB0b3A7XG4gICAgXHR0aGlzLmJvdHRvbSA9IGJvdHRvbTtcblxuICAgIFx0dGhpcy5uZWFyID0gKCBuZWFyICE9PSB1bmRlZmluZWQgKSA/IG5lYXIgOiAwLjE7XG4gICAgXHR0aGlzLmZhciA9ICggZmFyICE9PSB1bmRlZmluZWQgKSA/IGZhciA6IDIwMDA7XG5cbiAgICBcdHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuXG4gICAgfVxuXG4gICAgT3J0aG9ncmFwaGljQ2FtZXJhLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIENhbWVyYS5wcm90b3R5cGUgKSwge1xuXG4gICAgXHRjb25zdHJ1Y3RvcjogT3J0aG9ncmFwaGljQ2FtZXJhLFxuXG4gICAgXHRpc09ydGhvZ3JhcGhpY0NhbWVyYTogdHJ1ZSxcblxuICAgIFx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cbiAgICBcdFx0Q2FtZXJhLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG4gICAgXHRcdHRoaXMubGVmdCA9IHNvdXJjZS5sZWZ0O1xuICAgIFx0XHR0aGlzLnJpZ2h0ID0gc291cmNlLnJpZ2h0O1xuICAgIFx0XHR0aGlzLnRvcCA9IHNvdXJjZS50b3A7XG4gICAgXHRcdHRoaXMuYm90dG9tID0gc291cmNlLmJvdHRvbTtcbiAgICBcdFx0dGhpcy5uZWFyID0gc291cmNlLm5lYXI7XG4gICAgXHRcdHRoaXMuZmFyID0gc291cmNlLmZhcjtcblxuICAgIFx0XHR0aGlzLnpvb20gPSBzb3VyY2Uuem9vbTtcbiAgICBcdFx0dGhpcy52aWV3ID0gc291cmNlLnZpZXcgPT09IG51bGwgPyBudWxsIDogT2JqZWN0LmFzc2lnbigge30sIHNvdXJjZS52aWV3ICk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldFZpZXdPZmZzZXQ6IGZ1bmN0aW9uKCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHgsIHksIHdpZHRoLCBoZWlnaHQgKSB7XG5cbiAgICBcdFx0dGhpcy52aWV3ID0ge1xuICAgIFx0XHRcdGZ1bGxXaWR0aDogZnVsbFdpZHRoLFxuICAgIFx0XHRcdGZ1bGxIZWlnaHQ6IGZ1bGxIZWlnaHQsXG4gICAgXHRcdFx0b2Zmc2V0WDogeCxcbiAgICBcdFx0XHRvZmZzZXRZOiB5LFxuICAgIFx0XHRcdHdpZHRoOiB3aWR0aCxcbiAgICBcdFx0XHRoZWlnaHQ6IGhlaWdodFxuICAgIFx0XHR9O1xuXG4gICAgXHRcdHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuXG4gICAgXHR9LFxuXG4gICAgXHRjbGVhclZpZXdPZmZzZXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgXHRcdHRoaXMudmlldyA9IG51bGw7XG4gICAgXHRcdHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuXG4gICAgXHR9LFxuXG4gICAgXHR1cGRhdGVQcm9qZWN0aW9uTWF0cml4OiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dmFyIGR4ID0gKCB0aGlzLnJpZ2h0IC0gdGhpcy5sZWZ0ICkgLyAoIDIgKiB0aGlzLnpvb20gKTtcbiAgICBcdFx0dmFyIGR5ID0gKCB0aGlzLnRvcCAtIHRoaXMuYm90dG9tICkgLyAoIDIgKiB0aGlzLnpvb20gKTtcbiAgICBcdFx0dmFyIGN4ID0gKCB0aGlzLnJpZ2h0ICsgdGhpcy5sZWZ0ICkgLyAyO1xuICAgIFx0XHR2YXIgY3kgPSAoIHRoaXMudG9wICsgdGhpcy5ib3R0b20gKSAvIDI7XG5cbiAgICBcdFx0dmFyIGxlZnQgPSBjeCAtIGR4O1xuICAgIFx0XHR2YXIgcmlnaHQgPSBjeCArIGR4O1xuICAgIFx0XHR2YXIgdG9wID0gY3kgKyBkeTtcbiAgICBcdFx0dmFyIGJvdHRvbSA9IGN5IC0gZHk7XG5cbiAgICBcdFx0aWYgKCB0aGlzLnZpZXcgIT09IG51bGwgKSB7XG5cbiAgICBcdFx0XHR2YXIgem9vbVcgPSB0aGlzLnpvb20gLyAoIHRoaXMudmlldy53aWR0aCAvIHRoaXMudmlldy5mdWxsV2lkdGggKTtcbiAgICBcdFx0XHR2YXIgem9vbUggPSB0aGlzLnpvb20gLyAoIHRoaXMudmlldy5oZWlnaHQgLyB0aGlzLnZpZXcuZnVsbEhlaWdodCApO1xuICAgIFx0XHRcdHZhciBzY2FsZVcgPSAoIHRoaXMucmlnaHQgLSB0aGlzLmxlZnQgKSAvIHRoaXMudmlldy53aWR0aDtcbiAgICBcdFx0XHR2YXIgc2NhbGVIID0gKCB0aGlzLnRvcCAtIHRoaXMuYm90dG9tICkgLyB0aGlzLnZpZXcuaGVpZ2h0O1xuXG4gICAgXHRcdFx0bGVmdCArPSBzY2FsZVcgKiAoIHRoaXMudmlldy5vZmZzZXRYIC8gem9vbVcgKTtcbiAgICBcdFx0XHRyaWdodCA9IGxlZnQgKyBzY2FsZVcgKiAoIHRoaXMudmlldy53aWR0aCAvIHpvb21XICk7XG4gICAgXHRcdFx0dG9wIC09IHNjYWxlSCAqICggdGhpcy52aWV3Lm9mZnNldFkgLyB6b29tSCApO1xuICAgIFx0XHRcdGJvdHRvbSA9IHRvcCAtIHNjYWxlSCAqICggdGhpcy52aWV3LmhlaWdodCAvIHpvb21IICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHRoaXMucHJvamVjdGlvbk1hdHJpeC5tYWtlT3J0aG9ncmFwaGljKCBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIHRoaXMubmVhciwgdGhpcy5mYXIgKTtcblxuICAgIFx0fSxcblxuICAgIFx0dG9KU09OOiBmdW5jdGlvbiAoIG1ldGEgKSB7XG5cbiAgICBcdFx0dmFyIGRhdGEgPSBPYmplY3QzRC5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMsIG1ldGEgKTtcblxuICAgIFx0XHRkYXRhLm9iamVjdC56b29tID0gdGhpcy56b29tO1xuICAgIFx0XHRkYXRhLm9iamVjdC5sZWZ0ID0gdGhpcy5sZWZ0O1xuICAgIFx0XHRkYXRhLm9iamVjdC5yaWdodCA9IHRoaXMucmlnaHQ7XG4gICAgXHRcdGRhdGEub2JqZWN0LnRvcCA9IHRoaXMudG9wO1xuICAgIFx0XHRkYXRhLm9iamVjdC5ib3R0b20gPSB0aGlzLmJvdHRvbTtcbiAgICBcdFx0ZGF0YS5vYmplY3QubmVhciA9IHRoaXMubmVhcjtcbiAgICBcdFx0ZGF0YS5vYmplY3QuZmFyID0gdGhpcy5mYXI7XG5cbiAgICBcdFx0aWYgKCB0aGlzLnZpZXcgIT09IG51bGwgKSBkYXRhLm9iamVjdC52aWV3ID0gT2JqZWN0LmFzc2lnbigge30sIHRoaXMudmlldyApO1xuXG4gICAgXHRcdHJldHVybiBkYXRhO1xuXG4gICAgXHR9XG5cbiAgICB9ICk7XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gV2ViR0xJbmRleGVkQnVmZmVyUmVuZGVyZXIoIGdsLCBleHRlbnNpb25zLCBpbmZvUmVuZGVyICkge1xuXG4gICAgXHR2YXIgbW9kZTtcblxuICAgIFx0ZnVuY3Rpb24gc2V0TW9kZSggdmFsdWUgKSB7XG5cbiAgICBcdFx0bW9kZSA9IHZhbHVlO1xuXG4gICAgXHR9XG5cbiAgICBcdHZhciB0eXBlLCBzaXplO1xuXG4gICAgXHRmdW5jdGlvbiBzZXRJbmRleCggaW5kZXggKSB7XG5cbiAgICBcdFx0aWYgKCBpbmRleC5hcnJheSBpbnN0YW5jZW9mIFVpbnQzMkFycmF5ICYmIGV4dGVuc2lvbnMuZ2V0KCAnT0VTX2VsZW1lbnRfaW5kZXhfdWludCcgKSApIHtcblxuICAgIFx0XHRcdHR5cGUgPSBnbC5VTlNJR05FRF9JTlQ7XG4gICAgXHRcdFx0c2l6ZSA9IDQ7XG5cbiAgICBcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdHR5cGUgPSBnbC5VTlNJR05FRF9TSE9SVDtcbiAgICBcdFx0XHRzaXplID0gMjtcblxuICAgIFx0XHR9XG5cbiAgICBcdH1cblxuICAgIFx0ZnVuY3Rpb24gcmVuZGVyKCBzdGFydCwgY291bnQgKSB7XG5cbiAgICBcdFx0Z2wuZHJhd0VsZW1lbnRzKCBtb2RlLCBjb3VudCwgdHlwZSwgc3RhcnQgKiBzaXplICk7XG5cbiAgICBcdFx0aW5mb1JlbmRlci5jYWxscyArKztcbiAgICBcdFx0aW5mb1JlbmRlci52ZXJ0aWNlcyArPSBjb3VudDtcblxuICAgIFx0XHRpZiAoIG1vZGUgPT09IGdsLlRSSUFOR0xFUyApIGluZm9SZW5kZXIuZmFjZXMgKz0gY291bnQgLyAzO1xuXG4gICAgXHR9XG5cbiAgICBcdGZ1bmN0aW9uIHJlbmRlckluc3RhbmNlcyggZ2VvbWV0cnksIHN0YXJ0LCBjb3VudCApIHtcblxuICAgIFx0XHR2YXIgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJyApO1xuXG4gICAgXHRcdGlmICggZXh0ZW5zaW9uID09PSBudWxsICkge1xuXG4gICAgXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMQnVmZmVyUmVuZGVyZXI6IHVzaW5nIFRIUkVFLkluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5IGJ1dCBoYXJkd2FyZSBkb2VzIG5vdCBzdXBwb3J0IGV4dGVuc2lvbiBBTkdMRV9pbnN0YW5jZWRfYXJyYXlzLicgKTtcbiAgICBcdFx0XHRyZXR1cm47XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGV4dGVuc2lvbi5kcmF3RWxlbWVudHNJbnN0YW5jZWRBTkdMRSggbW9kZSwgY291bnQsIHR5cGUsIHN0YXJ0ICogc2l6ZSwgZ2VvbWV0cnkubWF4SW5zdGFuY2VkQ291bnQgKTtcblxuICAgIFx0XHRpbmZvUmVuZGVyLmNhbGxzICsrO1xuICAgIFx0XHRpbmZvUmVuZGVyLnZlcnRpY2VzICs9IGNvdW50ICogZ2VvbWV0cnkubWF4SW5zdGFuY2VkQ291bnQ7XG5cbiAgICBcdFx0aWYgKCBtb2RlID09PSBnbC5UUklBTkdMRVMgKSBpbmZvUmVuZGVyLmZhY2VzICs9IGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50ICogY291bnQgLyAzO1xuXG4gICAgXHR9XG5cbiAgICBcdHJldHVybiB7XG5cbiAgICBcdFx0c2V0TW9kZTogc2V0TW9kZSxcbiAgICBcdFx0c2V0SW5kZXg6IHNldEluZGV4LFxuICAgIFx0XHRyZW5kZXI6IHJlbmRlcixcbiAgICBcdFx0cmVuZGVySW5zdGFuY2VzOiByZW5kZXJJbnN0YW5jZXNcblxuICAgIFx0fTtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBXZWJHTEJ1ZmZlclJlbmRlcmVyKCBnbCwgZXh0ZW5zaW9ucywgaW5mb1JlbmRlciApIHtcblxuICAgIFx0dmFyIG1vZGU7XG5cbiAgICBcdGZ1bmN0aW9uIHNldE1vZGUoIHZhbHVlICkge1xuXG4gICAgXHRcdG1vZGUgPSB2YWx1ZTtcblxuICAgIFx0fVxuXG4gICAgXHRmdW5jdGlvbiByZW5kZXIoIHN0YXJ0LCBjb3VudCApIHtcblxuICAgIFx0XHRnbC5kcmF3QXJyYXlzKCBtb2RlLCBzdGFydCwgY291bnQgKTtcblxuICAgIFx0XHRpbmZvUmVuZGVyLmNhbGxzICsrO1xuICAgIFx0XHRpbmZvUmVuZGVyLnZlcnRpY2VzICs9IGNvdW50O1xuXG4gICAgXHRcdGlmICggbW9kZSA9PT0gZ2wuVFJJQU5HTEVTICkgaW5mb1JlbmRlci5mYWNlcyArPSBjb3VudCAvIDM7XG5cbiAgICBcdH1cblxuICAgIFx0ZnVuY3Rpb24gcmVuZGVySW5zdGFuY2VzKCBnZW9tZXRyeSApIHtcblxuICAgIFx0XHR2YXIgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJyApO1xuXG4gICAgXHRcdGlmICggZXh0ZW5zaW9uID09PSBudWxsICkge1xuXG4gICAgXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMQnVmZmVyUmVuZGVyZXI6IHVzaW5nIFRIUkVFLkluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5IGJ1dCBoYXJkd2FyZSBkb2VzIG5vdCBzdXBwb3J0IGV4dGVuc2lvbiBBTkdMRV9pbnN0YW5jZWRfYXJyYXlzLicgKTtcbiAgICBcdFx0XHRyZXR1cm47XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHZhciBwb3NpdGlvbiA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cbiAgICBcdFx0dmFyIGNvdW50ID0gMDtcblxuICAgIFx0XHRpZiAoIChwb3NpdGlvbiAmJiBwb3NpdGlvbi5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlKSApIHtcblxuICAgIFx0XHRcdGNvdW50ID0gcG9zaXRpb24uZGF0YS5jb3VudDtcblxuICAgIFx0XHRcdGV4dGVuc2lvbi5kcmF3QXJyYXlzSW5zdGFuY2VkQU5HTEUoIG1vZGUsIDAsIGNvdW50LCBnZW9tZXRyeS5tYXhJbnN0YW5jZWRDb3VudCApO1xuXG4gICAgXHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRjb3VudCA9IHBvc2l0aW9uLmNvdW50O1xuXG4gICAgXHRcdFx0ZXh0ZW5zaW9uLmRyYXdBcnJheXNJbnN0YW5jZWRBTkdMRSggbW9kZSwgMCwgY291bnQsIGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50ICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGluZm9SZW5kZXIuY2FsbHMgKys7XG4gICAgXHRcdGluZm9SZW5kZXIudmVydGljZXMgKz0gY291bnQgKiBnZW9tZXRyeS5tYXhJbnN0YW5jZWRDb3VudDtcblxuICAgIFx0XHRpZiAoIG1vZGUgPT09IGdsLlRSSUFOR0xFUyApIGluZm9SZW5kZXIuZmFjZXMgKz0gZ2VvbWV0cnkubWF4SW5zdGFuY2VkQ291bnQgKiBjb3VudCAvIDM7XG5cbiAgICBcdH1cblxuICAgIFx0cmV0dXJuIHtcbiAgICBcdFx0c2V0TW9kZTogc2V0TW9kZSxcbiAgICBcdFx0cmVuZGVyOiByZW5kZXIsXG4gICAgXHRcdHJlbmRlckluc3RhbmNlczogcmVuZGVySW5zdGFuY2VzXG4gICAgXHR9O1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gV2ViR0xMaWdodHMoKSB7XG5cbiAgICBcdHZhciBsaWdodHMgPSB7fTtcblxuICAgIFx0cmV0dXJuIHtcblxuICAgIFx0XHRnZXQ6IGZ1bmN0aW9uICggbGlnaHQgKSB7XG5cbiAgICBcdFx0XHRpZiAoIGxpZ2h0c1sgbGlnaHQuaWQgXSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0XHRyZXR1cm4gbGlnaHRzWyBsaWdodC5pZCBdO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0dmFyIHVuaWZvcm1zO1xuXG4gICAgXHRcdFx0c3dpdGNoICggbGlnaHQudHlwZSApIHtcblxuICAgIFx0XHRcdFx0Y2FzZSAnRGlyZWN0aW9uYWxMaWdodCc6XG4gICAgXHRcdFx0XHRcdHVuaWZvcm1zID0ge1xuICAgIFx0XHRcdFx0XHRcdGRpcmVjdGlvbjogbmV3IFZlY3RvcjMoKSxcbiAgICBcdFx0XHRcdFx0XHRjb2xvcjogbmV3IENvbG9yKCksXG5cbiAgICBcdFx0XHRcdFx0XHRzaGFkb3c6IGZhbHNlLFxuICAgIFx0XHRcdFx0XHRcdHNoYWRvd0JpYXM6IDAsXG4gICAgXHRcdFx0XHRcdFx0c2hhZG93UmFkaXVzOiAxLFxuICAgIFx0XHRcdFx0XHRcdHNoYWRvd01hcFNpemU6IG5ldyBWZWN0b3IyKClcbiAgICBcdFx0XHRcdFx0fTtcbiAgICBcdFx0XHRcdFx0YnJlYWs7XG5cbiAgICBcdFx0XHRcdGNhc2UgJ1Nwb3RMaWdodCc6XG4gICAgXHRcdFx0XHRcdHVuaWZvcm1zID0ge1xuICAgIFx0XHRcdFx0XHRcdHBvc2l0aW9uOiBuZXcgVmVjdG9yMygpLFxuICAgIFx0XHRcdFx0XHRcdGRpcmVjdGlvbjogbmV3IFZlY3RvcjMoKSxcbiAgICBcdFx0XHRcdFx0XHRjb2xvcjogbmV3IENvbG9yKCksXG4gICAgXHRcdFx0XHRcdFx0ZGlzdGFuY2U6IDAsXG4gICAgXHRcdFx0XHRcdFx0Y29uZUNvczogMCxcbiAgICBcdFx0XHRcdFx0XHRwZW51bWJyYUNvczogMCxcbiAgICBcdFx0XHRcdFx0XHRkZWNheTogMCxcblxuICAgIFx0XHRcdFx0XHRcdHNoYWRvdzogZmFsc2UsXG4gICAgXHRcdFx0XHRcdFx0c2hhZG93QmlhczogMCxcbiAgICBcdFx0XHRcdFx0XHRzaGFkb3dSYWRpdXM6IDEsXG4gICAgXHRcdFx0XHRcdFx0c2hhZG93TWFwU2l6ZTogbmV3IFZlY3RvcjIoKVxuICAgIFx0XHRcdFx0XHR9O1xuICAgIFx0XHRcdFx0XHRicmVhaztcblxuICAgIFx0XHRcdFx0Y2FzZSAnUG9pbnRMaWdodCc6XG4gICAgXHRcdFx0XHRcdHVuaWZvcm1zID0ge1xuICAgIFx0XHRcdFx0XHRcdHBvc2l0aW9uOiBuZXcgVmVjdG9yMygpLFxuICAgIFx0XHRcdFx0XHRcdGNvbG9yOiBuZXcgQ29sb3IoKSxcbiAgICBcdFx0XHRcdFx0XHRkaXN0YW5jZTogMCxcbiAgICBcdFx0XHRcdFx0XHRkZWNheTogMCxcblxuICAgIFx0XHRcdFx0XHRcdHNoYWRvdzogZmFsc2UsXG4gICAgXHRcdFx0XHRcdFx0c2hhZG93QmlhczogMCxcbiAgICBcdFx0XHRcdFx0XHRzaGFkb3dSYWRpdXM6IDEsXG4gICAgXHRcdFx0XHRcdFx0c2hhZG93TWFwU2l6ZTogbmV3IFZlY3RvcjIoKVxuICAgIFx0XHRcdFx0XHR9O1xuICAgIFx0XHRcdFx0XHRicmVhaztcblxuICAgIFx0XHRcdFx0Y2FzZSAnSGVtaXNwaGVyZUxpZ2h0JzpcbiAgICBcdFx0XHRcdFx0dW5pZm9ybXMgPSB7XG4gICAgXHRcdFx0XHRcdFx0ZGlyZWN0aW9uOiBuZXcgVmVjdG9yMygpLFxuICAgIFx0XHRcdFx0XHRcdHNreUNvbG9yOiBuZXcgQ29sb3IoKSxcbiAgICBcdFx0XHRcdFx0XHRncm91bmRDb2xvcjogbmV3IENvbG9yKClcbiAgICBcdFx0XHRcdFx0fTtcbiAgICBcdFx0XHRcdFx0YnJlYWs7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRsaWdodHNbIGxpZ2h0LmlkIF0gPSB1bmlmb3JtcztcblxuICAgIFx0XHRcdHJldHVybiB1bmlmb3JtcztcblxuICAgIFx0XHR9XG5cbiAgICBcdH07XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gYWRkTGluZU51bWJlcnMoIHN0cmluZyApIHtcblxuICAgIFx0dmFyIGxpbmVzID0gc3RyaW5nLnNwbGl0KCAnXFxuJyApO1xuXG4gICAgXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkgKysgKSB7XG5cbiAgICBcdFx0bGluZXNbIGkgXSA9ICggaSArIDEgKSArICc6ICcgKyBsaW5lc1sgaSBdO1xuXG4gICAgXHR9XG5cbiAgICBcdHJldHVybiBsaW5lcy5qb2luKCAnXFxuJyApO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gV2ViR0xTaGFkZXIoIGdsLCB0eXBlLCBzdHJpbmcgKSB7XG5cbiAgICBcdHZhciBzaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoIHR5cGUgKTtcblxuICAgIFx0Z2wuc2hhZGVyU291cmNlKCBzaGFkZXIsIHN0cmluZyApO1xuICAgIFx0Z2wuY29tcGlsZVNoYWRlciggc2hhZGVyICk7XG5cbiAgICBcdGlmICggZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKCBzaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTICkgPT09IGZhbHNlICkge1xuXG4gICAgXHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFNoYWRlcjogU2hhZGVyIGNvdWxkblxcJ3QgY29tcGlsZS4nICk7XG5cbiAgICBcdH1cblxuICAgIFx0aWYgKCBnbC5nZXRTaGFkZXJJbmZvTG9nKCBzaGFkZXIgKSAhPT0gJycgKSB7XG5cbiAgICBcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xTaGFkZXI6IGdsLmdldFNoYWRlckluZm9Mb2coKScsIHR5cGUgPT09IGdsLlZFUlRFWF9TSEFERVIgPyAndmVydGV4JyA6ICdmcmFnbWVudCcsIGdsLmdldFNoYWRlckluZm9Mb2coIHNoYWRlciApLCBhZGRMaW5lTnVtYmVycyggc3RyaW5nICkgKTtcblxuICAgIFx0fVxuXG4gICAgXHQvLyAtLWVuYWJsZS1wcml2aWxlZ2VkLXdlYmdsLWV4dGVuc2lvblxuICAgIFx0Ly8gY29uc29sZS5sb2coIHR5cGUsIGdsLmdldEV4dGVuc2lvbiggJ1dFQkdMX2RlYnVnX3NoYWRlcnMnICkuZ2V0VHJhbnNsYXRlZFNoYWRlclNvdXJjZSggc2hhZGVyICkgKTtcblxuICAgIFx0cmV0dXJuIHNoYWRlcjtcblxuICAgIH1cblxuICAgIHZhciBwcm9ncmFtSWRDb3VudCA9IDA7XG5cbiAgICBmdW5jdGlvbiBnZXRFbmNvZGluZ0NvbXBvbmVudHMoIGVuY29kaW5nICkge1xuXG4gICAgXHRzd2l0Y2ggKCBlbmNvZGluZyApIHtcblxuICAgIFx0XHRjYXNlIExpbmVhckVuY29kaW5nOlxuICAgIFx0XHRcdHJldHVybiBbICdMaW5lYXInLCcoIHZhbHVlICknIF07XG4gICAgXHRcdGNhc2Ugc1JHQkVuY29kaW5nOlxuICAgIFx0XHRcdHJldHVybiBbICdzUkdCJywnKCB2YWx1ZSApJyBdO1xuICAgIFx0XHRjYXNlIFJHQkVFbmNvZGluZzpcbiAgICBcdFx0XHRyZXR1cm4gWyAnUkdCRScsJyggdmFsdWUgKScgXTtcbiAgICBcdFx0Y2FzZSBSR0JNN0VuY29kaW5nOlxuICAgIFx0XHRcdHJldHVybiBbICdSR0JNJywnKCB2YWx1ZSwgNy4wICknIF07XG4gICAgXHRcdGNhc2UgUkdCTTE2RW5jb2Rpbmc6XG4gICAgXHRcdFx0cmV0dXJuIFsgJ1JHQk0nLCcoIHZhbHVlLCAxNi4wICknIF07XG4gICAgXHRcdGNhc2UgUkdCREVuY29kaW5nOlxuICAgIFx0XHRcdHJldHVybiBbICdSR0JEJywnKCB2YWx1ZSwgMjU2LjAgKScgXTtcbiAgICBcdFx0Y2FzZSBHYW1tYUVuY29kaW5nOlxuICAgIFx0XHRcdHJldHVybiBbICdHYW1tYScsJyggdmFsdWUsIGZsb2F0KCBHQU1NQV9GQUNUT1IgKSApJyBdO1xuICAgIFx0XHRkZWZhdWx0OlxuICAgIFx0XHRcdHRocm93IG5ldyBFcnJvciggJ3Vuc3VwcG9ydGVkIGVuY29kaW5nOiAnICsgZW5jb2RpbmcgKTtcblxuICAgIFx0fVxuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0VGV4ZWxEZWNvZGluZ0Z1bmN0aW9uKCBmdW5jdGlvbk5hbWUsIGVuY29kaW5nICkge1xuXG4gICAgXHR2YXIgY29tcG9uZW50cyA9IGdldEVuY29kaW5nQ29tcG9uZW50cyggZW5jb2RpbmcgKTtcbiAgICBcdHJldHVybiBcInZlYzQgXCIgKyBmdW5jdGlvbk5hbWUgKyBcIiggdmVjNCB2YWx1ZSApIHsgcmV0dXJuIFwiICsgY29tcG9uZW50c1sgMCBdICsgXCJUb0xpbmVhclwiICsgY29tcG9uZW50c1sgMSBdICsgXCI7IH1cIjtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFRleGVsRW5jb2RpbmdGdW5jdGlvbiggZnVuY3Rpb25OYW1lLCBlbmNvZGluZyApIHtcblxuICAgIFx0dmFyIGNvbXBvbmVudHMgPSBnZXRFbmNvZGluZ0NvbXBvbmVudHMoIGVuY29kaW5nICk7XG4gICAgXHRyZXR1cm4gXCJ2ZWM0IFwiICsgZnVuY3Rpb25OYW1lICsgXCIoIHZlYzQgdmFsdWUgKSB7IHJldHVybiBMaW5lYXJUb1wiICsgY29tcG9uZW50c1sgMCBdICsgY29tcG9uZW50c1sgMSBdICsgXCI7IH1cIjtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFRvbmVNYXBwaW5nRnVuY3Rpb24oIGZ1bmN0aW9uTmFtZSwgdG9uZU1hcHBpbmcgKSB7XG5cbiAgICBcdHZhciB0b25lTWFwcGluZ05hbWU7XG5cbiAgICBcdHN3aXRjaCAoIHRvbmVNYXBwaW5nICkge1xuXG4gICAgXHRcdGNhc2UgTGluZWFyVG9uZU1hcHBpbmc6XG4gICAgXHRcdFx0dG9uZU1hcHBpbmdOYW1lID0gXCJMaW5lYXJcIjtcbiAgICBcdFx0XHRicmVhaztcblxuICAgIFx0XHRjYXNlIFJlaW5oYXJkVG9uZU1hcHBpbmc6XG4gICAgXHRcdFx0dG9uZU1hcHBpbmdOYW1lID0gXCJSZWluaGFyZFwiO1xuICAgIFx0XHRcdGJyZWFrO1xuXG4gICAgXHRcdGNhc2UgVW5jaGFydGVkMlRvbmVNYXBwaW5nOlxuICAgIFx0XHRcdHRvbmVNYXBwaW5nTmFtZSA9IFwiVW5jaGFydGVkMlwiO1xuICAgIFx0XHRcdGJyZWFrO1xuXG4gICAgXHRcdGNhc2UgQ2luZW9uVG9uZU1hcHBpbmc6XG4gICAgXHRcdFx0dG9uZU1hcHBpbmdOYW1lID0gXCJPcHRpbWl6ZWRDaW5lb25cIjtcbiAgICBcdFx0XHRicmVhaztcblxuICAgIFx0XHRkZWZhdWx0OlxuICAgIFx0XHRcdHRocm93IG5ldyBFcnJvciggJ3Vuc3VwcG9ydGVkIHRvbmVNYXBwaW5nOiAnICsgdG9uZU1hcHBpbmcgKTtcblxuICAgIFx0fVxuXG4gICAgXHRyZXR1cm4gXCJ2ZWMzIFwiICsgZnVuY3Rpb25OYW1lICsgXCIoIHZlYzMgY29sb3IgKSB7IHJldHVybiBcIiArIHRvbmVNYXBwaW5nTmFtZSArIFwiVG9uZU1hcHBpbmcoIGNvbG9yICk7IH1cIjtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlRXh0ZW5zaW9ucyggZXh0ZW5zaW9ucywgcGFyYW1ldGVycywgcmVuZGVyZXJFeHRlbnNpb25zICkge1xuXG4gICAgXHRleHRlbnNpb25zID0gZXh0ZW5zaW9ucyB8fCB7fTtcblxuICAgIFx0dmFyIGNodW5rcyA9IFtcbiAgICBcdFx0KCBleHRlbnNpb25zLmRlcml2YXRpdmVzIHx8IHBhcmFtZXRlcnMuZW52TWFwQ3ViZVVWIHx8IHBhcmFtZXRlcnMuYnVtcE1hcCB8fCBwYXJhbWV0ZXJzLm5vcm1hbE1hcCB8fCBwYXJhbWV0ZXJzLmZsYXRTaGFkaW5nICkgPyAnI2V4dGVuc2lvbiBHTF9PRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXMgOiBlbmFibGUnIDogJycsXG4gICAgXHRcdCggZXh0ZW5zaW9ucy5mcmFnRGVwdGggfHwgcGFyYW1ldGVycy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyICkgJiYgcmVuZGVyZXJFeHRlbnNpb25zLmdldCggJ0VYVF9mcmFnX2RlcHRoJyApID8gJyNleHRlbnNpb24gR0xfRVhUX2ZyYWdfZGVwdGggOiBlbmFibGUnIDogJycsXG4gICAgXHRcdCggZXh0ZW5zaW9ucy5kcmF3QnVmZmVycyApICYmIHJlbmRlcmVyRXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9kcmF3X2J1ZmZlcnMnICkgPyAnI2V4dGVuc2lvbiBHTF9FWFRfZHJhd19idWZmZXJzIDogcmVxdWlyZScgOiAnJyxcbiAgICBcdFx0KCBleHRlbnNpb25zLnNoYWRlclRleHR1cmVMT0QgfHwgcGFyYW1ldGVycy5lbnZNYXAgKSAmJiByZW5kZXJlckV4dGVuc2lvbnMuZ2V0KCAnRVhUX3NoYWRlcl90ZXh0dXJlX2xvZCcgKSA/ICcjZXh0ZW5zaW9uIEdMX0VYVF9zaGFkZXJfdGV4dHVyZV9sb2QgOiBlbmFibGUnIDogJycsXG4gICAgXHRdO1xuXG4gICAgXHRyZXR1cm4gY2h1bmtzLmZpbHRlciggZmlsdGVyRW1wdHlMaW5lICkuam9pbiggJ1xcbicgKTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlRGVmaW5lcyggZGVmaW5lcyApIHtcblxuICAgIFx0dmFyIGNodW5rcyA9IFtdO1xuXG4gICAgXHRmb3IgKCB2YXIgbmFtZSBpbiBkZWZpbmVzICkge1xuXG4gICAgXHRcdHZhciB2YWx1ZSA9IGRlZmluZXNbIG5hbWUgXTtcblxuICAgIFx0XHRpZiAoIHZhbHVlID09PSBmYWxzZSApIGNvbnRpbnVlO1xuXG4gICAgXHRcdGNodW5rcy5wdXNoKCAnI2RlZmluZSAnICsgbmFtZSArICcgJyArIHZhbHVlICk7XG5cbiAgICBcdH1cblxuICAgIFx0cmV0dXJuIGNodW5rcy5qb2luKCAnXFxuJyApO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmV0Y2hBdHRyaWJ1dGVMb2NhdGlvbnMoIGdsLCBwcm9ncmFtLCBpZGVudGlmaWVycyApIHtcblxuICAgIFx0dmFyIGF0dHJpYnV0ZXMgPSB7fTtcblxuICAgIFx0dmFyIG4gPSBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKCBwcm9ncmFtLCBnbC5BQ1RJVkVfQVRUUklCVVRFUyApO1xuXG4gICAgXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBuOyBpICsrICkge1xuXG4gICAgXHRcdHZhciBpbmZvID0gZ2wuZ2V0QWN0aXZlQXR0cmliKCBwcm9ncmFtLCBpICk7XG4gICAgXHRcdHZhciBuYW1lID0gaW5mby5uYW1lO1xuXG4gICAgXHRcdC8vIGNvbnNvbGUubG9nKFwiVEhSRUUuV2ViR0xQcm9ncmFtOiBBQ1RJVkUgVkVSVEVYIEFUVFJJQlVURTpcIiwgbmFtZSwgaSApO1xuXG4gICAgXHRcdGF0dHJpYnV0ZXNbIG5hbWUgXSA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKCBwcm9ncmFtLCBuYW1lICk7XG5cbiAgICBcdH1cblxuICAgIFx0cmV0dXJuIGF0dHJpYnV0ZXM7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaWx0ZXJFbXB0eUxpbmUoIHN0cmluZyApIHtcblxuICAgIFx0cmV0dXJuIHN0cmluZyAhPT0gJyc7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXBsYWNlTGlnaHROdW1zKCBzdHJpbmcsIHBhcmFtZXRlcnMgKSB7XG5cbiAgICBcdHJldHVybiBzdHJpbmdcbiAgICBcdFx0LnJlcGxhY2UoIC9OVU1fRElSX0xJR0hUUy9nLCBwYXJhbWV0ZXJzLm51bURpckxpZ2h0cyApXG4gICAgXHRcdC5yZXBsYWNlKCAvTlVNX1NQT1RfTElHSFRTL2csIHBhcmFtZXRlcnMubnVtU3BvdExpZ2h0cyApXG4gICAgXHRcdC5yZXBsYWNlKCAvTlVNX1BPSU5UX0xJR0hUUy9nLCBwYXJhbWV0ZXJzLm51bVBvaW50TGlnaHRzIClcbiAgICBcdFx0LnJlcGxhY2UoIC9OVU1fSEVNSV9MSUdIVFMvZywgcGFyYW1ldGVycy5udW1IZW1pTGlnaHRzICk7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUluY2x1ZGVzKCBzdHJpbmcgKSB7XG5cbiAgICBcdHZhciBwYXR0ZXJuID0gLyNpbmNsdWRlICs8KFtcXHdcXGQuXSspPi9nO1xuXG4gICAgXHRmdW5jdGlvbiByZXBsYWNlKCBtYXRjaCwgaW5jbHVkZSApIHtcblxuICAgIFx0XHR2YXIgcmVwbGFjZSA9IFNoYWRlckNodW5rWyBpbmNsdWRlIF07XG5cbiAgICBcdFx0aWYgKCByZXBsYWNlID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdDYW4gbm90IHJlc29sdmUgI2luY2x1ZGUgPCcgKyBpbmNsdWRlICsgJz4nICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiBwYXJzZUluY2x1ZGVzKCByZXBsYWNlICk7XG5cbiAgICBcdH1cblxuICAgIFx0cmV0dXJuIHN0cmluZy5yZXBsYWNlKCBwYXR0ZXJuLCByZXBsYWNlICk7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1bnJvbGxMb29wcyggc3RyaW5nICkge1xuXG4gICAgXHR2YXIgcGF0dGVybiA9IC9mb3IgXFwoIGludCBpIFxcPSAoXFxkKylcXDsgaSA8IChcXGQrKVxcOyBpIFxcK1xcKyBcXCkgXFx7KFtcXHNcXFNdKz8pKD89XFx9KVxcfS9nO1xuXG4gICAgXHRmdW5jdGlvbiByZXBsYWNlKCBtYXRjaCwgc3RhcnQsIGVuZCwgc25pcHBldCApIHtcblxuICAgIFx0XHR2YXIgdW5yb2xsID0gJyc7XG5cbiAgICBcdFx0Zm9yICggdmFyIGkgPSBwYXJzZUludCggc3RhcnQgKTsgaSA8IHBhcnNlSW50KCBlbmQgKTsgaSArKyApIHtcblxuICAgIFx0XHRcdHVucm9sbCArPSBzbmlwcGV0LnJlcGxhY2UoIC9cXFsgaSBcXF0vZywgJ1sgJyArIGkgKyAnIF0nICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiB1bnJvbGw7XG5cbiAgICBcdH1cblxuICAgIFx0cmV0dXJuIHN0cmluZy5yZXBsYWNlKCBwYXR0ZXJuLCByZXBsYWNlICk7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBXZWJHTFByb2dyYW0oIHJlbmRlcmVyLCBjb2RlLCBtYXRlcmlhbCwgcGFyYW1ldGVycyApIHtcblxuICAgIFx0dmFyIGdsID0gcmVuZGVyZXIuY29udGV4dDtcblxuICAgIFx0dmFyIGV4dGVuc2lvbnMgPSBtYXRlcmlhbC5leHRlbnNpb25zO1xuICAgIFx0dmFyIGRlZmluZXMgPSBtYXRlcmlhbC5kZWZpbmVzO1xuXG4gICAgXHR2YXIgdmVydGV4U2hhZGVyID0gbWF0ZXJpYWwuX193ZWJnbFNoYWRlci52ZXJ0ZXhTaGFkZXI7XG4gICAgXHR2YXIgZnJhZ21lbnRTaGFkZXIgPSBtYXRlcmlhbC5fX3dlYmdsU2hhZGVyLmZyYWdtZW50U2hhZGVyO1xuXG4gICAgXHR2YXIgc2hhZG93TWFwVHlwZURlZmluZSA9ICdTSEFET1dNQVBfVFlQRV9CQVNJQyc7XG5cbiAgICBcdGlmICggcGFyYW1ldGVycy5zaGFkb3dNYXBUeXBlID09PSBQQ0ZTaGFkb3dNYXAgKSB7XG5cbiAgICBcdFx0c2hhZG93TWFwVHlwZURlZmluZSA9ICdTSEFET1dNQVBfVFlQRV9QQ0YnO1xuXG4gICAgXHR9IGVsc2UgaWYgKCBwYXJhbWV0ZXJzLnNoYWRvd01hcFR5cGUgPT09IFBDRlNvZnRTaGFkb3dNYXAgKSB7XG5cbiAgICBcdFx0c2hhZG93TWFwVHlwZURlZmluZSA9ICdTSEFET1dNQVBfVFlQRV9QQ0ZfU09GVCc7XG5cbiAgICBcdH1cblxuICAgIFx0dmFyIGVudk1hcFR5cGVEZWZpbmUgPSAnRU5WTUFQX1RZUEVfQ1VCRSc7XG4gICAgXHR2YXIgZW52TWFwTW9kZURlZmluZSA9ICdFTlZNQVBfTU9ERV9SRUZMRUNUSU9OJztcbiAgICBcdHZhciBlbnZNYXBCbGVuZGluZ0RlZmluZSA9ICdFTlZNQVBfQkxFTkRJTkdfTVVMVElQTFknO1xuXG4gICAgXHRpZiAoIHBhcmFtZXRlcnMuZW52TWFwICkge1xuXG4gICAgXHRcdHN3aXRjaCAoIG1hdGVyaWFsLmVudk1hcC5tYXBwaW5nICkge1xuXG4gICAgXHRcdFx0Y2FzZSBDdWJlUmVmbGVjdGlvbk1hcHBpbmc6XG4gICAgXHRcdFx0Y2FzZSBDdWJlUmVmcmFjdGlvbk1hcHBpbmc6XG4gICAgXHRcdFx0XHRlbnZNYXBUeXBlRGVmaW5lID0gJ0VOVk1BUF9UWVBFX0NVQkUnO1xuICAgIFx0XHRcdFx0YnJlYWs7XG5cbiAgICBcdFx0XHRjYXNlIEN1YmVVVlJlZmxlY3Rpb25NYXBwaW5nOlxuICAgIFx0XHRcdGNhc2UgQ3ViZVVWUmVmcmFjdGlvbk1hcHBpbmc6XG4gICAgXHRcdFx0XHRlbnZNYXBUeXBlRGVmaW5lID0gJ0VOVk1BUF9UWVBFX0NVQkVfVVYnO1xuICAgIFx0XHRcdFx0YnJlYWs7XG5cbiAgICBcdFx0XHRjYXNlIEVxdWlyZWN0YW5ndWxhclJlZmxlY3Rpb25NYXBwaW5nOlxuICAgIFx0XHRcdGNhc2UgRXF1aXJlY3Rhbmd1bGFyUmVmcmFjdGlvbk1hcHBpbmc6XG4gICAgXHRcdFx0XHRlbnZNYXBUeXBlRGVmaW5lID0gJ0VOVk1BUF9UWVBFX0VRVUlSRUMnO1xuICAgIFx0XHRcdFx0YnJlYWs7XG5cbiAgICBcdFx0XHRjYXNlIFNwaGVyaWNhbFJlZmxlY3Rpb25NYXBwaW5nOlxuICAgIFx0XHRcdFx0ZW52TWFwVHlwZURlZmluZSA9ICdFTlZNQVBfVFlQRV9TUEhFUkUnO1xuICAgIFx0XHRcdFx0YnJlYWs7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHN3aXRjaCAoIG1hdGVyaWFsLmVudk1hcC5tYXBwaW5nICkge1xuXG4gICAgXHRcdFx0Y2FzZSBDdWJlUmVmcmFjdGlvbk1hcHBpbmc6XG4gICAgXHRcdFx0Y2FzZSBFcXVpcmVjdGFuZ3VsYXJSZWZyYWN0aW9uTWFwcGluZzpcbiAgICBcdFx0XHRcdGVudk1hcE1vZGVEZWZpbmUgPSAnRU5WTUFQX01PREVfUkVGUkFDVElPTic7XG4gICAgXHRcdFx0XHRicmVhaztcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0c3dpdGNoICggbWF0ZXJpYWwuY29tYmluZSApIHtcblxuICAgIFx0XHRcdGNhc2UgTXVsdGlwbHlPcGVyYXRpb246XG4gICAgXHRcdFx0XHRlbnZNYXBCbGVuZGluZ0RlZmluZSA9ICdFTlZNQVBfQkxFTkRJTkdfTVVMVElQTFknO1xuICAgIFx0XHRcdFx0YnJlYWs7XG5cbiAgICBcdFx0XHRjYXNlIE1peE9wZXJhdGlvbjpcbiAgICBcdFx0XHRcdGVudk1hcEJsZW5kaW5nRGVmaW5lID0gJ0VOVk1BUF9CTEVORElOR19NSVgnO1xuICAgIFx0XHRcdFx0YnJlYWs7XG5cbiAgICBcdFx0XHRjYXNlIEFkZE9wZXJhdGlvbjpcbiAgICBcdFx0XHRcdGVudk1hcEJsZW5kaW5nRGVmaW5lID0gJ0VOVk1BUF9CTEVORElOR19BREQnO1xuICAgIFx0XHRcdFx0YnJlYWs7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9XG5cbiAgICBcdHZhciBnYW1tYUZhY3RvckRlZmluZSA9ICggcmVuZGVyZXIuZ2FtbWFGYWN0b3IgPiAwICkgPyByZW5kZXJlci5nYW1tYUZhY3RvciA6IDEuMDtcblxuICAgIFx0Ly8gY29uc29sZS5sb2coICdidWlsZGluZyBuZXcgcHJvZ3JhbSAnICk7XG5cbiAgICBcdC8vXG5cbiAgICBcdHZhciBjdXN0b21FeHRlbnNpb25zID0gZ2VuZXJhdGVFeHRlbnNpb25zKCBleHRlbnNpb25zLCBwYXJhbWV0ZXJzLCByZW5kZXJlci5leHRlbnNpb25zICk7XG5cbiAgICBcdHZhciBjdXN0b21EZWZpbmVzID0gZ2VuZXJhdGVEZWZpbmVzKCBkZWZpbmVzICk7XG5cbiAgICBcdC8vXG5cbiAgICBcdHZhciBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuXG4gICAgXHR2YXIgcHJlZml4VmVydGV4LCBwcmVmaXhGcmFnbWVudDtcblxuICAgIFx0aWYgKCBtYXRlcmlhbC5pc1Jhd1NoYWRlck1hdGVyaWFsICkge1xuXG4gICAgXHRcdHByZWZpeFZlcnRleCA9IFtcblxuICAgIFx0XHRcdGN1c3RvbURlZmluZXMsXG5cbiAgICBcdFx0XHQnXFxuJ1xuXG4gICAgXHRcdF0uZmlsdGVyKCBmaWx0ZXJFbXB0eUxpbmUgKS5qb2luKCAnXFxuJyApO1xuXG4gICAgXHRcdHByZWZpeEZyYWdtZW50ID0gW1xuXG4gICAgXHRcdFx0Y3VzdG9tRXh0ZW5zaW9ucyxcbiAgICBcdFx0XHRjdXN0b21EZWZpbmVzLFxuXG4gICAgXHRcdFx0J1xcbidcblxuICAgIFx0XHRdLmZpbHRlciggZmlsdGVyRW1wdHlMaW5lICkuam9pbiggJ1xcbicgKTtcblxuICAgIFx0fSBlbHNlIHtcblxuICAgIFx0XHRwcmVmaXhWZXJ0ZXggPSBbXG5cbiAgICBcdFx0XHQncHJlY2lzaW9uICcgKyBwYXJhbWV0ZXJzLnByZWNpc2lvbiArICcgZmxvYXQ7JyxcbiAgICBcdFx0XHQncHJlY2lzaW9uICcgKyBwYXJhbWV0ZXJzLnByZWNpc2lvbiArICcgaW50OycsXG5cbiAgICBcdFx0XHQnI2RlZmluZSBTSEFERVJfTkFNRSAnICsgbWF0ZXJpYWwuX193ZWJnbFNoYWRlci5uYW1lLFxuXG4gICAgXHRcdFx0Y3VzdG9tRGVmaW5lcyxcblxuICAgIFx0XHRcdHBhcmFtZXRlcnMuc3VwcG9ydHNWZXJ0ZXhUZXh0dXJlcyA/ICcjZGVmaW5lIFZFUlRFWF9URVhUVVJFUycgOiAnJyxcblxuICAgIFx0XHRcdCcjZGVmaW5lIEdBTU1BX0ZBQ1RPUiAnICsgZ2FtbWFGYWN0b3JEZWZpbmUsXG5cbiAgICBcdFx0XHQnI2RlZmluZSBNQVhfQk9ORVMgJyArIHBhcmFtZXRlcnMubWF4Qm9uZXMsXG5cbiAgICBcdFx0XHRwYXJhbWV0ZXJzLm1hcCA/ICcjZGVmaW5lIFVTRV9NQVAnIDogJycsXG4gICAgXHRcdFx0cGFyYW1ldGVycy5lbnZNYXAgPyAnI2RlZmluZSBVU0VfRU5WTUFQJyA6ICcnLFxuICAgIFx0XHRcdHBhcmFtZXRlcnMuZW52TWFwID8gJyNkZWZpbmUgJyArIGVudk1hcE1vZGVEZWZpbmUgOiAnJyxcbiAgICBcdFx0XHRwYXJhbWV0ZXJzLmxpZ2h0TWFwID8gJyNkZWZpbmUgVVNFX0xJR0hUTUFQJyA6ICcnLFxuICAgIFx0XHRcdHBhcmFtZXRlcnMuYW9NYXAgPyAnI2RlZmluZSBVU0VfQU9NQVAnIDogJycsXG4gICAgXHRcdFx0cGFyYW1ldGVycy5lbWlzc2l2ZU1hcCA/ICcjZGVmaW5lIFVTRV9FTUlTU0lWRU1BUCcgOiAnJyxcbiAgICBcdFx0XHRwYXJhbWV0ZXJzLmJ1bXBNYXAgPyAnI2RlZmluZSBVU0VfQlVNUE1BUCcgOiAnJyxcbiAgICBcdFx0XHRwYXJhbWV0ZXJzLm5vcm1hbE1hcCA/ICcjZGVmaW5lIFVTRV9OT1JNQUxNQVAnIDogJycsXG4gICAgXHRcdFx0cGFyYW1ldGVycy5kaXNwbGFjZW1lbnRNYXAgJiYgcGFyYW1ldGVycy5zdXBwb3J0c1ZlcnRleFRleHR1cmVzID8gJyNkZWZpbmUgVVNFX0RJU1BMQUNFTUVOVE1BUCcgOiAnJyxcbiAgICBcdFx0XHRwYXJhbWV0ZXJzLnNwZWN1bGFyTWFwID8gJyNkZWZpbmUgVVNFX1NQRUNVTEFSTUFQJyA6ICcnLFxuICAgIFx0XHRcdHBhcmFtZXRlcnMucm91Z2huZXNzTWFwID8gJyNkZWZpbmUgVVNFX1JPVUdITkVTU01BUCcgOiAnJyxcbiAgICBcdFx0XHRwYXJhbWV0ZXJzLm1ldGFsbmVzc01hcCA/ICcjZGVmaW5lIFVTRV9NRVRBTE5FU1NNQVAnIDogJycsXG4gICAgXHRcdFx0cGFyYW1ldGVycy5hbHBoYU1hcCA/ICcjZGVmaW5lIFVTRV9BTFBIQU1BUCcgOiAnJyxcbiAgICBcdFx0XHRwYXJhbWV0ZXJzLnZlcnRleENvbG9ycyA/ICcjZGVmaW5lIFVTRV9DT0xPUicgOiAnJyxcblxuICAgIFx0XHRcdHBhcmFtZXRlcnMuZmxhdFNoYWRpbmcgPyAnI2RlZmluZSBGTEFUX1NIQURFRCcgOiAnJyxcblxuICAgIFx0XHRcdHBhcmFtZXRlcnMuc2tpbm5pbmcgPyAnI2RlZmluZSBVU0VfU0tJTk5JTkcnIDogJycsXG4gICAgXHRcdFx0cGFyYW1ldGVycy51c2VWZXJ0ZXhUZXh0dXJlID8gJyNkZWZpbmUgQk9ORV9URVhUVVJFJyA6ICcnLFxuXG4gICAgXHRcdFx0cGFyYW1ldGVycy5tb3JwaFRhcmdldHMgPyAnI2RlZmluZSBVU0VfTU9SUEhUQVJHRVRTJyA6ICcnLFxuICAgIFx0XHRcdHBhcmFtZXRlcnMubW9ycGhOb3JtYWxzICYmIHBhcmFtZXRlcnMuZmxhdFNoYWRpbmcgPT09IGZhbHNlID8gJyNkZWZpbmUgVVNFX01PUlBITk9STUFMUycgOiAnJyxcbiAgICBcdFx0XHRwYXJhbWV0ZXJzLmRvdWJsZVNpZGVkID8gJyNkZWZpbmUgRE9VQkxFX1NJREVEJyA6ICcnLFxuICAgIFx0XHRcdHBhcmFtZXRlcnMuZmxpcFNpZGVkID8gJyNkZWZpbmUgRkxJUF9TSURFRCcgOiAnJyxcblxuICAgIFx0XHRcdCcjZGVmaW5lIE5VTV9DTElQUElOR19QTEFORVMgJyArIHBhcmFtZXRlcnMubnVtQ2xpcHBpbmdQbGFuZXMsXG5cbiAgICBcdFx0XHRwYXJhbWV0ZXJzLnNoYWRvd01hcEVuYWJsZWQgPyAnI2RlZmluZSBVU0VfU0hBRE9XTUFQJyA6ICcnLFxuICAgIFx0XHRcdHBhcmFtZXRlcnMuc2hhZG93TWFwRW5hYmxlZCA/ICcjZGVmaW5lICcgKyBzaGFkb3dNYXBUeXBlRGVmaW5lIDogJycsXG5cbiAgICBcdFx0XHRwYXJhbWV0ZXJzLnNpemVBdHRlbnVhdGlvbiA/ICcjZGVmaW5lIFVTRV9TSVpFQVRURU5VQVRJT04nIDogJycsXG5cbiAgICBcdFx0XHRwYXJhbWV0ZXJzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgPyAnI2RlZmluZSBVU0VfTE9HREVQVEhCVUYnIDogJycsXG4gICAgXHRcdFx0cGFyYW1ldGVycy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyICYmIHJlbmRlcmVyLmV4dGVuc2lvbnMuZ2V0KCAnRVhUX2ZyYWdfZGVwdGgnICkgPyAnI2RlZmluZSBVU0VfTE9HREVQVEhCVUZfRVhUJyA6ICcnLFxuXG4gICAgXHRcdFx0J3VuaWZvcm0gbWF0NCBtb2RlbE1hdHJpeDsnLFxuICAgIFx0XHRcdCd1bmlmb3JtIG1hdDQgbW9kZWxWaWV3TWF0cml4OycsXG4gICAgXHRcdFx0J3VuaWZvcm0gbWF0NCBwcm9qZWN0aW9uTWF0cml4OycsXG4gICAgXHRcdFx0J3VuaWZvcm0gbWF0NCB2aWV3TWF0cml4OycsXG4gICAgXHRcdFx0J3VuaWZvcm0gbWF0MyBub3JtYWxNYXRyaXg7JyxcbiAgICBcdFx0XHQndW5pZm9ybSB2ZWMzIGNhbWVyYVBvc2l0aW9uOycsXG5cbiAgICBcdFx0XHQnYXR0cmlidXRlIHZlYzMgcG9zaXRpb247JyxcbiAgICBcdFx0XHQnYXR0cmlidXRlIHZlYzMgbm9ybWFsOycsXG4gICAgXHRcdFx0J2F0dHJpYnV0ZSB2ZWMyIHV2OycsXG5cbiAgICBcdFx0XHQnI2lmZGVmIFVTRV9DT0xPUicsXG5cbiAgICBcdFx0XHQnXHRhdHRyaWJ1dGUgdmVjMyBjb2xvcjsnLFxuXG4gICAgXHRcdFx0JyNlbmRpZicsXG5cbiAgICBcdFx0XHQnI2lmZGVmIFVTRV9NT1JQSFRBUkdFVFMnLFxuXG4gICAgXHRcdFx0J1x0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQwOycsXG4gICAgXHRcdFx0J1x0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQxOycsXG4gICAgXHRcdFx0J1x0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQyOycsXG4gICAgXHRcdFx0J1x0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQzOycsXG5cbiAgICBcdFx0XHQnXHQjaWZkZWYgVVNFX01PUlBITk9STUFMUycsXG5cbiAgICBcdFx0XHQnXHRcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoTm9ybWFsMDsnLFxuICAgIFx0XHRcdCdcdFx0YXR0cmlidXRlIHZlYzMgbW9ycGhOb3JtYWwxOycsXG4gICAgXHRcdFx0J1x0XHRhdHRyaWJ1dGUgdmVjMyBtb3JwaE5vcm1hbDI7JyxcbiAgICBcdFx0XHQnXHRcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoTm9ybWFsMzsnLFxuXG4gICAgXHRcdFx0J1x0I2Vsc2UnLFxuXG4gICAgXHRcdFx0J1x0XHRhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDQ7JyxcbiAgICBcdFx0XHQnXHRcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0NTsnLFxuICAgIFx0XHRcdCdcdFx0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQ2OycsXG4gICAgXHRcdFx0J1x0XHRhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDc7JyxcblxuICAgIFx0XHRcdCdcdCNlbmRpZicsXG5cbiAgICBcdFx0XHQnI2VuZGlmJyxcblxuICAgIFx0XHRcdCcjaWZkZWYgVVNFX1NLSU5OSU5HJyxcblxuICAgIFx0XHRcdCdcdGF0dHJpYnV0ZSB2ZWM0IHNraW5JbmRleDsnLFxuICAgIFx0XHRcdCdcdGF0dHJpYnV0ZSB2ZWM0IHNraW5XZWlnaHQ7JyxcblxuICAgIFx0XHRcdCcjZW5kaWYnLFxuXG4gICAgXHRcdFx0J1xcbidcblxuICAgIFx0XHRdLmZpbHRlciggZmlsdGVyRW1wdHlMaW5lICkuam9pbiggJ1xcbicgKTtcblxuICAgIFx0XHRwcmVmaXhGcmFnbWVudCA9IFtcblxuICAgIFx0XHRcdGN1c3RvbUV4dGVuc2lvbnMsXG5cbiAgICBcdFx0XHQncHJlY2lzaW9uICcgKyBwYXJhbWV0ZXJzLnByZWNpc2lvbiArICcgZmxvYXQ7JyxcbiAgICBcdFx0XHQncHJlY2lzaW9uICcgKyBwYXJhbWV0ZXJzLnByZWNpc2lvbiArICcgaW50OycsXG5cbiAgICBcdFx0XHQnI2RlZmluZSBTSEFERVJfTkFNRSAnICsgbWF0ZXJpYWwuX193ZWJnbFNoYWRlci5uYW1lLFxuXG4gICAgXHRcdFx0Y3VzdG9tRGVmaW5lcyxcblxuICAgIFx0XHRcdHBhcmFtZXRlcnMuYWxwaGFUZXN0ID8gJyNkZWZpbmUgQUxQSEFURVNUICcgKyBwYXJhbWV0ZXJzLmFscGhhVGVzdCA6ICcnLFxuXG4gICAgXHRcdFx0JyNkZWZpbmUgR0FNTUFfRkFDVE9SICcgKyBnYW1tYUZhY3RvckRlZmluZSxcblxuICAgIFx0XHRcdCggcGFyYW1ldGVycy51c2VGb2cgJiYgcGFyYW1ldGVycy5mb2cgKSA/ICcjZGVmaW5lIFVTRV9GT0cnIDogJycsXG4gICAgXHRcdFx0KCBwYXJhbWV0ZXJzLnVzZUZvZyAmJiBwYXJhbWV0ZXJzLmZvZ0V4cCApID8gJyNkZWZpbmUgRk9HX0VYUDInIDogJycsXG5cbiAgICBcdFx0XHRwYXJhbWV0ZXJzLm1hcCA/ICcjZGVmaW5lIFVTRV9NQVAnIDogJycsXG4gICAgXHRcdFx0cGFyYW1ldGVycy5lbnZNYXAgPyAnI2RlZmluZSBVU0VfRU5WTUFQJyA6ICcnLFxuICAgIFx0XHRcdHBhcmFtZXRlcnMuZW52TWFwID8gJyNkZWZpbmUgJyArIGVudk1hcFR5cGVEZWZpbmUgOiAnJyxcbiAgICBcdFx0XHRwYXJhbWV0ZXJzLmVudk1hcCA/ICcjZGVmaW5lICcgKyBlbnZNYXBNb2RlRGVmaW5lIDogJycsXG4gICAgXHRcdFx0cGFyYW1ldGVycy5lbnZNYXAgPyAnI2RlZmluZSAnICsgZW52TWFwQmxlbmRpbmdEZWZpbmUgOiAnJyxcbiAgICBcdFx0XHRwYXJhbWV0ZXJzLmxpZ2h0TWFwID8gJyNkZWZpbmUgVVNFX0xJR0hUTUFQJyA6ICcnLFxuICAgIFx0XHRcdHBhcmFtZXRlcnMuYW9NYXAgPyAnI2RlZmluZSBVU0VfQU9NQVAnIDogJycsXG4gICAgXHRcdFx0cGFyYW1ldGVycy5lbWlzc2l2ZU1hcCA/ICcjZGVmaW5lIFVTRV9FTUlTU0lWRU1BUCcgOiAnJyxcbiAgICBcdFx0XHRwYXJhbWV0ZXJzLmJ1bXBNYXAgPyAnI2RlZmluZSBVU0VfQlVNUE1BUCcgOiAnJyxcbiAgICBcdFx0XHRwYXJhbWV0ZXJzLm5vcm1hbE1hcCA/ICcjZGVmaW5lIFVTRV9OT1JNQUxNQVAnIDogJycsXG4gICAgXHRcdFx0cGFyYW1ldGVycy5zcGVjdWxhck1hcCA/ICcjZGVmaW5lIFVTRV9TUEVDVUxBUk1BUCcgOiAnJyxcbiAgICBcdFx0XHRwYXJhbWV0ZXJzLnJvdWdobmVzc01hcCA/ICcjZGVmaW5lIFVTRV9ST1VHSE5FU1NNQVAnIDogJycsXG4gICAgXHRcdFx0cGFyYW1ldGVycy5tZXRhbG5lc3NNYXAgPyAnI2RlZmluZSBVU0VfTUVUQUxORVNTTUFQJyA6ICcnLFxuICAgIFx0XHRcdHBhcmFtZXRlcnMuYWxwaGFNYXAgPyAnI2RlZmluZSBVU0VfQUxQSEFNQVAnIDogJycsXG4gICAgXHRcdFx0cGFyYW1ldGVycy52ZXJ0ZXhDb2xvcnMgPyAnI2RlZmluZSBVU0VfQ09MT1InIDogJycsXG5cbiAgICBcdFx0XHRwYXJhbWV0ZXJzLmZsYXRTaGFkaW5nID8gJyNkZWZpbmUgRkxBVF9TSEFERUQnIDogJycsXG5cbiAgICBcdFx0XHRwYXJhbWV0ZXJzLmRvdWJsZVNpZGVkID8gJyNkZWZpbmUgRE9VQkxFX1NJREVEJyA6ICcnLFxuICAgIFx0XHRcdHBhcmFtZXRlcnMuZmxpcFNpZGVkID8gJyNkZWZpbmUgRkxJUF9TSURFRCcgOiAnJyxcblxuICAgIFx0XHRcdCcjZGVmaW5lIE5VTV9DTElQUElOR19QTEFORVMgJyArIHBhcmFtZXRlcnMubnVtQ2xpcHBpbmdQbGFuZXMsXG5cbiAgICBcdFx0XHRwYXJhbWV0ZXJzLnNoYWRvd01hcEVuYWJsZWQgPyAnI2RlZmluZSBVU0VfU0hBRE9XTUFQJyA6ICcnLFxuICAgIFx0XHRcdHBhcmFtZXRlcnMuc2hhZG93TWFwRW5hYmxlZCA/ICcjZGVmaW5lICcgKyBzaGFkb3dNYXBUeXBlRGVmaW5lIDogJycsXG5cbiAgICBcdFx0XHRwYXJhbWV0ZXJzLnByZW11bHRpcGxpZWRBbHBoYSA/IFwiI2RlZmluZSBQUkVNVUxUSVBMSUVEX0FMUEhBXCIgOiAnJyxcblxuICAgIFx0XHRcdHBhcmFtZXRlcnMucGh5c2ljYWxseUNvcnJlY3RMaWdodHMgPyBcIiNkZWZpbmUgUEhZU0lDQUxMWV9DT1JSRUNUX0xJR0hUU1wiIDogJycsXG5cbiAgICBcdFx0XHRwYXJhbWV0ZXJzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgPyAnI2RlZmluZSBVU0VfTE9HREVQVEhCVUYnIDogJycsXG4gICAgXHRcdFx0cGFyYW1ldGVycy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyICYmIHJlbmRlcmVyLmV4dGVuc2lvbnMuZ2V0KCAnRVhUX2ZyYWdfZGVwdGgnICkgPyAnI2RlZmluZSBVU0VfTE9HREVQVEhCVUZfRVhUJyA6ICcnLFxuXG4gICAgXHRcdFx0cGFyYW1ldGVycy5lbnZNYXAgJiYgcmVuZGVyZXIuZXh0ZW5zaW9ucy5nZXQoICdFWFRfc2hhZGVyX3RleHR1cmVfbG9kJyApID8gJyNkZWZpbmUgVEVYVFVSRV9MT0RfRVhUJyA6ICcnLFxuXG4gICAgXHRcdFx0J3VuaWZvcm0gbWF0NCB2aWV3TWF0cml4OycsXG4gICAgXHRcdFx0J3VuaWZvcm0gdmVjMyBjYW1lcmFQb3NpdGlvbjsnLFxuXG4gICAgXHRcdFx0KCBwYXJhbWV0ZXJzLnRvbmVNYXBwaW5nICE9PSBOb1RvbmVNYXBwaW5nICkgPyBcIiNkZWZpbmUgVE9ORV9NQVBQSU5HXCIgOiAnJyxcbiAgICBcdFx0XHQoIHBhcmFtZXRlcnMudG9uZU1hcHBpbmcgIT09IE5vVG9uZU1hcHBpbmcgKSA/IFNoYWRlckNodW5rWyAndG9uZW1hcHBpbmdfcGFyc19mcmFnbWVudCcgXSA6ICcnLCAgLy8gdGhpcyBjb2RlIGlzIHJlcXVpcmVkIGhlcmUgYmVjYXVzZSBpdCBpcyB1c2VkIGJ5IHRoZSB0b25lTWFwcGluZygpIGZ1bmN0aW9uIGRlZmluZWQgYmVsb3dcbiAgICBcdFx0XHQoIHBhcmFtZXRlcnMudG9uZU1hcHBpbmcgIT09IE5vVG9uZU1hcHBpbmcgKSA/IGdldFRvbmVNYXBwaW5nRnVuY3Rpb24oIFwidG9uZU1hcHBpbmdcIiwgcGFyYW1ldGVycy50b25lTWFwcGluZyApIDogJycsXG5cbiAgICBcdFx0XHQoIHBhcmFtZXRlcnMub3V0cHV0RW5jb2RpbmcgfHwgcGFyYW1ldGVycy5tYXBFbmNvZGluZyB8fCBwYXJhbWV0ZXJzLmVudk1hcEVuY29kaW5nIHx8IHBhcmFtZXRlcnMuZW1pc3NpdmVNYXBFbmNvZGluZyApID8gU2hhZGVyQ2h1bmtbICdlbmNvZGluZ3NfcGFyc19mcmFnbWVudCcgXSA6ICcnLCAvLyB0aGlzIGNvZGUgaXMgcmVxdWlyZWQgaGVyZSBiZWNhdXNlIGl0IGlzIHVzZWQgYnkgdGhlIHZhcmlvdXMgZW5jb2RpbmcvZGVjb2RpbmcgZnVuY3Rpb24gZGVmaW5lZCBiZWxvd1xuICAgIFx0XHRcdHBhcmFtZXRlcnMubWFwRW5jb2RpbmcgPyBnZXRUZXhlbERlY29kaW5nRnVuY3Rpb24oICdtYXBUZXhlbFRvTGluZWFyJywgcGFyYW1ldGVycy5tYXBFbmNvZGluZyApIDogJycsXG4gICAgXHRcdFx0cGFyYW1ldGVycy5lbnZNYXBFbmNvZGluZyA/IGdldFRleGVsRGVjb2RpbmdGdW5jdGlvbiggJ2Vudk1hcFRleGVsVG9MaW5lYXInLCBwYXJhbWV0ZXJzLmVudk1hcEVuY29kaW5nICkgOiAnJyxcbiAgICBcdFx0XHRwYXJhbWV0ZXJzLmVtaXNzaXZlTWFwRW5jb2RpbmcgPyBnZXRUZXhlbERlY29kaW5nRnVuY3Rpb24oICdlbWlzc2l2ZU1hcFRleGVsVG9MaW5lYXInLCBwYXJhbWV0ZXJzLmVtaXNzaXZlTWFwRW5jb2RpbmcgKSA6ICcnLFxuICAgIFx0XHRcdHBhcmFtZXRlcnMub3V0cHV0RW5jb2RpbmcgPyBnZXRUZXhlbEVuY29kaW5nRnVuY3Rpb24oIFwibGluZWFyVG9PdXRwdXRUZXhlbFwiLCBwYXJhbWV0ZXJzLm91dHB1dEVuY29kaW5nICkgOiAnJyxcblxuICAgIFx0XHRcdHBhcmFtZXRlcnMuZGVwdGhQYWNraW5nID8gXCIjZGVmaW5lIERFUFRIX1BBQ0tJTkcgXCIgKyBtYXRlcmlhbC5kZXB0aFBhY2tpbmcgOiAnJyxcblxuICAgIFx0XHRcdCdcXG4nXG5cbiAgICBcdFx0XS5maWx0ZXIoIGZpbHRlckVtcHR5TGluZSApLmpvaW4oICdcXG4nICk7XG5cbiAgICBcdH1cblxuICAgIFx0dmVydGV4U2hhZGVyID0gcGFyc2VJbmNsdWRlcyggdmVydGV4U2hhZGVyLCBwYXJhbWV0ZXJzICk7XG4gICAgXHR2ZXJ0ZXhTaGFkZXIgPSByZXBsYWNlTGlnaHROdW1zKCB2ZXJ0ZXhTaGFkZXIsIHBhcmFtZXRlcnMgKTtcblxuICAgIFx0ZnJhZ21lbnRTaGFkZXIgPSBwYXJzZUluY2x1ZGVzKCBmcmFnbWVudFNoYWRlciwgcGFyYW1ldGVycyApO1xuICAgIFx0ZnJhZ21lbnRTaGFkZXIgPSByZXBsYWNlTGlnaHROdW1zKCBmcmFnbWVudFNoYWRlciwgcGFyYW1ldGVycyApO1xuXG4gICAgXHRpZiAoICEgbWF0ZXJpYWwuaXNTaGFkZXJNYXRlcmlhbCApIHtcblxuICAgIFx0XHR2ZXJ0ZXhTaGFkZXIgPSB1bnJvbGxMb29wcyggdmVydGV4U2hhZGVyICk7XG4gICAgXHRcdGZyYWdtZW50U2hhZGVyID0gdW5yb2xsTG9vcHMoIGZyYWdtZW50U2hhZGVyICk7XG5cbiAgICBcdH1cblxuICAgIFx0dmFyIHZlcnRleEdsc2wgPSBwcmVmaXhWZXJ0ZXggKyB2ZXJ0ZXhTaGFkZXI7XG4gICAgXHR2YXIgZnJhZ21lbnRHbHNsID0gcHJlZml4RnJhZ21lbnQgKyBmcmFnbWVudFNoYWRlcjtcblxuICAgIFx0Ly8gY29uc29sZS5sb2coICcqVkVSVEVYKicsIHZlcnRleEdsc2wgKTtcbiAgICBcdC8vIGNvbnNvbGUubG9nKCAnKkZSQUdNRU5UKicsIGZyYWdtZW50R2xzbCApO1xuXG4gICAgXHR2YXIgZ2xWZXJ0ZXhTaGFkZXIgPSBXZWJHTFNoYWRlciggZ2wsIGdsLlZFUlRFWF9TSEFERVIsIHZlcnRleEdsc2wgKTtcbiAgICBcdHZhciBnbEZyYWdtZW50U2hhZGVyID0gV2ViR0xTaGFkZXIoIGdsLCBnbC5GUkFHTUVOVF9TSEFERVIsIGZyYWdtZW50R2xzbCApO1xuXG4gICAgXHRnbC5hdHRhY2hTaGFkZXIoIHByb2dyYW0sIGdsVmVydGV4U2hhZGVyICk7XG4gICAgXHRnbC5hdHRhY2hTaGFkZXIoIHByb2dyYW0sIGdsRnJhZ21lbnRTaGFkZXIgKTtcblxuICAgIFx0Ly8gRm9yY2UgYSBwYXJ0aWN1bGFyIGF0dHJpYnV0ZSB0byBpbmRleCAwLlxuXG4gICAgXHRpZiAoIG1hdGVyaWFsLmluZGV4MEF0dHJpYnV0ZU5hbWUgIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRnbC5iaW5kQXR0cmliTG9jYXRpb24oIHByb2dyYW0sIDAsIG1hdGVyaWFsLmluZGV4MEF0dHJpYnV0ZU5hbWUgKTtcblxuICAgIFx0fSBlbHNlIGlmICggcGFyYW1ldGVycy5tb3JwaFRhcmdldHMgPT09IHRydWUgKSB7XG5cbiAgICBcdFx0Ly8gcHJvZ3JhbXMgd2l0aCBtb3JwaFRhcmdldHMgZGlzcGxhY2UgcG9zaXRpb24gb3V0IG9mIGF0dHJpYnV0ZSAwXG4gICAgXHRcdGdsLmJpbmRBdHRyaWJMb2NhdGlvbiggcHJvZ3JhbSwgMCwgJ3Bvc2l0aW9uJyApO1xuXG4gICAgXHR9XG5cbiAgICBcdGdsLmxpbmtQcm9ncmFtKCBwcm9ncmFtICk7XG5cbiAgICBcdHZhciBwcm9ncmFtTG9nID0gZ2wuZ2V0UHJvZ3JhbUluZm9Mb2coIHByb2dyYW0gKTtcbiAgICBcdHZhciB2ZXJ0ZXhMb2cgPSBnbC5nZXRTaGFkZXJJbmZvTG9nKCBnbFZlcnRleFNoYWRlciApO1xuICAgIFx0dmFyIGZyYWdtZW50TG9nID0gZ2wuZ2V0U2hhZGVySW5mb0xvZyggZ2xGcmFnbWVudFNoYWRlciApO1xuXG4gICAgXHR2YXIgcnVubmFibGUgPSB0cnVlO1xuICAgIFx0dmFyIGhhdmVEaWFnbm9zdGljcyA9IHRydWU7XG5cbiAgICBcdC8vIGNvbnNvbGUubG9nKCAnKipWRVJURVgqKicsIGdsLmdldEV4dGVuc2lvbiggJ1dFQkdMX2RlYnVnX3NoYWRlcnMnICkuZ2V0VHJhbnNsYXRlZFNoYWRlclNvdXJjZSggZ2xWZXJ0ZXhTaGFkZXIgKSApO1xuICAgIFx0Ly8gY29uc29sZS5sb2coICcqKkZSQUdNRU5UKionLCBnbC5nZXRFeHRlbnNpb24oICdXRUJHTF9kZWJ1Z19zaGFkZXJzJyApLmdldFRyYW5zbGF0ZWRTaGFkZXJTb3VyY2UoIGdsRnJhZ21lbnRTaGFkZXIgKSApO1xuXG4gICAgXHRpZiAoIGdsLmdldFByb2dyYW1QYXJhbWV0ZXIoIHByb2dyYW0sIGdsLkxJTktfU1RBVFVTICkgPT09IGZhbHNlICkge1xuXG4gICAgXHRcdHJ1bm5hYmxlID0gZmFsc2U7XG5cbiAgICBcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMUHJvZ3JhbTogc2hhZGVyIGVycm9yOiAnLCBnbC5nZXRFcnJvcigpLCAnZ2wuVkFMSURBVEVfU1RBVFVTJywgZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlciggcHJvZ3JhbSwgZ2wuVkFMSURBVEVfU1RBVFVTICksICdnbC5nZXRQcm9ncmFtSW5mb0xvZycsIHByb2dyYW1Mb2csIHZlcnRleExvZywgZnJhZ21lbnRMb2cgKTtcblxuICAgIFx0fSBlbHNlIGlmICggcHJvZ3JhbUxvZyAhPT0gJycgKSB7XG5cbiAgICBcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xQcm9ncmFtOiBnbC5nZXRQcm9ncmFtSW5mb0xvZygpJywgcHJvZ3JhbUxvZyApO1xuXG4gICAgXHR9IGVsc2UgaWYgKCB2ZXJ0ZXhMb2cgPT09ICcnIHx8IGZyYWdtZW50TG9nID09PSAnJyApIHtcblxuICAgIFx0XHRoYXZlRGlhZ25vc3RpY3MgPSBmYWxzZTtcblxuICAgIFx0fVxuXG4gICAgXHRpZiAoIGhhdmVEaWFnbm9zdGljcyApIHtcblxuICAgIFx0XHR0aGlzLmRpYWdub3N0aWNzID0ge1xuXG4gICAgXHRcdFx0cnVubmFibGU6IHJ1bm5hYmxlLFxuICAgIFx0XHRcdG1hdGVyaWFsOiBtYXRlcmlhbCxcblxuICAgIFx0XHRcdHByb2dyYW1Mb2c6IHByb2dyYW1Mb2csXG5cbiAgICBcdFx0XHR2ZXJ0ZXhTaGFkZXI6IHtcblxuICAgIFx0XHRcdFx0bG9nOiB2ZXJ0ZXhMb2csXG4gICAgXHRcdFx0XHRwcmVmaXg6IHByZWZpeFZlcnRleFxuXG4gICAgXHRcdFx0fSxcblxuICAgIFx0XHRcdGZyYWdtZW50U2hhZGVyOiB7XG5cbiAgICBcdFx0XHRcdGxvZzogZnJhZ21lbnRMb2csXG4gICAgXHRcdFx0XHRwcmVmaXg6IHByZWZpeEZyYWdtZW50XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fTtcblxuICAgIFx0fVxuXG4gICAgXHQvLyBjbGVhbiB1cFxuXG4gICAgXHRnbC5kZWxldGVTaGFkZXIoIGdsVmVydGV4U2hhZGVyICk7XG4gICAgXHRnbC5kZWxldGVTaGFkZXIoIGdsRnJhZ21lbnRTaGFkZXIgKTtcblxuICAgIFx0Ly8gc2V0IHVwIGNhY2hpbmcgZm9yIHVuaWZvcm0gbG9jYXRpb25zXG5cbiAgICBcdHZhciBjYWNoZWRVbmlmb3JtcztcblxuICAgIFx0dGhpcy5nZXRVbmlmb3JtcyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgXHRcdGlmICggY2FjaGVkVW5pZm9ybXMgPT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdGNhY2hlZFVuaWZvcm1zID1cbiAgICBcdFx0XHRcdFx0bmV3IFdlYkdMVW5pZm9ybXMoIGdsLCBwcm9ncmFtLCByZW5kZXJlciApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gY2FjaGVkVW5pZm9ybXM7XG5cbiAgICBcdH07XG5cbiAgICBcdC8vIHNldCB1cCBjYWNoaW5nIGZvciBhdHRyaWJ1dGUgbG9jYXRpb25zXG5cbiAgICBcdHZhciBjYWNoZWRBdHRyaWJ1dGVzO1xuXG4gICAgXHR0aGlzLmdldEF0dHJpYnV0ZXMgPSBmdW5jdGlvbigpIHtcblxuICAgIFx0XHRpZiAoIGNhY2hlZEF0dHJpYnV0ZXMgPT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdGNhY2hlZEF0dHJpYnV0ZXMgPSBmZXRjaEF0dHJpYnV0ZUxvY2F0aW9ucyggZ2wsIHByb2dyYW0gKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIGNhY2hlZEF0dHJpYnV0ZXM7XG5cbiAgICBcdH07XG5cbiAgICBcdC8vIGZyZWUgcmVzb3VyY2VcblxuICAgIFx0dGhpcy5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG5cbiAgICBcdFx0Z2wuZGVsZXRlUHJvZ3JhbSggcHJvZ3JhbSApO1xuICAgIFx0XHR0aGlzLnByb2dyYW0gPSB1bmRlZmluZWQ7XG5cbiAgICBcdH07XG5cbiAgICBcdC8vIERFUFJFQ0FURURcblxuICAgIFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIHRoaXMsIHtcblxuICAgIFx0XHR1bmlmb3Jtczoge1xuICAgIFx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cbiAgICBcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUHJvZ3JhbTogLnVuaWZvcm1zIGlzIG5vdyAuZ2V0VW5pZm9ybXMoKS4nICk7XG4gICAgXHRcdFx0XHRyZXR1cm4gdGhpcy5nZXRVbmlmb3JtcygpO1xuXG4gICAgXHRcdFx0fVxuICAgIFx0XHR9LFxuXG4gICAgXHRcdGF0dHJpYnV0ZXM6IHtcbiAgICBcdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFByb2dyYW06IC5hdHRyaWJ1dGVzIGlzIG5vdyAuZ2V0QXR0cmlidXRlcygpLicgKTtcbiAgICBcdFx0XHRcdHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZXMoKTtcblxuICAgIFx0XHRcdH1cbiAgICBcdFx0fVxuXG4gICAgXHR9ICk7XG5cblxuICAgIFx0Ly9cblxuICAgIFx0dGhpcy5pZCA9IHByb2dyYW1JZENvdW50ICsrO1xuICAgIFx0dGhpcy5jb2RlID0gY29kZTtcbiAgICBcdHRoaXMudXNlZFRpbWVzID0gMTtcbiAgICBcdHRoaXMucHJvZ3JhbSA9IHByb2dyYW07XG4gICAgXHR0aGlzLnZlcnRleFNoYWRlciA9IGdsVmVydGV4U2hhZGVyO1xuICAgIFx0dGhpcy5mcmFnbWVudFNoYWRlciA9IGdsRnJhZ21lbnRTaGFkZXI7XG5cbiAgICBcdHJldHVybiB0aGlzO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gV2ViR0xQcm9ncmFtcyggcmVuZGVyZXIsIGNhcGFiaWxpdGllcyApIHtcblxuICAgIFx0dmFyIHByb2dyYW1zID0gW107XG5cbiAgICBcdHZhciBzaGFkZXJJRHMgPSB7XG4gICAgXHRcdE1lc2hEZXB0aE1hdGVyaWFsOiAnZGVwdGgnLFxuICAgIFx0XHRNZXNoTm9ybWFsTWF0ZXJpYWw6ICdub3JtYWwnLFxuICAgIFx0XHRNZXNoQmFzaWNNYXRlcmlhbDogJ2Jhc2ljJyxcbiAgICBcdFx0TWVzaExhbWJlcnRNYXRlcmlhbDogJ2xhbWJlcnQnLFxuICAgIFx0XHRNZXNoUGhvbmdNYXRlcmlhbDogJ3Bob25nJyxcbiAgICBcdFx0TWVzaFN0YW5kYXJkTWF0ZXJpYWw6ICdwaHlzaWNhbCcsXG4gICAgXHRcdE1lc2hQaHlzaWNhbE1hdGVyaWFsOiAncGh5c2ljYWwnLFxuICAgIFx0XHRMaW5lQmFzaWNNYXRlcmlhbDogJ2Jhc2ljJyxcbiAgICBcdFx0TGluZURhc2hlZE1hdGVyaWFsOiAnZGFzaGVkJyxcbiAgICBcdFx0UG9pbnRzTWF0ZXJpYWw6ICdwb2ludHMnXG4gICAgXHR9O1xuXG4gICAgXHR2YXIgcGFyYW1ldGVyTmFtZXMgPSBbXG4gICAgXHRcdFwicHJlY2lzaW9uXCIsIFwic3VwcG9ydHNWZXJ0ZXhUZXh0dXJlc1wiLCBcIm1hcFwiLCBcIm1hcEVuY29kaW5nXCIsIFwiZW52TWFwXCIsIFwiZW52TWFwTW9kZVwiLCBcImVudk1hcEVuY29kaW5nXCIsXG4gICAgXHRcdFwibGlnaHRNYXBcIiwgXCJhb01hcFwiLCBcImVtaXNzaXZlTWFwXCIsIFwiZW1pc3NpdmVNYXBFbmNvZGluZ1wiLCBcImJ1bXBNYXBcIiwgXCJub3JtYWxNYXBcIiwgXCJkaXNwbGFjZW1lbnRNYXBcIiwgXCJzcGVjdWxhck1hcFwiLFxuICAgIFx0XHRcInJvdWdobmVzc01hcFwiLCBcIm1ldGFsbmVzc01hcFwiLFxuICAgIFx0XHRcImFscGhhTWFwXCIsIFwiY29tYmluZVwiLCBcInZlcnRleENvbG9yc1wiLCBcImZvZ1wiLCBcInVzZUZvZ1wiLCBcImZvZ0V4cFwiLFxuICAgIFx0XHRcImZsYXRTaGFkaW5nXCIsIFwic2l6ZUF0dGVudWF0aW9uXCIsIFwibG9nYXJpdGhtaWNEZXB0aEJ1ZmZlclwiLCBcInNraW5uaW5nXCIsXG4gICAgXHRcdFwibWF4Qm9uZXNcIiwgXCJ1c2VWZXJ0ZXhUZXh0dXJlXCIsIFwibW9ycGhUYXJnZXRzXCIsIFwibW9ycGhOb3JtYWxzXCIsXG4gICAgXHRcdFwibWF4TW9ycGhUYXJnZXRzXCIsIFwibWF4TW9ycGhOb3JtYWxzXCIsIFwicHJlbXVsdGlwbGllZEFscGhhXCIsXG4gICAgXHRcdFwibnVtRGlyTGlnaHRzXCIsIFwibnVtUG9pbnRMaWdodHNcIiwgXCJudW1TcG90TGlnaHRzXCIsIFwibnVtSGVtaUxpZ2h0c1wiLFxuICAgIFx0XHRcInNoYWRvd01hcEVuYWJsZWRcIiwgXCJzaGFkb3dNYXBUeXBlXCIsIFwidG9uZU1hcHBpbmdcIiwgJ3BoeXNpY2FsbHlDb3JyZWN0TGlnaHRzJyxcbiAgICBcdFx0XCJhbHBoYVRlc3RcIiwgXCJkb3VibGVTaWRlZFwiLCBcImZsaXBTaWRlZFwiLCBcIm51bUNsaXBwaW5nUGxhbmVzXCIsIFwiZGVwdGhQYWNraW5nXCJcbiAgICBcdF07XG5cblxuICAgIFx0ZnVuY3Rpb24gYWxsb2NhdGVCb25lcyggb2JqZWN0ICkge1xuXG4gICAgXHRcdGlmICggY2FwYWJpbGl0aWVzLmZsb2F0VmVydGV4VGV4dHVyZXMgJiYgb2JqZWN0ICYmIG9iamVjdC5za2VsZXRvbiAmJiBvYmplY3Quc2tlbGV0b24udXNlVmVydGV4VGV4dHVyZSApIHtcblxuICAgIFx0XHRcdHJldHVybiAxMDI0O1xuXG4gICAgXHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHQvLyBkZWZhdWx0IGZvciB3aGVuIG9iamVjdCBpcyBub3Qgc3BlY2lmaWVkXG4gICAgXHRcdFx0Ly8gKCBmb3IgZXhhbXBsZSB3aGVuIHByZWJ1aWxkaW5nIHNoYWRlciB0byBiZSB1c2VkIHdpdGggbXVsdGlwbGUgb2JqZWN0cyApXG4gICAgXHRcdFx0Ly9cbiAgICBcdFx0XHQvLyAgLSBsZWF2ZSBzb21lIGV4dHJhIHNwYWNlIGZvciBvdGhlciB1bmlmb3Jtc1xuICAgIFx0XHRcdC8vICAtIGxpbWl0IGhlcmUgaXMgQU5HTEUncyAyNTQgbWF4IHVuaWZvcm0gdmVjdG9yc1xuICAgIFx0XHRcdC8vICAgICh1cCB0byA1NCBzaG91bGQgYmUgc2FmZSlcblxuICAgIFx0XHRcdHZhciBuVmVydGV4VW5pZm9ybXMgPSBjYXBhYmlsaXRpZXMubWF4VmVydGV4VW5pZm9ybXM7XG4gICAgXHRcdFx0dmFyIG5WZXJ0ZXhNYXRyaWNlcyA9IE1hdGguZmxvb3IoICggblZlcnRleFVuaWZvcm1zIC0gMjAgKSAvIDQgKTtcblxuICAgIFx0XHRcdHZhciBtYXhCb25lcyA9IG5WZXJ0ZXhNYXRyaWNlcztcblxuICAgIFx0XHRcdGlmICggb2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgKG9iamVjdCAmJiBvYmplY3QuaXNTa2lubmVkTWVzaCkgKSB7XG5cbiAgICBcdFx0XHRcdG1heEJvbmVzID0gTWF0aC5taW4oIG9iamVjdC5za2VsZXRvbi5ib25lcy5sZW5ndGgsIG1heEJvbmVzICk7XG5cbiAgICBcdFx0XHRcdGlmICggbWF4Qm9uZXMgPCBvYmplY3Quc2tlbGV0b24uYm9uZXMubGVuZ3RoICkge1xuXG4gICAgXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1dlYkdMUmVuZGVyZXI6IHRvbyBtYW55IGJvbmVzIC0gJyArIG9iamVjdC5za2VsZXRvbi5ib25lcy5sZW5ndGggKyAnLCB0aGlzIEdQVSBzdXBwb3J0cyBqdXN0ICcgKyBtYXhCb25lcyArICcgKHRyeSBPcGVuR0wgaW5zdGVhZCBvZiBBTkdMRSknICk7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdHJldHVybiBtYXhCb25lcztcblxuICAgIFx0XHR9XG5cbiAgICBcdH1cblxuICAgIFx0ZnVuY3Rpb24gZ2V0VGV4dHVyZUVuY29kaW5nRnJvbU1hcCggbWFwLCBnYW1tYU92ZXJyaWRlTGluZWFyICkge1xuXG4gICAgXHRcdHZhciBlbmNvZGluZztcblxuICAgIFx0XHRpZiAoICEgbWFwICkge1xuXG4gICAgXHRcdFx0ZW5jb2RpbmcgPSBMaW5lYXJFbmNvZGluZztcblxuICAgIFx0XHR9IGVsc2UgaWYgKCAobWFwICYmIG1hcC5pc1RleHR1cmUpICkge1xuXG4gICAgXHRcdFx0ZW5jb2RpbmcgPSBtYXAuZW5jb2Rpbmc7XG5cbiAgICBcdFx0fSBlbHNlIGlmICggKG1hcCAmJiBtYXAuaXNXZWJHTFJlbmRlclRhcmdldCkgKSB7XG5cbiAgICBcdFx0XHRjb25zb2xlLndhcm4oIFwiVEhSRUUuV2ViR0xQcm9ncmFtcy5nZXRUZXh0dXJlRW5jb2RpbmdGcm9tTWFwOiBkb24ndCB1c2UgcmVuZGVyIHRhcmdldHMgYXMgdGV4dHVyZXMuIFVzZSB0aGVpciAudGV4dHVyZSBwcm9wZXJ0eSBpbnN0ZWFkLlwiICk7XG4gICAgXHRcdFx0ZW5jb2RpbmcgPSBtYXAudGV4dHVyZS5lbmNvZGluZztcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0Ly8gYWRkIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IGZvciBXZWJHTFJlbmRlcmVyLmdhbW1hSW5wdXQvZ2FtbWFPdXRwdXQgcGFyYW1ldGVyLCBzaG91bGQgcHJvYmFibHkgYmUgcmVtb3ZlZCBhdCBzb21lIHBvaW50LlxuICAgIFx0XHRpZiAoIGVuY29kaW5nID09PSBMaW5lYXJFbmNvZGluZyAmJiBnYW1tYU92ZXJyaWRlTGluZWFyICkge1xuXG4gICAgXHRcdFx0ZW5jb2RpbmcgPSBHYW1tYUVuY29kaW5nO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gZW5jb2Rpbmc7XG5cbiAgICBcdH1cblxuICAgIFx0dGhpcy5nZXRQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCBtYXRlcmlhbCwgbGlnaHRzLCBmb2csIG5DbGlwUGxhbmVzLCBvYmplY3QgKSB7XG5cbiAgICBcdFx0dmFyIHNoYWRlcklEID0gc2hhZGVySURzWyBtYXRlcmlhbC50eXBlIF07XG5cbiAgICBcdFx0Ly8gaGV1cmlzdGljcyB0byBjcmVhdGUgc2hhZGVyIHBhcmFtZXRlcnMgYWNjb3JkaW5nIHRvIGxpZ2h0cyBpbiB0aGUgc2NlbmVcbiAgICBcdFx0Ly8gKG5vdCB0byBibG93IG92ZXIgbWF4TGlnaHRzIGJ1ZGdldClcblxuICAgIFx0XHR2YXIgbWF4Qm9uZXMgPSBhbGxvY2F0ZUJvbmVzKCBvYmplY3QgKTtcbiAgICBcdFx0dmFyIHByZWNpc2lvbiA9IHJlbmRlcmVyLmdldFByZWNpc2lvbigpO1xuXG4gICAgXHRcdGlmICggbWF0ZXJpYWwucHJlY2lzaW9uICE9PSBudWxsICkge1xuXG4gICAgXHRcdFx0cHJlY2lzaW9uID0gY2FwYWJpbGl0aWVzLmdldE1heFByZWNpc2lvbiggbWF0ZXJpYWwucHJlY2lzaW9uICk7XG5cbiAgICBcdFx0XHRpZiAoIHByZWNpc2lvbiAhPT0gbWF0ZXJpYWwucHJlY2lzaW9uICkge1xuXG4gICAgXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFByb2dyYW0uZ2V0UGFyYW1ldGVyczonLCBtYXRlcmlhbC5wcmVjaXNpb24sICdub3Qgc3VwcG9ydGVkLCB1c2luZycsIHByZWNpc2lvbiwgJ2luc3RlYWQuJyApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHR2YXIgY3VycmVudFJlbmRlclRhcmdldCA9IHJlbmRlcmVyLmdldEN1cnJlbnRSZW5kZXJUYXJnZXQoKTtcblxuICAgIFx0XHR2YXIgcGFyYW1ldGVycyA9IHtcblxuICAgIFx0XHRcdHNoYWRlcklEOiBzaGFkZXJJRCxcblxuICAgIFx0XHRcdHByZWNpc2lvbjogcHJlY2lzaW9uLFxuICAgIFx0XHRcdHN1cHBvcnRzVmVydGV4VGV4dHVyZXM6IGNhcGFiaWxpdGllcy52ZXJ0ZXhUZXh0dXJlcyxcbiAgICBcdFx0XHRvdXRwdXRFbmNvZGluZzogZ2V0VGV4dHVyZUVuY29kaW5nRnJvbU1hcCggKCAhIGN1cnJlbnRSZW5kZXJUYXJnZXQgKSA/IG51bGwgOiBjdXJyZW50UmVuZGVyVGFyZ2V0LnRleHR1cmUsIHJlbmRlcmVyLmdhbW1hT3V0cHV0ICksXG4gICAgXHRcdFx0bWFwOiAhISBtYXRlcmlhbC5tYXAsXG4gICAgXHRcdFx0bWFwRW5jb2Rpbmc6IGdldFRleHR1cmVFbmNvZGluZ0Zyb21NYXAoIG1hdGVyaWFsLm1hcCwgcmVuZGVyZXIuZ2FtbWFJbnB1dCApLFxuICAgIFx0XHRcdGVudk1hcDogISEgbWF0ZXJpYWwuZW52TWFwLFxuICAgIFx0XHRcdGVudk1hcE1vZGU6IG1hdGVyaWFsLmVudk1hcCAmJiBtYXRlcmlhbC5lbnZNYXAubWFwcGluZyxcbiAgICBcdFx0XHRlbnZNYXBFbmNvZGluZzogZ2V0VGV4dHVyZUVuY29kaW5nRnJvbU1hcCggbWF0ZXJpYWwuZW52TWFwLCByZW5kZXJlci5nYW1tYUlucHV0ICksXG4gICAgXHRcdFx0ZW52TWFwQ3ViZVVWOiAoICEhIG1hdGVyaWFsLmVudk1hcCApICYmICggKCBtYXRlcmlhbC5lbnZNYXAubWFwcGluZyA9PT0gQ3ViZVVWUmVmbGVjdGlvbk1hcHBpbmcgKSB8fCAoIG1hdGVyaWFsLmVudk1hcC5tYXBwaW5nID09PSBDdWJlVVZSZWZyYWN0aW9uTWFwcGluZyApICksXG4gICAgXHRcdFx0bGlnaHRNYXA6ICEhIG1hdGVyaWFsLmxpZ2h0TWFwLFxuICAgIFx0XHRcdGFvTWFwOiAhISBtYXRlcmlhbC5hb01hcCxcbiAgICBcdFx0XHRlbWlzc2l2ZU1hcDogISEgbWF0ZXJpYWwuZW1pc3NpdmVNYXAsXG4gICAgXHRcdFx0ZW1pc3NpdmVNYXBFbmNvZGluZzogZ2V0VGV4dHVyZUVuY29kaW5nRnJvbU1hcCggbWF0ZXJpYWwuZW1pc3NpdmVNYXAsIHJlbmRlcmVyLmdhbW1hSW5wdXQgKSxcbiAgICBcdFx0XHRidW1wTWFwOiAhISBtYXRlcmlhbC5idW1wTWFwLFxuICAgIFx0XHRcdG5vcm1hbE1hcDogISEgbWF0ZXJpYWwubm9ybWFsTWFwLFxuICAgIFx0XHRcdGRpc3BsYWNlbWVudE1hcDogISEgbWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwLFxuICAgIFx0XHRcdHJvdWdobmVzc01hcDogISEgbWF0ZXJpYWwucm91Z2huZXNzTWFwLFxuICAgIFx0XHRcdG1ldGFsbmVzc01hcDogISEgbWF0ZXJpYWwubWV0YWxuZXNzTWFwLFxuICAgIFx0XHRcdHNwZWN1bGFyTWFwOiAhISBtYXRlcmlhbC5zcGVjdWxhck1hcCxcbiAgICBcdFx0XHRhbHBoYU1hcDogISEgbWF0ZXJpYWwuYWxwaGFNYXAsXG5cbiAgICBcdFx0XHRjb21iaW5lOiBtYXRlcmlhbC5jb21iaW5lLFxuXG4gICAgXHRcdFx0dmVydGV4Q29sb3JzOiBtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMsXG5cbiAgICBcdFx0XHRmb2c6ICEhIGZvZyxcbiAgICBcdFx0XHR1c2VGb2c6IG1hdGVyaWFsLmZvZyxcbiAgICBcdFx0XHRmb2dFeHA6IChmb2cgJiYgZm9nLmlzRm9nRXhwMiksXG5cbiAgICBcdFx0XHRmbGF0U2hhZGluZzogbWF0ZXJpYWwuc2hhZGluZyA9PT0gRmxhdFNoYWRpbmcsXG5cbiAgICBcdFx0XHRzaXplQXR0ZW51YXRpb246IG1hdGVyaWFsLnNpemVBdHRlbnVhdGlvbixcbiAgICBcdFx0XHRsb2dhcml0aG1pY0RlcHRoQnVmZmVyOiBjYXBhYmlsaXRpZXMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlcixcblxuICAgIFx0XHRcdHNraW5uaW5nOiBtYXRlcmlhbC5za2lubmluZyxcbiAgICBcdFx0XHRtYXhCb25lczogbWF4Qm9uZXMsXG4gICAgXHRcdFx0dXNlVmVydGV4VGV4dHVyZTogY2FwYWJpbGl0aWVzLmZsb2F0VmVydGV4VGV4dHVyZXMgJiYgb2JqZWN0ICYmIG9iamVjdC5za2VsZXRvbiAmJiBvYmplY3Quc2tlbGV0b24udXNlVmVydGV4VGV4dHVyZSxcblxuICAgIFx0XHRcdG1vcnBoVGFyZ2V0czogbWF0ZXJpYWwubW9ycGhUYXJnZXRzLFxuICAgIFx0XHRcdG1vcnBoTm9ybWFsczogbWF0ZXJpYWwubW9ycGhOb3JtYWxzLFxuICAgIFx0XHRcdG1heE1vcnBoVGFyZ2V0czogcmVuZGVyZXIubWF4TW9ycGhUYXJnZXRzLFxuICAgIFx0XHRcdG1heE1vcnBoTm9ybWFsczogcmVuZGVyZXIubWF4TW9ycGhOb3JtYWxzLFxuXG4gICAgXHRcdFx0bnVtRGlyTGlnaHRzOiBsaWdodHMuZGlyZWN0aW9uYWwubGVuZ3RoLFxuICAgIFx0XHRcdG51bVBvaW50TGlnaHRzOiBsaWdodHMucG9pbnQubGVuZ3RoLFxuICAgIFx0XHRcdG51bVNwb3RMaWdodHM6IGxpZ2h0cy5zcG90Lmxlbmd0aCxcbiAgICBcdFx0XHRudW1IZW1pTGlnaHRzOiBsaWdodHMuaGVtaS5sZW5ndGgsXG5cbiAgICBcdFx0XHRudW1DbGlwcGluZ1BsYW5lczogbkNsaXBQbGFuZXMsXG5cbiAgICBcdFx0XHRzaGFkb3dNYXBFbmFibGVkOiByZW5kZXJlci5zaGFkb3dNYXAuZW5hYmxlZCAmJiBvYmplY3QucmVjZWl2ZVNoYWRvdyAmJiBsaWdodHMuc2hhZG93cy5sZW5ndGggPiAwLFxuICAgIFx0XHRcdHNoYWRvd01hcFR5cGU6IHJlbmRlcmVyLnNoYWRvd01hcC50eXBlLFxuXG4gICAgXHRcdFx0dG9uZU1hcHBpbmc6IHJlbmRlcmVyLnRvbmVNYXBwaW5nLFxuICAgIFx0XHRcdHBoeXNpY2FsbHlDb3JyZWN0TGlnaHRzOiByZW5kZXJlci5waHlzaWNhbGx5Q29ycmVjdExpZ2h0cyxcblxuICAgIFx0XHRcdHByZW11bHRpcGxpZWRBbHBoYTogbWF0ZXJpYWwucHJlbXVsdGlwbGllZEFscGhhLFxuXG4gICAgXHRcdFx0YWxwaGFUZXN0OiBtYXRlcmlhbC5hbHBoYVRlc3QsXG4gICAgXHRcdFx0ZG91YmxlU2lkZWQ6IG1hdGVyaWFsLnNpZGUgPT09IERvdWJsZVNpZGUsXG4gICAgXHRcdFx0ZmxpcFNpZGVkOiBtYXRlcmlhbC5zaWRlID09PSBCYWNrU2lkZSxcblxuICAgIFx0XHRcdGRlcHRoUGFja2luZzogKCBtYXRlcmlhbC5kZXB0aFBhY2tpbmcgIT09IHVuZGVmaW5lZCApID8gbWF0ZXJpYWwuZGVwdGhQYWNraW5nIDogZmFsc2VcblxuICAgIFx0XHR9O1xuXG4gICAgXHRcdHJldHVybiBwYXJhbWV0ZXJzO1xuXG4gICAgXHR9O1xuXG4gICAgXHR0aGlzLmdldFByb2dyYW1Db2RlID0gZnVuY3Rpb24gKCBtYXRlcmlhbCwgcGFyYW1ldGVycyApIHtcblxuICAgIFx0XHR2YXIgYXJyYXkgPSBbXTtcblxuICAgIFx0XHRpZiAoIHBhcmFtZXRlcnMuc2hhZGVySUQgKSB7XG5cbiAgICBcdFx0XHRhcnJheS5wdXNoKCBwYXJhbWV0ZXJzLnNoYWRlcklEICk7XG5cbiAgICBcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdGFycmF5LnB1c2goIG1hdGVyaWFsLmZyYWdtZW50U2hhZGVyICk7XG4gICAgXHRcdFx0YXJyYXkucHVzaCggbWF0ZXJpYWwudmVydGV4U2hhZGVyICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGlmICggbWF0ZXJpYWwuZGVmaW5lcyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0Zm9yICggdmFyIG5hbWUgaW4gbWF0ZXJpYWwuZGVmaW5lcyApIHtcblxuICAgIFx0XHRcdFx0YXJyYXkucHVzaCggbmFtZSApO1xuICAgIFx0XHRcdFx0YXJyYXkucHVzaCggbWF0ZXJpYWwuZGVmaW5lc1sgbmFtZSBdICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHBhcmFtZXRlck5hbWVzLmxlbmd0aDsgaSArKyApIHtcblxuICAgIFx0XHRcdGFycmF5LnB1c2goIHBhcmFtZXRlcnNbIHBhcmFtZXRlck5hbWVzWyBpIF0gXSApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gYXJyYXkuam9pbigpO1xuXG4gICAgXHR9O1xuXG4gICAgXHR0aGlzLmFjcXVpcmVQcm9ncmFtID0gZnVuY3Rpb24gKCBtYXRlcmlhbCwgcGFyYW1ldGVycywgY29kZSApIHtcblxuICAgIFx0XHR2YXIgcHJvZ3JhbTtcblxuICAgIFx0XHQvLyBDaGVjayBpZiBjb2RlIGhhcyBiZWVuIGFscmVhZHkgY29tcGlsZWRcbiAgICBcdFx0Zm9yICggdmFyIHAgPSAwLCBwbCA9IHByb2dyYW1zLmxlbmd0aDsgcCA8IHBsOyBwICsrICkge1xuXG4gICAgXHRcdFx0dmFyIHByb2dyYW1JbmZvID0gcHJvZ3JhbXNbIHAgXTtcblxuICAgIFx0XHRcdGlmICggcHJvZ3JhbUluZm8uY29kZSA9PT0gY29kZSApIHtcblxuICAgIFx0XHRcdFx0cHJvZ3JhbSA9IHByb2dyYW1JbmZvO1xuICAgIFx0XHRcdFx0KysgcHJvZ3JhbS51c2VkVGltZXM7XG5cbiAgICBcdFx0XHRcdGJyZWFrO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoIHByb2dyYW0gPT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdHByb2dyYW0gPSBuZXcgV2ViR0xQcm9ncmFtKCByZW5kZXJlciwgY29kZSwgbWF0ZXJpYWwsIHBhcmFtZXRlcnMgKTtcbiAgICBcdFx0XHRwcm9ncmFtcy5wdXNoKCBwcm9ncmFtICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiBwcm9ncmFtO1xuXG4gICAgXHR9O1xuXG4gICAgXHR0aGlzLnJlbGVhc2VQcm9ncmFtID0gZnVuY3Rpb24oIHByb2dyYW0gKSB7XG5cbiAgICBcdFx0aWYgKCAtLSBwcm9ncmFtLnVzZWRUaW1lcyA9PT0gMCApIHtcblxuICAgIFx0XHRcdC8vIFJlbW92ZSBmcm9tIHVub3JkZXJlZCBzZXRcbiAgICBcdFx0XHR2YXIgaSA9IHByb2dyYW1zLmluZGV4T2YoIHByb2dyYW0gKTtcbiAgICBcdFx0XHRwcm9ncmFtc1sgaSBdID0gcHJvZ3JhbXNbIHByb2dyYW1zLmxlbmd0aCAtIDEgXTtcbiAgICBcdFx0XHRwcm9ncmFtcy5wb3AoKTtcblxuICAgIFx0XHRcdC8vIEZyZWUgV2ViR0wgcmVzb3VyY2VzXG4gICAgXHRcdFx0cHJvZ3JhbS5kZXN0cm95KCk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9O1xuXG4gICAgXHQvLyBFeHBvc2VkIGZvciByZXNvdXJjZSBtb25pdG9yaW5nICYgZXJyb3IgZmVlZGJhY2sgdmlhIHJlbmRlcmVyLmluZm86XG4gICAgXHR0aGlzLnByb2dyYW1zID0gcHJvZ3JhbXM7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBXZWJHTEdlb21ldHJpZXMoIGdsLCBwcm9wZXJ0aWVzLCBpbmZvICkge1xuXG4gICAgXHR2YXIgZ2VvbWV0cmllcyA9IHt9O1xuXG4gICAgXHRmdW5jdGlvbiBvbkdlb21ldHJ5RGlzcG9zZSggZXZlbnQgKSB7XG5cbiAgICBcdFx0dmFyIGdlb21ldHJ5ID0gZXZlbnQudGFyZ2V0O1xuICAgIFx0XHR2YXIgYnVmZmVyZ2VvbWV0cnkgPSBnZW9tZXRyaWVzWyBnZW9tZXRyeS5pZCBdO1xuXG4gICAgXHRcdGlmICggYnVmZmVyZ2VvbWV0cnkuaW5kZXggIT09IG51bGwgKSB7XG5cbiAgICBcdFx0XHRkZWxldGVBdHRyaWJ1dGUoIGJ1ZmZlcmdlb21ldHJ5LmluZGV4ICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGRlbGV0ZUF0dHJpYnV0ZXMoIGJ1ZmZlcmdlb21ldHJ5LmF0dHJpYnV0ZXMgKTtcblxuICAgIFx0XHRnZW9tZXRyeS5yZW1vdmVFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uR2VvbWV0cnlEaXNwb3NlICk7XG5cbiAgICBcdFx0ZGVsZXRlIGdlb21ldHJpZXNbIGdlb21ldHJ5LmlkIF07XG5cbiAgICBcdFx0Ly8gVE9ET1xuXG4gICAgXHRcdHZhciBwcm9wZXJ0eSA9IHByb3BlcnRpZXMuZ2V0KCBnZW9tZXRyeSApO1xuXG4gICAgXHRcdGlmICggcHJvcGVydHkud2lyZWZyYW1lICkge1xuXG4gICAgXHRcdFx0ZGVsZXRlQXR0cmlidXRlKCBwcm9wZXJ0eS53aXJlZnJhbWUgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cHJvcGVydGllcy5kZWxldGUoIGdlb21ldHJ5ICk7XG5cbiAgICBcdFx0dmFyIGJ1ZmZlcnByb3BlcnR5ID0gcHJvcGVydGllcy5nZXQoIGJ1ZmZlcmdlb21ldHJ5ICk7XG5cbiAgICBcdFx0aWYgKCBidWZmZXJwcm9wZXJ0eS53aXJlZnJhbWUgKSB7XG5cbiAgICBcdFx0XHRkZWxldGVBdHRyaWJ1dGUoIGJ1ZmZlcnByb3BlcnR5LndpcmVmcmFtZSApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRwcm9wZXJ0aWVzLmRlbGV0ZSggYnVmZmVyZ2VvbWV0cnkgKTtcblxuICAgIFx0XHQvL1xuXG4gICAgXHRcdGluZm8ubWVtb3J5Lmdlb21ldHJpZXMgLS07XG5cbiAgICBcdH1cblxuICAgIFx0ZnVuY3Rpb24gZ2V0QXR0cmlidXRlQnVmZmVyKCBhdHRyaWJ1dGUgKSB7XG5cbiAgICBcdFx0aWYgKCBhdHRyaWJ1dGUuaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSApIHtcblxuICAgIFx0XHRcdHJldHVybiBwcm9wZXJ0aWVzLmdldCggYXR0cmlidXRlLmRhdGEgKS5fX3dlYmdsQnVmZmVyO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gcHJvcGVydGllcy5nZXQoIGF0dHJpYnV0ZSApLl9fd2ViZ2xCdWZmZXI7XG5cbiAgICBcdH1cblxuICAgIFx0ZnVuY3Rpb24gZGVsZXRlQXR0cmlidXRlKCBhdHRyaWJ1dGUgKSB7XG5cbiAgICBcdFx0dmFyIGJ1ZmZlciA9IGdldEF0dHJpYnV0ZUJ1ZmZlciggYXR0cmlidXRlICk7XG5cbiAgICBcdFx0aWYgKCBidWZmZXIgIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdGdsLmRlbGV0ZUJ1ZmZlciggYnVmZmVyICk7XG4gICAgXHRcdFx0cmVtb3ZlQXR0cmlidXRlQnVmZmVyKCBhdHRyaWJ1dGUgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdH1cblxuICAgIFx0ZnVuY3Rpb24gZGVsZXRlQXR0cmlidXRlcyggYXR0cmlidXRlcyApIHtcblxuICAgIFx0XHRmb3IgKCB2YXIgbmFtZSBpbiBhdHRyaWJ1dGVzICkge1xuXG4gICAgXHRcdFx0ZGVsZXRlQXR0cmlidXRlKCBhdHRyaWJ1dGVzWyBuYW1lIF0gKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdH1cblxuICAgIFx0ZnVuY3Rpb24gcmVtb3ZlQXR0cmlidXRlQnVmZmVyKCBhdHRyaWJ1dGUgKSB7XG5cbiAgICBcdFx0aWYgKCBhdHRyaWJ1dGUuaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSApIHtcblxuICAgIFx0XHRcdHByb3BlcnRpZXMuZGVsZXRlKCBhdHRyaWJ1dGUuZGF0YSApO1xuXG4gICAgXHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRwcm9wZXJ0aWVzLmRlbGV0ZSggYXR0cmlidXRlICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9XG5cbiAgICBcdHJldHVybiB7XG5cbiAgICBcdFx0Z2V0OiBmdW5jdGlvbiAoIG9iamVjdCApIHtcblxuICAgIFx0XHRcdHZhciBnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeTtcblxuICAgIFx0XHRcdGlmICggZ2VvbWV0cmllc1sgZ2VvbWV0cnkuaWQgXSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0XHRyZXR1cm4gZ2VvbWV0cmllc1sgZ2VvbWV0cnkuaWQgXTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGdlb21ldHJ5LmFkZEV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25HZW9tZXRyeURpc3Bvc2UgKTtcblxuICAgIFx0XHRcdHZhciBidWZmZXJnZW9tZXRyeTtcblxuICAgIFx0XHRcdGlmICggZ2VvbWV0cnkuaXNCdWZmZXJHZW9tZXRyeSApIHtcblxuICAgIFx0XHRcdFx0YnVmZmVyZ2VvbWV0cnkgPSBnZW9tZXRyeTtcblxuICAgIFx0XHRcdH0gZWxzZSBpZiAoIGdlb21ldHJ5LmlzR2VvbWV0cnkgKSB7XG5cbiAgICBcdFx0XHRcdGlmICggZ2VvbWV0cnkuX2J1ZmZlckdlb21ldHJ5ID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRcdFx0Z2VvbWV0cnkuX2J1ZmZlckdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCkuc2V0RnJvbU9iamVjdCggb2JqZWN0ICk7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0YnVmZmVyZ2VvbWV0cnkgPSBnZW9tZXRyeS5fYnVmZmVyR2VvbWV0cnk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRnZW9tZXRyaWVzWyBnZW9tZXRyeS5pZCBdID0gYnVmZmVyZ2VvbWV0cnk7XG5cbiAgICBcdFx0XHRpbmZvLm1lbW9yeS5nZW9tZXRyaWVzICsrO1xuXG4gICAgXHRcdFx0cmV0dXJuIGJ1ZmZlcmdlb21ldHJ5O1xuXG4gICAgXHRcdH1cblxuICAgIFx0fTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIFdlYkdMT2JqZWN0cyggZ2wsIHByb3BlcnRpZXMsIGluZm8gKSB7XG5cbiAgICBcdHZhciBnZW9tZXRyaWVzID0gbmV3IFdlYkdMR2VvbWV0cmllcyggZ2wsIHByb3BlcnRpZXMsIGluZm8gKTtcblxuICAgIFx0Ly9cblxuICAgIFx0ZnVuY3Rpb24gdXBkYXRlKCBvYmplY3QgKSB7XG5cbiAgICBcdFx0Ly8gVE9ETzogQXZvaWQgdXBkYXRpbmcgdHdpY2UgKHdoZW4gdXNpbmcgc2hhZG93TWFwKS4gTWF5YmUgYWRkIGZyYW1lIGNvdW50ZXIuXG5cbiAgICBcdFx0dmFyIGdlb21ldHJ5ID0gZ2VvbWV0cmllcy5nZXQoIG9iamVjdCApO1xuXG4gICAgXHRcdGlmICggb2JqZWN0Lmdlb21ldHJ5LmlzR2VvbWV0cnkgKSB7XG5cbiAgICBcdFx0XHRnZW9tZXRyeS51cGRhdGVGcm9tT2JqZWN0KCBvYmplY3QgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0dmFyIGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XG4gICAgXHRcdHZhciBhdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcblxuICAgIFx0XHRpZiAoIGluZGV4ICE9PSBudWxsICkge1xuXG4gICAgXHRcdFx0dXBkYXRlQXR0cmlidXRlKCBpbmRleCwgZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0Zm9yICggdmFyIG5hbWUgaW4gYXR0cmlidXRlcyApIHtcblxuICAgIFx0XHRcdHVwZGF0ZUF0dHJpYnV0ZSggYXR0cmlidXRlc1sgbmFtZSBdLCBnbC5BUlJBWV9CVUZGRVIgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0Ly8gbW9ycGggdGFyZ2V0c1xuXG4gICAgXHRcdHZhciBtb3JwaEF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXM7XG5cbiAgICBcdFx0Zm9yICggdmFyIG5hbWUgaW4gbW9ycGhBdHRyaWJ1dGVzICkge1xuXG4gICAgXHRcdFx0dmFyIGFycmF5ID0gbW9ycGhBdHRyaWJ1dGVzWyBuYW1lIF07XG5cbiAgICBcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBhcnJheS5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgXHRcdFx0XHR1cGRhdGVBdHRyaWJ1dGUoIGFycmF5WyBpIF0sIGdsLkFSUkFZX0JVRkZFUiApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gZ2VvbWV0cnk7XG5cbiAgICBcdH1cblxuICAgIFx0ZnVuY3Rpb24gdXBkYXRlQXR0cmlidXRlKCBhdHRyaWJ1dGUsIGJ1ZmZlclR5cGUgKSB7XG5cbiAgICBcdFx0dmFyIGRhdGEgPSAoIGF0dHJpYnV0ZS5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlICkgPyBhdHRyaWJ1dGUuZGF0YSA6IGF0dHJpYnV0ZTtcblxuICAgIFx0XHR2YXIgYXR0cmlidXRlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCBkYXRhICk7XG5cbiAgICBcdFx0aWYgKCBhdHRyaWJ1dGVQcm9wZXJ0aWVzLl9fd2ViZ2xCdWZmZXIgPT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdGNyZWF0ZUJ1ZmZlciggYXR0cmlidXRlUHJvcGVydGllcywgZGF0YSwgYnVmZmVyVHlwZSApO1xuXG4gICAgXHRcdH0gZWxzZSBpZiAoIGF0dHJpYnV0ZVByb3BlcnRpZXMudmVyc2lvbiAhPT0gZGF0YS52ZXJzaW9uICkge1xuXG4gICAgXHRcdFx0dXBkYXRlQnVmZmVyKCBhdHRyaWJ1dGVQcm9wZXJ0aWVzLCBkYXRhLCBidWZmZXJUeXBlICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9XG5cbiAgICBcdGZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciggYXR0cmlidXRlUHJvcGVydGllcywgZGF0YSwgYnVmZmVyVHlwZSApIHtcblxuICAgIFx0XHRhdHRyaWJ1dGVQcm9wZXJ0aWVzLl9fd2ViZ2xCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBcdFx0Z2wuYmluZEJ1ZmZlciggYnVmZmVyVHlwZSwgYXR0cmlidXRlUHJvcGVydGllcy5fX3dlYmdsQnVmZmVyICk7XG5cbiAgICBcdFx0dmFyIHVzYWdlID0gZGF0YS5keW5hbWljID8gZ2wuRFlOQU1JQ19EUkFXIDogZ2wuU1RBVElDX0RSQVc7XG5cbiAgICBcdFx0Z2wuYnVmZmVyRGF0YSggYnVmZmVyVHlwZSwgZGF0YS5hcnJheSwgdXNhZ2UgKTtcblxuICAgIFx0XHRhdHRyaWJ1dGVQcm9wZXJ0aWVzLnZlcnNpb24gPSBkYXRhLnZlcnNpb247XG5cbiAgICBcdH1cblxuICAgIFx0ZnVuY3Rpb24gdXBkYXRlQnVmZmVyKCBhdHRyaWJ1dGVQcm9wZXJ0aWVzLCBkYXRhLCBidWZmZXJUeXBlICkge1xuXG4gICAgXHRcdGdsLmJpbmRCdWZmZXIoIGJ1ZmZlclR5cGUsIGF0dHJpYnV0ZVByb3BlcnRpZXMuX193ZWJnbEJ1ZmZlciApO1xuXG4gICAgXHRcdGlmICggZGF0YS5keW5hbWljID09PSBmYWxzZSB8fCBkYXRhLnVwZGF0ZVJhbmdlLmNvdW50ID09PSAtIDEgKSB7XG5cbiAgICBcdFx0XHQvLyBOb3QgdXNpbmcgdXBkYXRlIHJhbmdlc1xuXG4gICAgXHRcdFx0Z2wuYnVmZmVyU3ViRGF0YSggYnVmZmVyVHlwZSwgMCwgZGF0YS5hcnJheSApO1xuXG4gICAgXHRcdH0gZWxzZSBpZiAoIGRhdGEudXBkYXRlUmFuZ2UuY291bnQgPT09IDAgKSB7XG5cbiAgICBcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xPYmplY3RzLnVwZGF0ZUJ1ZmZlcjogZHluYW1pYyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUgbWFya2VkIGFzIG5lZWRzVXBkYXRlIGJ1dCB1cGRhdGVSYW5nZS5jb3VudCBpcyAwLCBlbnN1cmUgeW91IGFyZSB1c2luZyBzZXQgbWV0aG9kcyBvciB1cGRhdGluZyBtYW51YWxseS4nICk7XG5cbiAgICBcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdGdsLmJ1ZmZlclN1YkRhdGEoIGJ1ZmZlclR5cGUsIGRhdGEudXBkYXRlUmFuZ2Uub2Zmc2V0ICogZGF0YS5hcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcbiAgICBcdFx0XHRcdFx0XHRcdCAgZGF0YS5hcnJheS5zdWJhcnJheSggZGF0YS51cGRhdGVSYW5nZS5vZmZzZXQsIGRhdGEudXBkYXRlUmFuZ2Uub2Zmc2V0ICsgZGF0YS51cGRhdGVSYW5nZS5jb3VudCApICk7XG5cbiAgICBcdFx0XHRkYXRhLnVwZGF0ZVJhbmdlLmNvdW50ID0gMDsgLy8gcmVzZXQgcmFuZ2VcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0YXR0cmlidXRlUHJvcGVydGllcy52ZXJzaW9uID0gZGF0YS52ZXJzaW9uO1xuXG4gICAgXHR9XG5cbiAgICBcdGZ1bmN0aW9uIGdldEF0dHJpYnV0ZUJ1ZmZlciggYXR0cmlidXRlICkge1xuXG4gICAgXHRcdGlmICggYXR0cmlidXRlLmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgKSB7XG5cbiAgICBcdFx0XHRyZXR1cm4gcHJvcGVydGllcy5nZXQoIGF0dHJpYnV0ZS5kYXRhICkuX193ZWJnbEJ1ZmZlcjtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIHByb3BlcnRpZXMuZ2V0KCBhdHRyaWJ1dGUgKS5fX3dlYmdsQnVmZmVyO1xuXG4gICAgXHR9XG5cbiAgICBcdGZ1bmN0aW9uIGdldFdpcmVmcmFtZUF0dHJpYnV0ZSggZ2VvbWV0cnkgKSB7XG5cbiAgICBcdFx0dmFyIHByb3BlcnR5ID0gcHJvcGVydGllcy5nZXQoIGdlb21ldHJ5ICk7XG5cbiAgICBcdFx0aWYgKCBwcm9wZXJ0eS53aXJlZnJhbWUgIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdHJldHVybiBwcm9wZXJ0eS53aXJlZnJhbWU7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHZhciBpbmRpY2VzID0gW107XG5cbiAgICBcdFx0dmFyIGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XG4gICAgXHRcdHZhciBhdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcbiAgICBcdFx0dmFyIHBvc2l0aW9uID0gYXR0cmlidXRlcy5wb3NpdGlvbjtcblxuICAgIFx0XHQvLyBjb25zb2xlLnRpbWUoICd3aXJlZnJhbWUnICk7XG5cbiAgICBcdFx0aWYgKCBpbmRleCAhPT0gbnVsbCApIHtcblxuICAgIFx0XHRcdHZhciBlZGdlcyA9IHt9O1xuICAgIFx0XHRcdHZhciBhcnJheSA9IGluZGV4LmFycmF5O1xuXG4gICAgXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gYXJyYXkubGVuZ3RoOyBpIDwgbDsgaSArPSAzICkge1xuXG4gICAgXHRcdFx0XHR2YXIgYSA9IGFycmF5WyBpICsgMCBdO1xuICAgIFx0XHRcdFx0dmFyIGIgPSBhcnJheVsgaSArIDEgXTtcbiAgICBcdFx0XHRcdHZhciBjID0gYXJyYXlbIGkgKyAyIF07XG5cbiAgICBcdFx0XHRcdGluZGljZXMucHVzaCggYSwgYiwgYiwgYywgYywgYSApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHR2YXIgYXJyYXkgPSBhdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xuXG4gICAgXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gKCBhcnJheS5sZW5ndGggLyAzICkgLSAxOyBpIDwgbDsgaSArPSAzICkge1xuXG4gICAgXHRcdFx0XHR2YXIgYSA9IGkgKyAwO1xuICAgIFx0XHRcdFx0dmFyIGIgPSBpICsgMTtcbiAgICBcdFx0XHRcdHZhciBjID0gaSArIDI7XG5cbiAgICBcdFx0XHRcdGluZGljZXMucHVzaCggYSwgYiwgYiwgYywgYywgYSApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHQvLyBjb25zb2xlLnRpbWVFbmQoICd3aXJlZnJhbWUnICk7XG5cbiAgICBcdFx0dmFyIFR5cGVBcnJheSA9IHBvc2l0aW9uLmNvdW50ID4gNjU1MzUgPyBVaW50MzJBcnJheSA6IFVpbnQxNkFycmF5O1xuICAgIFx0XHR2YXIgYXR0cmlidXRlID0gbmV3IEJ1ZmZlckF0dHJpYnV0ZSggbmV3IFR5cGVBcnJheSggaW5kaWNlcyApLCAxICk7XG5cbiAgICBcdFx0dXBkYXRlQXR0cmlidXRlKCBhdHRyaWJ1dGUsIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSICk7XG5cbiAgICBcdFx0cHJvcGVydHkud2lyZWZyYW1lID0gYXR0cmlidXRlO1xuXG4gICAgXHRcdHJldHVybiBhdHRyaWJ1dGU7XG5cbiAgICBcdH1cblxuICAgIFx0cmV0dXJuIHtcblxuICAgIFx0XHRnZXRBdHRyaWJ1dGVCdWZmZXI6IGdldEF0dHJpYnV0ZUJ1ZmZlcixcbiAgICBcdFx0Z2V0V2lyZWZyYW1lQXR0cmlidXRlOiBnZXRXaXJlZnJhbWVBdHRyaWJ1dGUsXG5cbiAgICBcdFx0dXBkYXRlOiB1cGRhdGVcblxuICAgIFx0fTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIFdlYkdMVGV4dHVyZXMoIF9nbCwgZXh0ZW5zaW9ucywgc3RhdGUsIHByb3BlcnRpZXMsIGNhcGFiaWxpdGllcywgcGFyYW1UaHJlZVRvR0wsIGluZm8gKSB7XG5cbiAgICBcdHZhciBfaW5mb01lbW9yeSA9IGluZm8ubWVtb3J5O1xuICAgIFx0dmFyIF9pc1dlYkdMMiA9ICggdHlwZW9mIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgIT09ICd1bmRlZmluZWQnICYmIF9nbCBpbnN0YW5jZW9mIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgKTtcblxuICAgIFx0Ly9cblxuICAgIFx0ZnVuY3Rpb24gY2xhbXBUb01heFNpemUoIGltYWdlLCBtYXhTaXplICkge1xuXG4gICAgXHRcdGlmICggaW1hZ2Uud2lkdGggPiBtYXhTaXplIHx8IGltYWdlLmhlaWdodCA+IG1heFNpemUgKSB7XG5cbiAgICBcdFx0XHQvLyBXYXJuaW5nOiBTY2FsaW5nIHRocm91Z2ggdGhlIGNhbnZhcyB3aWxsIG9ubHkgd29yayB3aXRoIGltYWdlcyB0aGF0IHVzZVxuICAgIFx0XHRcdC8vIHByZW11bHRpcGxpZWQgYWxwaGEuXG5cbiAgICBcdFx0XHR2YXIgc2NhbGUgPSBtYXhTaXplIC8gTWF0aC5tYXgoIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQgKTtcblxuICAgIFx0XHRcdHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJywgJ2NhbnZhcycgKTtcbiAgICBcdFx0XHRjYW52YXMud2lkdGggPSBNYXRoLmZsb29yKCBpbWFnZS53aWR0aCAqIHNjYWxlICk7XG4gICAgXHRcdFx0Y2FudmFzLmhlaWdodCA9IE1hdGguZmxvb3IoIGltYWdlLmhlaWdodCAqIHNjYWxlICk7XG5cbiAgICBcdFx0XHR2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCAnMmQnICk7XG4gICAgXHRcdFx0Y29udGV4dC5kcmF3SW1hZ2UoIGltYWdlLCAwLCAwLCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0LCAwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQgKTtcblxuICAgIFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IGltYWdlIGlzIHRvbyBiaWcgKCcgKyBpbWFnZS53aWR0aCArICd4JyArIGltYWdlLmhlaWdodCArICcpLiBSZXNpemVkIHRvICcgKyBjYW52YXMud2lkdGggKyAneCcgKyBjYW52YXMuaGVpZ2h0LCBpbWFnZSApO1xuXG4gICAgXHRcdFx0cmV0dXJuIGNhbnZhcztcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIGltYWdlO1xuXG4gICAgXHR9XG5cbiAgICBcdGZ1bmN0aW9uIGlzUG93ZXJPZlR3byggaW1hZ2UgKSB7XG5cbiAgICBcdFx0cmV0dXJuIGV4cG9ydHMuTWF0aC5pc1Bvd2VyT2ZUd28oIGltYWdlLndpZHRoICkgJiYgZXhwb3J0cy5NYXRoLmlzUG93ZXJPZlR3byggaW1hZ2UuaGVpZ2h0ICk7XG5cbiAgICBcdH1cblxuICAgIFx0ZnVuY3Rpb24gbWFrZVBvd2VyT2ZUd28oIGltYWdlICkge1xuXG4gICAgXHRcdGlmICggaW1hZ2UgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50IHx8IGltYWdlIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQgKSB7XG5cbiAgICBcdFx0XHR2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCcsICdjYW52YXMnICk7XG4gICAgXHRcdFx0Y2FudmFzLndpZHRoID0gZXhwb3J0cy5NYXRoLm5lYXJlc3RQb3dlck9mVHdvKCBpbWFnZS53aWR0aCApO1xuICAgIFx0XHRcdGNhbnZhcy5oZWlnaHQgPSBleHBvcnRzLk1hdGgubmVhcmVzdFBvd2VyT2ZUd28oIGltYWdlLmhlaWdodCApO1xuXG4gICAgXHRcdFx0dmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCggJzJkJyApO1xuICAgIFx0XHRcdGNvbnRleHQuZHJhd0ltYWdlKCBpbWFnZSwgMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0ICk7XG5cbiAgICBcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBpbWFnZSBpcyBub3QgcG93ZXIgb2YgdHdvICgnICsgaW1hZ2Uud2lkdGggKyAneCcgKyBpbWFnZS5oZWlnaHQgKyAnKS4gUmVzaXplZCB0byAnICsgY2FudmFzLndpZHRoICsgJ3gnICsgY2FudmFzLmhlaWdodCwgaW1hZ2UgKTtcblxuICAgIFx0XHRcdHJldHVybiBjYW52YXM7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiBpbWFnZTtcblxuICAgIFx0fVxuXG4gICAgXHRmdW5jdGlvbiB0ZXh0dXJlTmVlZHNQb3dlck9mVHdvKCB0ZXh0dXJlICkge1xuXG4gICAgXHRcdGlmICggdGV4dHVyZS53cmFwUyAhPT0gQ2xhbXBUb0VkZ2VXcmFwcGluZyB8fCB0ZXh0dXJlLndyYXBUICE9PSBDbGFtcFRvRWRnZVdyYXBwaW5nICkgcmV0dXJuIHRydWU7XG4gICAgXHRcdGlmICggdGV4dHVyZS5taW5GaWx0ZXIgIT09IE5lYXJlc3RGaWx0ZXIgJiYgdGV4dHVyZS5taW5GaWx0ZXIgIT09IExpbmVhckZpbHRlciApIHJldHVybiB0cnVlO1xuXG4gICAgXHRcdHJldHVybiBmYWxzZTtcblxuICAgIFx0fVxuXG4gICAgXHQvLyBGYWxsYmFjayBmaWx0ZXJzIGZvciBub24tcG93ZXItb2YtMiB0ZXh0dXJlc1xuXG4gICAgXHRmdW5jdGlvbiBmaWx0ZXJGYWxsYmFjayggZiApIHtcblxuICAgIFx0XHRpZiAoIGYgPT09IE5lYXJlc3RGaWx0ZXIgfHwgZiA9PT0gTmVhcmVzdE1pcE1hcE5lYXJlc3RGaWx0ZXIgfHwgZiA9PT0gTmVhcmVzdE1pcE1hcExpbmVhckZpbHRlciApIHtcblxuICAgIFx0XHRcdHJldHVybiBfZ2wuTkVBUkVTVDtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIF9nbC5MSU5FQVI7XG5cbiAgICBcdH1cblxuICAgIFx0Ly9cblxuICAgIFx0ZnVuY3Rpb24gb25UZXh0dXJlRGlzcG9zZSggZXZlbnQgKSB7XG5cbiAgICBcdFx0dmFyIHRleHR1cmUgPSBldmVudC50YXJnZXQ7XG5cbiAgICBcdFx0dGV4dHVyZS5yZW1vdmVFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uVGV4dHVyZURpc3Bvc2UgKTtcblxuICAgIFx0XHRkZWFsbG9jYXRlVGV4dHVyZSggdGV4dHVyZSApO1xuXG4gICAgXHRcdF9pbmZvTWVtb3J5LnRleHR1cmVzIC0tO1xuXG5cbiAgICBcdH1cblxuICAgIFx0ZnVuY3Rpb24gb25SZW5kZXJUYXJnZXREaXNwb3NlKCBldmVudCApIHtcblxuICAgIFx0XHR2YXIgcmVuZGVyVGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuXG4gICAgXHRcdHJlbmRlclRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uUmVuZGVyVGFyZ2V0RGlzcG9zZSApO1xuXG4gICAgXHRcdGRlYWxsb2NhdGVSZW5kZXJUYXJnZXQoIHJlbmRlclRhcmdldCApO1xuXG4gICAgXHRcdF9pbmZvTWVtb3J5LnRleHR1cmVzIC0tO1xuXG4gICAgXHR9XG5cbiAgICBcdC8vXG5cbiAgICBcdGZ1bmN0aW9uIGRlYWxsb2NhdGVUZXh0dXJlKCB0ZXh0dXJlICkge1xuXG4gICAgXHRcdHZhciB0ZXh0dXJlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCB0ZXh0dXJlICk7XG5cbiAgICBcdFx0aWYgKCB0ZXh0dXJlLmltYWdlICYmIHRleHR1cmVQcm9wZXJ0aWVzLl9faW1hZ2VfX3dlYmdsVGV4dHVyZUN1YmUgKSB7XG5cbiAgICBcdFx0XHQvLyBjdWJlIHRleHR1cmVcblxuICAgIFx0XHRcdF9nbC5kZWxldGVUZXh0dXJlKCB0ZXh0dXJlUHJvcGVydGllcy5fX2ltYWdlX193ZWJnbFRleHR1cmVDdWJlICk7XG5cbiAgICBcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdC8vIDJEIHRleHR1cmVcblxuICAgIFx0XHRcdGlmICggdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbEluaXQgPT09IHVuZGVmaW5lZCApIHJldHVybjtcblxuICAgIFx0XHRcdF9nbC5kZWxldGVUZXh0dXJlKCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHQvLyByZW1vdmUgYWxsIHdlYmdsIHByb3BlcnRpZXNcbiAgICBcdFx0cHJvcGVydGllcy5kZWxldGUoIHRleHR1cmUgKTtcblxuICAgIFx0fVxuXG4gICAgXHRmdW5jdGlvbiBkZWFsbG9jYXRlUmVuZGVyVGFyZ2V0KCByZW5kZXJUYXJnZXQgKSB7XG5cbiAgICBcdFx0dmFyIHJlbmRlclRhcmdldFByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0ICk7XG4gICAgXHRcdHZhciB0ZXh0dXJlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQudGV4dHVyZSApO1xuXG4gICAgXHRcdGlmICggISByZW5kZXJUYXJnZXQgKSByZXR1cm47XG5cbiAgICBcdFx0aWYgKCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0X2dsLmRlbGV0ZVRleHR1cmUoIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGlmICggcmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZSApIHtcblxuICAgIFx0XHRcdHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUuZGlzcG9zZSgpO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoIChyZW5kZXJUYXJnZXQgJiYgcmVuZGVyVGFyZ2V0LmlzV2ViR0xSZW5kZXJUYXJnZXRDdWJlKSApIHtcblxuICAgIFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IDY7IGkgKysgKSB7XG5cbiAgICBcdFx0XHRcdF9nbC5kZWxldGVGcmFtZWJ1ZmZlciggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXJbIGkgXSApO1xuICAgIFx0XHRcdFx0aWYgKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xEZXB0aGJ1ZmZlciApIF9nbC5kZWxldGVSZW5kZXJidWZmZXIoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbERlcHRoYnVmZmVyWyBpIF0gKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0X2dsLmRlbGV0ZUZyYW1lYnVmZmVyKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlciApO1xuICAgIFx0XHRcdGlmICggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRGVwdGhidWZmZXIgKSBfZ2wuZGVsZXRlUmVuZGVyYnVmZmVyKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xEZXB0aGJ1ZmZlciApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRwcm9wZXJ0aWVzLmRlbGV0ZSggcmVuZGVyVGFyZ2V0LnRleHR1cmUgKTtcbiAgICBcdFx0cHJvcGVydGllcy5kZWxldGUoIHJlbmRlclRhcmdldCApO1xuXG4gICAgXHR9XG5cbiAgICBcdC8vXG5cblxuXG4gICAgXHRmdW5jdGlvbiBzZXRUZXh0dXJlMkQoIHRleHR1cmUsIHNsb3QgKSB7XG5cbiAgICBcdFx0dmFyIHRleHR1cmVQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIHRleHR1cmUgKTtcblxuICAgIFx0XHRpZiAoIHRleHR1cmUudmVyc2lvbiA+IDAgJiYgdGV4dHVyZVByb3BlcnRpZXMuX192ZXJzaW9uICE9PSB0ZXh0dXJlLnZlcnNpb24gKSB7XG5cbiAgICBcdFx0XHR2YXIgaW1hZ2UgPSB0ZXh0dXJlLmltYWdlO1xuXG4gICAgXHRcdFx0aWYgKCBpbWFnZSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBUZXh0dXJlIG1hcmtlZCBmb3IgdXBkYXRlIGJ1dCBpbWFnZSBpcyB1bmRlZmluZWQnLCB0ZXh0dXJlICk7XG5cbiAgICBcdFx0XHR9IGVsc2UgaWYgKCBpbWFnZS5jb21wbGV0ZSA9PT0gZmFsc2UgKSB7XG5cbiAgICBcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IFRleHR1cmUgbWFya2VkIGZvciB1cGRhdGUgYnV0IGltYWdlIGlzIGluY29tcGxldGUnLCB0ZXh0dXJlICk7XG5cbiAgICBcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHR1cGxvYWRUZXh0dXJlKCB0ZXh0dXJlUHJvcGVydGllcywgdGV4dHVyZSwgc2xvdCApO1xuICAgIFx0XHRcdFx0cmV0dXJuO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHRzdGF0ZS5hY3RpdmVUZXh0dXJlKCBfZ2wuVEVYVFVSRTAgKyBzbG90ICk7XG4gICAgXHRcdHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgKTtcblxuICAgIFx0fVxuXG4gICAgXHRmdW5jdGlvbiBzZXRUZXh0dXJlQ3ViZSggdGV4dHVyZSwgc2xvdCApIHtcblxuICAgIFx0XHR2YXIgdGV4dHVyZVByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggdGV4dHVyZSApO1xuXG4gICAgXHRcdGlmICggdGV4dHVyZS5pbWFnZS5sZW5ndGggPT09IDYgKSB7XG5cbiAgICBcdFx0XHRpZiAoIHRleHR1cmUudmVyc2lvbiA+IDAgJiYgdGV4dHVyZVByb3BlcnRpZXMuX192ZXJzaW9uICE9PSB0ZXh0dXJlLnZlcnNpb24gKSB7XG5cbiAgICBcdFx0XHRcdGlmICggISB0ZXh0dXJlUHJvcGVydGllcy5fX2ltYWdlX193ZWJnbFRleHR1cmVDdWJlICkge1xuXG4gICAgXHRcdFx0XHRcdHRleHR1cmUuYWRkRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvblRleHR1cmVEaXNwb3NlICk7XG5cbiAgICBcdFx0XHRcdFx0dGV4dHVyZVByb3BlcnRpZXMuX19pbWFnZV9fd2ViZ2xUZXh0dXJlQ3ViZSA9IF9nbC5jcmVhdGVUZXh0dXJlKCk7XG5cbiAgICBcdFx0XHRcdFx0X2luZm9NZW1vcnkudGV4dHVyZXMgKys7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0c3RhdGUuYWN0aXZlVGV4dHVyZSggX2dsLlRFWFRVUkUwICsgc2xvdCApO1xuICAgIFx0XHRcdFx0c3RhdGUuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFX0NVQkVfTUFQLCB0ZXh0dXJlUHJvcGVydGllcy5fX2ltYWdlX193ZWJnbFRleHR1cmVDdWJlICk7XG5cbiAgICBcdFx0XHRcdF9nbC5waXhlbFN0b3JlaSggX2dsLlVOUEFDS19GTElQX1lfV0VCR0wsIHRleHR1cmUuZmxpcFkgKTtcblxuICAgIFx0XHRcdFx0dmFyIGlzQ29tcHJlc3NlZCA9ICh0ZXh0dXJlICYmIHRleHR1cmUuaXNDb21wcmVzc2VkVGV4dHVyZSk7XG4gICAgXHRcdFx0XHR2YXIgaXNEYXRhVGV4dHVyZSA9ICh0ZXh0dXJlLmltYWdlWyAwIF0gJiYgdGV4dHVyZS5pbWFnZVsgMCBdLmlzRGF0YVRleHR1cmUpO1xuXG4gICAgXHRcdFx0XHR2YXIgY3ViZUltYWdlID0gW107XG5cbiAgICBcdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IDY7IGkgKysgKSB7XG5cbiAgICBcdFx0XHRcdFx0aWYgKCAhIGlzQ29tcHJlc3NlZCAmJiAhIGlzRGF0YVRleHR1cmUgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHRjdWJlSW1hZ2VbIGkgXSA9IGNsYW1wVG9NYXhTaXplKCB0ZXh0dXJlLmltYWdlWyBpIF0sIGNhcGFiaWxpdGllcy5tYXhDdWJlbWFwU2l6ZSApO1xuXG4gICAgXHRcdFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdFx0XHRjdWJlSW1hZ2VbIGkgXSA9IGlzRGF0YVRleHR1cmUgPyB0ZXh0dXJlLmltYWdlWyBpIF0uaW1hZ2UgOiB0ZXh0dXJlLmltYWdlWyBpIF07XG5cbiAgICBcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdHZhciBpbWFnZSA9IGN1YmVJbWFnZVsgMCBdLFxuICAgIFx0XHRcdFx0aXNQb3dlck9mVHdvSW1hZ2UgPSBpc1Bvd2VyT2ZUd28oIGltYWdlICksXG4gICAgXHRcdFx0XHRnbEZvcm1hdCA9IHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlLmZvcm1hdCApLFxuICAgIFx0XHRcdFx0Z2xUeXBlID0gcGFyYW1UaHJlZVRvR0woIHRleHR1cmUudHlwZSApO1xuXG4gICAgXHRcdFx0XHRzZXRUZXh0dXJlUGFyYW1ldGVycyggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIHRleHR1cmUsIGlzUG93ZXJPZlR3b0ltYWdlICk7XG5cbiAgICBcdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IDY7IGkgKysgKSB7XG5cbiAgICBcdFx0XHRcdFx0aWYgKCAhIGlzQ29tcHJlc3NlZCApIHtcblxuICAgIFx0XHRcdFx0XHRcdGlmICggaXNEYXRhVGV4dHVyZSApIHtcblxuICAgIFx0XHRcdFx0XHRcdFx0c3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGksIDAsIGdsRm9ybWF0LCBjdWJlSW1hZ2VbIGkgXS53aWR0aCwgY3ViZUltYWdlWyBpIF0uaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBjdWJlSW1hZ2VbIGkgXS5kYXRhICk7XG5cbiAgICBcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRcdFx0XHRzdGF0ZS50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSwgMCwgZ2xGb3JtYXQsIGdsRm9ybWF0LCBnbFR5cGUsIGN1YmVJbWFnZVsgaSBdICk7XG5cbiAgICBcdFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0XHRcdHZhciBtaXBtYXAsIG1pcG1hcHMgPSBjdWJlSW1hZ2VbIGkgXS5taXBtYXBzO1xuXG4gICAgXHRcdFx0XHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IG1pcG1hcHMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHRcdG1pcG1hcCA9IG1pcG1hcHNbIGogXTtcblxuICAgIFx0XHRcdFx0XHRcdFx0aWYgKCB0ZXh0dXJlLmZvcm1hdCAhPT0gUkdCQUZvcm1hdCAmJiB0ZXh0dXJlLmZvcm1hdCAhPT0gUkdCRm9ybWF0ICkge1xuXG4gICAgXHRcdFx0XHRcdFx0XHRcdGlmICggc3RhdGUuZ2V0Q29tcHJlc3NlZFRleHR1cmVGb3JtYXRzKCkuaW5kZXhPZiggZ2xGb3JtYXQgKSA+IC0gMSApIHtcblxuICAgIFx0XHRcdFx0XHRcdFx0XHRcdHN0YXRlLmNvbXByZXNzZWRUZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSwgaiwgZ2xGb3JtYXQsIG1pcG1hcC53aWR0aCwgbWlwbWFwLmhlaWdodCwgMCwgbWlwbWFwLmRhdGEgKTtcblxuICAgIFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCBcIlRIUkVFLldlYkdMUmVuZGVyZXI6IEF0dGVtcHQgdG8gbG9hZCB1bnN1cHBvcnRlZCBjb21wcmVzc2VkIHRleHR1cmUgZm9ybWF0IGluIC5zZXRUZXh0dXJlQ3ViZSgpXCIgKTtcblxuICAgIFx0XHRcdFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdFx0XHRcdFx0c3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGksIGosIGdsRm9ybWF0LCBtaXBtYXAud2lkdGgsIG1pcG1hcC5oZWlnaHQsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIG1pcG1hcC5kYXRhICk7XG5cbiAgICBcdFx0XHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0aWYgKCB0ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyAmJiBpc1Bvd2VyT2ZUd29JbWFnZSApIHtcblxuICAgIFx0XHRcdFx0XHRfZ2wuZ2VuZXJhdGVNaXBtYXAoIF9nbC5URVhUVVJFX0NVQkVfTUFQICk7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0dGV4dHVyZVByb3BlcnRpZXMuX192ZXJzaW9uID0gdGV4dHVyZS52ZXJzaW9uO1xuXG4gICAgXHRcdFx0XHRpZiAoIHRleHR1cmUub25VcGRhdGUgKSB0ZXh0dXJlLm9uVXBkYXRlKCB0ZXh0dXJlICk7XG5cbiAgICBcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRzdGF0ZS5hY3RpdmVUZXh0dXJlKCBfZ2wuVEVYVFVSRTAgKyBzbG90ICk7XG4gICAgXHRcdFx0XHRzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIHRleHR1cmVQcm9wZXJ0aWVzLl9faW1hZ2VfX3dlYmdsVGV4dHVyZUN1YmUgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdH1cblxuICAgIFx0ZnVuY3Rpb24gc2V0VGV4dHVyZUN1YmVEeW5hbWljKCB0ZXh0dXJlLCBzbG90ICkge1xuXG4gICAgXHRcdHN0YXRlLmFjdGl2ZVRleHR1cmUoIF9nbC5URVhUVVJFMCArIHNsb3QgKTtcbiAgICBcdFx0c3RhdGUuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFX0NVQkVfTUFQLCBwcm9wZXJ0aWVzLmdldCggdGV4dHVyZSApLl9fd2ViZ2xUZXh0dXJlICk7XG5cbiAgICBcdH1cblxuICAgIFx0ZnVuY3Rpb24gc2V0VGV4dHVyZVBhcmFtZXRlcnMoIHRleHR1cmVUeXBlLCB0ZXh0dXJlLCBpc1Bvd2VyT2ZUd29JbWFnZSApIHtcblxuICAgIFx0XHR2YXIgZXh0ZW5zaW9uO1xuXG4gICAgXHRcdGlmICggaXNQb3dlck9mVHdvSW1hZ2UgKSB7XG5cbiAgICBcdFx0XHRfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX1dSQVBfUywgcGFyYW1UaHJlZVRvR0woIHRleHR1cmUud3JhcFMgKSApO1xuICAgIFx0XHRcdF9nbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfV1JBUF9ULCBwYXJhbVRocmVlVG9HTCggdGV4dHVyZS53cmFwVCApICk7XG5cbiAgICBcdFx0XHRfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX01BR19GSUxURVIsIHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlLm1hZ0ZpbHRlciApICk7XG4gICAgXHRcdFx0X2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBwYXJhbVRocmVlVG9HTCggdGV4dHVyZS5taW5GaWx0ZXIgKSApO1xuXG4gICAgXHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX1dSQVBfUywgX2dsLkNMQU1QX1RPX0VER0UgKTtcbiAgICBcdFx0XHRfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX1dSQVBfVCwgX2dsLkNMQU1QX1RPX0VER0UgKTtcblxuICAgIFx0XHRcdGlmICggdGV4dHVyZS53cmFwUyAhPT0gQ2xhbXBUb0VkZ2VXcmFwcGluZyB8fCB0ZXh0dXJlLndyYXBUICE9PSBDbGFtcFRvRWRnZVdyYXBwaW5nICkge1xuXG4gICAgXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBUZXh0dXJlIGlzIG5vdCBwb3dlciBvZiB0d28uIFRleHR1cmUud3JhcFMgYW5kIFRleHR1cmUud3JhcFQgc2hvdWxkIGJlIHNldCB0byBUSFJFRS5DbGFtcFRvRWRnZVdyYXBwaW5nLicsIHRleHR1cmUgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdF9nbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZmlsdGVyRmFsbGJhY2soIHRleHR1cmUubWFnRmlsdGVyICkgKTtcbiAgICBcdFx0XHRfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX01JTl9GSUxURVIsIGZpbHRlckZhbGxiYWNrKCB0ZXh0dXJlLm1pbkZpbHRlciApICk7XG5cbiAgICBcdFx0XHRpZiAoIHRleHR1cmUubWluRmlsdGVyICE9PSBOZWFyZXN0RmlsdGVyICYmIHRleHR1cmUubWluRmlsdGVyICE9PSBMaW5lYXJGaWx0ZXIgKSB7XG5cbiAgICBcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IFRleHR1cmUgaXMgbm90IHBvd2VyIG9mIHR3by4gVGV4dHVyZS5taW5GaWx0ZXIgc2hvdWxkIGJlIHNldCB0byBUSFJFRS5OZWFyZXN0RmlsdGVyIG9yIFRIUkVFLkxpbmVhckZpbHRlci4nLCB0ZXh0dXJlICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJyApO1xuXG4gICAgXHRcdGlmICggZXh0ZW5zaW9uICkge1xuXG4gICAgXHRcdFx0aWYgKCB0ZXh0dXJlLnR5cGUgPT09IEZsb2F0VHlwZSAmJiBleHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2Zsb2F0X2xpbmVhcicgKSA9PT0gbnVsbCApIHJldHVybjtcbiAgICBcdFx0XHRpZiAoIHRleHR1cmUudHlwZSA9PT0gSGFsZkZsb2F0VHlwZSAmJiBleHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2hhbGZfZmxvYXRfbGluZWFyJyApID09PSBudWxsICkgcmV0dXJuO1xuXG4gICAgXHRcdFx0aWYgKCB0ZXh0dXJlLmFuaXNvdHJvcHkgPiAxIHx8IHByb3BlcnRpZXMuZ2V0KCB0ZXh0dXJlICkuX19jdXJyZW50QW5pc290cm9weSApIHtcblxuICAgIFx0XHRcdFx0X2dsLnRleFBhcmFtZXRlcmYoIHRleHR1cmVUeXBlLCBleHRlbnNpb24uVEVYVFVSRV9NQVhfQU5JU09UUk9QWV9FWFQsIE1hdGgubWluKCB0ZXh0dXJlLmFuaXNvdHJvcHksIGNhcGFiaWxpdGllcy5nZXRNYXhBbmlzb3Ryb3B5KCkgKSApO1xuICAgIFx0XHRcdFx0cHJvcGVydGllcy5nZXQoIHRleHR1cmUgKS5fX2N1cnJlbnRBbmlzb3Ryb3B5ID0gdGV4dHVyZS5hbmlzb3Ryb3B5O1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0fVxuXG4gICAgXHRmdW5jdGlvbiB1cGxvYWRUZXh0dXJlKCB0ZXh0dXJlUHJvcGVydGllcywgdGV4dHVyZSwgc2xvdCApIHtcblxuICAgIFx0XHRpZiAoIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xJbml0ID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHR0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsSW5pdCA9IHRydWU7XG5cbiAgICBcdFx0XHR0ZXh0dXJlLmFkZEV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25UZXh0dXJlRGlzcG9zZSApO1xuXG4gICAgXHRcdFx0dGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgPSBfZ2wuY3JlYXRlVGV4dHVyZSgpO1xuXG4gICAgXHRcdFx0X2luZm9NZW1vcnkudGV4dHVyZXMgKys7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHN0YXRlLmFjdGl2ZVRleHR1cmUoIF9nbC5URVhUVVJFMCArIHNsb3QgKTtcbiAgICBcdFx0c3RhdGUuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFXzJELCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSApO1xuXG4gICAgXHRcdF9nbC5waXhlbFN0b3JlaSggX2dsLlVOUEFDS19GTElQX1lfV0VCR0wsIHRleHR1cmUuZmxpcFkgKTtcbiAgICBcdFx0X2dsLnBpeGVsU3RvcmVpKCBfZ2wuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCB0ZXh0dXJlLnByZW11bHRpcGx5QWxwaGEgKTtcbiAgICBcdFx0X2dsLnBpeGVsU3RvcmVpKCBfZ2wuVU5QQUNLX0FMSUdOTUVOVCwgdGV4dHVyZS51bnBhY2tBbGlnbm1lbnQgKTtcblxuICAgIFx0XHR2YXIgaW1hZ2UgPSBjbGFtcFRvTWF4U2l6ZSggdGV4dHVyZS5pbWFnZSwgY2FwYWJpbGl0aWVzLm1heFRleHR1cmVTaXplICk7XG5cbiAgICBcdFx0aWYgKCB0ZXh0dXJlTmVlZHNQb3dlck9mVHdvKCB0ZXh0dXJlICkgJiYgaXNQb3dlck9mVHdvKCBpbWFnZSApID09PSBmYWxzZSApIHtcblxuICAgIFx0XHRcdGltYWdlID0gbWFrZVBvd2VyT2ZUd28oIGltYWdlICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHZhciBpc1Bvd2VyT2ZUd29JbWFnZSA9IGlzUG93ZXJPZlR3byggaW1hZ2UgKSxcbiAgICBcdFx0Z2xGb3JtYXQgPSBwYXJhbVRocmVlVG9HTCggdGV4dHVyZS5mb3JtYXQgKSxcbiAgICBcdFx0Z2xUeXBlID0gcGFyYW1UaHJlZVRvR0woIHRleHR1cmUudHlwZSApO1xuXG4gICAgXHRcdHNldFRleHR1cmVQYXJhbWV0ZXJzKCBfZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSwgaXNQb3dlck9mVHdvSW1hZ2UgKTtcblxuICAgIFx0XHR2YXIgbWlwbWFwLCBtaXBtYXBzID0gdGV4dHVyZS5taXBtYXBzO1xuXG4gICAgXHRcdGlmICggKHRleHR1cmUgJiYgdGV4dHVyZS5pc0RlcHRoVGV4dHVyZSkgKSB7XG5cbiAgICBcdFx0XHQvLyBwb3B1bGF0ZSBkZXB0aCB0ZXh0dXJlIHdpdGggZHVtbXkgZGF0YVxuXG4gICAgXHRcdFx0dmFyIGludGVybmFsRm9ybWF0ID0gX2dsLkRFUFRIX0NPTVBPTkVOVDtcblxuICAgIFx0XHRcdGlmICggdGV4dHVyZS50eXBlID09PSBGbG9hdFR5cGUgKSB7XG5cbiAgICBcdFx0XHRcdGlmICggIV9pc1dlYkdMMiApIHRocm93IG5ldyBFcnJvcignRmxvYXQgRGVwdGggVGV4dHVyZSBvbmx5IHN1cHBvcnRlZCBpbiBXZWJHTDIuMCcpO1xuICAgIFx0XHRcdFx0aW50ZXJuYWxGb3JtYXQgPSBfZ2wuREVQVEhfQ09NUE9ORU5UMzJGO1xuXG4gICAgXHRcdFx0fSBlbHNlIGlmICggX2lzV2ViR0wyICkge1xuXG4gICAgXHRcdFx0XHQvLyBXZWJHTCAyLjAgcmVxdWlyZXMgc2lnbmVkIGludGVybmFsZm9ybWF0IGZvciBnbFRleEltYWdlMkRcbiAgICBcdFx0XHRcdGludGVybmFsRm9ybWF0ID0gX2dsLkRFUFRIX0NPTVBPTkVOVDE2O1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0Ly8gRGVwdGggc3RlbmNpbCB0ZXh0dXJlcyBuZWVkIHRoZSBERVBUSF9TVEVOQ0lMIGludGVybmFsIGZvcm1hdFxuICAgIFx0XHRcdC8vIChodHRwczovL3d3dy5raHJvbm9zLm9yZy9yZWdpc3RyeS93ZWJnbC9leHRlbnNpb25zL1dFQkdMX2RlcHRoX3RleHR1cmUvKVxuICAgIFx0XHRcdGlmICggdGV4dHVyZS5mb3JtYXQgPT09IERlcHRoU3RlbmNpbEZvcm1hdCApIHtcblxuICAgIFx0XHRcdFx0aW50ZXJuYWxGb3JtYXQgPSBfZ2wuREVQVEhfU1RFTkNJTDtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCAwLCBpbnRlcm5hbEZvcm1hdCwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgbnVsbCApO1xuXG4gICAgXHRcdH0gZWxzZSBpZiAoICh0ZXh0dXJlICYmIHRleHR1cmUuaXNEYXRhVGV4dHVyZSkgKSB7XG5cbiAgICBcdFx0XHQvLyB1c2UgbWFudWFsbHkgY3JlYXRlZCBtaXBtYXBzIGlmIGF2YWlsYWJsZVxuICAgIFx0XHRcdC8vIGlmIHRoZXJlIGFyZSBubyBtYW51YWwgbWlwbWFwc1xuICAgIFx0XHRcdC8vIHNldCAwIGxldmVsIG1pcG1hcCBhbmQgdGhlbiB1c2UgR0wgdG8gZ2VuZXJhdGUgb3RoZXIgbWlwbWFwIGxldmVsc1xuXG4gICAgXHRcdFx0aWYgKCBtaXBtYXBzLmxlbmd0aCA+IDAgJiYgaXNQb3dlck9mVHdvSW1hZ2UgKSB7XG5cbiAgICBcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBtaXBtYXBzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgXHRcdFx0XHRcdG1pcG1hcCA9IG1pcG1hcHNbIGkgXTtcbiAgICBcdFx0XHRcdFx0c3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfMkQsIGksIGdsRm9ybWF0LCBtaXBtYXAud2lkdGgsIG1pcG1hcC5oZWlnaHQsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIG1pcG1hcC5kYXRhICk7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0dGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcblxuICAgIFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCAwLCBnbEZvcm1hdCwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgaW1hZ2UuZGF0YSApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH0gZWxzZSBpZiAoICh0ZXh0dXJlICYmIHRleHR1cmUuaXNDb21wcmVzc2VkVGV4dHVyZSkgKSB7XG5cbiAgICBcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gbWlwbWFwcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgIFx0XHRcdFx0bWlwbWFwID0gbWlwbWFwc1sgaSBdO1xuXG4gICAgXHRcdFx0XHRpZiAoIHRleHR1cmUuZm9ybWF0ICE9PSBSR0JBRm9ybWF0ICYmIHRleHR1cmUuZm9ybWF0ICE9PSBSR0JGb3JtYXQgKSB7XG5cbiAgICBcdFx0XHRcdFx0aWYgKCBzdGF0ZS5nZXRDb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMoKS5pbmRleE9mKCBnbEZvcm1hdCApID4gLSAxICkge1xuXG4gICAgXHRcdFx0XHRcdFx0c3RhdGUuY29tcHJlc3NlZFRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCBpLCBnbEZvcm1hdCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCAwLCBtaXBtYXAuZGF0YSApO1xuXG4gICAgXHRcdFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oIFwiVEhSRUUuV2ViR0xSZW5kZXJlcjogQXR0ZW1wdCB0byBsb2FkIHVuc3VwcG9ydGVkIGNvbXByZXNzZWQgdGV4dHVyZSBmb3JtYXQgaW4gLnVwbG9hZFRleHR1cmUoKVwiICk7XG5cbiAgICBcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRcdHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCBpLCBnbEZvcm1hdCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBtaXBtYXAuZGF0YSApO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdC8vIHJlZ3VsYXIgVGV4dHVyZSAoaW1hZ2UsIHZpZGVvLCBjYW52YXMpXG5cbiAgICBcdFx0XHQvLyB1c2UgbWFudWFsbHkgY3JlYXRlZCBtaXBtYXBzIGlmIGF2YWlsYWJsZVxuICAgIFx0XHRcdC8vIGlmIHRoZXJlIGFyZSBubyBtYW51YWwgbWlwbWFwc1xuICAgIFx0XHRcdC8vIHNldCAwIGxldmVsIG1pcG1hcCBhbmQgdGhlbiB1c2UgR0wgdG8gZ2VuZXJhdGUgb3RoZXIgbWlwbWFwIGxldmVsc1xuXG4gICAgXHRcdFx0aWYgKCBtaXBtYXBzLmxlbmd0aCA+IDAgJiYgaXNQb3dlck9mVHdvSW1hZ2UgKSB7XG5cbiAgICBcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBtaXBtYXBzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgXHRcdFx0XHRcdG1pcG1hcCA9IG1pcG1hcHNbIGkgXTtcbiAgICBcdFx0XHRcdFx0c3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfMkQsIGksIGdsRm9ybWF0LCBnbEZvcm1hdCwgZ2xUeXBlLCBtaXBtYXAgKTtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHR0ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuXG4gICAgXHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0c3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfMkQsIDAsIGdsRm9ybWF0LCBnbEZvcm1hdCwgZ2xUeXBlLCBpbWFnZSApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoIHRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzICYmIGlzUG93ZXJPZlR3b0ltYWdlICkgX2dsLmdlbmVyYXRlTWlwbWFwKCBfZ2wuVEVYVFVSRV8yRCApO1xuXG4gICAgXHRcdHRleHR1cmVQcm9wZXJ0aWVzLl9fdmVyc2lvbiA9IHRleHR1cmUudmVyc2lvbjtcblxuICAgIFx0XHRpZiAoIHRleHR1cmUub25VcGRhdGUgKSB0ZXh0dXJlLm9uVXBkYXRlKCB0ZXh0dXJlICk7XG5cbiAgICBcdH1cblxuICAgIFx0Ly8gUmVuZGVyIHRhcmdldHNcblxuICAgIFx0Ly8gU2V0dXAgc3RvcmFnZSBmb3IgdGFyZ2V0IHRleHR1cmUgYW5kIGJpbmQgaXQgdG8gY29ycmVjdCBmcmFtZWJ1ZmZlclxuICAgIFx0ZnVuY3Rpb24gc2V0dXBGcmFtZUJ1ZmZlclRleHR1cmUoIGZyYW1lYnVmZmVyLCByZW5kZXJUYXJnZXQsIGF0dGFjaG1lbnQsIHRleHR1cmVUYXJnZXQgKSB7XG5cbiAgICBcdFx0dmFyIGdsRm9ybWF0ID0gcGFyYW1UaHJlZVRvR0woIHJlbmRlclRhcmdldC50ZXh0dXJlLmZvcm1hdCApO1xuICAgIFx0XHR2YXIgZ2xUeXBlID0gcGFyYW1UaHJlZVRvR0woIHJlbmRlclRhcmdldC50ZXh0dXJlLnR5cGUgKTtcbiAgICBcdFx0c3RhdGUudGV4SW1hZ2UyRCggdGV4dHVyZVRhcmdldCwgMCwgZ2xGb3JtYXQsIHJlbmRlclRhcmdldC53aWR0aCwgcmVuZGVyVGFyZ2V0LmhlaWdodCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgbnVsbCApO1xuICAgIFx0XHRfZ2wuYmluZEZyYW1lYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyICk7XG4gICAgXHRcdF9nbC5mcmFtZWJ1ZmZlclRleHR1cmUyRCggX2dsLkZSQU1FQlVGRkVSLCBhdHRhY2htZW50LCB0ZXh0dXJlVGFyZ2V0LCBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0LnRleHR1cmUgKS5fX3dlYmdsVGV4dHVyZSwgMCApO1xuICAgIFx0XHRfZ2wuYmluZEZyYW1lYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIG51bGwgKTtcblxuICAgIFx0fVxuXG4gICAgXHQvLyBTZXR1cCBzdG9yYWdlIGZvciBpbnRlcm5hbCBkZXB0aC9zdGVuY2lsIGJ1ZmZlcnMgYW5kIGJpbmQgdG8gY29ycmVjdCBmcmFtZWJ1ZmZlclxuICAgIFx0ZnVuY3Rpb24gc2V0dXBSZW5kZXJCdWZmZXJTdG9yYWdlKCByZW5kZXJidWZmZXIsIHJlbmRlclRhcmdldCApIHtcblxuICAgIFx0XHRfZ2wuYmluZFJlbmRlcmJ1ZmZlciggX2dsLlJFTkRFUkJVRkZFUiwgcmVuZGVyYnVmZmVyICk7XG5cbiAgICBcdFx0aWYgKCByZW5kZXJUYXJnZXQuZGVwdGhCdWZmZXIgJiYgISByZW5kZXJUYXJnZXQuc3RlbmNpbEJ1ZmZlciApIHtcblxuICAgIFx0XHRcdF9nbC5yZW5kZXJidWZmZXJTdG9yYWdlKCBfZ2wuUkVOREVSQlVGRkVSLCBfZ2wuREVQVEhfQ09NUE9ORU5UMTYsIHJlbmRlclRhcmdldC53aWR0aCwgcmVuZGVyVGFyZ2V0LmhlaWdodCApO1xuICAgIFx0XHRcdF9nbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBfZ2wuREVQVEhfQVRUQUNITUVOVCwgX2dsLlJFTkRFUkJVRkZFUiwgcmVuZGVyYnVmZmVyICk7XG5cbiAgICBcdFx0fSBlbHNlIGlmICggcmVuZGVyVGFyZ2V0LmRlcHRoQnVmZmVyICYmIHJlbmRlclRhcmdldC5zdGVuY2lsQnVmZmVyICkge1xuXG4gICAgXHRcdFx0X2dsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoIF9nbC5SRU5ERVJCVUZGRVIsIF9nbC5ERVBUSF9TVEVOQ0lMLCByZW5kZXJUYXJnZXQud2lkdGgsIHJlbmRlclRhcmdldC5oZWlnaHQgKTtcbiAgICBcdFx0XHRfZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgX2dsLkRFUFRIX1NURU5DSUxfQVRUQUNITUVOVCwgX2dsLlJFTkRFUkJVRkZFUiwgcmVuZGVyYnVmZmVyICk7XG5cbiAgICBcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdC8vIEZJWE1FOiBXZSBkb24ndCBzdXBwb3J0ICFkZXB0aCAhc3RlbmNpbFxuICAgIFx0XHRcdF9nbC5yZW5kZXJidWZmZXJTdG9yYWdlKCBfZ2wuUkVOREVSQlVGRkVSLCBfZ2wuUkdCQTQsIHJlbmRlclRhcmdldC53aWR0aCwgcmVuZGVyVGFyZ2V0LmhlaWdodCApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRfZ2wuYmluZFJlbmRlcmJ1ZmZlciggX2dsLlJFTkRFUkJVRkZFUiwgbnVsbCApO1xuXG4gICAgXHR9XG5cbiAgICBcdC8vIFNldHVwIHJlc291cmNlcyBmb3IgYSBEZXB0aCBUZXh0dXJlIGZvciBhIEZCTyAobmVlZHMgYW4gZXh0ZW5zaW9uKVxuICAgIFx0ZnVuY3Rpb24gc2V0dXBEZXB0aFRleHR1cmUoIGZyYW1lYnVmZmVyLCByZW5kZXJUYXJnZXQgKSB7XG5cbiAgICBcdFx0dmFyIGlzQ3ViZSA9ICggKHJlbmRlclRhcmdldCAmJiByZW5kZXJUYXJnZXQuaXNXZWJHTFJlbmRlclRhcmdldEN1YmUpICk7XG4gICAgXHRcdGlmICggaXNDdWJlICkgdGhyb3cgbmV3IEVycm9yKCdEZXB0aCBUZXh0dXJlIHdpdGggY3ViZSByZW5kZXIgdGFyZ2V0cyBpcyBub3Qgc3VwcG9ydGVkIScpO1xuXG4gICAgXHRcdF9nbC5iaW5kRnJhbWVidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgZnJhbWVidWZmZXIgKTtcblxuICAgIFx0XHRpZiAoICEoIChyZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlICYmIHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUuaXNEZXB0aFRleHR1cmUpICkgKSB7XG5cbiAgICBcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ3JlbmRlclRhcmdldC5kZXB0aFRleHR1cmUgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBUSFJFRS5EZXB0aFRleHR1cmUnKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0Ly8gdXBsb2FkIGFuIGVtcHR5IGRlcHRoIHRleHR1cmUgd2l0aCBmcmFtZWJ1ZmZlciBzaXplXG4gICAgXHRcdGlmICggIXByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlICkuX193ZWJnbFRleHR1cmUgfHxcbiAgICBcdFx0XHRcdHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUuaW1hZ2Uud2lkdGggIT09IHJlbmRlclRhcmdldC53aWR0aCB8fFxuICAgIFx0XHRcdFx0cmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZS5pbWFnZS5oZWlnaHQgIT09IHJlbmRlclRhcmdldC5oZWlnaHQgKSB7XG4gICAgXHRcdFx0cmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZS5pbWFnZS53aWR0aCA9IHJlbmRlclRhcmdldC53aWR0aDtcbiAgICBcdFx0XHRyZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlLmltYWdlLmhlaWdodCA9IHJlbmRlclRhcmdldC5oZWlnaHQ7XG4gICAgXHRcdFx0cmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgXHRcdH1cblxuICAgIFx0XHRzZXRUZXh0dXJlMkQoIHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUsIDAgKTtcblxuICAgIFx0XHR2YXIgd2ViZ2xEZXB0aFRleHR1cmUgPSBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZSApLl9fd2ViZ2xUZXh0dXJlO1xuXG4gICAgXHRcdGlmICggcmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZS5mb3JtYXQgPT09IERlcHRoRm9ybWF0ICkge1xuXG4gICAgXHRcdFx0X2dsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKCBfZ2wuRlJBTUVCVUZGRVIsIF9nbC5ERVBUSF9BVFRBQ0hNRU5ULCBfZ2wuVEVYVFVSRV8yRCwgd2ViZ2xEZXB0aFRleHR1cmUsIDAgKTtcblxuICAgIFx0XHR9IGVsc2UgaWYgKCByZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlLmZvcm1hdCA9PT0gRGVwdGhTdGVuY2lsRm9ybWF0ICkge1xuXG4gICAgXHRcdFx0X2dsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKCBfZ2wuRlJBTUVCVUZGRVIsIF9nbC5ERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQsIF9nbC5URVhUVVJFXzJELCB3ZWJnbERlcHRoVGV4dHVyZSwgMCApO1xuXG4gICAgXHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZGVwdGhUZXh0dXJlIGZvcm1hdCcpXG5cbiAgICBcdFx0fVxuXG4gICAgXHR9XG5cbiAgICBcdC8vIFNldHVwIEdMIHJlc291cmNlcyBmb3IgYSBub24tdGV4dHVyZSBkZXB0aCBidWZmZXJcbiAgICBcdGZ1bmN0aW9uIHNldHVwRGVwdGhSZW5kZXJidWZmZXIoIHJlbmRlclRhcmdldCApIHtcblxuICAgIFx0XHR2YXIgcmVuZGVyVGFyZ2V0UHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQgKTtcblxuICAgIFx0XHR2YXIgaXNDdWJlID0gKCAocmVuZGVyVGFyZ2V0ICYmIHJlbmRlclRhcmdldC5pc1dlYkdMUmVuZGVyVGFyZ2V0Q3ViZSkgKTtcblxuICAgIFx0XHRpZiAoIHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUgKSB7XG5cbiAgICBcdFx0XHRpZiAoIGlzQ3ViZSApIHRocm93IG5ldyBFcnJvcigndGFyZ2V0LmRlcHRoVGV4dHVyZSBub3Qgc3VwcG9ydGVkIGluIEN1YmUgcmVuZGVyIHRhcmdldHMnKTtcblxuICAgIFx0XHRcdHNldHVwRGVwdGhUZXh0dXJlKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlciwgcmVuZGVyVGFyZ2V0ICk7XG5cbiAgICBcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdGlmICggaXNDdWJlICkge1xuXG4gICAgXHRcdFx0XHRyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xEZXB0aGJ1ZmZlciA9IFtdO1xuXG4gICAgXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpICsrICkge1xuXG4gICAgXHRcdFx0XHRcdF9nbC5iaW5kRnJhbWVidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXJbIGkgXSApO1xuICAgIFx0XHRcdFx0XHRyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xEZXB0aGJ1ZmZlclsgaSBdID0gX2dsLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpO1xuICAgIFx0XHRcdFx0XHRzZXR1cFJlbmRlckJ1ZmZlclN0b3JhZ2UoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbERlcHRoYnVmZmVyWyBpIF0sIHJlbmRlclRhcmdldCApO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRfZ2wuYmluZEZyYW1lYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyICk7XG4gICAgXHRcdFx0XHRyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xEZXB0aGJ1ZmZlciA9IF9nbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcbiAgICBcdFx0XHRcdHNldHVwUmVuZGVyQnVmZmVyU3RvcmFnZSggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRGVwdGhidWZmZXIsIHJlbmRlclRhcmdldCApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHRfZ2wuYmluZEZyYW1lYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIG51bGwgKTtcblxuICAgIFx0fVxuXG4gICAgXHQvLyBTZXQgdXAgR0wgcmVzb3VyY2VzIGZvciB0aGUgcmVuZGVyIHRhcmdldFxuICAgIFx0ZnVuY3Rpb24gc2V0dXBSZW5kZXJUYXJnZXQoIHJlbmRlclRhcmdldCApIHtcblxuICAgIFx0XHR2YXIgcmVuZGVyVGFyZ2V0UHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQgKTtcbiAgICBcdFx0dmFyIHRleHR1cmVQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldC50ZXh0dXJlICk7XG5cbiAgICBcdFx0cmVuZGVyVGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25SZW5kZXJUYXJnZXREaXNwb3NlICk7XG5cbiAgICBcdFx0dGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgPSBfZ2wuY3JlYXRlVGV4dHVyZSgpO1xuXG4gICAgXHRcdF9pbmZvTWVtb3J5LnRleHR1cmVzICsrO1xuXG4gICAgXHRcdHZhciBpc0N1YmUgPSAoIChyZW5kZXJUYXJnZXQgJiYgcmVuZGVyVGFyZ2V0LmlzV2ViR0xSZW5kZXJUYXJnZXRDdWJlKSApO1xuICAgIFx0XHR2YXIgaXNUYXJnZXRQb3dlck9mVHdvID0gaXNQb3dlck9mVHdvKCByZW5kZXJUYXJnZXQgKTtcblxuICAgIFx0XHQvLyBTZXR1cCBmcmFtZWJ1ZmZlclxuXG4gICAgXHRcdGlmICggaXNDdWJlICkge1xuXG4gICAgXHRcdFx0cmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXIgPSBbXTtcblxuICAgIFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IDY7IGkgKysgKSB7XG5cbiAgICBcdFx0XHRcdHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyWyBpIF0gPSBfZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0cmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXIgPSBfZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0Ly8gU2V0dXAgY29sb3IgYnVmZmVyXG5cbiAgICBcdFx0aWYgKCBpc0N1YmUgKSB7XG5cbiAgICBcdFx0XHRzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlICk7XG4gICAgXHRcdFx0c2V0VGV4dHVyZVBhcmFtZXRlcnMoIF9nbC5URVhUVVJFX0NVQkVfTUFQLCByZW5kZXJUYXJnZXQudGV4dHVyZSwgaXNUYXJnZXRQb3dlck9mVHdvICk7XG5cbiAgICBcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpICsrICkge1xuXG4gICAgXHRcdFx0XHRzZXR1cEZyYW1lQnVmZmVyVGV4dHVyZSggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXJbIGkgXSwgcmVuZGVyVGFyZ2V0LCBfZ2wuQ09MT1JfQVRUQUNITUVOVDAsIF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRpZiAoIHJlbmRlclRhcmdldC50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyAmJiBpc1RhcmdldFBvd2VyT2ZUd28gKSBfZ2wuZ2VuZXJhdGVNaXBtYXAoIF9nbC5URVhUVVJFX0NVQkVfTUFQICk7XG4gICAgXHRcdFx0c3RhdGUuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFX0NVQkVfTUFQLCBudWxsICk7XG5cbiAgICBcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgKTtcbiAgICBcdFx0XHRzZXRUZXh0dXJlUGFyYW1ldGVycyggX2dsLlRFWFRVUkVfMkQsIHJlbmRlclRhcmdldC50ZXh0dXJlLCBpc1RhcmdldFBvd2VyT2ZUd28gKTtcbiAgICBcdFx0XHRzZXR1cEZyYW1lQnVmZmVyVGV4dHVyZSggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXIsIHJlbmRlclRhcmdldCwgX2dsLkNPTE9SX0FUVEFDSE1FTlQwLCBfZ2wuVEVYVFVSRV8yRCApO1xuXG4gICAgXHRcdFx0aWYgKCByZW5kZXJUYXJnZXQudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgJiYgaXNUYXJnZXRQb3dlck9mVHdvICkgX2dsLmdlbmVyYXRlTWlwbWFwKCBfZ2wuVEVYVFVSRV8yRCApO1xuICAgIFx0XHRcdHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV8yRCwgbnVsbCApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHQvLyBTZXR1cCBkZXB0aCBhbmQgc3RlbmNpbCBidWZmZXJzXG5cbiAgICBcdFx0aWYgKCByZW5kZXJUYXJnZXQuZGVwdGhCdWZmZXIgKSB7XG5cbiAgICBcdFx0XHRzZXR1cERlcHRoUmVuZGVyYnVmZmVyKCByZW5kZXJUYXJnZXQgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdH1cblxuICAgIFx0ZnVuY3Rpb24gdXBkYXRlUmVuZGVyVGFyZ2V0TWlwbWFwKCByZW5kZXJUYXJnZXQgKSB7XG5cbiAgICBcdFx0dmFyIHRleHR1cmUgPSByZW5kZXJUYXJnZXQudGV4dHVyZTtcblxuICAgIFx0XHRpZiAoIHRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzICYmIGlzUG93ZXJPZlR3byggcmVuZGVyVGFyZ2V0ICkgJiZcbiAgICBcdFx0XHRcdHRleHR1cmUubWluRmlsdGVyICE9PSBOZWFyZXN0RmlsdGVyICYmXG4gICAgXHRcdFx0XHR0ZXh0dXJlLm1pbkZpbHRlciAhPT0gTGluZWFyRmlsdGVyICkge1xuXG4gICAgXHRcdFx0dmFyIHRhcmdldCA9IChyZW5kZXJUYXJnZXQgJiYgcmVuZGVyVGFyZ2V0LmlzV2ViR0xSZW5kZXJUYXJnZXRDdWJlKSA/IF9nbC5URVhUVVJFX0NVQkVfTUFQIDogX2dsLlRFWFRVUkVfMkQ7XG4gICAgXHRcdFx0dmFyIHdlYmdsVGV4dHVyZSA9IHByb3BlcnRpZXMuZ2V0KCB0ZXh0dXJlICkuX193ZWJnbFRleHR1cmU7XG5cbiAgICBcdFx0XHRzdGF0ZS5iaW5kVGV4dHVyZSggdGFyZ2V0LCB3ZWJnbFRleHR1cmUgKTtcbiAgICBcdFx0XHRfZ2wuZ2VuZXJhdGVNaXBtYXAoIHRhcmdldCApO1xuICAgIFx0XHRcdHN0YXRlLmJpbmRUZXh0dXJlKCB0YXJnZXQsIG51bGwgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdH1cblxuICAgIFx0dGhpcy5zZXRUZXh0dXJlMkQgPSBzZXRUZXh0dXJlMkQ7XG4gICAgXHR0aGlzLnNldFRleHR1cmVDdWJlID0gc2V0VGV4dHVyZUN1YmU7XG4gICAgXHR0aGlzLnNldFRleHR1cmVDdWJlRHluYW1pYyA9IHNldFRleHR1cmVDdWJlRHluYW1pYztcbiAgICBcdHRoaXMuc2V0dXBSZW5kZXJUYXJnZXQgPSBzZXR1cFJlbmRlclRhcmdldDtcbiAgICBcdHRoaXMudXBkYXRlUmVuZGVyVGFyZ2V0TWlwbWFwID0gdXBkYXRlUmVuZGVyVGFyZ2V0TWlwbWFwO1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBmb3JkYWNpb3VzIC8gZm9yZGFjaW91cy5naXRodWIuaW9cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIFdlYkdMUHJvcGVydGllcygpIHtcblxuICAgIFx0dmFyIHByb3BlcnRpZXMgPSB7fTtcblxuICAgIFx0cmV0dXJuIHtcblxuICAgIFx0XHRnZXQ6IGZ1bmN0aW9uICggb2JqZWN0ICkge1xuXG4gICAgXHRcdFx0dmFyIHV1aWQgPSBvYmplY3QudXVpZDtcbiAgICBcdFx0XHR2YXIgbWFwID0gcHJvcGVydGllc1sgdXVpZCBdO1xuXG4gICAgXHRcdFx0aWYgKCBtYXAgPT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0bWFwID0ge307XG4gICAgXHRcdFx0XHRwcm9wZXJ0aWVzWyB1dWlkIF0gPSBtYXA7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRyZXR1cm4gbWFwO1xuXG4gICAgXHRcdH0sXG5cbiAgICBcdFx0ZGVsZXRlOiBmdW5jdGlvbiAoIG9iamVjdCApIHtcblxuICAgIFx0XHRcdGRlbGV0ZSBwcm9wZXJ0aWVzWyBvYmplY3QudXVpZCBdO1xuXG4gICAgXHRcdH0sXG5cbiAgICBcdFx0Y2xlYXI6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHRcdHByb3BlcnRpZXMgPSB7fTtcblxuICAgIFx0XHR9XG5cbiAgICBcdH07XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBXZWJHTFN0YXRlKCBnbCwgZXh0ZW5zaW9ucywgcGFyYW1UaHJlZVRvR0wgKSB7XG5cbiAgICBcdGZ1bmN0aW9uIENvbG9yQnVmZmVyKCkge1xuXG4gICAgXHRcdHZhciBsb2NrZWQgPSBmYWxzZTtcblxuICAgIFx0XHR2YXIgY29sb3IgPSBuZXcgVmVjdG9yNCgpO1xuICAgIFx0XHR2YXIgY3VycmVudENvbG9yTWFzayA9IG51bGw7XG4gICAgXHRcdHZhciBjdXJyZW50Q29sb3JDbGVhciA9IG5ldyBWZWN0b3I0KCk7XG5cbiAgICBcdFx0cmV0dXJuIHtcblxuICAgIFx0XHRcdHNldE1hc2s6IGZ1bmN0aW9uICggY29sb3JNYXNrICkge1xuXG4gICAgXHRcdFx0XHRpZiAoIGN1cnJlbnRDb2xvck1hc2sgIT09IGNvbG9yTWFzayAmJiAhIGxvY2tlZCApIHtcblxuICAgIFx0XHRcdFx0XHRnbC5jb2xvck1hc2soIGNvbG9yTWFzaywgY29sb3JNYXNrLCBjb2xvck1hc2ssIGNvbG9yTWFzayApO1xuICAgIFx0XHRcdFx0XHRjdXJyZW50Q29sb3JNYXNrID0gY29sb3JNYXNrO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9LFxuXG4gICAgXHRcdFx0c2V0TG9ja2VkOiBmdW5jdGlvbiAoIGxvY2sgKSB7XG5cbiAgICBcdFx0XHRcdGxvY2tlZCA9IGxvY2s7XG5cbiAgICBcdFx0XHR9LFxuXG4gICAgXHRcdFx0c2V0Q2xlYXI6IGZ1bmN0aW9uICggciwgZywgYiwgYSApIHtcblxuICAgIFx0XHRcdFx0Y29sb3Iuc2V0KCByLCBnLCBiLCBhICk7XG5cbiAgICBcdFx0XHRcdGlmICggY3VycmVudENvbG9yQ2xlYXIuZXF1YWxzKCBjb2xvciApID09PSBmYWxzZSApIHtcblxuICAgIFx0XHRcdFx0XHRnbC5jbGVhckNvbG9yKCByLCBnLCBiLCBhICk7XG4gICAgXHRcdFx0XHRcdGN1cnJlbnRDb2xvckNsZWFyLmNvcHkoIGNvbG9yICk7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH0sXG5cbiAgICBcdFx0XHRyZXNldDogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdFx0XHRsb2NrZWQgPSBmYWxzZTtcblxuICAgIFx0XHRcdFx0Y3VycmVudENvbG9yTWFzayA9IG51bGw7XG4gICAgXHRcdFx0XHRjdXJyZW50Q29sb3JDbGVhci5zZXQoIDAsIDAsIDAsIDEgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9O1xuXG4gICAgXHR9XG5cbiAgICBcdGZ1bmN0aW9uIERlcHRoQnVmZmVyKCkge1xuXG4gICAgXHRcdHZhciBsb2NrZWQgPSBmYWxzZTtcblxuICAgIFx0XHR2YXIgY3VycmVudERlcHRoTWFzayA9IG51bGw7XG4gICAgXHRcdHZhciBjdXJyZW50RGVwdGhGdW5jID0gbnVsbDtcbiAgICBcdFx0dmFyIGN1cnJlbnREZXB0aENsZWFyID0gbnVsbDtcblxuICAgIFx0XHRyZXR1cm4ge1xuXG4gICAgXHRcdFx0c2V0VGVzdDogZnVuY3Rpb24gKCBkZXB0aFRlc3QgKSB7XG5cbiAgICBcdFx0XHRcdGlmICggZGVwdGhUZXN0ICkge1xuXG4gICAgXHRcdFx0XHRcdGVuYWJsZSggZ2wuREVQVEhfVEVTVCApO1xuXG4gICAgXHRcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRcdGRpc2FibGUoIGdsLkRFUFRIX1RFU1QgKTtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fSxcblxuICAgIFx0XHRcdHNldE1hc2s6IGZ1bmN0aW9uICggZGVwdGhNYXNrICkge1xuXG4gICAgXHRcdFx0XHRpZiAoIGN1cnJlbnREZXB0aE1hc2sgIT09IGRlcHRoTWFzayAmJiAhIGxvY2tlZCApIHtcblxuICAgIFx0XHRcdFx0XHRnbC5kZXB0aE1hc2soIGRlcHRoTWFzayApO1xuICAgIFx0XHRcdFx0XHRjdXJyZW50RGVwdGhNYXNrID0gZGVwdGhNYXNrO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9LFxuXG4gICAgXHRcdFx0c2V0RnVuYzogZnVuY3Rpb24gKCBkZXB0aEZ1bmMgKSB7XG5cbiAgICBcdFx0XHRcdGlmICggY3VycmVudERlcHRoRnVuYyAhPT0gZGVwdGhGdW5jICkge1xuXG4gICAgXHRcdFx0XHRcdGlmICggZGVwdGhGdW5jICkge1xuXG4gICAgXHRcdFx0XHRcdFx0c3dpdGNoICggZGVwdGhGdW5jICkge1xuXG4gICAgXHRcdFx0XHRcdFx0XHRjYXNlIE5ldmVyRGVwdGg6XG5cbiAgICBcdFx0XHRcdFx0XHRcdFx0Z2wuZGVwdGhGdW5jKCBnbC5ORVZFUiApO1xuICAgIFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuICAgIFx0XHRcdFx0XHRcdFx0Y2FzZSBBbHdheXNEZXB0aDpcblxuICAgIFx0XHRcdFx0XHRcdFx0XHRnbC5kZXB0aEZ1bmMoIGdsLkFMV0FZUyApO1xuICAgIFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuICAgIFx0XHRcdFx0XHRcdFx0Y2FzZSBMZXNzRGVwdGg6XG5cbiAgICBcdFx0XHRcdFx0XHRcdFx0Z2wuZGVwdGhGdW5jKCBnbC5MRVNTICk7XG4gICAgXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG4gICAgXHRcdFx0XHRcdFx0XHRjYXNlIExlc3NFcXVhbERlcHRoOlxuXG4gICAgXHRcdFx0XHRcdFx0XHRcdGdsLmRlcHRoRnVuYyggZ2wuTEVRVUFMICk7XG4gICAgXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG4gICAgXHRcdFx0XHRcdFx0XHRjYXNlIEVxdWFsRGVwdGg6XG5cbiAgICBcdFx0XHRcdFx0XHRcdFx0Z2wuZGVwdGhGdW5jKCBnbC5FUVVBTCApO1xuICAgIFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuICAgIFx0XHRcdFx0XHRcdFx0Y2FzZSBHcmVhdGVyRXF1YWxEZXB0aDpcblxuICAgIFx0XHRcdFx0XHRcdFx0XHRnbC5kZXB0aEZ1bmMoIGdsLkdFUVVBTCApO1xuICAgIFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuICAgIFx0XHRcdFx0XHRcdFx0Y2FzZSBHcmVhdGVyRGVwdGg6XG5cbiAgICBcdFx0XHRcdFx0XHRcdFx0Z2wuZGVwdGhGdW5jKCBnbC5HUkVBVEVSICk7XG4gICAgXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG4gICAgXHRcdFx0XHRcdFx0XHRjYXNlIE5vdEVxdWFsRGVwdGg6XG5cbiAgICBcdFx0XHRcdFx0XHRcdFx0Z2wuZGVwdGhGdW5jKCBnbC5OT1RFUVVBTCApO1xuICAgIFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuICAgIFx0XHRcdFx0XHRcdFx0ZGVmYXVsdDpcblxuICAgIFx0XHRcdFx0XHRcdFx0XHRnbC5kZXB0aEZ1bmMoIGdsLkxFUVVBTCApO1xuXG4gICAgXHRcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdFx0XHRnbC5kZXB0aEZ1bmMoIGdsLkxFUVVBTCApO1xuXG4gICAgXHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0XHRjdXJyZW50RGVwdGhGdW5jID0gZGVwdGhGdW5jO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9LFxuXG4gICAgXHRcdFx0c2V0TG9ja2VkOiBmdW5jdGlvbiAoIGxvY2sgKSB7XG5cbiAgICBcdFx0XHRcdGxvY2tlZCA9IGxvY2s7XG5cbiAgICBcdFx0XHR9LFxuXG4gICAgXHRcdFx0c2V0Q2xlYXI6IGZ1bmN0aW9uICggZGVwdGggKSB7XG5cbiAgICBcdFx0XHRcdGlmICggY3VycmVudERlcHRoQ2xlYXIgIT09IGRlcHRoICkge1xuXG4gICAgXHRcdFx0XHRcdGdsLmNsZWFyRGVwdGgoIGRlcHRoICk7XG4gICAgXHRcdFx0XHRcdGN1cnJlbnREZXB0aENsZWFyID0gZGVwdGg7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH0sXG5cbiAgICBcdFx0XHRyZXNldDogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdFx0XHRsb2NrZWQgPSBmYWxzZTtcblxuICAgIFx0XHRcdFx0Y3VycmVudERlcHRoTWFzayA9IG51bGw7XG4gICAgXHRcdFx0XHRjdXJyZW50RGVwdGhGdW5jID0gbnVsbDtcbiAgICBcdFx0XHRcdGN1cnJlbnREZXB0aENsZWFyID0gbnVsbDtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9O1xuXG4gICAgXHR9XG5cbiAgICBcdGZ1bmN0aW9uIFN0ZW5jaWxCdWZmZXIoKSB7XG5cbiAgICBcdFx0dmFyIGxvY2tlZCA9IGZhbHNlO1xuXG4gICAgXHRcdHZhciBjdXJyZW50U3RlbmNpbE1hc2sgPSBudWxsO1xuICAgIFx0XHR2YXIgY3VycmVudFN0ZW5jaWxGdW5jID0gbnVsbDtcbiAgICBcdFx0dmFyIGN1cnJlbnRTdGVuY2lsUmVmID0gbnVsbDtcbiAgICBcdFx0dmFyIGN1cnJlbnRTdGVuY2lsRnVuY01hc2sgPSBudWxsO1xuICAgIFx0XHR2YXIgY3VycmVudFN0ZW5jaWxGYWlsICA9IG51bGw7XG4gICAgXHRcdHZhciBjdXJyZW50U3RlbmNpbFpGYWlsID0gbnVsbDtcbiAgICBcdFx0dmFyIGN1cnJlbnRTdGVuY2lsWlBhc3MgPSBudWxsO1xuICAgIFx0XHR2YXIgY3VycmVudFN0ZW5jaWxDbGVhciA9IG51bGw7XG5cbiAgICBcdFx0cmV0dXJuIHtcblxuICAgIFx0XHRcdHNldFRlc3Q6IGZ1bmN0aW9uICggc3RlbmNpbFRlc3QgKSB7XG5cbiAgICBcdFx0XHRcdGlmICggc3RlbmNpbFRlc3QgKSB7XG5cbiAgICBcdFx0XHRcdFx0ZW5hYmxlKCBnbC5TVEVOQ0lMX1RFU1QgKTtcblxuICAgIFx0XHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0XHRkaXNhYmxlKCBnbC5TVEVOQ0lMX1RFU1QgKTtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fSxcblxuICAgIFx0XHRcdHNldE1hc2s6IGZ1bmN0aW9uICggc3RlbmNpbE1hc2sgKSB7XG5cbiAgICBcdFx0XHRcdGlmICggY3VycmVudFN0ZW5jaWxNYXNrICE9PSBzdGVuY2lsTWFzayAmJiAhIGxvY2tlZCApIHtcblxuICAgIFx0XHRcdFx0XHRnbC5zdGVuY2lsTWFzayggc3RlbmNpbE1hc2sgKTtcbiAgICBcdFx0XHRcdFx0Y3VycmVudFN0ZW5jaWxNYXNrID0gc3RlbmNpbE1hc2s7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH0sXG5cbiAgICBcdFx0XHRzZXRGdW5jOiBmdW5jdGlvbiAoIHN0ZW5jaWxGdW5jLCBzdGVuY2lsUmVmLCBzdGVuY2lsTWFzayApIHtcblxuICAgIFx0XHRcdFx0aWYgKCBjdXJyZW50U3RlbmNpbEZ1bmMgIT09IHN0ZW5jaWxGdW5jIHx8XG4gICAgXHRcdFx0XHQgICAgIGN1cnJlbnRTdGVuY2lsUmVmIFx0IT09IHN0ZW5jaWxSZWYgXHR8fFxuICAgIFx0XHRcdFx0ICAgICBjdXJyZW50U3RlbmNpbEZ1bmNNYXNrICE9PSBzdGVuY2lsTWFzayApIHtcblxuICAgIFx0XHRcdFx0XHRnbC5zdGVuY2lsRnVuYyggc3RlbmNpbEZ1bmMsICBzdGVuY2lsUmVmLCBzdGVuY2lsTWFzayApO1xuXG4gICAgXHRcdFx0XHRcdGN1cnJlbnRTdGVuY2lsRnVuYyA9IHN0ZW5jaWxGdW5jO1xuICAgIFx0XHRcdFx0XHRjdXJyZW50U3RlbmNpbFJlZiAgPSBzdGVuY2lsUmVmO1xuICAgIFx0XHRcdFx0XHRjdXJyZW50U3RlbmNpbEZ1bmNNYXNrID0gc3RlbmNpbE1hc2s7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH0sXG5cbiAgICBcdFx0XHRzZXRPcDogZnVuY3Rpb24gKCBzdGVuY2lsRmFpbCwgc3RlbmNpbFpGYWlsLCBzdGVuY2lsWlBhc3MgKSB7XG5cbiAgICBcdFx0XHRcdGlmICggY3VycmVudFN0ZW5jaWxGYWlsXHQgIT09IHN0ZW5jaWxGYWlsIFx0fHxcbiAgICBcdFx0XHRcdCAgICAgY3VycmVudFN0ZW5jaWxaRmFpbCAhPT0gc3RlbmNpbFpGYWlsIHx8XG4gICAgXHRcdFx0XHQgICAgIGN1cnJlbnRTdGVuY2lsWlBhc3MgIT09IHN0ZW5jaWxaUGFzcyApIHtcblxuICAgIFx0XHRcdFx0XHRnbC5zdGVuY2lsT3AoIHN0ZW5jaWxGYWlsLCAgc3RlbmNpbFpGYWlsLCBzdGVuY2lsWlBhc3MgKTtcblxuICAgIFx0XHRcdFx0XHRjdXJyZW50U3RlbmNpbEZhaWwgID0gc3RlbmNpbEZhaWw7XG4gICAgXHRcdFx0XHRcdGN1cnJlbnRTdGVuY2lsWkZhaWwgPSBzdGVuY2lsWkZhaWw7XG4gICAgXHRcdFx0XHRcdGN1cnJlbnRTdGVuY2lsWlBhc3MgPSBzdGVuY2lsWlBhc3M7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH0sXG5cbiAgICBcdFx0XHRzZXRMb2NrZWQ6IGZ1bmN0aW9uICggbG9jayApIHtcblxuICAgIFx0XHRcdFx0bG9ja2VkID0gbG9jaztcblxuICAgIFx0XHRcdH0sXG5cbiAgICBcdFx0XHRzZXRDbGVhcjogZnVuY3Rpb24gKCBzdGVuY2lsICkge1xuXG4gICAgXHRcdFx0XHRpZiAoIGN1cnJlbnRTdGVuY2lsQ2xlYXIgIT09IHN0ZW5jaWwgKSB7XG5cbiAgICBcdFx0XHRcdFx0Z2wuY2xlYXJTdGVuY2lsKCBzdGVuY2lsICk7XG4gICAgXHRcdFx0XHRcdGN1cnJlbnRTdGVuY2lsQ2xlYXIgPSBzdGVuY2lsO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9LFxuXG4gICAgXHRcdFx0cmVzZXQ6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHRcdFx0bG9ja2VkID0gZmFsc2U7XG5cbiAgICBcdFx0XHRcdGN1cnJlbnRTdGVuY2lsTWFzayA9IG51bGw7XG4gICAgXHRcdFx0XHRjdXJyZW50U3RlbmNpbEZ1bmMgPSBudWxsO1xuICAgIFx0XHRcdFx0Y3VycmVudFN0ZW5jaWxSZWYgPSBudWxsO1xuICAgIFx0XHRcdFx0Y3VycmVudFN0ZW5jaWxGdW5jTWFzayA9IG51bGw7XG4gICAgXHRcdFx0XHRjdXJyZW50U3RlbmNpbEZhaWwgPSBudWxsO1xuICAgIFx0XHRcdFx0Y3VycmVudFN0ZW5jaWxaRmFpbCA9IG51bGw7XG4gICAgXHRcdFx0XHRjdXJyZW50U3RlbmNpbFpQYXNzID0gbnVsbDtcbiAgICBcdFx0XHRcdGN1cnJlbnRTdGVuY2lsQ2xlYXIgPSBudWxsO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH07XG5cbiAgICBcdH1cblxuICAgIFx0Ly9cblxuICAgIFx0dmFyIGNvbG9yQnVmZmVyID0gbmV3IENvbG9yQnVmZmVyKCk7XG4gICAgXHR2YXIgZGVwdGhCdWZmZXIgPSBuZXcgRGVwdGhCdWZmZXIoKTtcbiAgICBcdHZhciBzdGVuY2lsQnVmZmVyID0gbmV3IFN0ZW5jaWxCdWZmZXIoKTtcblxuICAgIFx0dmFyIG1heFZlcnRleEF0dHJpYnV0ZXMgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLk1BWF9WRVJURVhfQVRUUklCUyApO1xuICAgIFx0dmFyIG5ld0F0dHJpYnV0ZXMgPSBuZXcgVWludDhBcnJheSggbWF4VmVydGV4QXR0cmlidXRlcyApO1xuICAgIFx0dmFyIGVuYWJsZWRBdHRyaWJ1dGVzID0gbmV3IFVpbnQ4QXJyYXkoIG1heFZlcnRleEF0dHJpYnV0ZXMgKTtcbiAgICBcdHZhciBhdHRyaWJ1dGVEaXZpc29ycyA9IG5ldyBVaW50OEFycmF5KCBtYXhWZXJ0ZXhBdHRyaWJ1dGVzICk7XG5cbiAgICBcdHZhciBjYXBhYmlsaXRpZXMgPSB7fTtcblxuICAgIFx0dmFyIGNvbXByZXNzZWRUZXh0dXJlRm9ybWF0cyA9IG51bGw7XG5cbiAgICBcdHZhciBjdXJyZW50QmxlbmRpbmcgPSBudWxsO1xuICAgIFx0dmFyIGN1cnJlbnRCbGVuZEVxdWF0aW9uID0gbnVsbDtcbiAgICBcdHZhciBjdXJyZW50QmxlbmRTcmMgPSBudWxsO1xuICAgIFx0dmFyIGN1cnJlbnRCbGVuZERzdCA9IG51bGw7XG4gICAgXHR2YXIgY3VycmVudEJsZW5kRXF1YXRpb25BbHBoYSA9IG51bGw7XG4gICAgXHR2YXIgY3VycmVudEJsZW5kU3JjQWxwaGEgPSBudWxsO1xuICAgIFx0dmFyIGN1cnJlbnRCbGVuZERzdEFscGhhID0gbnVsbDtcbiAgICBcdHZhciBjdXJyZW50UHJlbXVsdGlwbGVkQWxwaGEgPSBmYWxzZTtcblxuICAgIFx0dmFyIGN1cnJlbnRGbGlwU2lkZWQgPSBudWxsO1xuICAgIFx0dmFyIGN1cnJlbnRDdWxsRmFjZSA9IG51bGw7XG5cbiAgICBcdHZhciBjdXJyZW50TGluZVdpZHRoID0gbnVsbDtcblxuICAgIFx0dmFyIGN1cnJlbnRQb2x5Z29uT2Zmc2V0RmFjdG9yID0gbnVsbDtcbiAgICBcdHZhciBjdXJyZW50UG9seWdvbk9mZnNldFVuaXRzID0gbnVsbDtcblxuICAgIFx0dmFyIGN1cnJlbnRTY2lzc29yVGVzdCA9IG51bGw7XG5cbiAgICBcdHZhciBtYXhUZXh0dXJlcyA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX1RFWFRVUkVfSU1BR0VfVU5JVFMgKTtcblxuICAgIFx0dmFyIGN1cnJlbnRUZXh0dXJlU2xvdCA9IG51bGw7XG4gICAgXHR2YXIgY3VycmVudEJvdW5kVGV4dHVyZXMgPSB7fTtcblxuICAgIFx0dmFyIGN1cnJlbnRTY2lzc29yID0gbmV3IFZlY3RvcjQoKTtcbiAgICBcdHZhciBjdXJyZW50Vmlld3BvcnQgPSBuZXcgVmVjdG9yNCgpO1xuXG4gICAgXHRmdW5jdGlvbiBjcmVhdGVUZXh0dXJlKCB0eXBlLCB0YXJnZXQsIGNvdW50ICkge1xuXG4gICAgXHRcdHZhciBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoIDQgKTsgLy8gNCBpcyByZXF1aXJlZCB0byBtYXRjaCBkZWZhdWx0IHVucGFjayBhbGlnbm1lbnQgb2YgNC5cbiAgICBcdFx0dmFyIHRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG5cbiAgICBcdFx0Z2wuYmluZFRleHR1cmUoIHR5cGUsIHRleHR1cmUgKTtcbiAgICBcdFx0Z2wudGV4UGFyYW1ldGVyaSggdHlwZSwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUICk7XG4gICAgXHRcdGdsLnRleFBhcmFtZXRlcmkoIHR5cGUsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTkVBUkVTVCApO1xuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGNvdW50OyBpICsrICkge1xuXG4gICAgXHRcdFx0Z2wudGV4SW1hZ2UyRCggdGFyZ2V0ICsgaSwgMCwgZ2wuUkdCQSwgMSwgMSwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgZGF0YSApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gdGV4dHVyZTtcblxuICAgIFx0fVxuXG4gICAgXHR2YXIgZW1wdHlUZXh0dXJlcyA9IHt9O1xuICAgIFx0ZW1wdHlUZXh0dXJlc1sgZ2wuVEVYVFVSRV8yRCBdID0gY3JlYXRlVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV8yRCwgMSApO1xuICAgIFx0ZW1wdHlUZXh0dXJlc1sgZ2wuVEVYVFVSRV9DVUJFX01BUCBdID0gY3JlYXRlVGV4dHVyZSggZ2wuVEVYVFVSRV9DVUJFX01BUCwgZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YLCA2ICk7XG5cbiAgICBcdC8vXG5cbiAgICBcdGZ1bmN0aW9uIGluaXQoKSB7XG5cbiAgICBcdFx0Y2xlYXJDb2xvciggMCwgMCwgMCwgMSApO1xuICAgIFx0XHRjbGVhckRlcHRoKCAxICk7XG4gICAgXHRcdGNsZWFyU3RlbmNpbCggMCApO1xuXG4gICAgXHRcdGVuYWJsZSggZ2wuREVQVEhfVEVTVCApO1xuICAgIFx0XHRzZXREZXB0aEZ1bmMoIExlc3NFcXVhbERlcHRoICk7XG5cbiAgICBcdFx0c2V0RmxpcFNpZGVkKCBmYWxzZSApO1xuICAgIFx0XHRzZXRDdWxsRmFjZSggQ3VsbEZhY2VCYWNrICk7XG4gICAgXHRcdGVuYWJsZSggZ2wuQ1VMTF9GQUNFICk7XG5cbiAgICBcdFx0ZW5hYmxlKCBnbC5CTEVORCApO1xuICAgIFx0XHRzZXRCbGVuZGluZyggTm9ybWFsQmxlbmRpbmcgKTtcblxuICAgIFx0fVxuXG4gICAgXHRmdW5jdGlvbiBpbml0QXR0cmlidXRlcygpIHtcblxuICAgIFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBuZXdBdHRyaWJ1dGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICBcdFx0XHRuZXdBdHRyaWJ1dGVzWyBpIF0gPSAwO1xuXG4gICAgXHRcdH1cblxuICAgIFx0fVxuXG4gICAgXHRmdW5jdGlvbiBlbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZSApIHtcblxuICAgIFx0XHRuZXdBdHRyaWJ1dGVzWyBhdHRyaWJ1dGUgXSA9IDE7XG5cbiAgICBcdFx0aWYgKCBlbmFibGVkQXR0cmlidXRlc1sgYXR0cmlidXRlIF0gPT09IDAgKSB7XG5cbiAgICBcdFx0XHRnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSggYXR0cmlidXRlICk7XG4gICAgXHRcdFx0ZW5hYmxlZEF0dHJpYnV0ZXNbIGF0dHJpYnV0ZSBdID0gMTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKCBhdHRyaWJ1dGVEaXZpc29yc1sgYXR0cmlidXRlIF0gIT09IDAgKSB7XG5cbiAgICBcdFx0XHR2YXIgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJyApO1xuXG4gICAgXHRcdFx0ZXh0ZW5zaW9uLnZlcnRleEF0dHJpYkRpdmlzb3JBTkdMRSggYXR0cmlidXRlLCAwICk7XG4gICAgXHRcdFx0YXR0cmlidXRlRGl2aXNvcnNbIGF0dHJpYnV0ZSBdID0gMDtcblxuICAgIFx0XHR9XG5cbiAgICBcdH1cblxuICAgIFx0ZnVuY3Rpb24gZW5hYmxlQXR0cmlidXRlQW5kRGl2aXNvciggYXR0cmlidXRlLCBtZXNoUGVyQXR0cmlidXRlLCBleHRlbnNpb24gKSB7XG5cbiAgICBcdFx0bmV3QXR0cmlidXRlc1sgYXR0cmlidXRlIF0gPSAxO1xuXG4gICAgXHRcdGlmICggZW5hYmxlZEF0dHJpYnV0ZXNbIGF0dHJpYnV0ZSBdID09PSAwICkge1xuXG4gICAgXHRcdFx0Z2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoIGF0dHJpYnV0ZSApO1xuICAgIFx0XHRcdGVuYWJsZWRBdHRyaWJ1dGVzWyBhdHRyaWJ1dGUgXSA9IDE7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGlmICggYXR0cmlidXRlRGl2aXNvcnNbIGF0dHJpYnV0ZSBdICE9PSBtZXNoUGVyQXR0cmlidXRlICkge1xuXG4gICAgXHRcdFx0ZXh0ZW5zaW9uLnZlcnRleEF0dHJpYkRpdmlzb3JBTkdMRSggYXR0cmlidXRlLCBtZXNoUGVyQXR0cmlidXRlICk7XG4gICAgXHRcdFx0YXR0cmlidXRlRGl2aXNvcnNbIGF0dHJpYnV0ZSBdID0gbWVzaFBlckF0dHJpYnV0ZTtcblxuICAgIFx0XHR9XG5cbiAgICBcdH1cblxuICAgIFx0ZnVuY3Rpb24gZGlzYWJsZVVudXNlZEF0dHJpYnV0ZXMoKSB7XG5cbiAgICBcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gZW5hYmxlZEF0dHJpYnV0ZXMubGVuZ3RoOyBpICE9PSBsOyArKyBpICkge1xuXG4gICAgXHRcdFx0aWYgKCBlbmFibGVkQXR0cmlidXRlc1sgaSBdICE9PSBuZXdBdHRyaWJ1dGVzWyBpIF0gKSB7XG5cbiAgICBcdFx0XHRcdGdsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheSggaSApO1xuICAgIFx0XHRcdFx0ZW5hYmxlZEF0dHJpYnV0ZXNbIGkgXSA9IDA7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9XG5cbiAgICBcdGZ1bmN0aW9uIGVuYWJsZSggaWQgKSB7XG5cbiAgICBcdFx0aWYgKCBjYXBhYmlsaXRpZXNbIGlkIF0gIT09IHRydWUgKSB7XG5cbiAgICBcdFx0XHRnbC5lbmFibGUoIGlkICk7XG4gICAgXHRcdFx0Y2FwYWJpbGl0aWVzWyBpZCBdID0gdHJ1ZTtcblxuICAgIFx0XHR9XG5cbiAgICBcdH1cblxuICAgIFx0ZnVuY3Rpb24gZGlzYWJsZSggaWQgKSB7XG5cbiAgICBcdFx0aWYgKCBjYXBhYmlsaXRpZXNbIGlkIF0gIT09IGZhbHNlICkge1xuXG4gICAgXHRcdFx0Z2wuZGlzYWJsZSggaWQgKTtcbiAgICBcdFx0XHRjYXBhYmlsaXRpZXNbIGlkIF0gPSBmYWxzZTtcblxuICAgIFx0XHR9XG5cbiAgICBcdH1cblxuICAgIFx0ZnVuY3Rpb24gZ2V0Q29tcHJlc3NlZFRleHR1cmVGb3JtYXRzKCkge1xuXG4gICAgXHRcdGlmICggY29tcHJlc3NlZFRleHR1cmVGb3JtYXRzID09PSBudWxsICkge1xuXG4gICAgXHRcdFx0Y29tcHJlc3NlZFRleHR1cmVGb3JtYXRzID0gW107XG5cbiAgICBcdFx0XHRpZiAoIGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjJyApIHx8XG4gICAgXHRcdFx0ICAgICBleHRlbnNpb25zLmdldCggJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJyApIHx8XG4gICAgXHRcdFx0ICAgICBleHRlbnNpb25zLmdldCggJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9ldGMxJyApICkge1xuXG4gICAgXHRcdFx0XHR2YXIgZm9ybWF0cyA9IGdsLmdldFBhcmFtZXRlciggZ2wuQ09NUFJFU1NFRF9URVhUVVJFX0ZPUk1BVFMgKTtcblxuICAgIFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZm9ybWF0cy5sZW5ndGg7IGkgKysgKSB7XG5cbiAgICBcdFx0XHRcdFx0Y29tcHJlc3NlZFRleHR1cmVGb3JtYXRzLnB1c2goIGZvcm1hdHNbIGkgXSApO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiBjb21wcmVzc2VkVGV4dHVyZUZvcm1hdHM7XG5cbiAgICBcdH1cblxuICAgIFx0ZnVuY3Rpb24gc2V0QmxlbmRpbmcoIGJsZW5kaW5nLCBibGVuZEVxdWF0aW9uLCBibGVuZFNyYywgYmxlbmREc3QsIGJsZW5kRXF1YXRpb25BbHBoYSwgYmxlbmRTcmNBbHBoYSwgYmxlbmREc3RBbHBoYSwgcHJlbXVsdGlwbGllZEFscGhhICkge1xuXG4gICAgXHRcdGlmICggYmxlbmRpbmcgIT09IE5vQmxlbmRpbmcgKSB7XG5cbiAgICBcdFx0XHRlbmFibGUoIGdsLkJMRU5EICk7XG5cbiAgICBcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdGRpc2FibGUoIGdsLkJMRU5EICk7XG4gICAgXHRcdFx0Y3VycmVudEJsZW5kaW5nID0gYmxlbmRpbmc7IC8vIG5vIGJsZW5kaW5nLCB0aGF0IGlzXG4gICAgXHRcdFx0cmV0dXJuO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoIGJsZW5kaW5nICE9PSBjdXJyZW50QmxlbmRpbmcgfHwgcHJlbXVsdGlwbGllZEFscGhhICE9PSBjdXJyZW50UHJlbXVsdGlwbGVkQWxwaGEgKSB7XG5cbiAgICBcdFx0XHRpZiAoIGJsZW5kaW5nID09PSBBZGRpdGl2ZUJsZW5kaW5nICkge1xuXG4gICAgXHRcdFx0XHRpZiAoIHByZW11bHRpcGxpZWRBbHBoYSApIHtcblxuICAgIFx0XHRcdFx0XHRnbC5ibGVuZEVxdWF0aW9uU2VwYXJhdGUoIGdsLkZVTkNfQURELCBnbC5GVU5DX0FERCApO1xuICAgIFx0XHRcdFx0XHRnbC5ibGVuZEZ1bmNTZXBhcmF0ZSggZ2wuT05FLCBnbC5PTkUsIGdsLk9ORSwgZ2wuT05FICk7XG5cbiAgICBcdFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdFx0Z2wuYmxlbmRFcXVhdGlvbiggZ2wuRlVOQ19BREQgKTtcbiAgICBcdFx0XHRcdFx0Z2wuYmxlbmRGdW5jKCBnbC5TUkNfQUxQSEEsIGdsLk9ORSApO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9IGVsc2UgaWYgKCBibGVuZGluZyA9PT0gU3VidHJhY3RpdmVCbGVuZGluZyApIHtcblxuICAgIFx0XHRcdFx0aWYgKCBwcmVtdWx0aXBsaWVkQWxwaGEgKSB7XG5cbiAgICBcdFx0XHRcdFx0Z2wuYmxlbmRFcXVhdGlvblNlcGFyYXRlKCBnbC5GVU5DX0FERCwgZ2wuRlVOQ19BREQgKTtcbiAgICBcdFx0XHRcdFx0Z2wuYmxlbmRGdW5jU2VwYXJhdGUoIGdsLlpFUk8sIGdsLlpFUk8sIGdsLk9ORV9NSU5VU19TUkNfQ09MT1IsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEgKTtcblxuICAgIFx0XHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0XHRnbC5ibGVuZEVxdWF0aW9uKCBnbC5GVU5DX0FERCApO1xuICAgIFx0XHRcdFx0XHRnbC5ibGVuZEZ1bmMoIGdsLlpFUk8sIGdsLk9ORV9NSU5VU19TUkNfQ09MT1IgKTtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fSBlbHNlIGlmICggYmxlbmRpbmcgPT09IE11bHRpcGx5QmxlbmRpbmcgKSB7XG5cbiAgICBcdFx0XHRcdGlmICggcHJlbXVsdGlwbGllZEFscGhhICkge1xuXG4gICAgXHRcdFx0XHRcdGdsLmJsZW5kRXF1YXRpb25TZXBhcmF0ZSggZ2wuRlVOQ19BREQsIGdsLkZVTkNfQUREICk7XG4gICAgXHRcdFx0XHRcdGdsLmJsZW5kRnVuY1NlcGFyYXRlKCBnbC5aRVJPLCBnbC5TUkNfQ09MT1IsIGdsLlpFUk8sIGdsLlNSQ19BTFBIQSApO1xuXG4gICAgXHRcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRcdGdsLmJsZW5kRXF1YXRpb24oIGdsLkZVTkNfQUREICk7XG4gICAgXHRcdFx0XHRcdGdsLmJsZW5kRnVuYyggZ2wuWkVSTywgZ2wuU1JDX0NPTE9SICk7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdGlmICggcHJlbXVsdGlwbGllZEFscGhhICkge1xuXG4gICAgXHRcdFx0XHRcdGdsLmJsZW5kRXF1YXRpb25TZXBhcmF0ZSggZ2wuRlVOQ19BREQsIGdsLkZVTkNfQUREICk7XG4gICAgXHRcdFx0XHRcdGdsLmJsZW5kRnVuY1NlcGFyYXRlKCBnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEsIGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSApO1xuXG4gICAgXHRcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRcdGdsLmJsZW5kRXF1YXRpb25TZXBhcmF0ZSggZ2wuRlVOQ19BREQsIGdsLkZVTkNfQUREICk7XG4gICAgXHRcdFx0XHRcdGdsLmJsZW5kRnVuY1NlcGFyYXRlKCBnbC5TUkNfQUxQSEEsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEsIGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSApO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRjdXJyZW50QmxlbmRpbmcgPSBibGVuZGluZztcbiAgICBcdFx0XHRjdXJyZW50UHJlbXVsdGlwbGVkQWxwaGEgPSBwcmVtdWx0aXBsaWVkQWxwaGE7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGlmICggYmxlbmRpbmcgPT09IEN1c3RvbUJsZW5kaW5nICkge1xuXG4gICAgXHRcdFx0YmxlbmRFcXVhdGlvbkFscGhhID0gYmxlbmRFcXVhdGlvbkFscGhhIHx8IGJsZW5kRXF1YXRpb247XG4gICAgXHRcdFx0YmxlbmRTcmNBbHBoYSA9IGJsZW5kU3JjQWxwaGEgfHwgYmxlbmRTcmM7XG4gICAgXHRcdFx0YmxlbmREc3RBbHBoYSA9IGJsZW5kRHN0QWxwaGEgfHwgYmxlbmREc3Q7XG5cbiAgICBcdFx0XHRpZiAoIGJsZW5kRXF1YXRpb24gIT09IGN1cnJlbnRCbGVuZEVxdWF0aW9uIHx8IGJsZW5kRXF1YXRpb25BbHBoYSAhPT0gY3VycmVudEJsZW5kRXF1YXRpb25BbHBoYSApIHtcblxuICAgIFx0XHRcdFx0Z2wuYmxlbmRFcXVhdGlvblNlcGFyYXRlKCBwYXJhbVRocmVlVG9HTCggYmxlbmRFcXVhdGlvbiApLCBwYXJhbVRocmVlVG9HTCggYmxlbmRFcXVhdGlvbkFscGhhICkgKTtcblxuICAgIFx0XHRcdFx0Y3VycmVudEJsZW5kRXF1YXRpb24gPSBibGVuZEVxdWF0aW9uO1xuICAgIFx0XHRcdFx0Y3VycmVudEJsZW5kRXF1YXRpb25BbHBoYSA9IGJsZW5kRXF1YXRpb25BbHBoYTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGlmICggYmxlbmRTcmMgIT09IGN1cnJlbnRCbGVuZFNyYyB8fCBibGVuZERzdCAhPT0gY3VycmVudEJsZW5kRHN0IHx8IGJsZW5kU3JjQWxwaGEgIT09IGN1cnJlbnRCbGVuZFNyY0FscGhhIHx8IGJsZW5kRHN0QWxwaGEgIT09IGN1cnJlbnRCbGVuZERzdEFscGhhICkge1xuXG4gICAgXHRcdFx0XHRnbC5ibGVuZEZ1bmNTZXBhcmF0ZSggcGFyYW1UaHJlZVRvR0woIGJsZW5kU3JjICksIHBhcmFtVGhyZWVUb0dMKCBibGVuZERzdCApLCBwYXJhbVRocmVlVG9HTCggYmxlbmRTcmNBbHBoYSApLCBwYXJhbVRocmVlVG9HTCggYmxlbmREc3RBbHBoYSApICk7XG5cbiAgICBcdFx0XHRcdGN1cnJlbnRCbGVuZFNyYyA9IGJsZW5kU3JjO1xuICAgIFx0XHRcdFx0Y3VycmVudEJsZW5kRHN0ID0gYmxlbmREc3Q7XG4gICAgXHRcdFx0XHRjdXJyZW50QmxlbmRTcmNBbHBoYSA9IGJsZW5kU3JjQWxwaGE7XG4gICAgXHRcdFx0XHRjdXJyZW50QmxlbmREc3RBbHBoYSA9IGJsZW5kRHN0QWxwaGE7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdGN1cnJlbnRCbGVuZEVxdWF0aW9uID0gbnVsbDtcbiAgICBcdFx0XHRjdXJyZW50QmxlbmRTcmMgPSBudWxsO1xuICAgIFx0XHRcdGN1cnJlbnRCbGVuZERzdCA9IG51bGw7XG4gICAgXHRcdFx0Y3VycmVudEJsZW5kRXF1YXRpb25BbHBoYSA9IG51bGw7XG4gICAgXHRcdFx0Y3VycmVudEJsZW5kU3JjQWxwaGEgPSBudWxsO1xuICAgIFx0XHRcdGN1cnJlbnRCbGVuZERzdEFscGhhID0gbnVsbDtcblxuICAgIFx0XHR9XG5cbiAgICBcdH1cblxuICAgIFx0Ly8gVE9ETyBEZXByZWNhdGVcblxuICAgIFx0ZnVuY3Rpb24gc2V0Q29sb3JXcml0ZSggY29sb3JXcml0ZSApIHtcblxuICAgIFx0XHRjb2xvckJ1ZmZlci5zZXRNYXNrKCBjb2xvcldyaXRlICk7XG5cbiAgICBcdH1cblxuICAgIFx0ZnVuY3Rpb24gc2V0RGVwdGhUZXN0KCBkZXB0aFRlc3QgKSB7XG5cbiAgICBcdFx0ZGVwdGhCdWZmZXIuc2V0VGVzdCggZGVwdGhUZXN0ICk7XG5cbiAgICBcdH1cblxuICAgIFx0ZnVuY3Rpb24gc2V0RGVwdGhXcml0ZSggZGVwdGhXcml0ZSApIHtcblxuICAgIFx0XHRkZXB0aEJ1ZmZlci5zZXRNYXNrKCBkZXB0aFdyaXRlICk7XG5cbiAgICBcdH1cblxuICAgIFx0ZnVuY3Rpb24gc2V0RGVwdGhGdW5jKCBkZXB0aEZ1bmMgKSB7XG5cbiAgICBcdFx0ZGVwdGhCdWZmZXIuc2V0RnVuYyggZGVwdGhGdW5jICk7XG5cbiAgICBcdH1cblxuICAgIFx0ZnVuY3Rpb24gc2V0U3RlbmNpbFRlc3QoIHN0ZW5jaWxUZXN0ICkge1xuXG4gICAgXHRcdHN0ZW5jaWxCdWZmZXIuc2V0VGVzdCggc3RlbmNpbFRlc3QgKTtcblxuICAgIFx0fVxuXG4gICAgXHRmdW5jdGlvbiBzZXRTdGVuY2lsV3JpdGUoIHN0ZW5jaWxXcml0ZSApIHtcblxuICAgIFx0XHRzdGVuY2lsQnVmZmVyLnNldE1hc2soIHN0ZW5jaWxXcml0ZSApO1xuXG4gICAgXHR9XG5cbiAgICBcdGZ1bmN0aW9uIHNldFN0ZW5jaWxGdW5jKCBzdGVuY2lsRnVuYywgc3RlbmNpbFJlZiwgc3RlbmNpbE1hc2sgKSB7XG5cbiAgICBcdFx0c3RlbmNpbEJ1ZmZlci5zZXRGdW5jKCBzdGVuY2lsRnVuYywgc3RlbmNpbFJlZiwgc3RlbmNpbE1hc2sgKTtcblxuICAgIFx0fVxuXG4gICAgXHRmdW5jdGlvbiBzZXRTdGVuY2lsT3AoIHN0ZW5jaWxGYWlsLCBzdGVuY2lsWkZhaWwsIHN0ZW5jaWxaUGFzcyApIHtcblxuICAgIFx0XHRzdGVuY2lsQnVmZmVyLnNldE9wKCBzdGVuY2lsRmFpbCwgc3RlbmNpbFpGYWlsLCBzdGVuY2lsWlBhc3MgKTtcblxuICAgIFx0fVxuXG4gICAgXHQvL1xuXG4gICAgXHRmdW5jdGlvbiBzZXRGbGlwU2lkZWQoIGZsaXBTaWRlZCApIHtcblxuICAgIFx0XHRpZiAoIGN1cnJlbnRGbGlwU2lkZWQgIT09IGZsaXBTaWRlZCApIHtcblxuICAgIFx0XHRcdGlmICggZmxpcFNpZGVkICkge1xuXG4gICAgXHRcdFx0XHRnbC5mcm9udEZhY2UoIGdsLkNXICk7XG5cbiAgICBcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRnbC5mcm9udEZhY2UoIGdsLkNDVyApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0Y3VycmVudEZsaXBTaWRlZCA9IGZsaXBTaWRlZDtcblxuICAgIFx0XHR9XG5cbiAgICBcdH1cblxuICAgIFx0ZnVuY3Rpb24gc2V0Q3VsbEZhY2UoIGN1bGxGYWNlICkge1xuXG4gICAgXHRcdGlmICggY3VsbEZhY2UgIT09IEN1bGxGYWNlTm9uZSApIHtcblxuICAgIFx0XHRcdGVuYWJsZSggZ2wuQ1VMTF9GQUNFICk7XG5cbiAgICBcdFx0XHRpZiAoIGN1bGxGYWNlICE9PSBjdXJyZW50Q3VsbEZhY2UgKSB7XG5cbiAgICBcdFx0XHRcdGlmICggY3VsbEZhY2UgPT09IEN1bGxGYWNlQmFjayApIHtcblxuICAgIFx0XHRcdFx0XHRnbC5jdWxsRmFjZSggZ2wuQkFDSyApO1xuXG4gICAgXHRcdFx0XHR9IGVsc2UgaWYgKCBjdWxsRmFjZSA9PT0gQ3VsbEZhY2VGcm9udCApIHtcblxuICAgIFx0XHRcdFx0XHRnbC5jdWxsRmFjZSggZ2wuRlJPTlQgKTtcblxuICAgIFx0XHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0XHRnbC5jdWxsRmFjZSggZ2wuRlJPTlRfQU5EX0JBQ0sgKTtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRkaXNhYmxlKCBnbC5DVUxMX0ZBQ0UgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0Y3VycmVudEN1bGxGYWNlID0gY3VsbEZhY2U7XG5cbiAgICBcdH1cblxuICAgIFx0ZnVuY3Rpb24gc2V0TGluZVdpZHRoKCB3aWR0aCApIHtcblxuICAgIFx0XHRpZiAoIHdpZHRoICE9PSBjdXJyZW50TGluZVdpZHRoICkge1xuXG4gICAgXHRcdFx0Z2wubGluZVdpZHRoKCB3aWR0aCApO1xuXG4gICAgXHRcdFx0Y3VycmVudExpbmVXaWR0aCA9IHdpZHRoO1xuXG4gICAgXHRcdH1cblxuICAgIFx0fVxuXG4gICAgXHRmdW5jdGlvbiBzZXRQb2x5Z29uT2Zmc2V0KCBwb2x5Z29uT2Zmc2V0LCBmYWN0b3IsIHVuaXRzICkge1xuXG4gICAgXHRcdGlmICggcG9seWdvbk9mZnNldCApIHtcblxuICAgIFx0XHRcdGVuYWJsZSggZ2wuUE9MWUdPTl9PRkZTRVRfRklMTCApO1xuXG4gICAgXHRcdFx0aWYgKCBjdXJyZW50UG9seWdvbk9mZnNldEZhY3RvciAhPT0gZmFjdG9yIHx8IGN1cnJlbnRQb2x5Z29uT2Zmc2V0VW5pdHMgIT09IHVuaXRzICkge1xuXG4gICAgXHRcdFx0XHRnbC5wb2x5Z29uT2Zmc2V0KCBmYWN0b3IsIHVuaXRzICk7XG5cbiAgICBcdFx0XHRcdGN1cnJlbnRQb2x5Z29uT2Zmc2V0RmFjdG9yID0gZmFjdG9yO1xuICAgIFx0XHRcdFx0Y3VycmVudFBvbHlnb25PZmZzZXRVbml0cyA9IHVuaXRzO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRkaXNhYmxlKCBnbC5QT0xZR09OX09GRlNFVF9GSUxMICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9XG5cbiAgICBcdGZ1bmN0aW9uIGdldFNjaXNzb3JUZXN0KCkge1xuXG4gICAgXHRcdHJldHVybiBjdXJyZW50U2Npc3NvclRlc3Q7XG5cbiAgICBcdH1cblxuICAgIFx0ZnVuY3Rpb24gc2V0U2Npc3NvclRlc3QoIHNjaXNzb3JUZXN0ICkge1xuXG4gICAgXHRcdGN1cnJlbnRTY2lzc29yVGVzdCA9IHNjaXNzb3JUZXN0O1xuXG4gICAgXHRcdGlmICggc2Npc3NvclRlc3QgKSB7XG5cbiAgICBcdFx0XHRlbmFibGUoIGdsLlNDSVNTT1JfVEVTVCApO1xuXG4gICAgXHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRkaXNhYmxlKCBnbC5TQ0lTU09SX1RFU1QgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdH1cblxuICAgIFx0Ly8gdGV4dHVyZVxuXG4gICAgXHRmdW5jdGlvbiBhY3RpdmVUZXh0dXJlKCB3ZWJnbFNsb3QgKSB7XG5cbiAgICBcdFx0aWYgKCB3ZWJnbFNsb3QgPT09IHVuZGVmaW5lZCApIHdlYmdsU2xvdCA9IGdsLlRFWFRVUkUwICsgbWF4VGV4dHVyZXMgLSAxO1xuXG4gICAgXHRcdGlmICggY3VycmVudFRleHR1cmVTbG90ICE9PSB3ZWJnbFNsb3QgKSB7XG5cbiAgICBcdFx0XHRnbC5hY3RpdmVUZXh0dXJlKCB3ZWJnbFNsb3QgKTtcbiAgICBcdFx0XHRjdXJyZW50VGV4dHVyZVNsb3QgPSB3ZWJnbFNsb3Q7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9XG5cbiAgICBcdGZ1bmN0aW9uIGJpbmRUZXh0dXJlKCB3ZWJnbFR5cGUsIHdlYmdsVGV4dHVyZSApIHtcblxuICAgIFx0XHRpZiAoIGN1cnJlbnRUZXh0dXJlU2xvdCA9PT0gbnVsbCApIHtcblxuICAgIFx0XHRcdGFjdGl2ZVRleHR1cmUoKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0dmFyIGJvdW5kVGV4dHVyZSA9IGN1cnJlbnRCb3VuZFRleHR1cmVzWyBjdXJyZW50VGV4dHVyZVNsb3QgXTtcblxuICAgIFx0XHRpZiAoIGJvdW5kVGV4dHVyZSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0Ym91bmRUZXh0dXJlID0geyB0eXBlOiB1bmRlZmluZWQsIHRleHR1cmU6IHVuZGVmaW5lZCB9O1xuICAgIFx0XHRcdGN1cnJlbnRCb3VuZFRleHR1cmVzWyBjdXJyZW50VGV4dHVyZVNsb3QgXSA9IGJvdW5kVGV4dHVyZTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKCBib3VuZFRleHR1cmUudHlwZSAhPT0gd2ViZ2xUeXBlIHx8IGJvdW5kVGV4dHVyZS50ZXh0dXJlICE9PSB3ZWJnbFRleHR1cmUgKSB7XG5cbiAgICBcdFx0XHRnbC5iaW5kVGV4dHVyZSggd2ViZ2xUeXBlLCB3ZWJnbFRleHR1cmUgfHwgZW1wdHlUZXh0dXJlc1sgd2ViZ2xUeXBlIF0gKTtcblxuICAgIFx0XHRcdGJvdW5kVGV4dHVyZS50eXBlID0gd2ViZ2xUeXBlO1xuICAgIFx0XHRcdGJvdW5kVGV4dHVyZS50ZXh0dXJlID0gd2ViZ2xUZXh0dXJlO1xuXG4gICAgXHRcdH1cblxuICAgIFx0fVxuXG4gICAgXHRmdW5jdGlvbiBjb21wcmVzc2VkVGV4SW1hZ2UyRCgpIHtcblxuICAgIFx0XHR0cnkge1xuXG4gICAgXHRcdFx0Z2wuY29tcHJlc3NlZFRleEltYWdlMkQuYXBwbHkoIGdsLCBhcmd1bWVudHMgKTtcblxuICAgIFx0XHR9IGNhdGNoICggZXJyb3IgKSB7XG5cbiAgICBcdFx0XHRjb25zb2xlLmVycm9yKCBlcnJvciApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0fVxuXG4gICAgXHRmdW5jdGlvbiB0ZXhJbWFnZTJEKCkge1xuXG4gICAgXHRcdHRyeSB7XG5cbiAgICBcdFx0XHRnbC50ZXhJbWFnZTJELmFwcGx5KCBnbCwgYXJndW1lbnRzICk7XG5cbiAgICBcdFx0fSBjYXRjaCAoIGVycm9yICkge1xuXG4gICAgXHRcdFx0Y29uc29sZS5lcnJvciggZXJyb3IgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdH1cblxuICAgIFx0Ly8gVE9ETyBEZXByZWNhdGVcblxuICAgIFx0ZnVuY3Rpb24gY2xlYXJDb2xvciggciwgZywgYiwgYSApIHtcblxuICAgIFx0XHRjb2xvckJ1ZmZlci5zZXRDbGVhciggciwgZywgYiwgYSApO1xuXG4gICAgXHR9XG5cbiAgICBcdGZ1bmN0aW9uIGNsZWFyRGVwdGgoIGRlcHRoICkge1xuXG4gICAgXHRcdGRlcHRoQnVmZmVyLnNldENsZWFyKCBkZXB0aCApO1xuXG4gICAgXHR9XG5cbiAgICBcdGZ1bmN0aW9uIGNsZWFyU3RlbmNpbCggc3RlbmNpbCApIHtcblxuICAgIFx0XHRzdGVuY2lsQnVmZmVyLnNldENsZWFyKCBzdGVuY2lsICk7XG5cbiAgICBcdH1cblxuICAgIFx0Ly9cblxuICAgIFx0ZnVuY3Rpb24gc2Npc3Nvciggc2Npc3NvciApIHtcblxuICAgIFx0XHRpZiAoIGN1cnJlbnRTY2lzc29yLmVxdWFscyggc2Npc3NvciApID09PSBmYWxzZSApIHtcblxuICAgIFx0XHRcdGdsLnNjaXNzb3IoIHNjaXNzb3IueCwgc2Npc3Nvci55LCBzY2lzc29yLnosIHNjaXNzb3IudyApO1xuICAgIFx0XHRcdGN1cnJlbnRTY2lzc29yLmNvcHkoIHNjaXNzb3IgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdH1cblxuICAgIFx0ZnVuY3Rpb24gdmlld3BvcnQoIHZpZXdwb3J0ICkge1xuXG4gICAgXHRcdGlmICggY3VycmVudFZpZXdwb3J0LmVxdWFscyggdmlld3BvcnQgKSA9PT0gZmFsc2UgKSB7XG5cbiAgICBcdFx0XHRnbC52aWV3cG9ydCggdmlld3BvcnQueCwgdmlld3BvcnQueSwgdmlld3BvcnQueiwgdmlld3BvcnQudyApO1xuICAgIFx0XHRcdGN1cnJlbnRWaWV3cG9ydC5jb3B5KCB2aWV3cG9ydCApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0fVxuXG4gICAgXHQvL1xuXG4gICAgXHRmdW5jdGlvbiByZXNldCgpIHtcblxuICAgIFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBlbmFibGVkQXR0cmlidXRlcy5sZW5ndGg7IGkgKysgKSB7XG5cbiAgICBcdFx0XHRpZiAoIGVuYWJsZWRBdHRyaWJ1dGVzWyBpIF0gPT09IDEgKSB7XG5cbiAgICBcdFx0XHRcdGdsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheSggaSApO1xuICAgIFx0XHRcdFx0ZW5hYmxlZEF0dHJpYnV0ZXNbIGkgXSA9IDA7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGNhcGFiaWxpdGllcyA9IHt9O1xuXG4gICAgXHRcdGNvbXByZXNzZWRUZXh0dXJlRm9ybWF0cyA9IG51bGw7XG5cbiAgICBcdFx0Y3VycmVudFRleHR1cmVTbG90ID0gbnVsbDtcbiAgICBcdFx0Y3VycmVudEJvdW5kVGV4dHVyZXMgPSB7fTtcblxuICAgIFx0XHRjdXJyZW50QmxlbmRpbmcgPSBudWxsO1xuXG4gICAgXHRcdGN1cnJlbnRGbGlwU2lkZWQgPSBudWxsO1xuICAgIFx0XHRjdXJyZW50Q3VsbEZhY2UgPSBudWxsO1xuXG4gICAgXHRcdGNvbG9yQnVmZmVyLnJlc2V0KCk7XG4gICAgXHRcdGRlcHRoQnVmZmVyLnJlc2V0KCk7XG4gICAgXHRcdHN0ZW5jaWxCdWZmZXIucmVzZXQoKTtcblxuICAgIFx0fVxuXG4gICAgXHRyZXR1cm4ge1xuXG4gICAgXHRcdGJ1ZmZlcnM6IHtcbiAgICBcdFx0XHRjb2xvcjogY29sb3JCdWZmZXIsXG4gICAgXHRcdFx0ZGVwdGg6IGRlcHRoQnVmZmVyLFxuICAgIFx0XHRcdHN0ZW5jaWw6IHN0ZW5jaWxCdWZmZXJcbiAgICBcdFx0fSxcblxuICAgIFx0XHRpbml0OiBpbml0LFxuICAgIFx0XHRpbml0QXR0cmlidXRlczogaW5pdEF0dHJpYnV0ZXMsXG4gICAgXHRcdGVuYWJsZUF0dHJpYnV0ZTogZW5hYmxlQXR0cmlidXRlLFxuICAgIFx0XHRlbmFibGVBdHRyaWJ1dGVBbmREaXZpc29yOiBlbmFibGVBdHRyaWJ1dGVBbmREaXZpc29yLFxuICAgIFx0XHRkaXNhYmxlVW51c2VkQXR0cmlidXRlczogZGlzYWJsZVVudXNlZEF0dHJpYnV0ZXMsXG4gICAgXHRcdGVuYWJsZTogZW5hYmxlLFxuICAgIFx0XHRkaXNhYmxlOiBkaXNhYmxlLFxuICAgIFx0XHRnZXRDb21wcmVzc2VkVGV4dHVyZUZvcm1hdHM6IGdldENvbXByZXNzZWRUZXh0dXJlRm9ybWF0cyxcblxuICAgIFx0XHRzZXRCbGVuZGluZzogc2V0QmxlbmRpbmcsXG5cbiAgICBcdFx0c2V0Q29sb3JXcml0ZTogc2V0Q29sb3JXcml0ZSxcbiAgICBcdFx0c2V0RGVwdGhUZXN0OiBzZXREZXB0aFRlc3QsXG4gICAgXHRcdHNldERlcHRoV3JpdGU6IHNldERlcHRoV3JpdGUsXG4gICAgXHRcdHNldERlcHRoRnVuYzogc2V0RGVwdGhGdW5jLFxuICAgIFx0XHRzZXRTdGVuY2lsVGVzdDogc2V0U3RlbmNpbFRlc3QsXG4gICAgXHRcdHNldFN0ZW5jaWxXcml0ZTogc2V0U3RlbmNpbFdyaXRlLFxuICAgIFx0XHRzZXRTdGVuY2lsRnVuYzogc2V0U3RlbmNpbEZ1bmMsXG4gICAgXHRcdHNldFN0ZW5jaWxPcDogc2V0U3RlbmNpbE9wLFxuXG4gICAgXHRcdHNldEZsaXBTaWRlZDogc2V0RmxpcFNpZGVkLFxuICAgIFx0XHRzZXRDdWxsRmFjZTogc2V0Q3VsbEZhY2UsXG5cbiAgICBcdFx0c2V0TGluZVdpZHRoOiBzZXRMaW5lV2lkdGgsXG4gICAgXHRcdHNldFBvbHlnb25PZmZzZXQ6IHNldFBvbHlnb25PZmZzZXQsXG5cbiAgICBcdFx0Z2V0U2Npc3NvclRlc3Q6IGdldFNjaXNzb3JUZXN0LFxuICAgIFx0XHRzZXRTY2lzc29yVGVzdDogc2V0U2Npc3NvclRlc3QsXG5cbiAgICBcdFx0YWN0aXZlVGV4dHVyZTogYWN0aXZlVGV4dHVyZSxcbiAgICBcdFx0YmluZFRleHR1cmU6IGJpbmRUZXh0dXJlLFxuICAgIFx0XHRjb21wcmVzc2VkVGV4SW1hZ2UyRDogY29tcHJlc3NlZFRleEltYWdlMkQsXG4gICAgXHRcdHRleEltYWdlMkQ6IHRleEltYWdlMkQsXG5cbiAgICBcdFx0Y2xlYXJDb2xvcjogY2xlYXJDb2xvcixcbiAgICBcdFx0Y2xlYXJEZXB0aDogY2xlYXJEZXB0aCxcbiAgICBcdFx0Y2xlYXJTdGVuY2lsOiBjbGVhclN0ZW5jaWwsXG5cbiAgICBcdFx0c2Npc3Nvcjogc2Npc3NvcixcbiAgICBcdFx0dmlld3BvcnQ6IHZpZXdwb3J0LFxuXG4gICAgXHRcdHJlc2V0OiByZXNldFxuXG4gICAgXHR9O1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIFdlYkdMQ2FwYWJpbGl0aWVzKCBnbCwgZXh0ZW5zaW9ucywgcGFyYW1ldGVycyApIHtcblxuICAgIFx0dmFyIG1heEFuaXNvdHJvcHk7XG5cbiAgICBcdGZ1bmN0aW9uIGdldE1heEFuaXNvdHJvcHkoKSB7XG5cbiAgICBcdFx0aWYgKCBtYXhBbmlzb3Ryb3B5ICE9PSB1bmRlZmluZWQgKSByZXR1cm4gbWF4QW5pc290cm9weTtcblxuICAgIFx0XHR2YXIgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnICk7XG5cbiAgICBcdFx0aWYgKCBleHRlbnNpb24gIT09IG51bGwgKSB7XG5cbiAgICBcdFx0XHRtYXhBbmlzb3Ryb3B5ID0gZ2wuZ2V0UGFyYW1ldGVyKCBleHRlbnNpb24uTUFYX1RFWFRVUkVfTUFYX0FOSVNPVFJPUFlfRVhUICk7XG5cbiAgICBcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdG1heEFuaXNvdHJvcHkgPSAwO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gbWF4QW5pc290cm9weTtcblxuICAgIFx0fVxuXG4gICAgXHRmdW5jdGlvbiBnZXRNYXhQcmVjaXNpb24oIHByZWNpc2lvbiApIHtcblxuICAgIFx0XHRpZiAoIHByZWNpc2lvbiA9PT0gJ2hpZ2hwJyApIHtcblxuICAgIFx0XHRcdGlmICggZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KCBnbC5WRVJURVhfU0hBREVSLCBnbC5ISUdIX0ZMT0FUICkucHJlY2lzaW9uID4gMCAmJlxuICAgIFx0XHRcdCAgICAgZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KCBnbC5GUkFHTUVOVF9TSEFERVIsIGdsLkhJR0hfRkxPQVQgKS5wcmVjaXNpb24gPiAwICkge1xuXG4gICAgXHRcdFx0XHRyZXR1cm4gJ2hpZ2hwJztcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdHByZWNpc2lvbiA9ICdtZWRpdW1wJztcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKCBwcmVjaXNpb24gPT09ICdtZWRpdW1wJyApIHtcblxuICAgIFx0XHRcdGlmICggZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KCBnbC5WRVJURVhfU0hBREVSLCBnbC5NRURJVU1fRkxPQVQgKS5wcmVjaXNpb24gPiAwICYmXG4gICAgXHRcdFx0ICAgICBnbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoIGdsLkZSQUdNRU5UX1NIQURFUiwgZ2wuTUVESVVNX0ZMT0FUICkucHJlY2lzaW9uID4gMCApIHtcblxuICAgIFx0XHRcdFx0cmV0dXJuICdtZWRpdW1wJztcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuICdsb3dwJztcblxuICAgIFx0fVxuXG4gICAgXHR2YXIgcHJlY2lzaW9uID0gcGFyYW1ldGVycy5wcmVjaXNpb24gIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMucHJlY2lzaW9uIDogJ2hpZ2hwJztcbiAgICBcdHZhciBtYXhQcmVjaXNpb24gPSBnZXRNYXhQcmVjaXNpb24oIHByZWNpc2lvbiApO1xuXG4gICAgXHRpZiAoIG1heFByZWNpc2lvbiAhPT0gcHJlY2lzaW9uICkge1xuXG4gICAgXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6JywgcHJlY2lzaW9uLCAnbm90IHN1cHBvcnRlZCwgdXNpbmcnLCBtYXhQcmVjaXNpb24sICdpbnN0ZWFkLicgKTtcbiAgICBcdFx0cHJlY2lzaW9uID0gbWF4UHJlY2lzaW9uO1xuXG4gICAgXHR9XG5cbiAgICBcdHZhciBsb2dhcml0aG1pY0RlcHRoQnVmZmVyID0gcGFyYW1ldGVycy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyID09PSB0cnVlICYmICEhIGV4dGVuc2lvbnMuZ2V0KCAnRVhUX2ZyYWdfZGVwdGgnICk7XG5cbiAgICBcdHZhciBtYXhUZXh0dXJlcyA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX1RFWFRVUkVfSU1BR0VfVU5JVFMgKTtcbiAgICBcdHZhciBtYXhWZXJ0ZXhUZXh0dXJlcyA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX1ZFUlRFWF9URVhUVVJFX0lNQUdFX1VOSVRTICk7XG4gICAgXHR2YXIgbWF4VGV4dHVyZVNpemUgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLk1BWF9URVhUVVJFX1NJWkUgKTtcbiAgICBcdHZhciBtYXhDdWJlbWFwU2l6ZSA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX0NVQkVfTUFQX1RFWFRVUkVfU0laRSApO1xuXG4gICAgXHR2YXIgbWF4QXR0cmlidXRlcyA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX1ZFUlRFWF9BVFRSSUJTICk7XG4gICAgXHR2YXIgbWF4VmVydGV4VW5pZm9ybXMgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLk1BWF9WRVJURVhfVU5JRk9STV9WRUNUT1JTICk7XG4gICAgXHR2YXIgbWF4VmFyeWluZ3MgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLk1BWF9WQVJZSU5HX1ZFQ1RPUlMgKTtcbiAgICBcdHZhciBtYXhGcmFnbWVudFVuaWZvcm1zID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5NQVhfRlJBR01FTlRfVU5JRk9STV9WRUNUT1JTICk7XG5cbiAgICBcdHZhciB2ZXJ0ZXhUZXh0dXJlcyA9IG1heFZlcnRleFRleHR1cmVzID4gMDtcbiAgICBcdHZhciBmbG9hdEZyYWdtZW50VGV4dHVyZXMgPSAhISBleHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2Zsb2F0JyApO1xuICAgIFx0dmFyIGZsb2F0VmVydGV4VGV4dHVyZXMgPSB2ZXJ0ZXhUZXh0dXJlcyAmJiBmbG9hdEZyYWdtZW50VGV4dHVyZXM7XG5cbiAgICBcdHJldHVybiB7XG5cbiAgICBcdFx0Z2V0TWF4QW5pc290cm9weTogZ2V0TWF4QW5pc290cm9weSxcbiAgICBcdFx0Z2V0TWF4UHJlY2lzaW9uOiBnZXRNYXhQcmVjaXNpb24sXG5cbiAgICBcdFx0cHJlY2lzaW9uOiBwcmVjaXNpb24sXG4gICAgXHRcdGxvZ2FyaXRobWljRGVwdGhCdWZmZXI6IGxvZ2FyaXRobWljRGVwdGhCdWZmZXIsXG5cbiAgICBcdFx0bWF4VGV4dHVyZXM6IG1heFRleHR1cmVzLFxuICAgIFx0XHRtYXhWZXJ0ZXhUZXh0dXJlczogbWF4VmVydGV4VGV4dHVyZXMsXG4gICAgXHRcdG1heFRleHR1cmVTaXplOiBtYXhUZXh0dXJlU2l6ZSxcbiAgICBcdFx0bWF4Q3ViZW1hcFNpemU6IG1heEN1YmVtYXBTaXplLFxuXG4gICAgXHRcdG1heEF0dHJpYnV0ZXM6IG1heEF0dHJpYnV0ZXMsXG4gICAgXHRcdG1heFZlcnRleFVuaWZvcm1zOiBtYXhWZXJ0ZXhVbmlmb3JtcyxcbiAgICBcdFx0bWF4VmFyeWluZ3M6IG1heFZhcnlpbmdzLFxuICAgIFx0XHRtYXhGcmFnbWVudFVuaWZvcm1zOiBtYXhGcmFnbWVudFVuaWZvcm1zLFxuXG4gICAgXHRcdHZlcnRleFRleHR1cmVzOiB2ZXJ0ZXhUZXh0dXJlcyxcbiAgICBcdFx0ZmxvYXRGcmFnbWVudFRleHR1cmVzOiBmbG9hdEZyYWdtZW50VGV4dHVyZXMsXG4gICAgXHRcdGZsb2F0VmVydGV4VGV4dHVyZXM6IGZsb2F0VmVydGV4VGV4dHVyZXNcblxuICAgIFx0fTtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBXZWJHTEV4dGVuc2lvbnMoIGdsICkge1xuXG4gICAgXHR2YXIgZXh0ZW5zaW9ucyA9IHt9O1xuXG4gICAgXHRyZXR1cm4ge1xuXG4gICAgXHRcdGdldDogZnVuY3Rpb24gKCBuYW1lICkge1xuXG4gICAgXHRcdFx0aWYgKCBleHRlbnNpb25zWyBuYW1lIF0gIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0cmV0dXJuIGV4dGVuc2lvbnNbIG5hbWUgXTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdHZhciBleHRlbnNpb247XG5cbiAgICBcdFx0XHRzd2l0Y2ggKCBuYW1lICkge1xuXG4gICAgXHRcdFx0XHRjYXNlICdXRUJHTF9kZXB0aF90ZXh0dXJlJzpcbiAgICBcdFx0XHRcdFx0ZXh0ZW5zaW9uID0gZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCR0xfZGVwdGhfdGV4dHVyZScgKSB8fCBnbC5nZXRFeHRlbnNpb24oICdNT1pfV0VCR0xfZGVwdGhfdGV4dHVyZScgKSB8fCBnbC5nZXRFeHRlbnNpb24oICdXRUJLSVRfV0VCR0xfZGVwdGhfdGV4dHVyZScgKTtcbiAgICBcdFx0XHRcdFx0YnJlYWs7XG5cbiAgICBcdFx0XHRcdGNhc2UgJ0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYyc6XG4gICAgXHRcdFx0XHRcdGV4dGVuc2lvbiA9IGdsLmdldEV4dGVuc2lvbiggJ0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycgKSB8fCBnbC5nZXRFeHRlbnNpb24oICdNT1pfRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJyApIHx8IGdsLmdldEV4dGVuc2lvbiggJ1dFQktJVF9FWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnICk7XG4gICAgXHRcdFx0XHRcdGJyZWFrO1xuXG4gICAgXHRcdFx0XHRjYXNlICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0Yyc6XG4gICAgXHRcdFx0XHRcdGV4dGVuc2lvbiA9IGdsLmdldEV4dGVuc2lvbiggJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJyApIHx8IGdsLmdldEV4dGVuc2lvbiggJ01PWl9XRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YycgKSB8fCBnbC5nZXRFeHRlbnNpb24oICdXRUJLSVRfV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMnICk7XG4gICAgXHRcdFx0XHRcdGJyZWFrO1xuXG4gICAgXHRcdFx0XHRjYXNlICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMnOlxuICAgIFx0XHRcdFx0XHRleHRlbnNpb24gPSBnbC5nZXRFeHRlbnNpb24oICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMnICkgfHwgZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCS0lUX1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0YycgKTtcbiAgICBcdFx0XHRcdFx0YnJlYWs7XG5cbiAgICBcdFx0XHRcdGNhc2UgJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9ldGMxJzpcbiAgICBcdFx0XHRcdFx0ZXh0ZW5zaW9uID0gZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX2V0YzEnICk7XG4gICAgXHRcdFx0XHRcdGJyZWFrO1xuXG4gICAgXHRcdFx0XHRkZWZhdWx0OlxuICAgIFx0XHRcdFx0XHRleHRlbnNpb24gPSBnbC5nZXRFeHRlbnNpb24oIG5hbWUgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGlmICggZXh0ZW5zaW9uID09PSBudWxsICkge1xuXG4gICAgXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAnICsgbmFtZSArICcgZXh0ZW5zaW9uIG5vdCBzdXBwb3J0ZWQuJyApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0ZXh0ZW5zaW9uc1sgbmFtZSBdID0gZXh0ZW5zaW9uO1xuXG4gICAgXHRcdFx0cmV0dXJuIGV4dGVuc2lvbjtcblxuICAgIFx0XHR9XG5cbiAgICBcdH07XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBXZWJHTENsaXBwaW5nKCkge1xuXG4gICAgXHR2YXIgc2NvcGUgPSB0aGlzLFxuXG4gICAgXHRcdGdsb2JhbFN0YXRlID0gbnVsbCxcbiAgICBcdFx0bnVtR2xvYmFsUGxhbmVzID0gMCxcbiAgICBcdFx0bG9jYWxDbGlwcGluZ0VuYWJsZWQgPSBmYWxzZSxcbiAgICBcdFx0cmVuZGVyaW5nU2hhZG93cyA9IGZhbHNlLFxuXG4gICAgXHRcdHBsYW5lID0gbmV3IFBsYW5lKCksXG4gICAgXHRcdHZpZXdOb3JtYWxNYXRyaXggPSBuZXcgTWF0cml4MygpLFxuXG4gICAgXHRcdHVuaWZvcm0gPSB7IHZhbHVlOiBudWxsLCBuZWVkc1VwZGF0ZTogZmFsc2UgfTtcblxuICAgIFx0dGhpcy51bmlmb3JtID0gdW5pZm9ybTtcbiAgICBcdHRoaXMubnVtUGxhbmVzID0gMDtcblxuICAgIFx0dGhpcy5pbml0ID0gZnVuY3Rpb24oIHBsYW5lcywgZW5hYmxlTG9jYWxDbGlwcGluZywgY2FtZXJhICkge1xuXG4gICAgXHRcdHZhciBlbmFibGVkID1cbiAgICBcdFx0XHRwbGFuZXMubGVuZ3RoICE9PSAwIHx8XG4gICAgXHRcdFx0ZW5hYmxlTG9jYWxDbGlwcGluZyB8fFxuICAgIFx0XHRcdC8vIGVuYWJsZSBzdGF0ZSBvZiBwcmV2aW91cyBmcmFtZSAtIHRoZSBjbGlwcGluZyBjb2RlIGhhcyB0b1xuICAgIFx0XHRcdC8vIHJ1biBhbm90aGVyIGZyYW1lIGluIG9yZGVyIHRvIHJlc2V0IHRoZSBzdGF0ZTpcbiAgICBcdFx0XHRudW1HbG9iYWxQbGFuZXMgIT09IDAgfHxcbiAgICBcdFx0XHRsb2NhbENsaXBwaW5nRW5hYmxlZDtcblxuICAgIFx0XHRsb2NhbENsaXBwaW5nRW5hYmxlZCA9IGVuYWJsZUxvY2FsQ2xpcHBpbmc7XG5cbiAgICBcdFx0Z2xvYmFsU3RhdGUgPSBwcm9qZWN0UGxhbmVzKCBwbGFuZXMsIGNhbWVyYSwgMCApO1xuICAgIFx0XHRudW1HbG9iYWxQbGFuZXMgPSBwbGFuZXMubGVuZ3RoO1xuXG4gICAgXHRcdHJldHVybiBlbmFibGVkO1xuXG4gICAgXHR9O1xuXG4gICAgXHR0aGlzLmJlZ2luU2hhZG93cyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgXHRcdHJlbmRlcmluZ1NoYWRvd3MgPSB0cnVlO1xuICAgIFx0XHRwcm9qZWN0UGxhbmVzKCBudWxsICk7XG5cbiAgICBcdH07XG5cbiAgICBcdHRoaXMuZW5kU2hhZG93cyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgXHRcdHJlbmRlcmluZ1NoYWRvd3MgPSBmYWxzZTtcbiAgICBcdFx0cmVzZXRHbG9iYWxTdGF0ZSgpO1xuXG4gICAgXHR9O1xuXG4gICAgXHR0aGlzLnNldFN0YXRlID0gZnVuY3Rpb24oIHBsYW5lcywgY2xpcFNoYWRvd3MsIGNhbWVyYSwgY2FjaGUsIGZyb21DYWNoZSApIHtcblxuICAgIFx0XHRpZiAoICEgbG9jYWxDbGlwcGluZ0VuYWJsZWQgfHxcbiAgICBcdFx0XHRcdHBsYW5lcyA9PT0gbnVsbCB8fCBwbGFuZXMubGVuZ3RoID09PSAwIHx8XG4gICAgXHRcdFx0XHRyZW5kZXJpbmdTaGFkb3dzICYmICEgY2xpcFNoYWRvd3MgKSB7XG4gICAgXHRcdFx0Ly8gdGhlcmUncyBubyBsb2NhbCBjbGlwcGluZ1xuXG4gICAgXHRcdFx0aWYgKCByZW5kZXJpbmdTaGFkb3dzICkge1xuICAgIFx0XHRcdFx0Ly8gdGhlcmUncyBubyBnbG9iYWwgY2xpcHBpbmdcblxuICAgIFx0XHRcdFx0cHJvamVjdFBsYW5lcyggbnVsbCApO1xuXG4gICAgXHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0cmVzZXRHbG9iYWxTdGF0ZSgpO1xuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0dmFyIG5HbG9iYWwgPSByZW5kZXJpbmdTaGFkb3dzID8gMCA6IG51bUdsb2JhbFBsYW5lcyxcbiAgICBcdFx0XHRcdGxHbG9iYWwgPSBuR2xvYmFsICogNCxcblxuICAgIFx0XHRcdFx0ZHN0QXJyYXkgPSBjYWNoZS5jbGlwcGluZ1N0YXRlIHx8IG51bGw7XG5cbiAgICBcdFx0XHR1bmlmb3JtLnZhbHVlID0gZHN0QXJyYXk7IC8vIGVuc3VyZSB1bmlxdWUgc3RhdGVcblxuICAgIFx0XHRcdGRzdEFycmF5ID0gcHJvamVjdFBsYW5lcyggcGxhbmVzLCBjYW1lcmEsIGxHbG9iYWwsIGZyb21DYWNoZSApO1xuXG4gICAgXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpICE9PSBsR2xvYmFsOyArKyBpICkge1xuXG4gICAgXHRcdFx0XHRkc3RBcnJheVsgaSBdID0gZ2xvYmFsU3RhdGVbIGkgXTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGNhY2hlLmNsaXBwaW5nU3RhdGUgPSBkc3RBcnJheTtcbiAgICBcdFx0XHR0aGlzLm51bVBsYW5lcyArPSBuR2xvYmFsO1xuXG4gICAgXHRcdH1cblxuXG4gICAgXHR9O1xuXG4gICAgXHRmdW5jdGlvbiByZXNldEdsb2JhbFN0YXRlKCkge1xuXG4gICAgXHRcdGlmICggdW5pZm9ybS52YWx1ZSAhPT0gZ2xvYmFsU3RhdGUgKSB7XG5cbiAgICBcdFx0XHR1bmlmb3JtLnZhbHVlID0gZ2xvYmFsU3RhdGU7XG4gICAgXHRcdFx0dW5pZm9ybS5uZWVkc1VwZGF0ZSA9IG51bUdsb2JhbFBsYW5lcyA+IDA7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHNjb3BlLm51bVBsYW5lcyA9IG51bUdsb2JhbFBsYW5lcztcblxuICAgIFx0fVxuXG4gICAgXHRmdW5jdGlvbiBwcm9qZWN0UGxhbmVzKCBwbGFuZXMsIGNhbWVyYSwgZHN0T2Zmc2V0LCBza2lwVHJhbnNmb3JtICkge1xuXG4gICAgXHRcdHZhciBuUGxhbmVzID0gcGxhbmVzICE9PSBudWxsID8gcGxhbmVzLmxlbmd0aCA6IDAsXG4gICAgXHRcdFx0ZHN0QXJyYXkgPSBudWxsO1xuXG4gICAgXHRcdGlmICggblBsYW5lcyAhPT0gMCApIHtcblxuICAgIFx0XHRcdGRzdEFycmF5ID0gdW5pZm9ybS52YWx1ZTtcblxuICAgIFx0XHRcdGlmICggc2tpcFRyYW5zZm9ybSAhPT0gdHJ1ZSB8fCBkc3RBcnJheSA9PT0gbnVsbCApIHtcblxuICAgIFx0XHRcdFx0dmFyIGZsYXRTaXplID0gZHN0T2Zmc2V0ICsgblBsYW5lcyAqIDQsXG4gICAgXHRcdFx0XHRcdHZpZXdNYXRyaXggPSBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlO1xuXG4gICAgXHRcdFx0XHR2aWV3Tm9ybWFsTWF0cml4LmdldE5vcm1hbE1hdHJpeCggdmlld01hdHJpeCApO1xuXG4gICAgXHRcdFx0XHRpZiAoIGRzdEFycmF5ID09PSBudWxsIHx8IGRzdEFycmF5Lmxlbmd0aCA8IGZsYXRTaXplICkge1xuXG4gICAgXHRcdFx0XHRcdGRzdEFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggZmxhdFNpemUgKTtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGk0ID0gZHN0T2Zmc2V0O1xuICAgIFx0XHRcdFx0XHRcdFx0XHRcdGkgIT09IG5QbGFuZXM7ICsrIGksIGk0ICs9IDQgKSB7XG5cbiAgICBcdFx0XHRcdFx0cGxhbmUuY29weSggcGxhbmVzWyBpIF0gKS5cbiAgICBcdFx0XHRcdFx0XHRcdGFwcGx5TWF0cml4NCggdmlld01hdHJpeCwgdmlld05vcm1hbE1hdHJpeCApO1xuXG4gICAgXHRcdFx0XHRcdHBsYW5lLm5vcm1hbC50b0FycmF5KCBkc3RBcnJheSwgaTQgKTtcbiAgICBcdFx0XHRcdFx0ZHN0QXJyYXlbIGk0ICsgMyBdID0gcGxhbmUuY29uc3RhbnQ7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdHVuaWZvcm0udmFsdWUgPSBkc3RBcnJheTtcbiAgICBcdFx0XHR1bmlmb3JtLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0c2NvcGUubnVtUGxhbmVzID0gblBsYW5lcztcbiAgICBcdFx0cmV0dXJuIGRzdEFycmF5O1xuXG4gICAgXHR9XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIHN1cGVyZWdnYmVydCAvIGh0dHA6Ly93d3cucGF1bGJydW50LmNvLnVrL1xuICAgICAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gICAgICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAgICAgKiBAYXV0aG9yIHN6aW1layAvIGh0dHBzOi8vZ2l0aHViLmNvbS9zemltZWsvXG4gICAgICogQGF1dGhvciB0c2Nod1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gV2ViR0xSZW5kZXJlciggcGFyYW1ldGVycyApIHtcblxuICAgIFx0Y29uc29sZS5sb2coICdUSFJFRS5XZWJHTFJlbmRlcmVyJywgUkVWSVNJT04gKTtcblxuICAgIFx0cGFyYW1ldGVycyA9IHBhcmFtZXRlcnMgfHwge307XG5cbiAgICBcdHZhciBfY2FudmFzID0gcGFyYW1ldGVycy5jYW52YXMgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuY2FudmFzIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCcsICdjYW52YXMnICksXG4gICAgXHRfY29udGV4dCA9IHBhcmFtZXRlcnMuY29udGV4dCAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5jb250ZXh0IDogbnVsbCxcblxuICAgIFx0X2FscGhhID0gcGFyYW1ldGVycy5hbHBoYSAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5hbHBoYSA6IGZhbHNlLFxuICAgIFx0X2RlcHRoID0gcGFyYW1ldGVycy5kZXB0aCAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5kZXB0aCA6IHRydWUsXG4gICAgXHRfc3RlbmNpbCA9IHBhcmFtZXRlcnMuc3RlbmNpbCAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5zdGVuY2lsIDogdHJ1ZSxcbiAgICBcdF9hbnRpYWxpYXMgPSBwYXJhbWV0ZXJzLmFudGlhbGlhcyAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5hbnRpYWxpYXMgOiBmYWxzZSxcbiAgICBcdF9wcmVtdWx0aXBsaWVkQWxwaGEgPSBwYXJhbWV0ZXJzLnByZW11bHRpcGxpZWRBbHBoYSAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5wcmVtdWx0aXBsaWVkQWxwaGEgOiB0cnVlLFxuICAgIFx0X3ByZXNlcnZlRHJhd2luZ0J1ZmZlciA9IHBhcmFtZXRlcnMucHJlc2VydmVEcmF3aW5nQnVmZmVyICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLnByZXNlcnZlRHJhd2luZ0J1ZmZlciA6IGZhbHNlO1xuXG4gICAgXHR2YXIgbGlnaHRzID0gW107XG5cbiAgICBcdHZhciBvcGFxdWVPYmplY3RzID0gW107XG4gICAgXHR2YXIgb3BhcXVlT2JqZWN0c0xhc3RJbmRleCA9IC0gMTtcbiAgICBcdHZhciB0cmFuc3BhcmVudE9iamVjdHMgPSBbXTtcbiAgICBcdHZhciB0cmFuc3BhcmVudE9iamVjdHNMYXN0SW5kZXggPSAtIDE7XG5cbiAgICBcdHZhciBtb3JwaEluZmx1ZW5jZXMgPSBuZXcgRmxvYXQzMkFycmF5KCA4ICk7XG5cbiAgICBcdHZhciBzcHJpdGVzID0gW107XG4gICAgXHR2YXIgbGVuc0ZsYXJlcyA9IFtdO1xuXG4gICAgXHQvLyBwdWJsaWMgcHJvcGVydGllc1xuXG4gICAgXHR0aGlzLmRvbUVsZW1lbnQgPSBfY2FudmFzO1xuICAgIFx0dGhpcy5jb250ZXh0ID0gbnVsbDtcblxuICAgIFx0Ly8gY2xlYXJpbmdcblxuICAgIFx0dGhpcy5hdXRvQ2xlYXIgPSB0cnVlO1xuICAgIFx0dGhpcy5hdXRvQ2xlYXJDb2xvciA9IHRydWU7XG4gICAgXHR0aGlzLmF1dG9DbGVhckRlcHRoID0gdHJ1ZTtcbiAgICBcdHRoaXMuYXV0b0NsZWFyU3RlbmNpbCA9IHRydWU7XG5cbiAgICBcdC8vIHNjZW5lIGdyYXBoXG5cbiAgICBcdHRoaXMuc29ydE9iamVjdHMgPSB0cnVlO1xuXG4gICAgXHQvLyB1c2VyLWRlZmluZWQgY2xpcHBpbmdcblxuICAgIFx0dGhpcy5jbGlwcGluZ1BsYW5lcyA9IFtdO1xuICAgIFx0dGhpcy5sb2NhbENsaXBwaW5nRW5hYmxlZCA9IGZhbHNlO1xuXG4gICAgXHQvLyBwaHlzaWNhbGx5IGJhc2VkIHNoYWRpbmdcblxuICAgIFx0dGhpcy5nYW1tYUZhY3RvciA9IDIuMDtcdC8vIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgIFx0dGhpcy5nYW1tYUlucHV0ID0gZmFsc2U7XG4gICAgXHR0aGlzLmdhbW1hT3V0cHV0ID0gZmFsc2U7XG5cbiAgICBcdC8vIHBoeXNpY2FsIGxpZ2h0c1xuXG4gICAgXHR0aGlzLnBoeXNpY2FsbHlDb3JyZWN0TGlnaHRzID0gZmFsc2U7XG5cbiAgICBcdC8vIHRvbmUgbWFwcGluZ1xuXG4gICAgXHR0aGlzLnRvbmVNYXBwaW5nID0gTGluZWFyVG9uZU1hcHBpbmc7XG4gICAgXHR0aGlzLnRvbmVNYXBwaW5nRXhwb3N1cmUgPSAxLjA7XG4gICAgXHR0aGlzLnRvbmVNYXBwaW5nV2hpdGVQb2ludCA9IDEuMDtcblxuICAgIFx0Ly8gbW9ycGhzXG5cbiAgICBcdHRoaXMubWF4TW9ycGhUYXJnZXRzID0gODtcbiAgICBcdHRoaXMubWF4TW9ycGhOb3JtYWxzID0gNDtcblxuICAgIFx0Ly8gaW50ZXJuYWwgcHJvcGVydGllc1xuXG4gICAgXHR2YXIgX3RoaXMgPSB0aGlzLFxuXG4gICAgXHQvLyBpbnRlcm5hbCBzdGF0ZSBjYWNoZVxuXG4gICAgXHRfY3VycmVudFByb2dyYW0gPSBudWxsLFxuICAgIFx0X2N1cnJlbnRSZW5kZXJUYXJnZXQgPSBudWxsLFxuICAgIFx0X2N1cnJlbnRGcmFtZWJ1ZmZlciA9IG51bGwsXG4gICAgXHRfY3VycmVudE1hdGVyaWFsSWQgPSAtIDEsXG4gICAgXHRfY3VycmVudEdlb21ldHJ5UHJvZ3JhbSA9ICcnLFxuICAgIFx0X2N1cnJlbnRDYW1lcmEgPSBudWxsLFxuXG4gICAgXHRfY3VycmVudFNjaXNzb3IgPSBuZXcgVmVjdG9yNCgpLFxuICAgIFx0X2N1cnJlbnRTY2lzc29yVGVzdCA9IG51bGwsXG5cbiAgICBcdF9jdXJyZW50Vmlld3BvcnQgPSBuZXcgVmVjdG9yNCgpLFxuXG4gICAgXHQvL1xuXG4gICAgXHRfdXNlZFRleHR1cmVVbml0cyA9IDAsXG5cbiAgICBcdC8vXG5cbiAgICBcdF9jbGVhckNvbG9yID0gbmV3IENvbG9yKCAweDAwMDAwMCApLFxuICAgIFx0X2NsZWFyQWxwaGEgPSAwLFxuXG4gICAgXHRfd2lkdGggPSBfY2FudmFzLndpZHRoLFxuICAgIFx0X2hlaWdodCA9IF9jYW52YXMuaGVpZ2h0LFxuXG4gICAgXHRfcGl4ZWxSYXRpbyA9IDEsXG5cbiAgICBcdF9zY2lzc29yID0gbmV3IFZlY3RvcjQoIDAsIDAsIF93aWR0aCwgX2hlaWdodCApLFxuICAgIFx0X3NjaXNzb3JUZXN0ID0gZmFsc2UsXG5cbiAgICBcdF92aWV3cG9ydCA9IG5ldyBWZWN0b3I0KCAwLCAwLCBfd2lkdGgsIF9oZWlnaHQgKSxcblxuICAgIFx0Ly8gZnJ1c3R1bVxuXG4gICAgXHRfZnJ1c3R1bSA9IG5ldyBGcnVzdHVtKCksXG5cbiAgICBcdC8vIGNsaXBwaW5nXG5cbiAgICBcdF9jbGlwcGluZyA9IG5ldyBXZWJHTENsaXBwaW5nKCksXG4gICAgXHRfY2xpcHBpbmdFbmFibGVkID0gZmFsc2UsXG4gICAgXHRfbG9jYWxDbGlwcGluZ0VuYWJsZWQgPSBmYWxzZSxcblxuICAgIFx0X3NwaGVyZSA9IG5ldyBTcGhlcmUoKSxcblxuICAgIFx0Ly8gY2FtZXJhIG1hdHJpY2VzIGNhY2hlXG5cbiAgICBcdF9wcm9qU2NyZWVuTWF0cml4ID0gbmV3IE1hdHJpeDQoKSxcblxuICAgIFx0X3ZlY3RvcjMgPSBuZXcgVmVjdG9yMygpLFxuXG4gICAgXHQvLyBsaWdodCBhcnJheXMgY2FjaGVcblxuICAgIFx0X2xpZ2h0cyA9IHtcblxuICAgIFx0XHRoYXNoOiAnJyxcblxuICAgIFx0XHRhbWJpZW50OiBbIDAsIDAsIDAgXSxcbiAgICBcdFx0ZGlyZWN0aW9uYWw6IFtdLFxuICAgIFx0XHRkaXJlY3Rpb25hbFNoYWRvd01hcDogW10sXG4gICAgXHRcdGRpcmVjdGlvbmFsU2hhZG93TWF0cml4OiBbXSxcbiAgICBcdFx0c3BvdDogW10sXG4gICAgXHRcdHNwb3RTaGFkb3dNYXA6IFtdLFxuICAgIFx0XHRzcG90U2hhZG93TWF0cml4OiBbXSxcbiAgICBcdFx0cG9pbnQ6IFtdLFxuICAgIFx0XHRwb2ludFNoYWRvd01hcDogW10sXG4gICAgXHRcdHBvaW50U2hhZG93TWF0cml4OiBbXSxcbiAgICBcdFx0aGVtaTogW10sXG5cbiAgICBcdFx0c2hhZG93czogW11cblxuICAgIFx0fSxcblxuICAgIFx0Ly8gaW5mb1xuXG4gICAgXHRfaW5mb1JlbmRlciA9IHtcblxuICAgIFx0XHRjYWxsczogMCxcbiAgICBcdFx0dmVydGljZXM6IDAsXG4gICAgXHRcdGZhY2VzOiAwLFxuICAgIFx0XHRwb2ludHM6IDBcblxuICAgIFx0fTtcblxuICAgIFx0dGhpcy5pbmZvID0ge1xuXG4gICAgXHRcdHJlbmRlcjogX2luZm9SZW5kZXIsXG4gICAgXHRcdG1lbW9yeToge1xuXG4gICAgXHRcdFx0Z2VvbWV0cmllczogMCxcbiAgICBcdFx0XHR0ZXh0dXJlczogMFxuXG4gICAgXHRcdH0sXG4gICAgXHRcdHByb2dyYW1zOiBudWxsXG5cbiAgICBcdH07XG5cblxuICAgIFx0Ly8gaW5pdGlhbGl6ZVxuXG4gICAgXHR2YXIgX2dsO1xuXG4gICAgXHR0cnkge1xuXG4gICAgXHRcdHZhciBhdHRyaWJ1dGVzID0ge1xuICAgIFx0XHRcdGFscGhhOiBfYWxwaGEsXG4gICAgXHRcdFx0ZGVwdGg6IF9kZXB0aCxcbiAgICBcdFx0XHRzdGVuY2lsOiBfc3RlbmNpbCxcbiAgICBcdFx0XHRhbnRpYWxpYXM6IF9hbnRpYWxpYXMsXG4gICAgXHRcdFx0cHJlbXVsdGlwbGllZEFscGhhOiBfcHJlbXVsdGlwbGllZEFscGhhLFxuICAgIFx0XHRcdHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogX3ByZXNlcnZlRHJhd2luZ0J1ZmZlclxuICAgIFx0XHR9O1xuXG4gICAgXHRcdF9nbCA9IF9jb250ZXh0IHx8IF9jYW52YXMuZ2V0Q29udGV4dCggJ3dlYmdsJywgYXR0cmlidXRlcyApIHx8IF9jYW52YXMuZ2V0Q29udGV4dCggJ2V4cGVyaW1lbnRhbC13ZWJnbCcsIGF0dHJpYnV0ZXMgKTtcblxuICAgIFx0XHRpZiAoIF9nbCA9PT0gbnVsbCApIHtcblxuICAgIFx0XHRcdGlmICggX2NhbnZhcy5nZXRDb250ZXh0KCAnd2ViZ2wnICkgIT09IG51bGwgKSB7XG5cbiAgICBcdFx0XHRcdHRocm93ICdFcnJvciBjcmVhdGluZyBXZWJHTCBjb250ZXh0IHdpdGggeW91ciBzZWxlY3RlZCBhdHRyaWJ1dGVzLic7XG5cbiAgICBcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHR0aHJvdyAnRXJyb3IgY3JlYXRpbmcgV2ViR0wgY29udGV4dC4nO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHQvLyBTb21lIGV4cGVyaW1lbnRhbC13ZWJnbCBpbXBsZW1lbnRhdGlvbnMgZG8gbm90IGhhdmUgZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0XG5cbiAgICBcdFx0aWYgKCBfZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0ID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRfZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0ID0gZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdFx0XHRyZXR1cm4geyAncmFuZ2VNaW4nOiAxLCAncmFuZ2VNYXgnOiAxLCAncHJlY2lzaW9uJzogMSB9O1xuXG4gICAgXHRcdFx0fTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0X2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCAnd2ViZ2xjb250ZXh0bG9zdCcsIG9uQ29udGV4dExvc3QsIGZhbHNlICk7XG5cbiAgICBcdH0gY2F0Y2ggKCBlcnJvciApIHtcblxuICAgIFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogJyArIGVycm9yICk7XG5cbiAgICBcdH1cblxuICAgIFx0dmFyIGV4dGVuc2lvbnMgPSBuZXcgV2ViR0xFeHRlbnNpb25zKCBfZ2wgKTtcblxuICAgIFx0ZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9kZXB0aF90ZXh0dXJlJyApO1xuICAgIFx0ZXh0ZW5zaW9ucy5nZXQoICdPRVNfdGV4dHVyZV9mbG9hdCcgKTtcbiAgICBcdGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyJyApO1xuICAgIFx0ZXh0ZW5zaW9ucy5nZXQoICdPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0JyApO1xuICAgIFx0ZXh0ZW5zaW9ucy5nZXQoICdPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0X2xpbmVhcicgKTtcbiAgICBcdGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzJyApO1xuICAgIFx0ZXh0ZW5zaW9ucy5nZXQoICdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJyApO1xuXG4gICAgXHRpZiAoIGV4dGVuc2lvbnMuZ2V0KCAnT0VTX2VsZW1lbnRfaW5kZXhfdWludCcgKSApIHtcblxuICAgIFx0XHRCdWZmZXJHZW9tZXRyeS5NYXhJbmRleCA9IDQyOTQ5NjcyOTY7XG5cbiAgICBcdH1cblxuICAgIFx0dmFyIGNhcGFiaWxpdGllcyA9IG5ldyBXZWJHTENhcGFiaWxpdGllcyggX2dsLCBleHRlbnNpb25zLCBwYXJhbWV0ZXJzICk7XG5cbiAgICBcdHZhciBzdGF0ZSA9IG5ldyBXZWJHTFN0YXRlKCBfZ2wsIGV4dGVuc2lvbnMsIHBhcmFtVGhyZWVUb0dMICk7XG4gICAgXHR2YXIgcHJvcGVydGllcyA9IG5ldyBXZWJHTFByb3BlcnRpZXMoKTtcbiAgICBcdHZhciB0ZXh0dXJlcyA9IG5ldyBXZWJHTFRleHR1cmVzKCBfZ2wsIGV4dGVuc2lvbnMsIHN0YXRlLCBwcm9wZXJ0aWVzLCBjYXBhYmlsaXRpZXMsIHBhcmFtVGhyZWVUb0dMLCB0aGlzLmluZm8gKTtcbiAgICBcdHZhciBvYmplY3RzID0gbmV3IFdlYkdMT2JqZWN0cyggX2dsLCBwcm9wZXJ0aWVzLCB0aGlzLmluZm8gKTtcbiAgICBcdHZhciBwcm9ncmFtQ2FjaGUgPSBuZXcgV2ViR0xQcm9ncmFtcyggdGhpcywgY2FwYWJpbGl0aWVzICk7XG4gICAgXHR2YXIgbGlnaHRDYWNoZSA9IG5ldyBXZWJHTExpZ2h0cygpO1xuXG4gICAgXHR0aGlzLmluZm8ucHJvZ3JhbXMgPSBwcm9ncmFtQ2FjaGUucHJvZ3JhbXM7XG5cbiAgICBcdHZhciBidWZmZXJSZW5kZXJlciA9IG5ldyBXZWJHTEJ1ZmZlclJlbmRlcmVyKCBfZ2wsIGV4dGVuc2lvbnMsIF9pbmZvUmVuZGVyICk7XG4gICAgXHR2YXIgaW5kZXhlZEJ1ZmZlclJlbmRlcmVyID0gbmV3IFdlYkdMSW5kZXhlZEJ1ZmZlclJlbmRlcmVyKCBfZ2wsIGV4dGVuc2lvbnMsIF9pbmZvUmVuZGVyICk7XG5cbiAgICBcdC8vXG5cbiAgICBcdHZhciBiYWNrZ3JvdW5kQ2FtZXJhID0gbmV3IE9ydGhvZ3JhcGhpY0NhbWVyYSggLSAxLCAxLCAxLCAtIDEsIDAsIDEgKTtcbiAgICBcdHZhciBiYWNrZ3JvdW5kQ2FtZXJhMiA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSgpO1xuICAgIFx0dmFyIGJhY2tncm91bmRQbGFuZU1lc2ggPSBuZXcgTWVzaChcbiAgICBcdFx0bmV3IFBsYW5lQnVmZmVyR2VvbWV0cnkoIDIsIDIgKSxcbiAgICBcdFx0bmV3IE1lc2hCYXNpY01hdGVyaWFsKCB7IGRlcHRoVGVzdDogZmFsc2UsIGRlcHRoV3JpdGU6IGZhbHNlLCBmb2c6IGZhbHNlIH0gKVxuICAgIFx0KTtcbiAgICBcdHZhciBiYWNrZ3JvdW5kQm94U2hhZGVyID0gU2hhZGVyTGliWyAnY3ViZScgXTtcbiAgICBcdHZhciBiYWNrZ3JvdW5kQm94TWVzaCA9IG5ldyBNZXNoKFxuICAgIFx0XHRuZXcgQm94QnVmZmVyR2VvbWV0cnkoIDUsIDUsIDUgKSxcbiAgICBcdFx0bmV3IFNoYWRlck1hdGVyaWFsKCB7XG4gICAgXHRcdFx0dW5pZm9ybXM6IGJhY2tncm91bmRCb3hTaGFkZXIudW5pZm9ybXMsXG4gICAgXHRcdFx0dmVydGV4U2hhZGVyOiBiYWNrZ3JvdW5kQm94U2hhZGVyLnZlcnRleFNoYWRlcixcbiAgICBcdFx0XHRmcmFnbWVudFNoYWRlcjogYmFja2dyb3VuZEJveFNoYWRlci5mcmFnbWVudFNoYWRlcixcbiAgICBcdFx0XHRzaWRlOiBCYWNrU2lkZSxcbiAgICBcdFx0XHRkZXB0aFRlc3Q6IGZhbHNlLFxuICAgIFx0XHRcdGRlcHRoV3JpdGU6IGZhbHNlLFxuICAgIFx0XHRcdGZvZzogZmFsc2VcbiAgICBcdFx0fSApXG4gICAgXHQpO1xuXG4gICAgXHQvL1xuXG4gICAgXHRmdW5jdGlvbiBnZXRUYXJnZXRQaXhlbFJhdGlvKCkge1xuXG4gICAgXHRcdHJldHVybiBfY3VycmVudFJlbmRlclRhcmdldCA9PT0gbnVsbCA/IF9waXhlbFJhdGlvIDogMTtcblxuICAgIFx0fVxuXG4gICAgXHRmdW5jdGlvbiBnbENsZWFyQ29sb3IoIHIsIGcsIGIsIGEgKSB7XG5cbiAgICBcdFx0aWYgKCBfcHJlbXVsdGlwbGllZEFscGhhID09PSB0cnVlICkge1xuXG4gICAgXHRcdFx0ciAqPSBhOyBnICo9IGE7IGIgKj0gYTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0c3RhdGUuY2xlYXJDb2xvciggciwgZywgYiwgYSApO1xuXG4gICAgXHR9XG5cbiAgICBcdGZ1bmN0aW9uIHNldERlZmF1bHRHTFN0YXRlKCkge1xuXG4gICAgXHRcdHN0YXRlLmluaXQoKTtcblxuICAgIFx0XHRzdGF0ZS5zY2lzc29yKCBfY3VycmVudFNjaXNzb3IuY29weSggX3NjaXNzb3IgKS5tdWx0aXBseVNjYWxhciggX3BpeGVsUmF0aW8gKSApO1xuICAgIFx0XHRzdGF0ZS52aWV3cG9ydCggX2N1cnJlbnRWaWV3cG9ydC5jb3B5KCBfdmlld3BvcnQgKS5tdWx0aXBseVNjYWxhciggX3BpeGVsUmF0aW8gKSApO1xuXG4gICAgXHRcdGdsQ2xlYXJDb2xvciggX2NsZWFyQ29sb3IuciwgX2NsZWFyQ29sb3IuZywgX2NsZWFyQ29sb3IuYiwgX2NsZWFyQWxwaGEgKTtcblxuICAgIFx0fVxuXG4gICAgXHRmdW5jdGlvbiByZXNldEdMU3RhdGUoKSB7XG5cbiAgICBcdFx0X2N1cnJlbnRQcm9ncmFtID0gbnVsbDtcbiAgICBcdFx0X2N1cnJlbnRDYW1lcmEgPSBudWxsO1xuXG4gICAgXHRcdF9jdXJyZW50R2VvbWV0cnlQcm9ncmFtID0gJyc7XG4gICAgXHRcdF9jdXJyZW50TWF0ZXJpYWxJZCA9IC0gMTtcblxuICAgIFx0XHRzdGF0ZS5yZXNldCgpO1xuXG4gICAgXHR9XG5cbiAgICBcdHNldERlZmF1bHRHTFN0YXRlKCk7XG5cbiAgICBcdHRoaXMuY29udGV4dCA9IF9nbDtcbiAgICBcdHRoaXMuY2FwYWJpbGl0aWVzID0gY2FwYWJpbGl0aWVzO1xuICAgIFx0dGhpcy5leHRlbnNpb25zID0gZXh0ZW5zaW9ucztcbiAgICBcdHRoaXMucHJvcGVydGllcyA9IHByb3BlcnRpZXM7XG4gICAgXHR0aGlzLnN0YXRlID0gc3RhdGU7XG5cbiAgICBcdC8vIHNoYWRvdyBtYXBcblxuICAgIFx0dmFyIHNoYWRvd01hcCA9IG5ldyBXZWJHTFNoYWRvd01hcCggdGhpcywgX2xpZ2h0cywgb2JqZWN0cywgY2FwYWJpbGl0aWVzICk7XG5cbiAgICBcdHRoaXMuc2hhZG93TWFwID0gc2hhZG93TWFwO1xuXG5cbiAgICBcdC8vIFBsdWdpbnNcblxuICAgIFx0dmFyIHNwcml0ZVBsdWdpbiA9IG5ldyBTcHJpdGVQbHVnaW4oIHRoaXMsIHNwcml0ZXMgKTtcbiAgICBcdHZhciBsZW5zRmxhcmVQbHVnaW4gPSBuZXcgTGVuc0ZsYXJlUGx1Z2luKCB0aGlzLCBsZW5zRmxhcmVzICk7XG5cbiAgICBcdC8vIEFQSVxuXG4gICAgXHR0aGlzLmdldENvbnRleHQgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0cmV0dXJuIF9nbDtcblxuICAgIFx0fTtcblxuICAgIFx0dGhpcy5nZXRDb250ZXh0QXR0cmlidXRlcyA9IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHRyZXR1cm4gX2dsLmdldENvbnRleHRBdHRyaWJ1dGVzKCk7XG5cbiAgICBcdH07XG5cbiAgICBcdHRoaXMuZm9yY2VDb250ZXh0TG9zcyA9IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHRleHRlbnNpb25zLmdldCggJ1dFQkdMX2xvc2VfY29udGV4dCcgKS5sb3NlQ29udGV4dCgpO1xuXG4gICAgXHR9O1xuXG4gICAgXHR0aGlzLmdldE1heEFuaXNvdHJvcHkgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0cmV0dXJuIGNhcGFiaWxpdGllcy5nZXRNYXhBbmlzb3Ryb3B5KCk7XG5cbiAgICBcdH07XG5cbiAgICBcdHRoaXMuZ2V0UHJlY2lzaW9uID0gZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHJldHVybiBjYXBhYmlsaXRpZXMucHJlY2lzaW9uO1xuXG4gICAgXHR9O1xuXG4gICAgXHR0aGlzLmdldFBpeGVsUmF0aW8gPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0cmV0dXJuIF9waXhlbFJhdGlvO1xuXG4gICAgXHR9O1xuXG4gICAgXHR0aGlzLnNldFBpeGVsUmF0aW8gPSBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG4gICAgXHRcdGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCApIHJldHVybjtcblxuICAgIFx0XHRfcGl4ZWxSYXRpbyA9IHZhbHVlO1xuXG4gICAgXHRcdHRoaXMuc2V0U2l6ZSggX3ZpZXdwb3J0LnosIF92aWV3cG9ydC53LCBmYWxzZSApO1xuXG4gICAgXHR9O1xuXG4gICAgXHR0aGlzLmdldFNpemUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0cmV0dXJuIHtcbiAgICBcdFx0XHR3aWR0aDogX3dpZHRoLFxuICAgIFx0XHRcdGhlaWdodDogX2hlaWdodFxuICAgIFx0XHR9O1xuXG4gICAgXHR9O1xuXG4gICAgXHR0aGlzLnNldFNpemUgPSBmdW5jdGlvbiAoIHdpZHRoLCBoZWlnaHQsIHVwZGF0ZVN0eWxlICkge1xuXG4gICAgXHRcdF93aWR0aCA9IHdpZHRoO1xuICAgIFx0XHRfaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgXHRcdF9jYW52YXMud2lkdGggPSB3aWR0aCAqIF9waXhlbFJhdGlvO1xuICAgIFx0XHRfY2FudmFzLmhlaWdodCA9IGhlaWdodCAqIF9waXhlbFJhdGlvO1xuXG4gICAgXHRcdGlmICggdXBkYXRlU3R5bGUgIT09IGZhbHNlICkge1xuXG4gICAgXHRcdFx0X2NhbnZhcy5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICBcdFx0XHRfY2FudmFzLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHRoaXMuc2V0Vmlld3BvcnQoIDAsIDAsIHdpZHRoLCBoZWlnaHQgKTtcblxuICAgIFx0fTtcblxuICAgIFx0dGhpcy5zZXRWaWV3cG9ydCA9IGZ1bmN0aW9uICggeCwgeSwgd2lkdGgsIGhlaWdodCApIHtcblxuICAgIFx0XHRzdGF0ZS52aWV3cG9ydCggX3ZpZXdwb3J0LnNldCggeCwgeSwgd2lkdGgsIGhlaWdodCApICk7XG5cbiAgICBcdH07XG5cbiAgICBcdHRoaXMuc2V0U2Npc3NvciA9IGZ1bmN0aW9uICggeCwgeSwgd2lkdGgsIGhlaWdodCApIHtcblxuICAgIFx0XHRzdGF0ZS5zY2lzc29yKCBfc2Npc3Nvci5zZXQoIHgsIHksIHdpZHRoLCBoZWlnaHQgKSApO1xuXG4gICAgXHR9O1xuXG4gICAgXHR0aGlzLnNldFNjaXNzb3JUZXN0ID0gZnVuY3Rpb24gKCBib29sZWFuICkge1xuXG4gICAgXHRcdHN0YXRlLnNldFNjaXNzb3JUZXN0KCBfc2Npc3NvclRlc3QgPSBib29sZWFuICk7XG5cbiAgICBcdH07XG5cbiAgICBcdC8vIENsZWFyaW5nXG5cbiAgICBcdHRoaXMuZ2V0Q2xlYXJDb2xvciA9IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHRyZXR1cm4gX2NsZWFyQ29sb3I7XG5cbiAgICBcdH07XG5cbiAgICBcdHRoaXMuc2V0Q2xlYXJDb2xvciA9IGZ1bmN0aW9uICggY29sb3IsIGFscGhhICkge1xuXG4gICAgXHRcdF9jbGVhckNvbG9yLnNldCggY29sb3IgKTtcblxuICAgIFx0XHRfY2xlYXJBbHBoYSA9IGFscGhhICE9PSB1bmRlZmluZWQgPyBhbHBoYSA6IDE7XG5cbiAgICBcdFx0Z2xDbGVhckNvbG9yKCBfY2xlYXJDb2xvci5yLCBfY2xlYXJDb2xvci5nLCBfY2xlYXJDb2xvci5iLCBfY2xlYXJBbHBoYSApO1xuXG4gICAgXHR9O1xuXG4gICAgXHR0aGlzLmdldENsZWFyQWxwaGEgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0cmV0dXJuIF9jbGVhckFscGhhO1xuXG4gICAgXHR9O1xuXG4gICAgXHR0aGlzLnNldENsZWFyQWxwaGEgPSBmdW5jdGlvbiAoIGFscGhhICkge1xuXG4gICAgXHRcdF9jbGVhckFscGhhID0gYWxwaGE7XG5cbiAgICBcdFx0Z2xDbGVhckNvbG9yKCBfY2xlYXJDb2xvci5yLCBfY2xlYXJDb2xvci5nLCBfY2xlYXJDb2xvci5iLCBfY2xlYXJBbHBoYSApO1xuXG4gICAgXHR9O1xuXG4gICAgXHR0aGlzLmNsZWFyID0gZnVuY3Rpb24gKCBjb2xvciwgZGVwdGgsIHN0ZW5jaWwgKSB7XG5cbiAgICBcdFx0dmFyIGJpdHMgPSAwO1xuXG4gICAgXHRcdGlmICggY29sb3IgPT09IHVuZGVmaW5lZCB8fCBjb2xvciApIGJpdHMgfD0gX2dsLkNPTE9SX0JVRkZFUl9CSVQ7XG4gICAgXHRcdGlmICggZGVwdGggPT09IHVuZGVmaW5lZCB8fCBkZXB0aCApIGJpdHMgfD0gX2dsLkRFUFRIX0JVRkZFUl9CSVQ7XG4gICAgXHRcdGlmICggc3RlbmNpbCA9PT0gdW5kZWZpbmVkIHx8IHN0ZW5jaWwgKSBiaXRzIHw9IF9nbC5TVEVOQ0lMX0JVRkZFUl9CSVQ7XG5cbiAgICBcdFx0X2dsLmNsZWFyKCBiaXRzICk7XG5cbiAgICBcdH07XG5cbiAgICBcdHRoaXMuY2xlYXJDb2xvciA9IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR0aGlzLmNsZWFyKCB0cnVlLCBmYWxzZSwgZmFsc2UgKTtcblxuICAgIFx0fTtcblxuICAgIFx0dGhpcy5jbGVhckRlcHRoID0gZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHRoaXMuY2xlYXIoIGZhbHNlLCB0cnVlLCBmYWxzZSApO1xuXG4gICAgXHR9O1xuXG4gICAgXHR0aGlzLmNsZWFyU3RlbmNpbCA9IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR0aGlzLmNsZWFyKCBmYWxzZSwgZmFsc2UsIHRydWUgKTtcblxuICAgIFx0fTtcblxuICAgIFx0dGhpcy5jbGVhclRhcmdldCA9IGZ1bmN0aW9uICggcmVuZGVyVGFyZ2V0LCBjb2xvciwgZGVwdGgsIHN0ZW5jaWwgKSB7XG5cbiAgICBcdFx0dGhpcy5zZXRSZW5kZXJUYXJnZXQoIHJlbmRlclRhcmdldCApO1xuICAgIFx0XHR0aGlzLmNsZWFyKCBjb2xvciwgZGVwdGgsIHN0ZW5jaWwgKTtcblxuICAgIFx0fTtcblxuICAgIFx0Ly8gUmVzZXRcblxuICAgIFx0dGhpcy5yZXNldEdMU3RhdGUgPSByZXNldEdMU3RhdGU7XG5cbiAgICBcdHRoaXMuZGlzcG9zZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgXHRcdHRyYW5zcGFyZW50T2JqZWN0cyA9IFtdO1xuICAgIFx0XHR0cmFuc3BhcmVudE9iamVjdHNMYXN0SW5kZXggPSAtMTtcbiAgICBcdFx0b3BhcXVlT2JqZWN0cyA9IFtdO1xuICAgIFx0XHRvcGFxdWVPYmplY3RzTGFzdEluZGV4ID0gLTE7XG5cbiAgICBcdFx0X2NhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCAnd2ViZ2xjb250ZXh0bG9zdCcsIG9uQ29udGV4dExvc3QsIGZhbHNlICk7XG5cbiAgICBcdH07XG5cbiAgICBcdC8vIEV2ZW50c1xuXG4gICAgXHRmdW5jdGlvbiBvbkNvbnRleHRMb3N0KCBldmVudCApIHtcblxuICAgIFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgXHRcdHJlc2V0R0xTdGF0ZSgpO1xuICAgIFx0XHRzZXREZWZhdWx0R0xTdGF0ZSgpO1xuXG4gICAgXHRcdHByb3BlcnRpZXMuY2xlYXIoKTtcblxuICAgIFx0fVxuXG4gICAgXHRmdW5jdGlvbiBvbk1hdGVyaWFsRGlzcG9zZSggZXZlbnQgKSB7XG5cbiAgICBcdFx0dmFyIG1hdGVyaWFsID0gZXZlbnQudGFyZ2V0O1xuXG4gICAgXHRcdG1hdGVyaWFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25NYXRlcmlhbERpc3Bvc2UgKTtcblxuICAgIFx0XHRkZWFsbG9jYXRlTWF0ZXJpYWwoIG1hdGVyaWFsICk7XG5cbiAgICBcdH1cblxuICAgIFx0Ly8gQnVmZmVyIGRlYWxsb2NhdGlvblxuXG4gICAgXHRmdW5jdGlvbiBkZWFsbG9jYXRlTWF0ZXJpYWwoIG1hdGVyaWFsICkge1xuXG4gICAgXHRcdHJlbGVhc2VNYXRlcmlhbFByb2dyYW1SZWZlcmVuY2UoIG1hdGVyaWFsICk7XG5cbiAgICBcdFx0cHJvcGVydGllcy5kZWxldGUoIG1hdGVyaWFsICk7XG5cbiAgICBcdH1cblxuXG4gICAgXHRmdW5jdGlvbiByZWxlYXNlTWF0ZXJpYWxQcm9ncmFtUmVmZXJlbmNlKCBtYXRlcmlhbCApIHtcblxuICAgIFx0XHR2YXIgcHJvZ3JhbUluZm8gPSBwcm9wZXJ0aWVzLmdldCggbWF0ZXJpYWwgKS5wcm9ncmFtO1xuXG4gICAgXHRcdG1hdGVyaWFsLnByb2dyYW0gPSB1bmRlZmluZWQ7XG5cbiAgICBcdFx0aWYgKCBwcm9ncmFtSW5mbyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0cHJvZ3JhbUNhY2hlLnJlbGVhc2VQcm9ncmFtKCBwcm9ncmFtSW5mbyApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0fVxuXG4gICAgXHQvLyBCdWZmZXIgcmVuZGVyaW5nXG5cbiAgICBcdHRoaXMucmVuZGVyQnVmZmVySW1tZWRpYXRlID0gZnVuY3Rpb24gKCBvYmplY3QsIHByb2dyYW0sIG1hdGVyaWFsICkge1xuXG4gICAgXHRcdHN0YXRlLmluaXRBdHRyaWJ1dGVzKCk7XG5cbiAgICBcdFx0dmFyIGJ1ZmZlcnMgPSBwcm9wZXJ0aWVzLmdldCggb2JqZWN0ICk7XG5cbiAgICBcdFx0aWYgKCBvYmplY3QuaGFzUG9zaXRpb25zICYmICEgYnVmZmVycy5wb3NpdGlvbiApIGJ1ZmZlcnMucG9zaXRpb24gPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgXHRcdGlmICggb2JqZWN0Lmhhc05vcm1hbHMgJiYgISBidWZmZXJzLm5vcm1hbCApIGJ1ZmZlcnMubm9ybWFsID0gX2dsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIFx0XHRpZiAoIG9iamVjdC5oYXNVdnMgJiYgISBidWZmZXJzLnV2ICkgYnVmZmVycy51diA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBcdFx0aWYgKCBvYmplY3QuaGFzQ29sb3JzICYmICEgYnVmZmVycy5jb2xvciApIGJ1ZmZlcnMuY29sb3IgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XG5cbiAgICBcdFx0dmFyIGF0dHJpYnV0ZXMgPSBwcm9ncmFtLmdldEF0dHJpYnV0ZXMoKTtcblxuICAgIFx0XHRpZiAoIG9iamVjdC5oYXNQb3NpdGlvbnMgKSB7XG5cbiAgICBcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgYnVmZmVycy5wb3NpdGlvbiApO1xuICAgIFx0XHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCBvYmplY3QucG9zaXRpb25BcnJheSwgX2dsLkRZTkFNSUNfRFJBVyApO1xuXG4gICAgXHRcdFx0c3RhdGUuZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLnBvc2l0aW9uICk7XG4gICAgXHRcdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMucG9zaXRpb24sIDMsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIDAgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKCBvYmplY3QuaGFzTm9ybWFscyApIHtcblxuICAgIFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXJzLm5vcm1hbCApO1xuXG4gICAgXHRcdFx0aWYgKCAhIG1hdGVyaWFsLmlzTWVzaFBob25nTWF0ZXJpYWwgJiZcbiAgICBcdFx0XHQgICAgICEgbWF0ZXJpYWwuaXNNZXNoU3RhbmRhcmRNYXRlcmlhbCAmJlxuICAgIFx0XHRcdCAgICAgICBtYXRlcmlhbC5zaGFkaW5nID09PSBGbGF0U2hhZGluZyApIHtcblxuICAgIFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gb2JqZWN0LmNvdW50ICogMzsgaSA8IGw7IGkgKz0gOSApIHtcblxuICAgIFx0XHRcdFx0XHR2YXIgYXJyYXkgPSBvYmplY3Qubm9ybWFsQXJyYXk7XG5cbiAgICBcdFx0XHRcdFx0dmFyIG54ID0gKCBhcnJheVsgaSArIDAgXSArIGFycmF5WyBpICsgMyBdICsgYXJyYXlbIGkgKyA2IF0gKSAvIDM7XG4gICAgXHRcdFx0XHRcdHZhciBueSA9ICggYXJyYXlbIGkgKyAxIF0gKyBhcnJheVsgaSArIDQgXSArIGFycmF5WyBpICsgNyBdICkgLyAzO1xuICAgIFx0XHRcdFx0XHR2YXIgbnogPSAoIGFycmF5WyBpICsgMiBdICsgYXJyYXlbIGkgKyA1IF0gKyBhcnJheVsgaSArIDggXSApIC8gMztcblxuICAgIFx0XHRcdFx0XHRhcnJheVsgaSArIDAgXSA9IG54O1xuICAgIFx0XHRcdFx0XHRhcnJheVsgaSArIDEgXSA9IG55O1xuICAgIFx0XHRcdFx0XHRhcnJheVsgaSArIDIgXSA9IG56O1xuXG4gICAgXHRcdFx0XHRcdGFycmF5WyBpICsgMyBdID0gbng7XG4gICAgXHRcdFx0XHRcdGFycmF5WyBpICsgNCBdID0gbnk7XG4gICAgXHRcdFx0XHRcdGFycmF5WyBpICsgNSBdID0gbno7XG5cbiAgICBcdFx0XHRcdFx0YXJyYXlbIGkgKyA2IF0gPSBueDtcbiAgICBcdFx0XHRcdFx0YXJyYXlbIGkgKyA3IF0gPSBueTtcbiAgICBcdFx0XHRcdFx0YXJyYXlbIGkgKyA4IF0gPSBuejtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIG9iamVjdC5ub3JtYWxBcnJheSwgX2dsLkRZTkFNSUNfRFJBVyApO1xuXG4gICAgXHRcdFx0c3RhdGUuZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLm5vcm1hbCApO1xuXG4gICAgXHRcdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMubm9ybWFsLCAzLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCAwICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGlmICggb2JqZWN0Lmhhc1V2cyAmJiBtYXRlcmlhbC5tYXAgKSB7XG5cbiAgICBcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgYnVmZmVycy51diApO1xuICAgIFx0XHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCBvYmplY3QudXZBcnJheSwgX2dsLkRZTkFNSUNfRFJBVyApO1xuXG4gICAgXHRcdFx0c3RhdGUuZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLnV2ICk7XG5cbiAgICBcdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy51diwgMiwgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoIG9iamVjdC5oYXNDb2xvcnMgJiYgbWF0ZXJpYWwudmVydGV4Q29sb3JzICE9PSBOb0NvbG9ycyApIHtcblxuICAgIFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXJzLmNvbG9yICk7XG4gICAgXHRcdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIG9iamVjdC5jb2xvckFycmF5LCBfZ2wuRFlOQU1JQ19EUkFXICk7XG5cbiAgICBcdFx0XHRzdGF0ZS5lbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMuY29sb3IgKTtcblxuICAgIFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLmNvbG9yLCAzLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCAwICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHN0YXRlLmRpc2FibGVVbnVzZWRBdHRyaWJ1dGVzKCk7XG5cbiAgICBcdFx0X2dsLmRyYXdBcnJheXMoIF9nbC5UUklBTkdMRVMsIDAsIG9iamVjdC5jb3VudCApO1xuXG4gICAgXHRcdG9iamVjdC5jb3VudCA9IDA7XG5cbiAgICBcdH07XG5cbiAgICBcdHRoaXMucmVuZGVyQnVmZmVyRGlyZWN0ID0gZnVuY3Rpb24gKCBjYW1lcmEsIGZvZywgZ2VvbWV0cnksIG1hdGVyaWFsLCBvYmplY3QsIGdyb3VwICkge1xuXG4gICAgXHRcdHNldE1hdGVyaWFsKCBtYXRlcmlhbCApO1xuXG4gICAgXHRcdHZhciBwcm9ncmFtID0gc2V0UHJvZ3JhbSggY2FtZXJhLCBmb2csIG1hdGVyaWFsLCBvYmplY3QgKTtcblxuICAgIFx0XHR2YXIgdXBkYXRlQnVmZmVycyA9IGZhbHNlO1xuICAgIFx0XHR2YXIgZ2VvbWV0cnlQcm9ncmFtID0gZ2VvbWV0cnkuaWQgKyAnXycgKyBwcm9ncmFtLmlkICsgJ18nICsgbWF0ZXJpYWwud2lyZWZyYW1lO1xuXG4gICAgXHRcdGlmICggZ2VvbWV0cnlQcm9ncmFtICE9PSBfY3VycmVudEdlb21ldHJ5UHJvZ3JhbSApIHtcblxuICAgIFx0XHRcdF9jdXJyZW50R2VvbWV0cnlQcm9ncmFtID0gZ2VvbWV0cnlQcm9ncmFtO1xuICAgIFx0XHRcdHVwZGF0ZUJ1ZmZlcnMgPSB0cnVlO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHQvLyBtb3JwaCB0YXJnZXRzXG5cbiAgICBcdFx0dmFyIG1vcnBoVGFyZ2V0SW5mbHVlbmNlcyA9IG9iamVjdC5tb3JwaFRhcmdldEluZmx1ZW5jZXM7XG5cbiAgICBcdFx0aWYgKCBtb3JwaFRhcmdldEluZmx1ZW5jZXMgIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdHZhciBhY3RpdmVJbmZsdWVuY2VzID0gW107XG5cbiAgICBcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBtb3JwaFRhcmdldEluZmx1ZW5jZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgIFx0XHRcdFx0dmFyIGluZmx1ZW5jZSA9IG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgaSBdO1xuICAgIFx0XHRcdFx0YWN0aXZlSW5mbHVlbmNlcy5wdXNoKCBbIGluZmx1ZW5jZSwgaSBdICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRhY3RpdmVJbmZsdWVuY2VzLnNvcnQoIGFic051bWVyaWNhbFNvcnQgKTtcblxuICAgIFx0XHRcdGlmICggYWN0aXZlSW5mbHVlbmNlcy5sZW5ndGggPiA4ICkge1xuXG4gICAgXHRcdFx0XHRhY3RpdmVJbmZsdWVuY2VzLmxlbmd0aCA9IDg7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHR2YXIgbW9ycGhBdHRyaWJ1dGVzID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzO1xuXG4gICAgXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gYWN0aXZlSW5mbHVlbmNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgXHRcdFx0XHR2YXIgaW5mbHVlbmNlID0gYWN0aXZlSW5mbHVlbmNlc1sgaSBdO1xuICAgIFx0XHRcdFx0bW9ycGhJbmZsdWVuY2VzWyBpIF0gPSBpbmZsdWVuY2VbIDAgXTtcblxuICAgIFx0XHRcdFx0aWYgKCBpbmZsdWVuY2VbIDAgXSAhPT0gMCApIHtcblxuICAgIFx0XHRcdFx0XHR2YXIgaW5kZXggPSBpbmZsdWVuY2VbIDEgXTtcblxuICAgIFx0XHRcdFx0XHRpZiAoIG1hdGVyaWFsLm1vcnBoVGFyZ2V0cyA9PT0gdHJ1ZSAmJiBtb3JwaEF0dHJpYnV0ZXMucG9zaXRpb24gKSBnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdtb3JwaFRhcmdldCcgKyBpLCBtb3JwaEF0dHJpYnV0ZXMucG9zaXRpb25bIGluZGV4IF0gKTtcbiAgICBcdFx0XHRcdFx0aWYgKCBtYXRlcmlhbC5tb3JwaE5vcm1hbHMgPT09IHRydWUgJiYgbW9ycGhBdHRyaWJ1dGVzLm5vcm1hbCApIGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ21vcnBoTm9ybWFsJyArIGksIG1vcnBoQXR0cmlidXRlcy5ub3JtYWxbIGluZGV4IF0gKTtcblxuICAgIFx0XHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0XHRpZiAoIG1hdGVyaWFsLm1vcnBoVGFyZ2V0cyA9PT0gdHJ1ZSApIGdlb21ldHJ5LnJlbW92ZUF0dHJpYnV0ZSggJ21vcnBoVGFyZ2V0JyArIGkgKTtcbiAgICBcdFx0XHRcdFx0aWYgKCBtYXRlcmlhbC5tb3JwaE5vcm1hbHMgPT09IHRydWUgKSBnZW9tZXRyeS5yZW1vdmVBdHRyaWJ1dGUoICdtb3JwaE5vcm1hbCcgKyBpICk7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGZvciAoIHZhciBpID0gYWN0aXZlSW5mbHVlbmNlcy5sZW5ndGgsIGlsID0gbW9ycGhJbmZsdWVuY2VzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgXHRcdFx0XHRtb3JwaEluZmx1ZW5jZXNbIGkgXSA9IDAuMDtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdHByb2dyYW0uZ2V0VW5pZm9ybXMoKS5zZXRWYWx1ZShcbiAgICBcdFx0XHRcdFx0X2dsLCAnbW9ycGhUYXJnZXRJbmZsdWVuY2VzJywgbW9ycGhJbmZsdWVuY2VzICk7XG5cbiAgICBcdFx0XHR1cGRhdGVCdWZmZXJzID0gdHJ1ZTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0Ly9cblxuICAgIFx0XHR2YXIgaW5kZXggPSBnZW9tZXRyeS5pbmRleDtcbiAgICBcdFx0dmFyIHBvc2l0aW9uID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcbiAgICBcdFx0dmFyIHJhbmdlRmFjdG9yID0gMTtcblxuICAgIFx0XHRpZiAoIG1hdGVyaWFsLndpcmVmcmFtZSA9PT0gdHJ1ZSApIHtcblxuICAgIFx0XHRcdGluZGV4ID0gb2JqZWN0cy5nZXRXaXJlZnJhbWVBdHRyaWJ1dGUoIGdlb21ldHJ5ICk7XG4gICAgXHRcdFx0cmFuZ2VGYWN0b3IgPSAyO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHR2YXIgcmVuZGVyZXI7XG5cbiAgICBcdFx0aWYgKCBpbmRleCAhPT0gbnVsbCApIHtcblxuICAgIFx0XHRcdHJlbmRlcmVyID0gaW5kZXhlZEJ1ZmZlclJlbmRlcmVyO1xuICAgIFx0XHRcdHJlbmRlcmVyLnNldEluZGV4KCBpbmRleCApO1xuXG4gICAgXHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRyZW5kZXJlciA9IGJ1ZmZlclJlbmRlcmVyO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoIHVwZGF0ZUJ1ZmZlcnMgKSB7XG5cbiAgICBcdFx0XHRzZXR1cFZlcnRleEF0dHJpYnV0ZXMoIG1hdGVyaWFsLCBwcm9ncmFtLCBnZW9tZXRyeSApO1xuXG4gICAgXHRcdFx0aWYgKCBpbmRleCAhPT0gbnVsbCApIHtcblxuICAgIFx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgb2JqZWN0cy5nZXRBdHRyaWJ1dGVCdWZmZXIoIGluZGV4ICkgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdFx0Ly9cblxuICAgIFx0XHR2YXIgZGF0YUNvdW50ID0gMDtcblxuICAgIFx0XHRpZiAoIGluZGV4ICE9PSBudWxsICkge1xuXG4gICAgXHRcdFx0ZGF0YUNvdW50ID0gaW5kZXguY291bnQ7XG5cbiAgICBcdFx0fSBlbHNlIGlmICggcG9zaXRpb24gIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdGRhdGFDb3VudCA9IHBvc2l0aW9uLmNvdW50O1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHR2YXIgcmFuZ2VTdGFydCA9IGdlb21ldHJ5LmRyYXdSYW5nZS5zdGFydCAqIHJhbmdlRmFjdG9yO1xuICAgIFx0XHR2YXIgcmFuZ2VDb3VudCA9IGdlb21ldHJ5LmRyYXdSYW5nZS5jb3VudCAqIHJhbmdlRmFjdG9yO1xuXG4gICAgXHRcdHZhciBncm91cFN0YXJ0ID0gZ3JvdXAgIT09IG51bGwgPyBncm91cC5zdGFydCAqIHJhbmdlRmFjdG9yIDogMDtcbiAgICBcdFx0dmFyIGdyb3VwQ291bnQgPSBncm91cCAhPT0gbnVsbCA/IGdyb3VwLmNvdW50ICogcmFuZ2VGYWN0b3IgOiBJbmZpbml0eTtcblxuICAgIFx0XHR2YXIgZHJhd1N0YXJ0ID0gTWF0aC5tYXgoIHJhbmdlU3RhcnQsIGdyb3VwU3RhcnQgKTtcbiAgICBcdFx0dmFyIGRyYXdFbmQgPSBNYXRoLm1pbiggZGF0YUNvdW50LCByYW5nZVN0YXJ0ICsgcmFuZ2VDb3VudCwgZ3JvdXBTdGFydCArIGdyb3VwQ291bnQgKSAtIDE7XG5cbiAgICBcdFx0dmFyIGRyYXdDb3VudCA9IE1hdGgubWF4KCAwLCBkcmF3RW5kIC0gZHJhd1N0YXJ0ICsgMSApO1xuXG4gICAgXHRcdGlmICggZHJhd0NvdW50ID09PSAwICkgcmV0dXJuO1xuXG4gICAgXHRcdC8vXG5cbiAgICBcdFx0aWYgKCBvYmplY3QuaXNNZXNoICkge1xuXG4gICAgXHRcdFx0aWYgKCBtYXRlcmlhbC53aXJlZnJhbWUgPT09IHRydWUgKSB7XG5cbiAgICBcdFx0XHRcdHN0YXRlLnNldExpbmVXaWR0aCggbWF0ZXJpYWwud2lyZWZyYW1lTGluZXdpZHRoICogZ2V0VGFyZ2V0UGl4ZWxSYXRpbygpICk7XG4gICAgXHRcdFx0XHRyZW5kZXJlci5zZXRNb2RlKCBfZ2wuTElORVMgKTtcblxuICAgIFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdHN3aXRjaCAoIG9iamVjdC5kcmF3TW9kZSApIHtcblxuICAgIFx0XHRcdFx0XHRjYXNlIFRyaWFuZ2xlc0RyYXdNb2RlOlxuICAgIFx0XHRcdFx0XHRcdHJlbmRlcmVyLnNldE1vZGUoIF9nbC5UUklBTkdMRVMgKTtcbiAgICBcdFx0XHRcdFx0XHRicmVhaztcblxuICAgIFx0XHRcdFx0XHRjYXNlIFRyaWFuZ2xlU3RyaXBEcmF3TW9kZTpcbiAgICBcdFx0XHRcdFx0XHRyZW5kZXJlci5zZXRNb2RlKCBfZ2wuVFJJQU5HTEVfU1RSSVAgKTtcbiAgICBcdFx0XHRcdFx0XHRicmVhaztcblxuICAgIFx0XHRcdFx0XHRjYXNlIFRyaWFuZ2xlRmFuRHJhd01vZGU6XG4gICAgXHRcdFx0XHRcdFx0cmVuZGVyZXIuc2V0TW9kZSggX2dsLlRSSUFOR0xFX0ZBTiApO1xuICAgIFx0XHRcdFx0XHRcdGJyZWFrO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9XG5cblxuICAgIFx0XHR9IGVsc2UgaWYgKCBvYmplY3QuaXNMaW5lICkge1xuXG4gICAgXHRcdFx0dmFyIGxpbmVXaWR0aCA9IG1hdGVyaWFsLmxpbmV3aWR0aDtcblxuICAgIFx0XHRcdGlmICggbGluZVdpZHRoID09PSB1bmRlZmluZWQgKSBsaW5lV2lkdGggPSAxOyAvLyBOb3QgdXNpbmcgTGluZSpNYXRlcmlhbFxuXG4gICAgXHRcdFx0c3RhdGUuc2V0TGluZVdpZHRoKCBsaW5lV2lkdGggKiBnZXRUYXJnZXRQaXhlbFJhdGlvKCkgKTtcblxuICAgIFx0XHRcdGlmICggb2JqZWN0LmlzTGluZVNlZ21lbnRzICkge1xuXG4gICAgXHRcdFx0XHRyZW5kZXJlci5zZXRNb2RlKCBfZ2wuTElORVMgKTtcblxuICAgIFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdHJlbmRlcmVyLnNldE1vZGUoIF9nbC5MSU5FX1NUUklQICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fSBlbHNlIGlmICggb2JqZWN0LmlzUG9pbnRzICkge1xuXG4gICAgXHRcdFx0cmVuZGVyZXIuc2V0TW9kZSggX2dsLlBPSU5UUyApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoIGdlb21ldHJ5ICYmIGdlb21ldHJ5LmlzSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkgKSB7XG5cbiAgICBcdFx0XHRpZiAoIGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50ID4gMCApIHtcblxuICAgIFx0XHRcdFx0cmVuZGVyZXIucmVuZGVySW5zdGFuY2VzKCBnZW9tZXRyeSwgZHJhd1N0YXJ0LCBkcmF3Q291bnQgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0cmVuZGVyZXIucmVuZGVyKCBkcmF3U3RhcnQsIGRyYXdDb3VudCApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0fTtcblxuICAgIFx0ZnVuY3Rpb24gc2V0dXBWZXJ0ZXhBdHRyaWJ1dGVzKCBtYXRlcmlhbCwgcHJvZ3JhbSwgZ2VvbWV0cnksIHN0YXJ0SW5kZXggKSB7XG5cbiAgICBcdFx0dmFyIGV4dGVuc2lvbjtcblxuICAgIFx0XHRpZiAoIGdlb21ldHJ5ICYmIGdlb21ldHJ5LmlzSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkgKSB7XG5cbiAgICBcdFx0XHRleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMnICk7XG5cbiAgICBcdFx0XHRpZiAoIGV4dGVuc2lvbiA9PT0gbnVsbCApIHtcblxuICAgIFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMUmVuZGVyZXIuc2V0dXBWZXJ0ZXhBdHRyaWJ1dGVzOiB1c2luZyBUSFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSBidXQgaGFyZHdhcmUgZG9lcyBub3Qgc3VwcG9ydCBleHRlbnNpb24gQU5HTEVfaW5zdGFuY2VkX2FycmF5cy4nICk7XG4gICAgXHRcdFx0XHRyZXR1cm47XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGlmICggc3RhcnRJbmRleCA9PT0gdW5kZWZpbmVkICkgc3RhcnRJbmRleCA9IDA7XG5cbiAgICBcdFx0c3RhdGUuaW5pdEF0dHJpYnV0ZXMoKTtcblxuICAgIFx0XHR2YXIgZ2VvbWV0cnlBdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcblxuICAgIFx0XHR2YXIgcHJvZ3JhbUF0dHJpYnV0ZXMgPSBwcm9ncmFtLmdldEF0dHJpYnV0ZXMoKTtcblxuICAgIFx0XHR2YXIgbWF0ZXJpYWxEZWZhdWx0QXR0cmlidXRlVmFsdWVzID0gbWF0ZXJpYWwuZGVmYXVsdEF0dHJpYnV0ZVZhbHVlcztcblxuICAgIFx0XHRmb3IgKCB2YXIgbmFtZSBpbiBwcm9ncmFtQXR0cmlidXRlcyApIHtcblxuICAgIFx0XHRcdHZhciBwcm9ncmFtQXR0cmlidXRlID0gcHJvZ3JhbUF0dHJpYnV0ZXNbIG5hbWUgXTtcblxuICAgIFx0XHRcdGlmICggcHJvZ3JhbUF0dHJpYnV0ZSA+PSAwICkge1xuXG4gICAgXHRcdFx0XHR2YXIgZ2VvbWV0cnlBdHRyaWJ1dGUgPSBnZW9tZXRyeUF0dHJpYnV0ZXNbIG5hbWUgXTtcblxuICAgIFx0XHRcdFx0aWYgKCBnZW9tZXRyeUF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0XHRcdHZhciB0eXBlID0gX2dsLkZMT0FUO1xuICAgIFx0XHRcdFx0XHR2YXIgYXJyYXkgPSBnZW9tZXRyeUF0dHJpYnV0ZS5hcnJheTtcbiAgICBcdFx0XHRcdFx0dmFyIG5vcm1hbGl6ZWQgPSBnZW9tZXRyeUF0dHJpYnV0ZS5ub3JtYWxpemVkO1xuXG4gICAgXHRcdFx0XHRcdGlmICggYXJyYXkgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHR0eXBlID0gX2dsLkZMT0FUO1xuXG4gICAgXHRcdFx0XHRcdH0gZWxzZSBpZiAoIGFycmF5IGluc3RhbmNlb2YgRmxvYXQ2NEFycmF5ICkge1xuXG4gICAgXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCBcIlVuc3VwcG9ydGVkIGRhdGEgYnVmZmVyIGZvcm1hdDogRmxvYXQ2NEFycmF5XCIgKTtcblxuICAgIFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBhcnJheSBpbnN0YW5jZW9mIFVpbnQxNkFycmF5ICkge1xuXG4gICAgXHRcdFx0XHRcdFx0dHlwZSA9IF9nbC5VTlNJR05FRF9TSE9SVDtcblxuICAgIFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBhcnJheSBpbnN0YW5jZW9mIEludDE2QXJyYXkgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHR0eXBlID0gX2dsLlNIT1JUO1xuXG4gICAgXHRcdFx0XHRcdH0gZWxzZSBpZiAoIGFycmF5IGluc3RhbmNlb2YgVWludDMyQXJyYXkgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHR0eXBlID0gX2dsLlVOU0lHTkVEX0lOVDtcblxuICAgIFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBhcnJheSBpbnN0YW5jZW9mIEludDMyQXJyYXkgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHR0eXBlID0gX2dsLklOVDtcblxuICAgIFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBhcnJheSBpbnN0YW5jZW9mIEludDhBcnJheSApIHtcblxuICAgIFx0XHRcdFx0XHRcdHR5cGUgPSBfZ2wuQllURTtcblxuICAgIFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBhcnJheSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHR0eXBlID0gX2dsLlVOU0lHTkVEX0JZVEU7XG5cbiAgICBcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRcdHZhciBzaXplID0gZ2VvbWV0cnlBdHRyaWJ1dGUuaXRlbVNpemU7XG4gICAgXHRcdFx0XHRcdHZhciBidWZmZXIgPSBvYmplY3RzLmdldEF0dHJpYnV0ZUJ1ZmZlciggZ2VvbWV0cnlBdHRyaWJ1dGUgKTtcblxuICAgIFx0XHRcdFx0XHRpZiAoIGdlb21ldHJ5QXR0cmlidXRlICYmIGdlb21ldHJ5QXR0cmlidXRlLmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHR2YXIgZGF0YSA9IGdlb21ldHJ5QXR0cmlidXRlLmRhdGE7XG4gICAgXHRcdFx0XHRcdFx0dmFyIHN0cmlkZSA9IGRhdGEuc3RyaWRlO1xuICAgIFx0XHRcdFx0XHRcdHZhciBvZmZzZXQgPSBnZW9tZXRyeUF0dHJpYnV0ZS5vZmZzZXQ7XG5cbiAgICBcdFx0XHRcdFx0XHRpZiAoIGRhdGEgJiYgZGF0YS5pc0luc3RhbmNlZEludGVybGVhdmVkQnVmZmVyICkge1xuXG4gICAgXHRcdFx0XHRcdFx0XHRzdGF0ZS5lbmFibGVBdHRyaWJ1dGVBbmREaXZpc29yKCBwcm9ncmFtQXR0cmlidXRlLCBkYXRhLm1lc2hQZXJBdHRyaWJ1dGUsIGV4dGVuc2lvbiApO1xuXG4gICAgXHRcdFx0XHRcdFx0XHRpZiAoIGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50ID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHRcdFx0Z2VvbWV0cnkubWF4SW5zdGFuY2VkQ291bnQgPSBkYXRhLm1lc2hQZXJBdHRyaWJ1dGUgKiBkYXRhLmNvdW50O1xuXG4gICAgXHRcdFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRcdFx0XHRzdGF0ZS5lbmFibGVBdHRyaWJ1dGUoIHByb2dyYW1BdHRyaWJ1dGUgKTtcblxuICAgIFx0XHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIgKTtcbiAgICBcdFx0XHRcdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggcHJvZ3JhbUF0dHJpYnV0ZSwgc2l6ZSwgdHlwZSwgbm9ybWFsaXplZCwgc3RyaWRlICogZGF0YS5hcnJheS5CWVRFU19QRVJfRUxFTUVOVCwgKCBzdGFydEluZGV4ICogc3RyaWRlICsgb2Zmc2V0ICkgKiBkYXRhLmFycmF5LkJZVEVTX1BFUl9FTEVNRU5UICk7XG5cbiAgICBcdFx0XHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0XHRcdGlmICggZ2VvbWV0cnlBdHRyaWJ1dGUgJiYgZ2VvbWV0cnlBdHRyaWJ1dGUuaXNJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHRcdHN0YXRlLmVuYWJsZUF0dHJpYnV0ZUFuZERpdmlzb3IoIHByb2dyYW1BdHRyaWJ1dGUsIGdlb21ldHJ5QXR0cmlidXRlLm1lc2hQZXJBdHRyaWJ1dGUsIGV4dGVuc2lvbiApO1xuXG4gICAgXHRcdFx0XHRcdFx0XHRpZiAoIGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50ID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHRcdFx0Z2VvbWV0cnkubWF4SW5zdGFuY2VkQ291bnQgPSBnZW9tZXRyeUF0dHJpYnV0ZS5tZXNoUGVyQXR0cmlidXRlICogZ2VvbWV0cnlBdHRyaWJ1dGUuY291bnQ7XG5cbiAgICBcdFx0XHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdFx0XHRcdHN0YXRlLmVuYWJsZUF0dHJpYnV0ZSggcHJvZ3JhbUF0dHJpYnV0ZSApO1xuXG4gICAgXHRcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlciApO1xuICAgIFx0XHRcdFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBwcm9ncmFtQXR0cmlidXRlLCBzaXplLCB0eXBlLCBub3JtYWxpemVkLCAwLCBzdGFydEluZGV4ICogc2l6ZSAqIGdlb21ldHJ5QXR0cmlidXRlLmFycmF5LkJZVEVTX1BFUl9FTEVNRU5UICk7XG5cbiAgICBcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbERlZmF1bHRBdHRyaWJ1dGVWYWx1ZXMgIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0XHR2YXIgdmFsdWUgPSBtYXRlcmlhbERlZmF1bHRBdHRyaWJ1dGVWYWx1ZXNbIG5hbWUgXTtcblxuICAgIFx0XHRcdFx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHRzd2l0Y2ggKCB2YWx1ZS5sZW5ndGggKSB7XG5cbiAgICBcdFx0XHRcdFx0XHRcdGNhc2UgMjpcbiAgICBcdFx0XHRcdFx0XHRcdFx0X2dsLnZlcnRleEF0dHJpYjJmdiggcHJvZ3JhbUF0dHJpYnV0ZSwgdmFsdWUgKTtcbiAgICBcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cbiAgICBcdFx0XHRcdFx0XHRcdGNhc2UgMzpcbiAgICBcdFx0XHRcdFx0XHRcdFx0X2dsLnZlcnRleEF0dHJpYjNmdiggcHJvZ3JhbUF0dHJpYnV0ZSwgdmFsdWUgKTtcbiAgICBcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cbiAgICBcdFx0XHRcdFx0XHRcdGNhc2UgNDpcbiAgICBcdFx0XHRcdFx0XHRcdFx0X2dsLnZlcnRleEF0dHJpYjRmdiggcHJvZ3JhbUF0dHJpYnV0ZSwgdmFsdWUgKTtcbiAgICBcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cbiAgICBcdFx0XHRcdFx0XHRcdGRlZmF1bHQ6XG4gICAgXHRcdFx0XHRcdFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWIxZnYoIHByb2dyYW1BdHRyaWJ1dGUsIHZhbHVlICk7XG5cbiAgICBcdFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHN0YXRlLmRpc2FibGVVbnVzZWRBdHRyaWJ1dGVzKCk7XG5cbiAgICBcdH1cblxuICAgIFx0Ly8gU29ydGluZ1xuXG4gICAgXHRmdW5jdGlvbiBhYnNOdW1lcmljYWxTb3J0KCBhLCBiICkge1xuXG4gICAgXHRcdHJldHVybiBNYXRoLmFicyggYlsgMCBdICkgLSBNYXRoLmFicyggYVsgMCBdICk7XG5cbiAgICBcdH1cblxuICAgIFx0ZnVuY3Rpb24gcGFpbnRlclNvcnRTdGFibGUoIGEsIGIgKSB7XG5cbiAgICBcdFx0aWYgKCBhLm9iamVjdC5yZW5kZXJPcmRlciAhPT0gYi5vYmplY3QucmVuZGVyT3JkZXIgKSB7XG5cbiAgICBcdFx0XHRyZXR1cm4gYS5vYmplY3QucmVuZGVyT3JkZXIgLSBiLm9iamVjdC5yZW5kZXJPcmRlcjtcblxuICAgIFx0XHR9IGVsc2UgaWYgKCBhLm1hdGVyaWFsLnByb2dyYW0gJiYgYi5tYXRlcmlhbC5wcm9ncmFtICYmIGEubWF0ZXJpYWwucHJvZ3JhbSAhPT0gYi5tYXRlcmlhbC5wcm9ncmFtICkge1xuXG4gICAgXHRcdFx0cmV0dXJuIGEubWF0ZXJpYWwucHJvZ3JhbS5pZCAtIGIubWF0ZXJpYWwucHJvZ3JhbS5pZDtcblxuICAgIFx0XHR9IGVsc2UgaWYgKCBhLm1hdGVyaWFsLmlkICE9PSBiLm1hdGVyaWFsLmlkICkge1xuXG4gICAgXHRcdFx0cmV0dXJuIGEubWF0ZXJpYWwuaWQgLSBiLm1hdGVyaWFsLmlkO1xuXG4gICAgXHRcdH0gZWxzZSBpZiAoIGEueiAhPT0gYi56ICkge1xuXG4gICAgXHRcdFx0cmV0dXJuIGEueiAtIGIuejtcblxuICAgIFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0cmV0dXJuIGEuaWQgLSBiLmlkO1xuXG4gICAgXHRcdH1cblxuICAgIFx0fVxuXG4gICAgXHRmdW5jdGlvbiByZXZlcnNlUGFpbnRlclNvcnRTdGFibGUoIGEsIGIgKSB7XG5cbiAgICBcdFx0aWYgKCBhLm9iamVjdC5yZW5kZXJPcmRlciAhPT0gYi5vYmplY3QucmVuZGVyT3JkZXIgKSB7XG5cbiAgICBcdFx0XHRyZXR1cm4gYS5vYmplY3QucmVuZGVyT3JkZXIgLSBiLm9iamVjdC5yZW5kZXJPcmRlcjtcblxuICAgIFx0XHR9IGlmICggYS56ICE9PSBiLnogKSB7XG5cbiAgICBcdFx0XHRyZXR1cm4gYi56IC0gYS56O1xuXG4gICAgXHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRyZXR1cm4gYS5pZCAtIGIuaWQ7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9XG5cbiAgICBcdC8vIFJlbmRlcmluZ1xuXG4gICAgXHR0aGlzLnJlbmRlciA9IGZ1bmN0aW9uICggc2NlbmUsIGNhbWVyYSwgcmVuZGVyVGFyZ2V0LCBmb3JjZUNsZWFyICkge1xuXG4gICAgXHRcdGlmICggY2FtZXJhICE9PSB1bmRlZmluZWQgJiYgY2FtZXJhLmlzQ2FtZXJhICE9PSB0cnVlICkge1xuXG4gICAgXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMUmVuZGVyZXIucmVuZGVyOiBjYW1lcmEgaXMgbm90IGFuIGluc3RhbmNlIG9mIFRIUkVFLkNhbWVyYS4nICk7XG4gICAgXHRcdFx0cmV0dXJuO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHR2YXIgZm9nID0gc2NlbmUuZm9nO1xuXG4gICAgXHRcdC8vIHJlc2V0IGNhY2hpbmcgZm9yIHRoaXMgZnJhbWVcblxuICAgIFx0XHRfY3VycmVudEdlb21ldHJ5UHJvZ3JhbSA9ICcnO1xuICAgIFx0XHRfY3VycmVudE1hdGVyaWFsSWQgPSAtIDE7XG4gICAgXHRcdF9jdXJyZW50Q2FtZXJhID0gbnVsbDtcblxuICAgIFx0XHQvLyB1cGRhdGUgc2NlbmUgZ3JhcGhcblxuICAgIFx0XHRpZiAoIHNjZW5lLmF1dG9VcGRhdGUgPT09IHRydWUgKSBzY2VuZS51cGRhdGVNYXRyaXhXb3JsZCgpO1xuXG4gICAgXHRcdC8vIHVwZGF0ZSBjYW1lcmEgbWF0cmljZXMgYW5kIGZydXN0dW1cblxuICAgIFx0XHRpZiAoIGNhbWVyYS5wYXJlbnQgPT09IG51bGwgKSBjYW1lcmEudXBkYXRlTWF0cml4V29ybGQoKTtcblxuICAgIFx0XHRjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLmdldEludmVyc2UoIGNhbWVyYS5tYXRyaXhXb3JsZCApO1xuXG4gICAgXHRcdF9wcm9qU2NyZWVuTWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4LCBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlICk7XG4gICAgXHRcdF9mcnVzdHVtLnNldEZyb21NYXRyaXgoIF9wcm9qU2NyZWVuTWF0cml4ICk7XG5cbiAgICBcdFx0bGlnaHRzLmxlbmd0aCA9IDA7XG5cbiAgICBcdFx0b3BhcXVlT2JqZWN0c0xhc3RJbmRleCA9IC0gMTtcbiAgICBcdFx0dHJhbnNwYXJlbnRPYmplY3RzTGFzdEluZGV4ID0gLSAxO1xuXG4gICAgXHRcdHNwcml0ZXMubGVuZ3RoID0gMDtcbiAgICBcdFx0bGVuc0ZsYXJlcy5sZW5ndGggPSAwO1xuXG4gICAgXHRcdF9sb2NhbENsaXBwaW5nRW5hYmxlZCA9IHRoaXMubG9jYWxDbGlwcGluZ0VuYWJsZWQ7XG4gICAgXHRcdF9jbGlwcGluZ0VuYWJsZWQgPSBfY2xpcHBpbmcuaW5pdCggdGhpcy5jbGlwcGluZ1BsYW5lcywgX2xvY2FsQ2xpcHBpbmdFbmFibGVkLCBjYW1lcmEgKTtcblxuICAgIFx0XHRwcm9qZWN0T2JqZWN0KCBzY2VuZSwgY2FtZXJhICk7XG5cbiAgICBcdFx0b3BhcXVlT2JqZWN0cy5sZW5ndGggPSBvcGFxdWVPYmplY3RzTGFzdEluZGV4ICsgMTtcbiAgICBcdFx0dHJhbnNwYXJlbnRPYmplY3RzLmxlbmd0aCA9IHRyYW5zcGFyZW50T2JqZWN0c0xhc3RJbmRleCArIDE7XG5cbiAgICBcdFx0aWYgKCBfdGhpcy5zb3J0T2JqZWN0cyA9PT0gdHJ1ZSApIHtcblxuICAgIFx0XHRcdG9wYXF1ZU9iamVjdHMuc29ydCggcGFpbnRlclNvcnRTdGFibGUgKTtcbiAgICBcdFx0XHR0cmFuc3BhcmVudE9iamVjdHMuc29ydCggcmV2ZXJzZVBhaW50ZXJTb3J0U3RhYmxlICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdC8vXG5cbiAgICBcdFx0aWYgKCBfY2xpcHBpbmdFbmFibGVkICkgX2NsaXBwaW5nLmJlZ2luU2hhZG93cygpO1xuXG4gICAgXHRcdHNldHVwU2hhZG93cyggbGlnaHRzICk7XG5cbiAgICBcdFx0c2hhZG93TWFwLnJlbmRlciggc2NlbmUsIGNhbWVyYSApO1xuXG4gICAgXHRcdHNldHVwTGlnaHRzKCBsaWdodHMsIGNhbWVyYSApO1xuXG4gICAgXHRcdGlmICggX2NsaXBwaW5nRW5hYmxlZCApIF9jbGlwcGluZy5lbmRTaGFkb3dzKCk7XG5cbiAgICBcdFx0Ly9cblxuICAgIFx0XHRfaW5mb1JlbmRlci5jYWxscyA9IDA7XG4gICAgXHRcdF9pbmZvUmVuZGVyLnZlcnRpY2VzID0gMDtcbiAgICBcdFx0X2luZm9SZW5kZXIuZmFjZXMgPSAwO1xuICAgIFx0XHRfaW5mb1JlbmRlci5wb2ludHMgPSAwO1xuXG4gICAgXHRcdGlmICggcmVuZGVyVGFyZ2V0ID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRyZW5kZXJUYXJnZXQgPSBudWxsO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHR0aGlzLnNldFJlbmRlclRhcmdldCggcmVuZGVyVGFyZ2V0ICk7XG5cbiAgICBcdFx0Ly9cblxuICAgIFx0XHR2YXIgYmFja2dyb3VuZCA9IHNjZW5lLmJhY2tncm91bmQ7XG5cbiAgICBcdFx0aWYgKCBiYWNrZ3JvdW5kID09PSBudWxsICkge1xuXG4gICAgXHRcdFx0Z2xDbGVhckNvbG9yKCBfY2xlYXJDb2xvci5yLCBfY2xlYXJDb2xvci5nLCBfY2xlYXJDb2xvci5iLCBfY2xlYXJBbHBoYSApO1xuXG4gICAgXHRcdH0gZWxzZSBpZiAoIGJhY2tncm91bmQgJiYgYmFja2dyb3VuZC5pc0NvbG9yICkge1xuXG4gICAgXHRcdFx0Z2xDbGVhckNvbG9yKCBiYWNrZ3JvdW5kLnIsIGJhY2tncm91bmQuZywgYmFja2dyb3VuZC5iLCAxICk7XG4gICAgXHRcdFx0Zm9yY2VDbGVhciA9IHRydWU7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGlmICggdGhpcy5hdXRvQ2xlYXIgfHwgZm9yY2VDbGVhciApIHtcblxuICAgIFx0XHRcdHRoaXMuY2xlYXIoIHRoaXMuYXV0b0NsZWFyQ29sb3IsIHRoaXMuYXV0b0NsZWFyRGVwdGgsIHRoaXMuYXV0b0NsZWFyU3RlbmNpbCApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoIGJhY2tncm91bmQgJiYgYmFja2dyb3VuZC5pc0N1YmVUZXh0dXJlICkge1xuXG4gICAgXHRcdFx0YmFja2dyb3VuZENhbWVyYTIucHJvamVjdGlvbk1hdHJpeC5jb3B5KCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeCApO1xuXG4gICAgXHRcdFx0YmFja2dyb3VuZENhbWVyYTIubWF0cml4V29ybGQuZXh0cmFjdFJvdGF0aW9uKCBjYW1lcmEubWF0cml4V29ybGQgKTtcbiAgICBcdFx0XHRiYWNrZ3JvdW5kQ2FtZXJhMi5tYXRyaXhXb3JsZEludmVyc2UuZ2V0SW52ZXJzZSggYmFja2dyb3VuZENhbWVyYTIubWF0cml4V29ybGQgKTtcblxuICAgIFx0XHRcdGJhY2tncm91bmRCb3hNZXNoLm1hdGVyaWFsLnVuaWZvcm1zWyBcInRDdWJlXCIgXS52YWx1ZSA9IGJhY2tncm91bmQ7XG4gICAgXHRcdFx0YmFja2dyb3VuZEJveE1lc2gubW9kZWxWaWV3TWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIGJhY2tncm91bmRDYW1lcmEyLm1hdHJpeFdvcmxkSW52ZXJzZSwgYmFja2dyb3VuZEJveE1lc2gubWF0cml4V29ybGQgKTtcblxuICAgIFx0XHRcdG9iamVjdHMudXBkYXRlKCBiYWNrZ3JvdW5kQm94TWVzaCApO1xuXG4gICAgXHRcdFx0X3RoaXMucmVuZGVyQnVmZmVyRGlyZWN0KCBiYWNrZ3JvdW5kQ2FtZXJhMiwgbnVsbCwgYmFja2dyb3VuZEJveE1lc2guZ2VvbWV0cnksIGJhY2tncm91bmRCb3hNZXNoLm1hdGVyaWFsLCBiYWNrZ3JvdW5kQm94TWVzaCwgbnVsbCApO1xuXG4gICAgXHRcdH0gZWxzZSBpZiAoIGJhY2tncm91bmQgJiYgYmFja2dyb3VuZC5pc1RleHR1cmUgKSB7XG5cbiAgICBcdFx0XHRiYWNrZ3JvdW5kUGxhbmVNZXNoLm1hdGVyaWFsLm1hcCA9IGJhY2tncm91bmQ7XG5cbiAgICBcdFx0XHRvYmplY3RzLnVwZGF0ZSggYmFja2dyb3VuZFBsYW5lTWVzaCApO1xuXG4gICAgXHRcdFx0X3RoaXMucmVuZGVyQnVmZmVyRGlyZWN0KCBiYWNrZ3JvdW5kQ2FtZXJhLCBudWxsLCBiYWNrZ3JvdW5kUGxhbmVNZXNoLmdlb21ldHJ5LCBiYWNrZ3JvdW5kUGxhbmVNZXNoLm1hdGVyaWFsLCBiYWNrZ3JvdW5kUGxhbmVNZXNoLCBudWxsICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdC8vXG5cbiAgICBcdFx0aWYgKCBzY2VuZS5vdmVycmlkZU1hdGVyaWFsICkge1xuXG4gICAgXHRcdFx0dmFyIG92ZXJyaWRlTWF0ZXJpYWwgPSBzY2VuZS5vdmVycmlkZU1hdGVyaWFsO1xuXG4gICAgXHRcdFx0cmVuZGVyT2JqZWN0cyggb3BhcXVlT2JqZWN0cywgY2FtZXJhLCBmb2csIG92ZXJyaWRlTWF0ZXJpYWwgKTtcbiAgICBcdFx0XHRyZW5kZXJPYmplY3RzKCB0cmFuc3BhcmVudE9iamVjdHMsIGNhbWVyYSwgZm9nLCBvdmVycmlkZU1hdGVyaWFsICk7XG5cbiAgICBcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdC8vIG9wYXF1ZSBwYXNzIChmcm9udC10by1iYWNrIG9yZGVyKVxuXG4gICAgXHRcdFx0c3RhdGUuc2V0QmxlbmRpbmcoIE5vQmxlbmRpbmcgKTtcbiAgICBcdFx0XHRyZW5kZXJPYmplY3RzKCBvcGFxdWVPYmplY3RzLCBjYW1lcmEsIGZvZyApO1xuXG4gICAgXHRcdFx0Ly8gdHJhbnNwYXJlbnQgcGFzcyAoYmFjay10by1mcm9udCBvcmRlcilcblxuICAgIFx0XHRcdHJlbmRlck9iamVjdHMoIHRyYW5zcGFyZW50T2JqZWN0cywgY2FtZXJhLCBmb2cgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0Ly8gY3VzdG9tIHJlbmRlciBwbHVnaW5zIChwb3N0IHBhc3MpXG5cbiAgICBcdFx0c3ByaXRlUGx1Z2luLnJlbmRlciggc2NlbmUsIGNhbWVyYSApO1xuICAgIFx0XHRsZW5zRmxhcmVQbHVnaW4ucmVuZGVyKCBzY2VuZSwgY2FtZXJhLCBfY3VycmVudFZpZXdwb3J0ICk7XG5cbiAgICBcdFx0Ly8gR2VuZXJhdGUgbWlwbWFwIGlmIHdlJ3JlIHVzaW5nIGFueSBraW5kIG9mIG1pcG1hcCBmaWx0ZXJpbmdcblxuICAgIFx0XHRpZiAoIHJlbmRlclRhcmdldCApIHtcblxuICAgIFx0XHRcdHRleHR1cmVzLnVwZGF0ZVJlbmRlclRhcmdldE1pcG1hcCggcmVuZGVyVGFyZ2V0ICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdC8vIEVuc3VyZSBkZXB0aCBidWZmZXIgd3JpdGluZyBpcyBlbmFibGVkIHNvIGl0IGNhbiBiZSBjbGVhcmVkIG9uIG5leHQgcmVuZGVyXG5cbiAgICBcdFx0c3RhdGUuc2V0RGVwdGhUZXN0KCB0cnVlICk7XG4gICAgXHRcdHN0YXRlLnNldERlcHRoV3JpdGUoIHRydWUgKTtcbiAgICBcdFx0c3RhdGUuc2V0Q29sb3JXcml0ZSggdHJ1ZSApO1xuXG4gICAgXHRcdC8vIF9nbC5maW5pc2goKTtcblxuICAgIFx0fTtcblxuICAgIFx0ZnVuY3Rpb24gcHVzaFJlbmRlckl0ZW0oIG9iamVjdCwgZ2VvbWV0cnksIG1hdGVyaWFsLCB6LCBncm91cCApIHtcblxuICAgIFx0XHR2YXIgYXJyYXksIGluZGV4O1xuXG4gICAgXHRcdC8vIGFsbG9jYXRlIHRoZSBuZXh0IHBvc2l0aW9uIGluIHRoZSBhcHByb3ByaWF0ZSBhcnJheVxuXG4gICAgXHRcdGlmICggbWF0ZXJpYWwudHJhbnNwYXJlbnQgKSB7XG5cbiAgICBcdFx0XHRhcnJheSA9IHRyYW5zcGFyZW50T2JqZWN0cztcbiAgICBcdFx0XHRpbmRleCA9ICsrIHRyYW5zcGFyZW50T2JqZWN0c0xhc3RJbmRleDtcblxuICAgIFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0YXJyYXkgPSBvcGFxdWVPYmplY3RzO1xuICAgIFx0XHRcdGluZGV4ID0gKysgb3BhcXVlT2JqZWN0c0xhc3RJbmRleDtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0Ly8gcmVjeWNsZSBleGlzdGluZyByZW5kZXIgaXRlbSBvciBncm93IHRoZSBhcnJheVxuXG4gICAgXHRcdHZhciByZW5kZXJJdGVtID0gYXJyYXlbIGluZGV4IF07XG5cbiAgICBcdFx0aWYgKCByZW5kZXJJdGVtICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRyZW5kZXJJdGVtLmlkID0gb2JqZWN0LmlkO1xuICAgIFx0XHRcdHJlbmRlckl0ZW0ub2JqZWN0ID0gb2JqZWN0O1xuICAgIFx0XHRcdHJlbmRlckl0ZW0uZ2VvbWV0cnkgPSBnZW9tZXRyeTtcbiAgICBcdFx0XHRyZW5kZXJJdGVtLm1hdGVyaWFsID0gbWF0ZXJpYWw7XG4gICAgXHRcdFx0cmVuZGVySXRlbS56ID0gX3ZlY3RvcjMuejtcbiAgICBcdFx0XHRyZW5kZXJJdGVtLmdyb3VwID0gZ3JvdXA7XG5cbiAgICBcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdHJlbmRlckl0ZW0gPSB7XG4gICAgXHRcdFx0XHRpZDogb2JqZWN0LmlkLFxuICAgIFx0XHRcdFx0b2JqZWN0OiBvYmplY3QsXG4gICAgXHRcdFx0XHRnZW9tZXRyeTogZ2VvbWV0cnksXG4gICAgXHRcdFx0XHRtYXRlcmlhbDogbWF0ZXJpYWwsXG4gICAgXHRcdFx0XHR6OiBfdmVjdG9yMy56LFxuICAgIFx0XHRcdFx0Z3JvdXA6IGdyb3VwXG4gICAgXHRcdFx0fTtcblxuICAgIFx0XHRcdC8vIGFzc2VydCggaW5kZXggPT09IGFycmF5Lmxlbmd0aCApO1xuICAgIFx0XHRcdGFycmF5LnB1c2goIHJlbmRlckl0ZW0gKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdH1cblxuICAgIFx0Ly8gVE9ETyBEdXBsaWNhdGVkIGNvZGUgKEZydXN0dW0pXG5cbiAgICBcdGZ1bmN0aW9uIGlzT2JqZWN0Vmlld2FibGUoIG9iamVjdCApIHtcblxuICAgIFx0XHR2YXIgZ2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnk7XG5cbiAgICBcdFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApXG4gICAgXHRcdFx0Z2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cbiAgICBcdFx0X3NwaGVyZS5jb3B5KCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSApLlxuICAgIFx0XHRcdGFwcGx5TWF0cml4NCggb2JqZWN0Lm1hdHJpeFdvcmxkICk7XG5cbiAgICBcdFx0cmV0dXJuIGlzU3BoZXJlVmlld2FibGUoIF9zcGhlcmUgKTtcblxuICAgIFx0fVxuXG4gICAgXHRmdW5jdGlvbiBpc1Nwcml0ZVZpZXdhYmxlKCBzcHJpdGUgKSB7XG5cbiAgICBcdFx0X3NwaGVyZS5jZW50ZXIuc2V0KCAwLCAwLCAwICk7XG4gICAgXHRcdF9zcGhlcmUucmFkaXVzID0gMC43MDcxMDY3ODExODY1NDc2O1xuICAgIFx0XHRfc3BoZXJlLmFwcGx5TWF0cml4NCggc3ByaXRlLm1hdHJpeFdvcmxkICk7XG5cbiAgICBcdFx0cmV0dXJuIGlzU3BoZXJlVmlld2FibGUoIF9zcGhlcmUgKTtcblxuICAgIFx0fVxuXG4gICAgXHRmdW5jdGlvbiBpc1NwaGVyZVZpZXdhYmxlKCBzcGhlcmUgKSB7XG5cbiAgICBcdFx0aWYgKCAhIF9mcnVzdHVtLmludGVyc2VjdHNTcGhlcmUoIHNwaGVyZSApICkgcmV0dXJuIGZhbHNlO1xuXG4gICAgXHRcdHZhciBudW1QbGFuZXMgPSBfY2xpcHBpbmcubnVtUGxhbmVzO1xuXG4gICAgXHRcdGlmICggbnVtUGxhbmVzID09PSAwICkgcmV0dXJuIHRydWU7XG5cbiAgICBcdFx0dmFyIHBsYW5lcyA9IF90aGlzLmNsaXBwaW5nUGxhbmVzLFxuXG4gICAgXHRcdFx0Y2VudGVyID0gc3BoZXJlLmNlbnRlcixcbiAgICBcdFx0XHRuZWdSYWQgPSAtIHNwaGVyZS5yYWRpdXMsXG4gICAgXHRcdFx0aSA9IDA7XG5cbiAgICBcdFx0ZG8ge1xuXG4gICAgXHRcdFx0Ly8gb3V0IHdoZW4gZGVlcGVyIHRoYW4gcmFkaXVzIGluIHRoZSBuZWdhdGl2ZSBoYWxmc3BhY2VcbiAgICBcdFx0XHRpZiAoIHBsYW5lc1sgaSBdLmRpc3RhbmNlVG9Qb2ludCggY2VudGVyICkgPCBuZWdSYWQgKSByZXR1cm4gZmFsc2U7XG5cbiAgICBcdFx0fSB3aGlsZSAoICsrIGkgIT09IG51bVBsYW5lcyApO1xuXG4gICAgXHRcdHJldHVybiB0cnVlO1xuXG4gICAgXHR9XG5cbiAgICBcdGZ1bmN0aW9uIHByb2plY3RPYmplY3QoIG9iamVjdCwgY2FtZXJhICkge1xuXG4gICAgXHRcdGlmICggb2JqZWN0LnZpc2libGUgPT09IGZhbHNlICkgcmV0dXJuO1xuXG4gICAgXHRcdHZhciB2aXNpYmxlID0gKCBvYmplY3QubGF5ZXJzLm1hc2sgJiBjYW1lcmEubGF5ZXJzLm1hc2sgKSAhPT0gMDtcblxuICAgIFx0XHRpZiAoIHZpc2libGUgKSB7XG5cbiAgICBcdFx0XHRpZiAoIG9iamVjdC5pc0xpZ2h0ICkge1xuXG4gICAgXHRcdFx0XHRsaWdodHMucHVzaCggb2JqZWN0ICk7XG5cbiAgICBcdFx0XHR9IGVsc2UgaWYgKCBvYmplY3QuaXNTcHJpdGUgKSB7XG5cbiAgICBcdFx0XHRcdGlmICggb2JqZWN0LmZydXN0dW1DdWxsZWQgPT09IGZhbHNlIHx8IGlzU3ByaXRlVmlld2FibGUoIG9iamVjdCApID09PSB0cnVlICkge1xuXG4gICAgXHRcdFx0XHRcdHNwcml0ZXMucHVzaCggb2JqZWN0ICk7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH0gZWxzZSBpZiAoIG9iamVjdC5pc0xlbnNGbGFyZSApIHtcblxuICAgIFx0XHRcdFx0bGVuc0ZsYXJlcy5wdXNoKCBvYmplY3QgKTtcblxuICAgIFx0XHRcdH0gZWxzZSBpZiAoIG9iamVjdC5pc0ltbWVkaWF0ZVJlbmRlck9iamVjdCApIHtcblxuICAgIFx0XHRcdFx0aWYgKCBfdGhpcy5zb3J0T2JqZWN0cyA9PT0gdHJ1ZSApIHtcblxuICAgIFx0XHRcdFx0XHRfdmVjdG9yMy5zZXRGcm9tTWF0cml4UG9zaXRpb24oIG9iamVjdC5tYXRyaXhXb3JsZCApO1xuICAgIFx0XHRcdFx0XHRfdmVjdG9yMy5hcHBseVByb2plY3Rpb24oIF9wcm9qU2NyZWVuTWF0cml4ICk7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0cHVzaFJlbmRlckl0ZW0oIG9iamVjdCwgbnVsbCwgb2JqZWN0Lm1hdGVyaWFsLCBfdmVjdG9yMy56LCBudWxsICk7XG5cbiAgICBcdFx0XHR9IGVsc2UgaWYgKCBvYmplY3QuaXNNZXNoIHx8IG9iamVjdC5pc0xpbmUgfHwgb2JqZWN0LmlzUG9pbnRzICkge1xuXG4gICAgXHRcdFx0XHRpZiAoIG9iamVjdC5pc1NraW5uZWRNZXNoICkge1xuXG4gICAgXHRcdFx0XHRcdG9iamVjdC5za2VsZXRvbi51cGRhdGUoKTtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRpZiAoIG9iamVjdC5mcnVzdHVtQ3VsbGVkID09PSBmYWxzZSB8fCBpc09iamVjdFZpZXdhYmxlKCBvYmplY3QgKSA9PT0gdHJ1ZSApIHtcblxuICAgIFx0XHRcdFx0XHR2YXIgbWF0ZXJpYWwgPSBvYmplY3QubWF0ZXJpYWw7XG5cbiAgICBcdFx0XHRcdFx0aWYgKCBtYXRlcmlhbC52aXNpYmxlID09PSB0cnVlICkge1xuXG4gICAgXHRcdFx0XHRcdFx0aWYgKCBfdGhpcy5zb3J0T2JqZWN0cyA9PT0gdHJ1ZSApIHtcblxuICAgIFx0XHRcdFx0XHRcdFx0X3ZlY3RvcjMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBvYmplY3QubWF0cml4V29ybGQgKTtcbiAgICBcdFx0XHRcdFx0XHRcdF92ZWN0b3IzLmFwcGx5UHJvamVjdGlvbiggX3Byb2pTY3JlZW5NYXRyaXggKTtcblxuICAgIFx0XHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0XHRcdHZhciBnZW9tZXRyeSA9IG9iamVjdHMudXBkYXRlKCBvYmplY3QgKTtcblxuICAgIFx0XHRcdFx0XHRcdGlmICggbWF0ZXJpYWwuaXNNdWx0aU1hdGVyaWFsICkge1xuXG4gICAgXHRcdFx0XHRcdFx0XHR2YXIgZ3JvdXBzID0gZ2VvbWV0cnkuZ3JvdXBzO1xuICAgIFx0XHRcdFx0XHRcdFx0dmFyIG1hdGVyaWFscyA9IG1hdGVyaWFsLm1hdGVyaWFscztcblxuICAgIFx0XHRcdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gZ3JvdXBzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHRcdFx0dmFyIGdyb3VwID0gZ3JvdXBzWyBpIF07XG4gICAgXHRcdFx0XHRcdFx0XHRcdHZhciBncm91cE1hdGVyaWFsID0gbWF0ZXJpYWxzWyBncm91cC5tYXRlcmlhbEluZGV4IF07XG5cbiAgICBcdFx0XHRcdFx0XHRcdFx0aWYgKCBncm91cE1hdGVyaWFsLnZpc2libGUgPT09IHRydWUgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHRcdFx0XHRwdXNoUmVuZGVySXRlbSggb2JqZWN0LCBnZW9tZXRyeSwgZ3JvdXBNYXRlcmlhbCwgX3ZlY3RvcjMueiwgZ3JvdXAgKTtcblxuICAgIFx0XHRcdFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdFx0XHRcdHB1c2hSZW5kZXJJdGVtKCBvYmplY3QsIGdlb21ldHJ5LCBtYXRlcmlhbCwgX3ZlY3RvcjMueiwgbnVsbCApO1xuXG4gICAgXHRcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHR2YXIgY2hpbGRyZW4gPSBvYmplY3QuY2hpbGRyZW47XG5cbiAgICBcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgIFx0XHRcdHByb2plY3RPYmplY3QoIGNoaWxkcmVuWyBpIF0sIGNhbWVyYSApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0fVxuXG4gICAgXHRmdW5jdGlvbiByZW5kZXJPYmplY3RzKCByZW5kZXJMaXN0LCBjYW1lcmEsIGZvZywgb3ZlcnJpZGVNYXRlcmlhbCApIHtcblxuICAgIFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSByZW5kZXJMaXN0Lmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICBcdFx0XHR2YXIgcmVuZGVySXRlbSA9IHJlbmRlckxpc3RbIGkgXTtcblxuICAgIFx0XHRcdHZhciBvYmplY3QgPSByZW5kZXJJdGVtLm9iamVjdDtcbiAgICBcdFx0XHR2YXIgZ2VvbWV0cnkgPSByZW5kZXJJdGVtLmdlb21ldHJ5O1xuICAgIFx0XHRcdHZhciBtYXRlcmlhbCA9IG92ZXJyaWRlTWF0ZXJpYWwgPT09IHVuZGVmaW5lZCA/IHJlbmRlckl0ZW0ubWF0ZXJpYWwgOiBvdmVycmlkZU1hdGVyaWFsO1xuICAgIFx0XHRcdHZhciBncm91cCA9IHJlbmRlckl0ZW0uZ3JvdXA7XG5cbiAgICBcdFx0XHRvYmplY3QubW9kZWxWaWV3TWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UsIG9iamVjdC5tYXRyaXhXb3JsZCApO1xuICAgIFx0XHRcdG9iamVjdC5ub3JtYWxNYXRyaXguZ2V0Tm9ybWFsTWF0cml4KCBvYmplY3QubW9kZWxWaWV3TWF0cml4ICk7XG5cbiAgICBcdFx0XHRpZiAoIG9iamVjdC5pc0ltbWVkaWF0ZVJlbmRlck9iamVjdCApIHtcblxuICAgIFx0XHRcdFx0c2V0TWF0ZXJpYWwoIG1hdGVyaWFsICk7XG5cbiAgICBcdFx0XHRcdHZhciBwcm9ncmFtID0gc2V0UHJvZ3JhbSggY2FtZXJhLCBmb2csIG1hdGVyaWFsLCBvYmplY3QgKTtcblxuICAgIFx0XHRcdFx0X2N1cnJlbnRHZW9tZXRyeVByb2dyYW0gPSAnJztcblxuICAgIFx0XHRcdFx0b2JqZWN0LnJlbmRlciggZnVuY3Rpb24gKCBvYmplY3QgKSB7XG5cbiAgICBcdFx0XHRcdFx0X3RoaXMucmVuZGVyQnVmZmVySW1tZWRpYXRlKCBvYmplY3QsIHByb2dyYW0sIG1hdGVyaWFsICk7XG5cbiAgICBcdFx0XHRcdH0gKTtcblxuICAgIFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdGlmICggb2JqZWN0Lm9uQmVmb3JlUmVuZGVyICE9PSBudWxsICkgb2JqZWN0Lm9uQmVmb3JlUmVuZGVyKCk7XG5cbiAgICBcdFx0XHRcdF90aGlzLnJlbmRlckJ1ZmZlckRpcmVjdCggY2FtZXJhLCBmb2csIGdlb21ldHJ5LCBtYXRlcmlhbCwgb2JqZWN0LCBncm91cCApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0fVxuXG4gICAgXHRmdW5jdGlvbiBpbml0TWF0ZXJpYWwoIG1hdGVyaWFsLCBmb2csIG9iamVjdCApIHtcblxuICAgIFx0XHR2YXIgbWF0ZXJpYWxQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIG1hdGVyaWFsICk7XG5cbiAgICBcdFx0dmFyIHBhcmFtZXRlcnMgPSBwcm9ncmFtQ2FjaGUuZ2V0UGFyYW1ldGVycyhcbiAgICBcdFx0XHRcdG1hdGVyaWFsLCBfbGlnaHRzLCBmb2csIF9jbGlwcGluZy5udW1QbGFuZXMsIG9iamVjdCApO1xuXG4gICAgXHRcdHZhciBjb2RlID0gcHJvZ3JhbUNhY2hlLmdldFByb2dyYW1Db2RlKCBtYXRlcmlhbCwgcGFyYW1ldGVycyApO1xuXG4gICAgXHRcdHZhciBwcm9ncmFtID0gbWF0ZXJpYWxQcm9wZXJ0aWVzLnByb2dyYW07XG4gICAgXHRcdHZhciBwcm9ncmFtQ2hhbmdlID0gdHJ1ZTtcblxuICAgIFx0XHRpZiAoIHByb2dyYW0gPT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdC8vIG5ldyBtYXRlcmlhbFxuICAgIFx0XHRcdG1hdGVyaWFsLmFkZEV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25NYXRlcmlhbERpc3Bvc2UgKTtcblxuICAgIFx0XHR9IGVsc2UgaWYgKCBwcm9ncmFtLmNvZGUgIT09IGNvZGUgKSB7XG5cbiAgICBcdFx0XHQvLyBjaGFuZ2VkIGdsc2wgb3IgcGFyYW1ldGVyc1xuICAgIFx0XHRcdHJlbGVhc2VNYXRlcmlhbFByb2dyYW1SZWZlcmVuY2UoIG1hdGVyaWFsICk7XG5cbiAgICBcdFx0fSBlbHNlIGlmICggcGFyYW1ldGVycy5zaGFkZXJJRCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0Ly8gc2FtZSBnbHNsIGFuZCB1bmlmb3JtIGxpc3RcbiAgICBcdFx0XHRyZXR1cm47XG5cbiAgICBcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdC8vIG9ubHkgcmVidWlsZCB1bmlmb3JtIGxpc3RcbiAgICBcdFx0XHRwcm9ncmFtQ2hhbmdlID0gZmFsc2U7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGlmICggcHJvZ3JhbUNoYW5nZSApIHtcblxuICAgIFx0XHRcdGlmICggcGFyYW1ldGVycy5zaGFkZXJJRCApIHtcblxuICAgIFx0XHRcdFx0dmFyIHNoYWRlciA9IFNoYWRlckxpYlsgcGFyYW1ldGVycy5zaGFkZXJJRCBdO1xuXG4gICAgXHRcdFx0XHRtYXRlcmlhbFByb3BlcnRpZXMuX193ZWJnbFNoYWRlciA9IHtcbiAgICBcdFx0XHRcdFx0bmFtZTogbWF0ZXJpYWwudHlwZSxcbiAgICBcdFx0XHRcdFx0dW5pZm9ybXM6IGV4cG9ydHMuVW5pZm9ybXNVdGlscy5jbG9uZSggc2hhZGVyLnVuaWZvcm1zICksXG4gICAgXHRcdFx0XHRcdHZlcnRleFNoYWRlcjogc2hhZGVyLnZlcnRleFNoYWRlcixcbiAgICBcdFx0XHRcdFx0ZnJhZ21lbnRTaGFkZXI6IHNoYWRlci5mcmFnbWVudFNoYWRlclxuICAgIFx0XHRcdFx0fTtcblxuICAgIFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdG1hdGVyaWFsUHJvcGVydGllcy5fX3dlYmdsU2hhZGVyID0ge1xuICAgIFx0XHRcdFx0XHRuYW1lOiBtYXRlcmlhbC50eXBlLFxuICAgIFx0XHRcdFx0XHR1bmlmb3JtczogbWF0ZXJpYWwudW5pZm9ybXMsXG4gICAgXHRcdFx0XHRcdHZlcnRleFNoYWRlcjogbWF0ZXJpYWwudmVydGV4U2hhZGVyLFxuICAgIFx0XHRcdFx0XHRmcmFnbWVudFNoYWRlcjogbWF0ZXJpYWwuZnJhZ21lbnRTaGFkZXJcbiAgICBcdFx0XHRcdH07XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRtYXRlcmlhbC5fX3dlYmdsU2hhZGVyID0gbWF0ZXJpYWxQcm9wZXJ0aWVzLl9fd2ViZ2xTaGFkZXI7XG5cbiAgICBcdFx0XHRwcm9ncmFtID0gcHJvZ3JhbUNhY2hlLmFjcXVpcmVQcm9ncmFtKCBtYXRlcmlhbCwgcGFyYW1ldGVycywgY29kZSApO1xuXG4gICAgXHRcdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLnByb2dyYW0gPSBwcm9ncmFtO1xuICAgIFx0XHRcdG1hdGVyaWFsLnByb2dyYW0gPSBwcm9ncmFtO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHR2YXIgYXR0cmlidXRlcyA9IHByb2dyYW0uZ2V0QXR0cmlidXRlcygpO1xuXG4gICAgXHRcdGlmICggbWF0ZXJpYWwubW9ycGhUYXJnZXRzICkge1xuXG4gICAgXHRcdFx0bWF0ZXJpYWwubnVtU3VwcG9ydGVkTW9ycGhUYXJnZXRzID0gMDtcblxuICAgIFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IF90aGlzLm1heE1vcnBoVGFyZ2V0czsgaSArKyApIHtcblxuICAgIFx0XHRcdFx0aWYgKCBhdHRyaWJ1dGVzWyAnbW9ycGhUYXJnZXQnICsgaSBdID49IDAgKSB7XG5cbiAgICBcdFx0XHRcdFx0bWF0ZXJpYWwubnVtU3VwcG9ydGVkTW9ycGhUYXJnZXRzICsrO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGlmICggbWF0ZXJpYWwubW9ycGhOb3JtYWxzICkge1xuXG4gICAgXHRcdFx0bWF0ZXJpYWwubnVtU3VwcG9ydGVkTW9ycGhOb3JtYWxzID0gMDtcblxuICAgIFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IF90aGlzLm1heE1vcnBoTm9ybWFsczsgaSArKyApIHtcblxuICAgIFx0XHRcdFx0aWYgKCBhdHRyaWJ1dGVzWyAnbW9ycGhOb3JtYWwnICsgaSBdID49IDAgKSB7XG5cbiAgICBcdFx0XHRcdFx0bWF0ZXJpYWwubnVtU3VwcG9ydGVkTW9ycGhOb3JtYWxzICsrO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHZhciB1bmlmb3JtcyA9IG1hdGVyaWFsUHJvcGVydGllcy5fX3dlYmdsU2hhZGVyLnVuaWZvcm1zO1xuXG4gICAgXHRcdGlmICggISBtYXRlcmlhbC5pc1NoYWRlck1hdGVyaWFsICYmXG4gICAgXHRcdCAgICAgISBtYXRlcmlhbC5pc1Jhd1NoYWRlck1hdGVyaWFsIHx8XG4gICAgXHRcdCAgICAgICBtYXRlcmlhbC5jbGlwcGluZyA9PT0gdHJ1ZSApIHtcblxuICAgIFx0XHRcdG1hdGVyaWFsUHJvcGVydGllcy5udW1DbGlwcGluZ1BsYW5lcyA9IF9jbGlwcGluZy5udW1QbGFuZXM7XG4gICAgXHRcdFx0dW5pZm9ybXMuY2xpcHBpbmdQbGFuZXMgPSBfY2xpcHBpbmcudW5pZm9ybTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLmZvZyA9IGZvZztcblxuICAgIFx0XHQvLyBzdG9yZSB0aGUgbGlnaHQgc2V0dXAgaXQgd2FzIGNyZWF0ZWQgZm9yXG5cbiAgICBcdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLmxpZ2h0c0hhc2ggPSBfbGlnaHRzLmhhc2g7XG5cbiAgICBcdFx0aWYgKCBtYXRlcmlhbC5saWdodHMgKSB7XG5cbiAgICBcdFx0XHQvLyB3aXJlIHVwIHRoZSBtYXRlcmlhbCB0byB0aGlzIHJlbmRlcmVyJ3MgbGlnaHRpbmcgc3RhdGVcblxuICAgIFx0XHRcdHVuaWZvcm1zLmFtYmllbnRMaWdodENvbG9yLnZhbHVlID0gX2xpZ2h0cy5hbWJpZW50O1xuICAgIFx0XHRcdHVuaWZvcm1zLmRpcmVjdGlvbmFsTGlnaHRzLnZhbHVlID0gX2xpZ2h0cy5kaXJlY3Rpb25hbDtcbiAgICBcdFx0XHR1bmlmb3Jtcy5zcG90TGlnaHRzLnZhbHVlID0gX2xpZ2h0cy5zcG90O1xuICAgIFx0XHRcdHVuaWZvcm1zLnBvaW50TGlnaHRzLnZhbHVlID0gX2xpZ2h0cy5wb2ludDtcbiAgICBcdFx0XHR1bmlmb3Jtcy5oZW1pc3BoZXJlTGlnaHRzLnZhbHVlID0gX2xpZ2h0cy5oZW1pO1xuXG4gICAgXHRcdFx0dW5pZm9ybXMuZGlyZWN0aW9uYWxTaGFkb3dNYXAudmFsdWUgPSBfbGlnaHRzLmRpcmVjdGlvbmFsU2hhZG93TWFwO1xuICAgIFx0XHRcdHVuaWZvcm1zLmRpcmVjdGlvbmFsU2hhZG93TWF0cml4LnZhbHVlID0gX2xpZ2h0cy5kaXJlY3Rpb25hbFNoYWRvd01hdHJpeDtcbiAgICBcdFx0XHR1bmlmb3Jtcy5zcG90U2hhZG93TWFwLnZhbHVlID0gX2xpZ2h0cy5zcG90U2hhZG93TWFwO1xuICAgIFx0XHRcdHVuaWZvcm1zLnNwb3RTaGFkb3dNYXRyaXgudmFsdWUgPSBfbGlnaHRzLnNwb3RTaGFkb3dNYXRyaXg7XG4gICAgXHRcdFx0dW5pZm9ybXMucG9pbnRTaGFkb3dNYXAudmFsdWUgPSBfbGlnaHRzLnBvaW50U2hhZG93TWFwO1xuICAgIFx0XHRcdHVuaWZvcm1zLnBvaW50U2hhZG93TWF0cml4LnZhbHVlID0gX2xpZ2h0cy5wb2ludFNoYWRvd01hdHJpeDtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0dmFyIHByb2dVbmlmb3JtcyA9IG1hdGVyaWFsUHJvcGVydGllcy5wcm9ncmFtLmdldFVuaWZvcm1zKCksXG4gICAgXHRcdFx0dW5pZm9ybXNMaXN0ID1cbiAgICBcdFx0XHRcdFx0V2ViR0xVbmlmb3Jtcy5zZXFXaXRoVmFsdWUoIHByb2dVbmlmb3Jtcy5zZXEsIHVuaWZvcm1zICk7XG5cbiAgICBcdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLnVuaWZvcm1zTGlzdCA9IHVuaWZvcm1zTGlzdDtcbiAgICBcdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLmR5bmFtaWNVbmlmb3JtcyA9XG4gICAgXHRcdFx0XHRXZWJHTFVuaWZvcm1zLnNwbGl0RHluYW1pYyggdW5pZm9ybXNMaXN0LCB1bmlmb3JtcyApO1xuXG4gICAgXHR9XG5cbiAgICBcdGZ1bmN0aW9uIHNldE1hdGVyaWFsKCBtYXRlcmlhbCApIHtcblxuICAgIFx0XHRtYXRlcmlhbC5zaWRlID09PSBEb3VibGVTaWRlXG4gICAgXHRcdFx0PyBzdGF0ZS5kaXNhYmxlKCBfZ2wuQ1VMTF9GQUNFIClcbiAgICBcdFx0XHQ6IHN0YXRlLmVuYWJsZSggX2dsLkNVTExfRkFDRSApO1xuXG4gICAgXHRcdHN0YXRlLnNldEZsaXBTaWRlZCggbWF0ZXJpYWwuc2lkZSA9PT0gQmFja1NpZGUgKTtcblxuICAgIFx0XHRtYXRlcmlhbC50cmFuc3BhcmVudCA9PT0gdHJ1ZVxuICAgIFx0XHRcdD8gc3RhdGUuc2V0QmxlbmRpbmcoIG1hdGVyaWFsLmJsZW5kaW5nLCBtYXRlcmlhbC5ibGVuZEVxdWF0aW9uLCBtYXRlcmlhbC5ibGVuZFNyYywgbWF0ZXJpYWwuYmxlbmREc3QsIG1hdGVyaWFsLmJsZW5kRXF1YXRpb25BbHBoYSwgbWF0ZXJpYWwuYmxlbmRTcmNBbHBoYSwgbWF0ZXJpYWwuYmxlbmREc3RBbHBoYSwgbWF0ZXJpYWwucHJlbXVsdGlwbGllZEFscGhhIClcbiAgICBcdFx0XHQ6IHN0YXRlLnNldEJsZW5kaW5nKCBOb0JsZW5kaW5nICk7XG5cbiAgICBcdFx0c3RhdGUuc2V0RGVwdGhGdW5jKCBtYXRlcmlhbC5kZXB0aEZ1bmMgKTtcbiAgICBcdFx0c3RhdGUuc2V0RGVwdGhUZXN0KCBtYXRlcmlhbC5kZXB0aFRlc3QgKTtcbiAgICBcdFx0c3RhdGUuc2V0RGVwdGhXcml0ZSggbWF0ZXJpYWwuZGVwdGhXcml0ZSApO1xuICAgIFx0XHRzdGF0ZS5zZXRDb2xvcldyaXRlKCBtYXRlcmlhbC5jb2xvcldyaXRlICk7XG4gICAgXHRcdHN0YXRlLnNldFBvbHlnb25PZmZzZXQoIG1hdGVyaWFsLnBvbHlnb25PZmZzZXQsIG1hdGVyaWFsLnBvbHlnb25PZmZzZXRGYWN0b3IsIG1hdGVyaWFsLnBvbHlnb25PZmZzZXRVbml0cyApO1xuXG4gICAgXHR9XG5cbiAgICBcdGZ1bmN0aW9uIHNldFByb2dyYW0oIGNhbWVyYSwgZm9nLCBtYXRlcmlhbCwgb2JqZWN0ICkge1xuXG4gICAgXHRcdF91c2VkVGV4dHVyZVVuaXRzID0gMDtcblxuICAgIFx0XHR2YXIgbWF0ZXJpYWxQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIG1hdGVyaWFsICk7XG5cbiAgICBcdFx0aWYgKCBfY2xpcHBpbmdFbmFibGVkICkge1xuXG4gICAgXHRcdFx0aWYgKCBfbG9jYWxDbGlwcGluZ0VuYWJsZWQgfHwgY2FtZXJhICE9PSBfY3VycmVudENhbWVyYSApIHtcblxuICAgIFx0XHRcdFx0dmFyIHVzZUNhY2hlID1cbiAgICBcdFx0XHRcdFx0XHRjYW1lcmEgPT09IF9jdXJyZW50Q2FtZXJhICYmXG4gICAgXHRcdFx0XHRcdFx0bWF0ZXJpYWwuaWQgPT09IF9jdXJyZW50TWF0ZXJpYWxJZDtcblxuICAgIFx0XHRcdFx0Ly8gd2UgbWlnaHQgd2FudCB0byBjYWxsIHRoaXMgZnVuY3Rpb24gd2l0aCBzb21lIENsaXBwaW5nR3JvdXBcbiAgICBcdFx0XHRcdC8vIG9iamVjdCBpbnN0ZWFkIG9mIHRoZSBtYXRlcmlhbCwgb25jZSBpdCBiZWNvbWVzIGZlYXNpYmxlXG4gICAgXHRcdFx0XHQvLyAoIzg0NjUsICM4Mzc5KVxuICAgIFx0XHRcdFx0X2NsaXBwaW5nLnNldFN0YXRlKFxuICAgIFx0XHRcdFx0XHRcdG1hdGVyaWFsLmNsaXBwaW5nUGxhbmVzLCBtYXRlcmlhbC5jbGlwU2hhZG93cyxcbiAgICBcdFx0XHRcdFx0XHRjYW1lcmEsIG1hdGVyaWFsUHJvcGVydGllcywgdXNlQ2FjaGUgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKCBtYXRlcmlhbC5uZWVkc1VwZGF0ZSA9PT0gZmFsc2UgKSB7XG5cbiAgICBcdFx0XHRpZiAoIG1hdGVyaWFsUHJvcGVydGllcy5wcm9ncmFtID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRcdG1hdGVyaWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgIFx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLmZvZyAmJiBtYXRlcmlhbFByb3BlcnRpZXMuZm9nICE9PSBmb2cgKSB7XG5cbiAgICBcdFx0XHRcdG1hdGVyaWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgIFx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLmxpZ2h0cyAmJiBtYXRlcmlhbFByb3BlcnRpZXMubGlnaHRzSGFzaCAhPT0gX2xpZ2h0cy5oYXNoICkge1xuXG4gICAgXHRcdFx0XHRtYXRlcmlhbC5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICBcdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbFByb3BlcnRpZXMubnVtQ2xpcHBpbmdQbGFuZXMgIT09IHVuZGVmaW5lZCAmJlxuICAgIFx0XHRcdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLm51bUNsaXBwaW5nUGxhbmVzICE9PSBfY2xpcHBpbmcubnVtUGxhbmVzICkge1xuXG4gICAgXHRcdFx0XHRtYXRlcmlhbC5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGlmICggbWF0ZXJpYWwubmVlZHNVcGRhdGUgKSB7XG5cbiAgICBcdFx0XHRpbml0TWF0ZXJpYWwoIG1hdGVyaWFsLCBmb2csIG9iamVjdCApO1xuICAgIFx0XHRcdG1hdGVyaWFsLm5lZWRzVXBkYXRlID0gZmFsc2U7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHZhciByZWZyZXNoUHJvZ3JhbSA9IGZhbHNlO1xuICAgIFx0XHR2YXIgcmVmcmVzaE1hdGVyaWFsID0gZmFsc2U7XG4gICAgXHRcdHZhciByZWZyZXNoTGlnaHRzID0gZmFsc2U7XG5cbiAgICBcdFx0dmFyIHByb2dyYW0gPSBtYXRlcmlhbFByb3BlcnRpZXMucHJvZ3JhbSxcbiAgICBcdFx0XHRwX3VuaWZvcm1zID0gcHJvZ3JhbS5nZXRVbmlmb3JtcygpLFxuICAgIFx0XHRcdG1fdW5pZm9ybXMgPSBtYXRlcmlhbFByb3BlcnRpZXMuX193ZWJnbFNoYWRlci51bmlmb3JtcztcblxuICAgIFx0XHRpZiAoIHByb2dyYW0uaWQgIT09IF9jdXJyZW50UHJvZ3JhbSApIHtcblxuICAgIFx0XHRcdF9nbC51c2VQcm9ncmFtKCBwcm9ncmFtLnByb2dyYW0gKTtcbiAgICBcdFx0XHRfY3VycmVudFByb2dyYW0gPSBwcm9ncmFtLmlkO1xuXG4gICAgXHRcdFx0cmVmcmVzaFByb2dyYW0gPSB0cnVlO1xuICAgIFx0XHRcdHJlZnJlc2hNYXRlcmlhbCA9IHRydWU7XG4gICAgXHRcdFx0cmVmcmVzaExpZ2h0cyA9IHRydWU7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGlmICggbWF0ZXJpYWwuaWQgIT09IF9jdXJyZW50TWF0ZXJpYWxJZCApIHtcblxuICAgIFx0XHRcdF9jdXJyZW50TWF0ZXJpYWxJZCA9IG1hdGVyaWFsLmlkO1xuXG4gICAgXHRcdFx0cmVmcmVzaE1hdGVyaWFsID0gdHJ1ZTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKCByZWZyZXNoUHJvZ3JhbSB8fCBjYW1lcmEgIT09IF9jdXJyZW50Q2FtZXJhICkge1xuXG4gICAgXHRcdFx0cF91bmlmb3Jtcy5zZXQoIF9nbCwgY2FtZXJhLCAncHJvamVjdGlvbk1hdHJpeCcgKTtcblxuICAgIFx0XHRcdGlmICggY2FwYWJpbGl0aWVzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgKSB7XG5cbiAgICBcdFx0XHRcdHBfdW5pZm9ybXMuc2V0VmFsdWUoIF9nbCwgJ2xvZ0RlcHRoQnVmRkMnLFxuICAgIFx0XHRcdFx0XHRcdDIuMCAvICggTWF0aC5sb2coIGNhbWVyYS5mYXIgKyAxLjAgKSAvIE1hdGguTE4yICkgKTtcblxuICAgIFx0XHRcdH1cblxuXG4gICAgXHRcdFx0aWYgKCBjYW1lcmEgIT09IF9jdXJyZW50Q2FtZXJhICkge1xuXG4gICAgXHRcdFx0XHRfY3VycmVudENhbWVyYSA9IGNhbWVyYTtcblxuICAgIFx0XHRcdFx0Ly8gbGlnaHRpbmcgdW5pZm9ybXMgZGVwZW5kIG9uIHRoZSBjYW1lcmEgc28gZW5mb3JjZSBhbiB1cGRhdGVcbiAgICBcdFx0XHRcdC8vIG5vdywgaW4gY2FzZSB0aGlzIG1hdGVyaWFsIHN1cHBvcnRzIGxpZ2h0cyAtIG9yIGxhdGVyLCB3aGVuXG4gICAgXHRcdFx0XHQvLyB0aGUgbmV4dCBtYXRlcmlhbCB0aGF0IGRvZXMgZ2V0cyBhY3RpdmF0ZWQ6XG5cbiAgICBcdFx0XHRcdHJlZnJlc2hNYXRlcmlhbCA9IHRydWU7XHRcdC8vIHNldCB0byB0cnVlIG9uIG1hdGVyaWFsIGNoYW5nZVxuICAgIFx0XHRcdFx0cmVmcmVzaExpZ2h0cyA9IHRydWU7XHRcdC8vIHJlbWFpbnMgc2V0IHVudGlsIHVwZGF0ZSBkb25lXG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHQvLyBsb2FkIG1hdGVyaWFsIHNwZWNpZmljIHVuaWZvcm1zXG4gICAgXHRcdFx0Ly8gKHNoYWRlciBtYXRlcmlhbCBhbHNvIGdldHMgdGhlbSBmb3IgdGhlIHNha2Ugb2YgZ2VuZXJpY2l0eSlcblxuICAgIFx0XHRcdGlmICggbWF0ZXJpYWwuaXNTaGFkZXJNYXRlcmlhbCB8fFxuICAgIFx0XHRcdCAgICAgbWF0ZXJpYWwuaXNNZXNoUGhvbmdNYXRlcmlhbCB8fFxuICAgIFx0XHRcdCAgICAgbWF0ZXJpYWwuaXNNZXNoU3RhbmRhcmRNYXRlcmlhbCB8fFxuICAgIFx0XHRcdCAgICAgbWF0ZXJpYWwuZW52TWFwICkge1xuXG4gICAgXHRcdFx0XHR2YXIgdUNhbVBvcyA9IHBfdW5pZm9ybXMubWFwLmNhbWVyYVBvc2l0aW9uO1xuXG4gICAgXHRcdFx0XHRpZiAoIHVDYW1Qb3MgIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0XHR1Q2FtUG9zLnNldFZhbHVlKCBfZ2wsXG4gICAgXHRcdFx0XHRcdFx0XHRfdmVjdG9yMy5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGNhbWVyYS5tYXRyaXhXb3JsZCApICk7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGlmICggbWF0ZXJpYWwuaXNNZXNoUGhvbmdNYXRlcmlhbCB8fFxuICAgIFx0XHRcdCAgICAgbWF0ZXJpYWwuaXNNZXNoTGFtYmVydE1hdGVyaWFsIHx8XG4gICAgXHRcdFx0ICAgICBtYXRlcmlhbC5pc01lc2hCYXNpY01hdGVyaWFsIHx8XG4gICAgXHRcdFx0ICAgICBtYXRlcmlhbC5pc01lc2hTdGFuZGFyZE1hdGVyaWFsIHx8XG4gICAgXHRcdFx0ICAgICBtYXRlcmlhbC5pc1NoYWRlck1hdGVyaWFsIHx8XG4gICAgXHRcdFx0ICAgICBtYXRlcmlhbC5za2lubmluZyApIHtcblxuICAgIFx0XHRcdFx0cF91bmlmb3Jtcy5zZXRWYWx1ZSggX2dsLCAndmlld01hdHJpeCcsIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdHBfdW5pZm9ybXMuc2V0KCBfZ2wsIF90aGlzLCAndG9uZU1hcHBpbmdFeHBvc3VyZScgKTtcbiAgICBcdFx0XHRwX3VuaWZvcm1zLnNldCggX2dsLCBfdGhpcywgJ3RvbmVNYXBwaW5nV2hpdGVQb2ludCcgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0Ly8gc2tpbm5pbmcgdW5pZm9ybXMgbXVzdCBiZSBzZXQgZXZlbiBpZiBtYXRlcmlhbCBkaWRuJ3QgY2hhbmdlXG4gICAgXHRcdC8vIGF1dG8tc2V0dGluZyBvZiB0ZXh0dXJlIHVuaXQgZm9yIGJvbmUgdGV4dHVyZSBtdXN0IGdvIGJlZm9yZSBvdGhlciB0ZXh0dXJlc1xuICAgIFx0XHQvLyBub3Qgc3VyZSB3aHksIGJ1dCBvdGhlcndpc2Ugd2VpcmQgdGhpbmdzIGhhcHBlblxuXG4gICAgXHRcdGlmICggbWF0ZXJpYWwuc2tpbm5pbmcgKSB7XG5cbiAgICBcdFx0XHRwX3VuaWZvcm1zLnNldE9wdGlvbmFsKCBfZ2wsIG9iamVjdCwgJ2JpbmRNYXRyaXgnICk7XG4gICAgXHRcdFx0cF91bmlmb3Jtcy5zZXRPcHRpb25hbCggX2dsLCBvYmplY3QsICdiaW5kTWF0cml4SW52ZXJzZScgKTtcblxuICAgIFx0XHRcdHZhciBza2VsZXRvbiA9IG9iamVjdC5za2VsZXRvbjtcblxuICAgIFx0XHRcdGlmICggc2tlbGV0b24gKSB7XG5cbiAgICBcdFx0XHRcdGlmICggY2FwYWJpbGl0aWVzLmZsb2F0VmVydGV4VGV4dHVyZXMgJiYgc2tlbGV0b24udXNlVmVydGV4VGV4dHVyZSApIHtcblxuICAgIFx0XHRcdFx0XHRwX3VuaWZvcm1zLnNldCggX2dsLCBza2VsZXRvbiwgJ2JvbmVUZXh0dXJlJyApO1xuICAgIFx0XHRcdFx0XHRwX3VuaWZvcm1zLnNldCggX2dsLCBza2VsZXRvbiwgJ2JvbmVUZXh0dXJlV2lkdGgnICk7XG4gICAgXHRcdFx0XHRcdHBfdW5pZm9ybXMuc2V0KCBfZ2wsIHNrZWxldG9uLCAnYm9uZVRleHR1cmVIZWlnaHQnICk7XG5cbiAgICBcdFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdFx0cF91bmlmb3Jtcy5zZXRPcHRpb25hbCggX2dsLCBza2VsZXRvbiwgJ2JvbmVNYXRyaWNlcycgKTtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoIHJlZnJlc2hNYXRlcmlhbCApIHtcblxuICAgIFx0XHRcdGlmICggbWF0ZXJpYWwubGlnaHRzICkge1xuXG4gICAgXHRcdFx0XHQvLyB0aGUgY3VycmVudCBtYXRlcmlhbCByZXF1aXJlcyBsaWdodGluZyBpbmZvXG5cbiAgICBcdFx0XHRcdC8vIG5vdGU6IGFsbCBsaWdodGluZyB1bmlmb3JtcyBhcmUgYWx3YXlzIHNldCBjb3JyZWN0bHlcbiAgICBcdFx0XHRcdC8vIHRoZXkgc2ltcGx5IHJlZmVyZW5jZSB0aGUgcmVuZGVyZXIncyBzdGF0ZSBmb3IgdGhlaXJcbiAgICBcdFx0XHRcdC8vIHZhbHVlc1xuICAgIFx0XHRcdFx0Ly9cbiAgICBcdFx0XHRcdC8vIHVzZSB0aGUgY3VycmVudCBtYXRlcmlhbCdzIC5uZWVkc1VwZGF0ZSBmbGFncyB0byBzZXRcbiAgICBcdFx0XHRcdC8vIHRoZSBHTCBzdGF0ZSB3aGVuIHJlcXVpcmVkXG5cbiAgICBcdFx0XHRcdG1hcmtVbmlmb3Jtc0xpZ2h0c05lZWRzVXBkYXRlKCBtX3VuaWZvcm1zLCByZWZyZXNoTGlnaHRzICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHQvLyByZWZyZXNoIHVuaWZvcm1zIGNvbW1vbiB0byBzZXZlcmFsIG1hdGVyaWFsc1xuXG4gICAgXHRcdFx0aWYgKCBmb2cgJiYgbWF0ZXJpYWwuZm9nICkge1xuXG4gICAgXHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNGb2coIG1fdW5pZm9ybXMsIGZvZyApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0aWYgKCBtYXRlcmlhbC5pc01lc2hCYXNpY01hdGVyaWFsIHx8XG4gICAgXHRcdFx0ICAgICBtYXRlcmlhbC5pc01lc2hMYW1iZXJ0TWF0ZXJpYWwgfHxcbiAgICBcdFx0XHQgICAgIG1hdGVyaWFsLmlzTWVzaFBob25nTWF0ZXJpYWwgfHxcbiAgICBcdFx0XHQgICAgIG1hdGVyaWFsLmlzTWVzaFN0YW5kYXJkTWF0ZXJpYWwgfHxcbiAgICBcdFx0XHQgICAgIG1hdGVyaWFsLmlzTWVzaERlcHRoTWF0ZXJpYWwgKSB7XG5cbiAgICBcdFx0XHRcdHJlZnJlc2hVbmlmb3Jtc0NvbW1vbiggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdC8vIHJlZnJlc2ggc2luZ2xlIG1hdGVyaWFsIHNwZWNpZmljIHVuaWZvcm1zXG5cbiAgICBcdFx0XHRpZiAoIG1hdGVyaWFsLmlzTGluZUJhc2ljTWF0ZXJpYWwgKSB7XG5cbiAgICBcdFx0XHRcdHJlZnJlc2hVbmlmb3Jtc0xpbmUoIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XG5cbiAgICBcdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5pc0xpbmVEYXNoZWRNYXRlcmlhbCApIHtcblxuICAgIFx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zTGluZSggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcbiAgICBcdFx0XHRcdHJlZnJlc2hVbmlmb3Jtc0Rhc2goIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XG5cbiAgICBcdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5pc1BvaW50c01hdGVyaWFsICkge1xuXG4gICAgXHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNQb2ludHMoIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XG5cbiAgICBcdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5pc01lc2hMYW1iZXJ0TWF0ZXJpYWwgKSB7XG5cbiAgICBcdFx0XHRcdHJlZnJlc2hVbmlmb3Jtc0xhbWJlcnQoIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XG5cbiAgICBcdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5pc01lc2hQaG9uZ01hdGVyaWFsICkge1xuXG4gICAgXHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNQaG9uZyggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcblxuICAgIFx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLmlzTWVzaFBoeXNpY2FsTWF0ZXJpYWwgKSB7XG5cbiAgICBcdFx0XHRcdHJlZnJlc2hVbmlmb3Jtc1BoeXNpY2FsKCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xuXG4gICAgXHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuaXNNZXNoU3RhbmRhcmRNYXRlcmlhbCApIHtcblxuICAgIFx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zU3RhbmRhcmQoIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XG5cbiAgICBcdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5pc01lc2hEZXB0aE1hdGVyaWFsICkge1xuXG4gICAgXHRcdFx0XHRpZiAoIG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcCApIHtcblxuICAgIFx0XHRcdFx0XHRtX3VuaWZvcm1zLmRpc3BsYWNlbWVudE1hcC52YWx1ZSA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcDtcbiAgICBcdFx0XHRcdFx0bV91bmlmb3Jtcy5kaXNwbGFjZW1lbnRTY2FsZS52YWx1ZSA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudFNjYWxlO1xuICAgIFx0XHRcdFx0XHRtX3VuaWZvcm1zLmRpc3BsYWNlbWVudEJpYXMudmFsdWUgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRCaWFzO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5pc01lc2hOb3JtYWxNYXRlcmlhbCApIHtcblxuICAgIFx0XHRcdFx0bV91bmlmb3Jtcy5vcGFjaXR5LnZhbHVlID0gbWF0ZXJpYWwub3BhY2l0eTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdFdlYkdMVW5pZm9ybXMudXBsb2FkKFxuICAgIFx0XHRcdFx0XHRfZ2wsIG1hdGVyaWFsUHJvcGVydGllcy51bmlmb3Jtc0xpc3QsIG1fdW5pZm9ybXMsIF90aGlzICk7XG5cbiAgICBcdFx0fVxuXG5cbiAgICBcdFx0Ly8gY29tbW9uIG1hdHJpY2VzXG5cbiAgICBcdFx0cF91bmlmb3Jtcy5zZXQoIF9nbCwgb2JqZWN0LCAnbW9kZWxWaWV3TWF0cml4JyApO1xuICAgIFx0XHRwX3VuaWZvcm1zLnNldCggX2dsLCBvYmplY3QsICdub3JtYWxNYXRyaXgnICk7XG4gICAgXHRcdHBfdW5pZm9ybXMuc2V0VmFsdWUoIF9nbCwgJ21vZGVsTWF0cml4Jywgb2JqZWN0Lm1hdHJpeFdvcmxkICk7XG5cblxuICAgIFx0XHQvLyBkeW5hbWljIHVuaWZvcm1zXG5cbiAgICBcdFx0dmFyIGR5blVuaWZvcm1zID0gbWF0ZXJpYWxQcm9wZXJ0aWVzLmR5bmFtaWNVbmlmb3JtcztcblxuICAgIFx0XHRpZiAoIGR5blVuaWZvcm1zICE9PSBudWxsICkge1xuXG4gICAgXHRcdFx0V2ViR0xVbmlmb3Jtcy5ldmFsRHluYW1pYyggZHluVW5pZm9ybXMsIG1fdW5pZm9ybXMsIG9iamVjdCwgbWF0ZXJpYWwsIGNhbWVyYSApO1xuICAgIFx0XHRcdFdlYkdMVW5pZm9ybXMudXBsb2FkKCBfZ2wsIGR5blVuaWZvcm1zLCBtX3VuaWZvcm1zLCBfdGhpcyApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gcHJvZ3JhbTtcblxuICAgIFx0fVxuXG4gICAgXHQvLyBVbmlmb3JtcyAocmVmcmVzaCB1bmlmb3JtcyBvYmplY3RzKVxuXG4gICAgXHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNDb21tb24oIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcblxuICAgIFx0XHR1bmlmb3Jtcy5vcGFjaXR5LnZhbHVlID0gbWF0ZXJpYWwub3BhY2l0eTtcblxuICAgIFx0XHR1bmlmb3Jtcy5kaWZmdXNlLnZhbHVlID0gbWF0ZXJpYWwuY29sb3I7XG5cbiAgICBcdFx0aWYgKCBtYXRlcmlhbC5lbWlzc2l2ZSApIHtcblxuICAgIFx0XHRcdHVuaWZvcm1zLmVtaXNzaXZlLnZhbHVlLmNvcHkoIG1hdGVyaWFsLmVtaXNzaXZlICkubXVsdGlwbHlTY2FsYXIoIG1hdGVyaWFsLmVtaXNzaXZlSW50ZW5zaXR5ICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHVuaWZvcm1zLm1hcC52YWx1ZSA9IG1hdGVyaWFsLm1hcDtcbiAgICBcdFx0dW5pZm9ybXMuc3BlY3VsYXJNYXAudmFsdWUgPSBtYXRlcmlhbC5zcGVjdWxhck1hcDtcbiAgICBcdFx0dW5pZm9ybXMuYWxwaGFNYXAudmFsdWUgPSBtYXRlcmlhbC5hbHBoYU1hcDtcblxuICAgIFx0XHRpZiAoIG1hdGVyaWFsLmFvTWFwICkge1xuXG4gICAgXHRcdFx0dW5pZm9ybXMuYW9NYXAudmFsdWUgPSBtYXRlcmlhbC5hb01hcDtcbiAgICBcdFx0XHR1bmlmb3Jtcy5hb01hcEludGVuc2l0eS52YWx1ZSA9IG1hdGVyaWFsLmFvTWFwSW50ZW5zaXR5O1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHQvLyB1diByZXBlYXQgYW5kIG9mZnNldCBzZXR0aW5nIHByaW9yaXRpZXNcbiAgICBcdFx0Ly8gMS4gY29sb3IgbWFwXG4gICAgXHRcdC8vIDIuIHNwZWN1bGFyIG1hcFxuICAgIFx0XHQvLyAzLiBub3JtYWwgbWFwXG4gICAgXHRcdC8vIDQuIGJ1bXAgbWFwXG4gICAgXHRcdC8vIDUuIGFscGhhIG1hcFxuICAgIFx0XHQvLyA2LiBlbWlzc2l2ZSBtYXBcblxuICAgIFx0XHR2YXIgdXZTY2FsZU1hcDtcblxuICAgIFx0XHRpZiAoIG1hdGVyaWFsLm1hcCApIHtcblxuICAgIFx0XHRcdHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5tYXA7XG5cbiAgICBcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuc3BlY3VsYXJNYXAgKSB7XG5cbiAgICBcdFx0XHR1dlNjYWxlTWFwID0gbWF0ZXJpYWwuc3BlY3VsYXJNYXA7XG5cbiAgICBcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwICkge1xuXG4gICAgXHRcdFx0dXZTY2FsZU1hcCA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcDtcblxuICAgIFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5ub3JtYWxNYXAgKSB7XG5cbiAgICBcdFx0XHR1dlNjYWxlTWFwID0gbWF0ZXJpYWwubm9ybWFsTWFwO1xuXG4gICAgXHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLmJ1bXBNYXAgKSB7XG5cbiAgICBcdFx0XHR1dlNjYWxlTWFwID0gbWF0ZXJpYWwuYnVtcE1hcDtcblxuICAgIFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5yb3VnaG5lc3NNYXAgKSB7XG5cbiAgICBcdFx0XHR1dlNjYWxlTWFwID0gbWF0ZXJpYWwucm91Z2huZXNzTWFwO1xuXG4gICAgXHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLm1ldGFsbmVzc01hcCApIHtcblxuICAgIFx0XHRcdHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5tZXRhbG5lc3NNYXA7XG5cbiAgICBcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuYWxwaGFNYXAgKSB7XG5cbiAgICBcdFx0XHR1dlNjYWxlTWFwID0gbWF0ZXJpYWwuYWxwaGFNYXA7XG5cbiAgICBcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuZW1pc3NpdmVNYXAgKSB7XG5cbiAgICBcdFx0XHR1dlNjYWxlTWFwID0gbWF0ZXJpYWwuZW1pc3NpdmVNYXA7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGlmICggdXZTY2FsZU1hcCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0Ly8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICBcdFx0XHRpZiAoIHV2U2NhbGVNYXAuaXNXZWJHTFJlbmRlclRhcmdldCApIHtcblxuICAgIFx0XHRcdFx0dXZTY2FsZU1hcCA9IHV2U2NhbGVNYXAudGV4dHVyZTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdHZhciBvZmZzZXQgPSB1dlNjYWxlTWFwLm9mZnNldDtcbiAgICBcdFx0XHR2YXIgcmVwZWF0ID0gdXZTY2FsZU1hcC5yZXBlYXQ7XG5cbiAgICBcdFx0XHR1bmlmb3Jtcy5vZmZzZXRSZXBlYXQudmFsdWUuc2V0KCBvZmZzZXQueCwgb2Zmc2V0LnksIHJlcGVhdC54LCByZXBlYXQueSApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHR1bmlmb3Jtcy5lbnZNYXAudmFsdWUgPSBtYXRlcmlhbC5lbnZNYXA7XG5cbiAgICBcdFx0Ly8gZG9uJ3QgZmxpcCBDdWJlVGV4dHVyZSBlbnZNYXBzLCBmbGlwIGV2ZXJ5dGhpbmcgZWxzZTpcbiAgICBcdFx0Ly8gIFdlYkdMUmVuZGVyVGFyZ2V0Q3ViZSB3aWxsIGJlIGZsaXBwZWQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgXHRcdC8vICBXZWJHTFJlbmRlclRhcmdldEN1YmUudGV4dHVyZSB3aWxsIGJlIGZsaXBwZWQgYmVjYXVzZSBpdCdzIGEgVGV4dHVyZSBhbmQgTk9UIGEgQ3ViZVRleHR1cmVcbiAgICBcdFx0Ly8gdGhpcyBjaGVjayBtdXN0IGJlIGhhbmRsZWQgZGlmZmVyZW50bHksIG9yIHJlbW92ZWQgZW50aXJlbHksIGlmIFdlYkdMUmVuZGVyVGFyZ2V0Q3ViZSB1c2VzIGEgQ3ViZVRleHR1cmUgaW4gdGhlIGZ1dHVyZVxuICAgIFx0XHR1bmlmb3Jtcy5mbGlwRW52TWFwLnZhbHVlID0gKCAhICggbWF0ZXJpYWwuZW52TWFwICYmIG1hdGVyaWFsLmVudk1hcC5pc0N1YmVUZXh0dXJlICkgKSA/IDEgOiAtIDE7XG5cbiAgICBcdFx0dW5pZm9ybXMucmVmbGVjdGl2aXR5LnZhbHVlID0gbWF0ZXJpYWwucmVmbGVjdGl2aXR5O1xuICAgIFx0XHR1bmlmb3Jtcy5yZWZyYWN0aW9uUmF0aW8udmFsdWUgPSBtYXRlcmlhbC5yZWZyYWN0aW9uUmF0aW87XG5cbiAgICBcdH1cblxuICAgIFx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zTGluZSggdW5pZm9ybXMsIG1hdGVyaWFsICkge1xuXG4gICAgXHRcdHVuaWZvcm1zLmRpZmZ1c2UudmFsdWUgPSBtYXRlcmlhbC5jb2xvcjtcbiAgICBcdFx0dW5pZm9ybXMub3BhY2l0eS52YWx1ZSA9IG1hdGVyaWFsLm9wYWNpdHk7XG5cbiAgICBcdH1cblxuICAgIFx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zRGFzaCggdW5pZm9ybXMsIG1hdGVyaWFsICkge1xuXG4gICAgXHRcdHVuaWZvcm1zLmRhc2hTaXplLnZhbHVlID0gbWF0ZXJpYWwuZGFzaFNpemU7XG4gICAgXHRcdHVuaWZvcm1zLnRvdGFsU2l6ZS52YWx1ZSA9IG1hdGVyaWFsLmRhc2hTaXplICsgbWF0ZXJpYWwuZ2FwU2l6ZTtcbiAgICBcdFx0dW5pZm9ybXMuc2NhbGUudmFsdWUgPSBtYXRlcmlhbC5zY2FsZTtcblxuICAgIFx0fVxuXG4gICAgXHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNQb2ludHMoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcblxuICAgIFx0XHR1bmlmb3Jtcy5kaWZmdXNlLnZhbHVlID0gbWF0ZXJpYWwuY29sb3I7XG4gICAgXHRcdHVuaWZvcm1zLm9wYWNpdHkudmFsdWUgPSBtYXRlcmlhbC5vcGFjaXR5O1xuICAgIFx0XHR1bmlmb3Jtcy5zaXplLnZhbHVlID0gbWF0ZXJpYWwuc2l6ZSAqIF9waXhlbFJhdGlvO1xuICAgIFx0XHR1bmlmb3Jtcy5zY2FsZS52YWx1ZSA9IF9jYW52YXMuY2xpZW50SGVpZ2h0ICogMC41O1xuXG4gICAgXHRcdHVuaWZvcm1zLm1hcC52YWx1ZSA9IG1hdGVyaWFsLm1hcDtcblxuICAgIFx0XHRpZiAoIG1hdGVyaWFsLm1hcCAhPT0gbnVsbCApIHtcblxuICAgIFx0XHRcdHZhciBvZmZzZXQgPSBtYXRlcmlhbC5tYXAub2Zmc2V0O1xuICAgIFx0XHRcdHZhciByZXBlYXQgPSBtYXRlcmlhbC5tYXAucmVwZWF0O1xuXG4gICAgXHRcdFx0dW5pZm9ybXMub2Zmc2V0UmVwZWF0LnZhbHVlLnNldCggb2Zmc2V0LngsIG9mZnNldC55LCByZXBlYXQueCwgcmVwZWF0LnkgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdH1cblxuICAgIFx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zRm9nKCB1bmlmb3JtcywgZm9nICkge1xuXG4gICAgXHRcdHVuaWZvcm1zLmZvZ0NvbG9yLnZhbHVlID0gZm9nLmNvbG9yO1xuXG4gICAgXHRcdGlmICggZm9nLmlzRm9nICkge1xuXG4gICAgXHRcdFx0dW5pZm9ybXMuZm9nTmVhci52YWx1ZSA9IGZvZy5uZWFyO1xuICAgIFx0XHRcdHVuaWZvcm1zLmZvZ0Zhci52YWx1ZSA9IGZvZy5mYXI7XG5cbiAgICBcdFx0fSBlbHNlIGlmICggZm9nLmlzRm9nRXhwMiApIHtcblxuICAgIFx0XHRcdHVuaWZvcm1zLmZvZ0RlbnNpdHkudmFsdWUgPSBmb2cuZGVuc2l0eTtcblxuICAgIFx0XHR9XG5cbiAgICBcdH1cblxuICAgIFx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zTGFtYmVydCggdW5pZm9ybXMsIG1hdGVyaWFsICkge1xuXG4gICAgXHRcdGlmICggbWF0ZXJpYWwubGlnaHRNYXAgKSB7XG5cbiAgICBcdFx0XHR1bmlmb3Jtcy5saWdodE1hcC52YWx1ZSA9IG1hdGVyaWFsLmxpZ2h0TWFwO1xuICAgIFx0XHRcdHVuaWZvcm1zLmxpZ2h0TWFwSW50ZW5zaXR5LnZhbHVlID0gbWF0ZXJpYWwubGlnaHRNYXBJbnRlbnNpdHk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGlmICggbWF0ZXJpYWwuZW1pc3NpdmVNYXAgKSB7XG5cbiAgICBcdFx0XHR1bmlmb3Jtcy5lbWlzc2l2ZU1hcC52YWx1ZSA9IG1hdGVyaWFsLmVtaXNzaXZlTWFwO1xuXG4gICAgXHRcdH1cblxuICAgIFx0fVxuXG4gICAgXHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNQaG9uZyggdW5pZm9ybXMsIG1hdGVyaWFsICkge1xuXG4gICAgXHRcdHVuaWZvcm1zLnNwZWN1bGFyLnZhbHVlID0gbWF0ZXJpYWwuc3BlY3VsYXI7XG4gICAgXHRcdHVuaWZvcm1zLnNoaW5pbmVzcy52YWx1ZSA9IE1hdGgubWF4KCBtYXRlcmlhbC5zaGluaW5lc3MsIDFlLTQgKTsgLy8gdG8gcHJldmVudCBwb3coIDAuMCwgMC4wIClcblxuICAgIFx0XHRpZiAoIG1hdGVyaWFsLmxpZ2h0TWFwICkge1xuXG4gICAgXHRcdFx0dW5pZm9ybXMubGlnaHRNYXAudmFsdWUgPSBtYXRlcmlhbC5saWdodE1hcDtcbiAgICBcdFx0XHR1bmlmb3Jtcy5saWdodE1hcEludGVuc2l0eS52YWx1ZSA9IG1hdGVyaWFsLmxpZ2h0TWFwSW50ZW5zaXR5O1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoIG1hdGVyaWFsLmVtaXNzaXZlTWFwICkge1xuXG4gICAgXHRcdFx0dW5pZm9ybXMuZW1pc3NpdmVNYXAudmFsdWUgPSBtYXRlcmlhbC5lbWlzc2l2ZU1hcDtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKCBtYXRlcmlhbC5idW1wTWFwICkge1xuXG4gICAgXHRcdFx0dW5pZm9ybXMuYnVtcE1hcC52YWx1ZSA9IG1hdGVyaWFsLmJ1bXBNYXA7XG4gICAgXHRcdFx0dW5pZm9ybXMuYnVtcFNjYWxlLnZhbHVlID0gbWF0ZXJpYWwuYnVtcFNjYWxlO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoIG1hdGVyaWFsLm5vcm1hbE1hcCApIHtcblxuICAgIFx0XHRcdHVuaWZvcm1zLm5vcm1hbE1hcC52YWx1ZSA9IG1hdGVyaWFsLm5vcm1hbE1hcDtcbiAgICBcdFx0XHR1bmlmb3Jtcy5ub3JtYWxTY2FsZS52YWx1ZS5jb3B5KCBtYXRlcmlhbC5ub3JtYWxTY2FsZSApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoIG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcCApIHtcblxuICAgIFx0XHRcdHVuaWZvcm1zLmRpc3BsYWNlbWVudE1hcC52YWx1ZSA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcDtcbiAgICBcdFx0XHR1bmlmb3Jtcy5kaXNwbGFjZW1lbnRTY2FsZS52YWx1ZSA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudFNjYWxlO1xuICAgIFx0XHRcdHVuaWZvcm1zLmRpc3BsYWNlbWVudEJpYXMudmFsdWUgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRCaWFzO1xuXG4gICAgXHRcdH1cblxuICAgIFx0fVxuXG4gICAgXHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNTdGFuZGFyZCggdW5pZm9ybXMsIG1hdGVyaWFsICkge1xuXG4gICAgXHRcdHVuaWZvcm1zLnJvdWdobmVzcy52YWx1ZSA9IG1hdGVyaWFsLnJvdWdobmVzcztcbiAgICBcdFx0dW5pZm9ybXMubWV0YWxuZXNzLnZhbHVlID0gbWF0ZXJpYWwubWV0YWxuZXNzO1xuXG4gICAgXHRcdGlmICggbWF0ZXJpYWwucm91Z2huZXNzTWFwICkge1xuXG4gICAgXHRcdFx0dW5pZm9ybXMucm91Z2huZXNzTWFwLnZhbHVlID0gbWF0ZXJpYWwucm91Z2huZXNzTWFwO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoIG1hdGVyaWFsLm1ldGFsbmVzc01hcCApIHtcblxuICAgIFx0XHRcdHVuaWZvcm1zLm1ldGFsbmVzc01hcC52YWx1ZSA9IG1hdGVyaWFsLm1ldGFsbmVzc01hcDtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKCBtYXRlcmlhbC5saWdodE1hcCApIHtcblxuICAgIFx0XHRcdHVuaWZvcm1zLmxpZ2h0TWFwLnZhbHVlID0gbWF0ZXJpYWwubGlnaHRNYXA7XG4gICAgXHRcdFx0dW5pZm9ybXMubGlnaHRNYXBJbnRlbnNpdHkudmFsdWUgPSBtYXRlcmlhbC5saWdodE1hcEludGVuc2l0eTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKCBtYXRlcmlhbC5lbWlzc2l2ZU1hcCApIHtcblxuICAgIFx0XHRcdHVuaWZvcm1zLmVtaXNzaXZlTWFwLnZhbHVlID0gbWF0ZXJpYWwuZW1pc3NpdmVNYXA7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGlmICggbWF0ZXJpYWwuYnVtcE1hcCApIHtcblxuICAgIFx0XHRcdHVuaWZvcm1zLmJ1bXBNYXAudmFsdWUgPSBtYXRlcmlhbC5idW1wTWFwO1xuICAgIFx0XHRcdHVuaWZvcm1zLmJ1bXBTY2FsZS52YWx1ZSA9IG1hdGVyaWFsLmJ1bXBTY2FsZTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKCBtYXRlcmlhbC5ub3JtYWxNYXAgKSB7XG5cbiAgICBcdFx0XHR1bmlmb3Jtcy5ub3JtYWxNYXAudmFsdWUgPSBtYXRlcmlhbC5ub3JtYWxNYXA7XG4gICAgXHRcdFx0dW5pZm9ybXMubm9ybWFsU2NhbGUudmFsdWUuY29weSggbWF0ZXJpYWwubm9ybWFsU2NhbGUgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKCBtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXAgKSB7XG5cbiAgICBcdFx0XHR1bmlmb3Jtcy5kaXNwbGFjZW1lbnRNYXAudmFsdWUgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXA7XG4gICAgXHRcdFx0dW5pZm9ybXMuZGlzcGxhY2VtZW50U2NhbGUudmFsdWUgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRTY2FsZTtcbiAgICBcdFx0XHR1bmlmb3Jtcy5kaXNwbGFjZW1lbnRCaWFzLnZhbHVlID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50QmlhcztcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKCBtYXRlcmlhbC5lbnZNYXAgKSB7XG5cbiAgICBcdFx0XHQvL3VuaWZvcm1zLmVudk1hcC52YWx1ZSA9IG1hdGVyaWFsLmVudk1hcDsgLy8gcGFydCBvZiB1bmlmb3JtcyBjb21tb25cbiAgICBcdFx0XHR1bmlmb3Jtcy5lbnZNYXBJbnRlbnNpdHkudmFsdWUgPSBtYXRlcmlhbC5lbnZNYXBJbnRlbnNpdHk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9XG5cbiAgICBcdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc1BoeXNpY2FsKCB1bmlmb3JtcywgbWF0ZXJpYWwgKSB7XG5cbiAgICBcdFx0dW5pZm9ybXMuY2xlYXJDb2F0LnZhbHVlID0gbWF0ZXJpYWwuY2xlYXJDb2F0O1xuICAgIFx0XHR1bmlmb3Jtcy5jbGVhckNvYXRSb3VnaG5lc3MudmFsdWUgPSBtYXRlcmlhbC5jbGVhckNvYXRSb3VnaG5lc3M7XG5cbiAgICBcdFx0cmVmcmVzaFVuaWZvcm1zU3RhbmRhcmQoIHVuaWZvcm1zLCBtYXRlcmlhbCApO1xuXG4gICAgXHR9XG5cbiAgICBcdC8vIElmIHVuaWZvcm1zIGFyZSBtYXJrZWQgYXMgY2xlYW4sIHRoZXkgZG9uJ3QgbmVlZCB0byBiZSBsb2FkZWQgdG8gdGhlIEdQVS5cblxuICAgIFx0ZnVuY3Rpb24gbWFya1VuaWZvcm1zTGlnaHRzTmVlZHNVcGRhdGUoIHVuaWZvcm1zLCB2YWx1ZSApIHtcblxuICAgIFx0XHR1bmlmb3Jtcy5hbWJpZW50TGlnaHRDb2xvci5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuXG4gICAgXHRcdHVuaWZvcm1zLmRpcmVjdGlvbmFsTGlnaHRzLm5lZWRzVXBkYXRlID0gdmFsdWU7XG4gICAgXHRcdHVuaWZvcm1zLnBvaW50TGlnaHRzLm5lZWRzVXBkYXRlID0gdmFsdWU7XG4gICAgXHRcdHVuaWZvcm1zLnNwb3RMaWdodHMubmVlZHNVcGRhdGUgPSB2YWx1ZTtcbiAgICBcdFx0dW5pZm9ybXMuaGVtaXNwaGVyZUxpZ2h0cy5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuXG4gICAgXHR9XG5cbiAgICBcdC8vIExpZ2h0aW5nXG5cbiAgICBcdGZ1bmN0aW9uIHNldHVwU2hhZG93cyggbGlnaHRzICkge1xuXG4gICAgXHRcdHZhciBsaWdodFNoYWRvd3NMZW5ndGggPSAwO1xuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGxpZ2h0cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgXHRcdFx0dmFyIGxpZ2h0ID0gbGlnaHRzWyBpIF07XG5cbiAgICBcdFx0XHRpZiAoIGxpZ2h0LmNhc3RTaGFkb3cgKSB7XG5cbiAgICBcdFx0XHRcdF9saWdodHMuc2hhZG93c1sgbGlnaHRTaGFkb3dzTGVuZ3RoICsrIF0gPSBsaWdodDtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdFx0X2xpZ2h0cy5zaGFkb3dzLmxlbmd0aCA9IGxpZ2h0U2hhZG93c0xlbmd0aDtcblxuICAgIFx0fVxuXG4gICAgXHRmdW5jdGlvbiBzZXR1cExpZ2h0cyggbGlnaHRzLCBjYW1lcmEgKSB7XG5cbiAgICBcdFx0dmFyIGwsIGxsLCBsaWdodCxcbiAgICBcdFx0ciA9IDAsIGcgPSAwLCBiID0gMCxcbiAgICBcdFx0Y29sb3IsXG4gICAgXHRcdGludGVuc2l0eSxcbiAgICBcdFx0ZGlzdGFuY2UsXG4gICAgXHRcdHNoYWRvd01hcCxcblxuICAgIFx0XHR2aWV3TWF0cml4ID0gY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSxcblxuICAgIFx0XHRkaXJlY3Rpb25hbExlbmd0aCA9IDAsXG4gICAgXHRcdHBvaW50TGVuZ3RoID0gMCxcbiAgICBcdFx0c3BvdExlbmd0aCA9IDAsXG4gICAgXHRcdGhlbWlMZW5ndGggPSAwO1xuXG4gICAgXHRcdGZvciAoIGwgPSAwLCBsbCA9IGxpZ2h0cy5sZW5ndGg7IGwgPCBsbDsgbCArKyApIHtcblxuICAgIFx0XHRcdGxpZ2h0ID0gbGlnaHRzWyBsIF07XG5cbiAgICBcdFx0XHRjb2xvciA9IGxpZ2h0LmNvbG9yO1xuICAgIFx0XHRcdGludGVuc2l0eSA9IGxpZ2h0LmludGVuc2l0eTtcbiAgICBcdFx0XHRkaXN0YW5jZSA9IGxpZ2h0LmRpc3RhbmNlO1xuXG4gICAgXHRcdFx0c2hhZG93TWFwID0gKCBsaWdodC5zaGFkb3cgJiYgbGlnaHQuc2hhZG93Lm1hcCApID8gbGlnaHQuc2hhZG93Lm1hcC50ZXh0dXJlIDogbnVsbDtcblxuICAgIFx0XHRcdGlmICggbGlnaHQuaXNBbWJpZW50TGlnaHQgKSB7XG5cbiAgICBcdFx0XHRcdHIgKz0gY29sb3IuciAqIGludGVuc2l0eTtcbiAgICBcdFx0XHRcdGcgKz0gY29sb3IuZyAqIGludGVuc2l0eTtcbiAgICBcdFx0XHRcdGIgKz0gY29sb3IuYiAqIGludGVuc2l0eTtcblxuICAgIFx0XHRcdH0gZWxzZSBpZiAoIGxpZ2h0LmlzRGlyZWN0aW9uYWxMaWdodCApIHtcblxuICAgIFx0XHRcdFx0dmFyIHVuaWZvcm1zID0gbGlnaHRDYWNoZS5nZXQoIGxpZ2h0ICk7XG5cbiAgICBcdFx0XHRcdHVuaWZvcm1zLmNvbG9yLmNvcHkoIGxpZ2h0LmNvbG9yICkubXVsdGlwbHlTY2FsYXIoIGxpZ2h0LmludGVuc2l0eSApO1xuICAgIFx0XHRcdFx0dW5pZm9ybXMuZGlyZWN0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQubWF0cml4V29ybGQgKTtcbiAgICBcdFx0XHRcdF92ZWN0b3IzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQudGFyZ2V0Lm1hdHJpeFdvcmxkICk7XG4gICAgXHRcdFx0XHR1bmlmb3Jtcy5kaXJlY3Rpb24uc3ViKCBfdmVjdG9yMyApO1xuICAgIFx0XHRcdFx0dW5pZm9ybXMuZGlyZWN0aW9uLnRyYW5zZm9ybURpcmVjdGlvbiggdmlld01hdHJpeCApO1xuXG4gICAgXHRcdFx0XHR1bmlmb3Jtcy5zaGFkb3cgPSBsaWdodC5jYXN0U2hhZG93O1xuXG4gICAgXHRcdFx0XHRpZiAoIGxpZ2h0LmNhc3RTaGFkb3cgKSB7XG5cbiAgICBcdFx0XHRcdFx0dW5pZm9ybXMuc2hhZG93QmlhcyA9IGxpZ2h0LnNoYWRvdy5iaWFzO1xuICAgIFx0XHRcdFx0XHR1bmlmb3Jtcy5zaGFkb3dSYWRpdXMgPSBsaWdodC5zaGFkb3cucmFkaXVzO1xuICAgIFx0XHRcdFx0XHR1bmlmb3Jtcy5zaGFkb3dNYXBTaXplID0gbGlnaHQuc2hhZG93Lm1hcFNpemU7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0X2xpZ2h0cy5kaXJlY3Rpb25hbFNoYWRvd01hcFsgZGlyZWN0aW9uYWxMZW5ndGggXSA9IHNoYWRvd01hcDtcbiAgICBcdFx0XHRcdF9saWdodHMuZGlyZWN0aW9uYWxTaGFkb3dNYXRyaXhbIGRpcmVjdGlvbmFsTGVuZ3RoIF0gPSBsaWdodC5zaGFkb3cubWF0cml4O1xuICAgIFx0XHRcdFx0X2xpZ2h0cy5kaXJlY3Rpb25hbFsgZGlyZWN0aW9uYWxMZW5ndGggKysgXSA9IHVuaWZvcm1zO1xuXG4gICAgXHRcdFx0fSBlbHNlIGlmICggbGlnaHQuaXNTcG90TGlnaHQgKSB7XG5cbiAgICBcdFx0XHRcdHZhciB1bmlmb3JtcyA9IGxpZ2h0Q2FjaGUuZ2V0KCBsaWdodCApO1xuXG4gICAgXHRcdFx0XHR1bmlmb3Jtcy5wb3NpdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0Lm1hdHJpeFdvcmxkICk7XG4gICAgXHRcdFx0XHR1bmlmb3Jtcy5wb3NpdGlvbi5hcHBseU1hdHJpeDQoIHZpZXdNYXRyaXggKTtcblxuICAgIFx0XHRcdFx0dW5pZm9ybXMuY29sb3IuY29weSggY29sb3IgKS5tdWx0aXBseVNjYWxhciggaW50ZW5zaXR5ICk7XG4gICAgXHRcdFx0XHR1bmlmb3Jtcy5kaXN0YW5jZSA9IGRpc3RhbmNlO1xuXG4gICAgXHRcdFx0XHR1bmlmb3Jtcy5kaXJlY3Rpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC5tYXRyaXhXb3JsZCApO1xuICAgIFx0XHRcdFx0X3ZlY3RvcjMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC50YXJnZXQubWF0cml4V29ybGQgKTtcbiAgICBcdFx0XHRcdHVuaWZvcm1zLmRpcmVjdGlvbi5zdWIoIF92ZWN0b3IzICk7XG4gICAgXHRcdFx0XHR1bmlmb3Jtcy5kaXJlY3Rpb24udHJhbnNmb3JtRGlyZWN0aW9uKCB2aWV3TWF0cml4ICk7XG5cbiAgICBcdFx0XHRcdHVuaWZvcm1zLmNvbmVDb3MgPSBNYXRoLmNvcyggbGlnaHQuYW5nbGUgKTtcbiAgICBcdFx0XHRcdHVuaWZvcm1zLnBlbnVtYnJhQ29zID0gTWF0aC5jb3MoIGxpZ2h0LmFuZ2xlICogKCAxIC0gbGlnaHQucGVudW1icmEgKSApO1xuICAgIFx0XHRcdFx0dW5pZm9ybXMuZGVjYXkgPSAoIGxpZ2h0LmRpc3RhbmNlID09PSAwICkgPyAwLjAgOiBsaWdodC5kZWNheTtcblxuICAgIFx0XHRcdFx0dW5pZm9ybXMuc2hhZG93ID0gbGlnaHQuY2FzdFNoYWRvdztcblxuICAgIFx0XHRcdFx0aWYgKCBsaWdodC5jYXN0U2hhZG93ICkge1xuXG4gICAgXHRcdFx0XHRcdHVuaWZvcm1zLnNoYWRvd0JpYXMgPSBsaWdodC5zaGFkb3cuYmlhcztcbiAgICBcdFx0XHRcdFx0dW5pZm9ybXMuc2hhZG93UmFkaXVzID0gbGlnaHQuc2hhZG93LnJhZGl1cztcbiAgICBcdFx0XHRcdFx0dW5pZm9ybXMuc2hhZG93TWFwU2l6ZSA9IGxpZ2h0LnNoYWRvdy5tYXBTaXplO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdF9saWdodHMuc3BvdFNoYWRvd01hcFsgc3BvdExlbmd0aCBdID0gc2hhZG93TWFwO1xuICAgIFx0XHRcdFx0X2xpZ2h0cy5zcG90U2hhZG93TWF0cml4WyBzcG90TGVuZ3RoIF0gPSBsaWdodC5zaGFkb3cubWF0cml4O1xuICAgIFx0XHRcdFx0X2xpZ2h0cy5zcG90WyBzcG90TGVuZ3RoICsrIF0gPSB1bmlmb3JtcztcblxuICAgIFx0XHRcdH0gZWxzZSBpZiAoIGxpZ2h0LmlzUG9pbnRMaWdodCApIHtcblxuICAgIFx0XHRcdFx0dmFyIHVuaWZvcm1zID0gbGlnaHRDYWNoZS5nZXQoIGxpZ2h0ICk7XG5cbiAgICBcdFx0XHRcdHVuaWZvcm1zLnBvc2l0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQubWF0cml4V29ybGQgKTtcbiAgICBcdFx0XHRcdHVuaWZvcm1zLnBvc2l0aW9uLmFwcGx5TWF0cml4NCggdmlld01hdHJpeCApO1xuXG4gICAgXHRcdFx0XHR1bmlmb3Jtcy5jb2xvci5jb3B5KCBsaWdodC5jb2xvciApLm11bHRpcGx5U2NhbGFyKCBsaWdodC5pbnRlbnNpdHkgKTtcbiAgICBcdFx0XHRcdHVuaWZvcm1zLmRpc3RhbmNlID0gbGlnaHQuZGlzdGFuY2U7XG4gICAgXHRcdFx0XHR1bmlmb3Jtcy5kZWNheSA9ICggbGlnaHQuZGlzdGFuY2UgPT09IDAgKSA/IDAuMCA6IGxpZ2h0LmRlY2F5O1xuXG4gICAgXHRcdFx0XHR1bmlmb3Jtcy5zaGFkb3cgPSBsaWdodC5jYXN0U2hhZG93O1xuXG4gICAgXHRcdFx0XHRpZiAoIGxpZ2h0LmNhc3RTaGFkb3cgKSB7XG5cbiAgICBcdFx0XHRcdFx0dW5pZm9ybXMuc2hhZG93QmlhcyA9IGxpZ2h0LnNoYWRvdy5iaWFzO1xuICAgIFx0XHRcdFx0XHR1bmlmb3Jtcy5zaGFkb3dSYWRpdXMgPSBsaWdodC5zaGFkb3cucmFkaXVzO1xuICAgIFx0XHRcdFx0XHR1bmlmb3Jtcy5zaGFkb3dNYXBTaXplID0gbGlnaHQuc2hhZG93Lm1hcFNpemU7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0X2xpZ2h0cy5wb2ludFNoYWRvd01hcFsgcG9pbnRMZW5ndGggXSA9IHNoYWRvd01hcDtcblxuICAgIFx0XHRcdFx0aWYgKCBfbGlnaHRzLnBvaW50U2hhZG93TWF0cml4WyBwb2ludExlbmd0aCBdID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRcdFx0X2xpZ2h0cy5wb2ludFNoYWRvd01hdHJpeFsgcG9pbnRMZW5ndGggXSA9IG5ldyBNYXRyaXg0KCk7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0Ly8gZm9yIHBvaW50IGxpZ2h0cyB3ZSBzZXQgdGhlIHNoYWRvdyBtYXRyaXggdG8gYmUgYSB0cmFuc2xhdGlvbi1vbmx5IG1hdHJpeFxuICAgIFx0XHRcdFx0Ly8gZXF1YWwgdG8gaW52ZXJzZSBvZiB0aGUgbGlnaHQncyBwb3NpdGlvblxuICAgIFx0XHRcdFx0X3ZlY3RvcjMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC5tYXRyaXhXb3JsZCApLm5lZ2F0ZSgpO1xuICAgIFx0XHRcdFx0X2xpZ2h0cy5wb2ludFNoYWRvd01hdHJpeFsgcG9pbnRMZW5ndGggXS5pZGVudGl0eSgpLnNldFBvc2l0aW9uKCBfdmVjdG9yMyApO1xuXG4gICAgXHRcdFx0XHRfbGlnaHRzLnBvaW50WyBwb2ludExlbmd0aCArKyBdID0gdW5pZm9ybXM7XG5cbiAgICBcdFx0XHR9IGVsc2UgaWYgKCBsaWdodC5pc0hlbWlzcGhlcmVMaWdodCApIHtcblxuICAgIFx0XHRcdFx0dmFyIHVuaWZvcm1zID0gbGlnaHRDYWNoZS5nZXQoIGxpZ2h0ICk7XG5cbiAgICBcdFx0XHRcdHVuaWZvcm1zLmRpcmVjdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0Lm1hdHJpeFdvcmxkICk7XG4gICAgXHRcdFx0XHR1bmlmb3Jtcy5kaXJlY3Rpb24udHJhbnNmb3JtRGlyZWN0aW9uKCB2aWV3TWF0cml4ICk7XG4gICAgXHRcdFx0XHR1bmlmb3Jtcy5kaXJlY3Rpb24ubm9ybWFsaXplKCk7XG5cbiAgICBcdFx0XHRcdHVuaWZvcm1zLnNreUNvbG9yLmNvcHkoIGxpZ2h0LmNvbG9yICkubXVsdGlwbHlTY2FsYXIoIGludGVuc2l0eSApO1xuICAgIFx0XHRcdFx0dW5pZm9ybXMuZ3JvdW5kQ29sb3IuY29weSggbGlnaHQuZ3JvdW5kQ29sb3IgKS5tdWx0aXBseVNjYWxhciggaW50ZW5zaXR5ICk7XG5cbiAgICBcdFx0XHRcdF9saWdodHMuaGVtaVsgaGVtaUxlbmd0aCArKyBdID0gdW5pZm9ybXM7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdF9saWdodHMuYW1iaWVudFsgMCBdID0gcjtcbiAgICBcdFx0X2xpZ2h0cy5hbWJpZW50WyAxIF0gPSBnO1xuICAgIFx0XHRfbGlnaHRzLmFtYmllbnRbIDIgXSA9IGI7XG5cbiAgICBcdFx0X2xpZ2h0cy5kaXJlY3Rpb25hbC5sZW5ndGggPSBkaXJlY3Rpb25hbExlbmd0aDtcbiAgICBcdFx0X2xpZ2h0cy5zcG90Lmxlbmd0aCA9IHNwb3RMZW5ndGg7XG4gICAgXHRcdF9saWdodHMucG9pbnQubGVuZ3RoID0gcG9pbnRMZW5ndGg7XG4gICAgXHRcdF9saWdodHMuaGVtaS5sZW5ndGggPSBoZW1pTGVuZ3RoO1xuXG4gICAgXHRcdF9saWdodHMuaGFzaCA9IGRpcmVjdGlvbmFsTGVuZ3RoICsgJywnICsgcG9pbnRMZW5ndGggKyAnLCcgKyBzcG90TGVuZ3RoICsgJywnICsgaGVtaUxlbmd0aCArICcsJyArIF9saWdodHMuc2hhZG93cy5sZW5ndGg7XG5cbiAgICBcdH1cblxuICAgIFx0Ly8gR0wgc3RhdGUgc2V0dGluZ1xuXG4gICAgXHR0aGlzLnNldEZhY2VDdWxsaW5nID0gZnVuY3Rpb24gKCBjdWxsRmFjZSwgZnJvbnRGYWNlRGlyZWN0aW9uICkge1xuXG4gICAgXHRcdHN0YXRlLnNldEN1bGxGYWNlKCBjdWxsRmFjZSApO1xuICAgIFx0XHRzdGF0ZS5zZXRGbGlwU2lkZWQoIGZyb250RmFjZURpcmVjdGlvbiA9PT0gRnJvbnRGYWNlRGlyZWN0aW9uQ1cgKTtcblxuICAgIFx0fTtcblxuICAgIFx0Ly8gVGV4dHVyZXNcblxuICAgIFx0ZnVuY3Rpb24gYWxsb2NUZXh0dXJlVW5pdCgpIHtcblxuICAgIFx0XHR2YXIgdGV4dHVyZVVuaXQgPSBfdXNlZFRleHR1cmVVbml0cztcblxuICAgIFx0XHRpZiAoIHRleHR1cmVVbml0ID49IGNhcGFiaWxpdGllcy5tYXhUZXh0dXJlcyApIHtcblxuICAgIFx0XHRcdGNvbnNvbGUud2FybiggJ1dlYkdMUmVuZGVyZXI6IHRyeWluZyB0byB1c2UgJyArIHRleHR1cmVVbml0ICsgJyB0ZXh0dXJlIHVuaXRzIHdoaWxlIHRoaXMgR1BVIHN1cHBvcnRzIG9ubHkgJyArIGNhcGFiaWxpdGllcy5tYXhUZXh0dXJlcyApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRfdXNlZFRleHR1cmVVbml0cyArPSAxO1xuXG4gICAgXHRcdHJldHVybiB0ZXh0dXJlVW5pdDtcblxuICAgIFx0fVxuXG4gICAgXHR0aGlzLmFsbG9jVGV4dHVyZVVuaXQgPSBhbGxvY1RleHR1cmVVbml0O1xuXG4gICAgXHQvLyB0aGlzLnNldFRleHR1cmUyRCA9IHNldFRleHR1cmUyRDtcbiAgICBcdHRoaXMuc2V0VGV4dHVyZTJEID0gKCBmdW5jdGlvbigpIHtcblxuICAgIFx0XHR2YXIgd2FybmVkID0gZmFsc2U7XG5cbiAgICBcdFx0Ly8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHk6IHBlZWwgdGV4dHVyZS50ZXh0dXJlXG4gICAgXHRcdHJldHVybiBmdW5jdGlvbiBzZXRUZXh0dXJlMkQoIHRleHR1cmUsIHNsb3QgKSB7XG5cbiAgICBcdFx0XHRpZiAoIHRleHR1cmUgJiYgdGV4dHVyZS5pc1dlYkdMUmVuZGVyVGFyZ2V0ICkge1xuXG4gICAgXHRcdFx0XHRpZiAoICEgd2FybmVkICkge1xuXG4gICAgXHRcdFx0XHRcdGNvbnNvbGUud2FybiggXCJUSFJFRS5XZWJHTFJlbmRlcmVyLnNldFRleHR1cmUyRDogZG9uJ3QgdXNlIHJlbmRlciB0YXJnZXRzIGFzIHRleHR1cmVzLiBVc2UgdGhlaXIgLnRleHR1cmUgcHJvcGVydHkgaW5zdGVhZC5cIiApO1xuICAgIFx0XHRcdFx0XHR3YXJuZWQgPSB0cnVlO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdHRleHR1cmUgPSB0ZXh0dXJlLnRleHR1cmU7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHR0ZXh0dXJlcy5zZXRUZXh0dXJlMkQoIHRleHR1cmUsIHNsb3QgKTtcblxuICAgIFx0XHR9O1xuXG4gICAgXHR9KCkgKTtcblxuICAgIFx0dGhpcy5zZXRUZXh0dXJlID0gKCBmdW5jdGlvbigpIHtcblxuICAgIFx0XHR2YXIgd2FybmVkID0gZmFsc2U7XG5cbiAgICBcdFx0cmV0dXJuIGZ1bmN0aW9uIHNldFRleHR1cmUoIHRleHR1cmUsIHNsb3QgKSB7XG5cbiAgICBcdFx0XHRpZiAoICEgd2FybmVkICkge1xuXG4gICAgXHRcdFx0XHRjb25zb2xlLndhcm4oIFwiVEhSRUUuV2ViR0xSZW5kZXJlcjogLnNldFRleHR1cmUgaXMgZGVwcmVjYXRlZCwgdXNlIHNldFRleHR1cmUyRCBpbnN0ZWFkLlwiICk7XG4gICAgXHRcdFx0XHR3YXJuZWQgPSB0cnVlO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0dGV4dHVyZXMuc2V0VGV4dHVyZTJEKCB0ZXh0dXJlLCBzbG90ICk7XG5cbiAgICBcdFx0fTtcblxuICAgIFx0fSgpICk7XG5cbiAgICBcdHRoaXMuc2V0VGV4dHVyZUN1YmUgPSAoIGZ1bmN0aW9uKCkge1xuXG4gICAgXHRcdHZhciB3YXJuZWQgPSBmYWxzZTtcblxuICAgIFx0XHRyZXR1cm4gZnVuY3Rpb24gc2V0VGV4dHVyZUN1YmUoIHRleHR1cmUsIHNsb3QgKSB7XG5cbiAgICBcdFx0XHQvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eTogcGVlbCB0ZXh0dXJlLnRleHR1cmVcbiAgICBcdFx0XHRpZiAoIHRleHR1cmUgJiYgdGV4dHVyZS5pc1dlYkdMUmVuZGVyVGFyZ2V0Q3ViZSApIHtcblxuICAgIFx0XHRcdFx0aWYgKCAhIHdhcm5lZCApIHtcblxuICAgIFx0XHRcdFx0XHRjb25zb2xlLndhcm4oIFwiVEhSRUUuV2ViR0xSZW5kZXJlci5zZXRUZXh0dXJlQ3ViZTogZG9uJ3QgdXNlIGN1YmUgcmVuZGVyIHRhcmdldHMgYXMgdGV4dHVyZXMuIFVzZSB0aGVpciAudGV4dHVyZSBwcm9wZXJ0eSBpbnN0ZWFkLlwiICk7XG4gICAgXHRcdFx0XHRcdHdhcm5lZCA9IHRydWU7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0dGV4dHVyZSA9IHRleHR1cmUudGV4dHVyZTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdC8vIGN1cnJlbnRseSByZWx5aW5nIG9uIHRoZSBmYWN0IHRoYXQgV2ViR0xSZW5kZXJUYXJnZXRDdWJlLnRleHR1cmUgaXMgYSBUZXh0dXJlIGFuZCBOT1QgYSBDdWJlVGV4dHVyZVxuICAgIFx0XHRcdC8vIFRPRE86IHVuaWZ5IHRoZXNlIGNvZGUgcGF0aHNcbiAgICBcdFx0XHRpZiAoICggdGV4dHVyZSAmJiB0ZXh0dXJlLmlzQ3ViZVRleHR1cmUgKSB8fFxuICAgIFx0XHRcdFx0ICggQXJyYXkuaXNBcnJheSggdGV4dHVyZS5pbWFnZSApICYmIHRleHR1cmUuaW1hZ2UubGVuZ3RoID09PSA2ICkgKSB7XG5cbiAgICBcdFx0XHRcdC8vIENvbXByZXNzZWRUZXh0dXJlIGNhbiBoYXZlIEFycmF5IGluIGltYWdlIDovXG5cbiAgICBcdFx0XHRcdC8vIHRoaXMgZnVuY3Rpb24gYWxvbmUgc2hvdWxkIHRha2UgY2FyZSBvZiBjdWJlIHRleHR1cmVzXG4gICAgXHRcdFx0XHR0ZXh0dXJlcy5zZXRUZXh0dXJlQ3ViZSggdGV4dHVyZSwgc2xvdCApO1xuXG4gICAgXHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0Ly8gYXNzdW1lZDogdGV4dHVyZSBwcm9wZXJ0eSBvZiBUSFJFRS5XZWJHTFJlbmRlclRhcmdldEN1YmVcblxuICAgIFx0XHRcdFx0dGV4dHVyZXMuc2V0VGV4dHVyZUN1YmVEeW5hbWljKCB0ZXh0dXJlLCBzbG90ICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fTtcblxuICAgIFx0fSgpICk7XG5cbiAgICBcdHRoaXMuZ2V0Q3VycmVudFJlbmRlclRhcmdldCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgXHRcdHJldHVybiBfY3VycmVudFJlbmRlclRhcmdldDtcblxuICAgIFx0fTtcblxuICAgIFx0dGhpcy5zZXRSZW5kZXJUYXJnZXQgPSBmdW5jdGlvbiAoIHJlbmRlclRhcmdldCApIHtcblxuICAgIFx0XHRfY3VycmVudFJlbmRlclRhcmdldCA9IHJlbmRlclRhcmdldDtcblxuICAgIFx0XHRpZiAoIHJlbmRlclRhcmdldCAmJiBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0ICkuX193ZWJnbEZyYW1lYnVmZmVyID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHR0ZXh0dXJlcy5zZXR1cFJlbmRlclRhcmdldCggcmVuZGVyVGFyZ2V0ICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHZhciBpc0N1YmUgPSAoIHJlbmRlclRhcmdldCAmJiByZW5kZXJUYXJnZXQuaXNXZWJHTFJlbmRlclRhcmdldEN1YmUgKTtcbiAgICBcdFx0dmFyIGZyYW1lYnVmZmVyO1xuXG4gICAgXHRcdGlmICggcmVuZGVyVGFyZ2V0ICkge1xuXG4gICAgXHRcdFx0dmFyIHJlbmRlclRhcmdldFByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0ICk7XG5cbiAgICBcdFx0XHRpZiAoIGlzQ3ViZSApIHtcblxuICAgIFx0XHRcdFx0ZnJhbWVidWZmZXIgPSByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlclsgcmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlIF07XG5cbiAgICBcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRmcmFtZWJ1ZmZlciA9IHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0X2N1cnJlbnRTY2lzc29yLmNvcHkoIHJlbmRlclRhcmdldC5zY2lzc29yICk7XG4gICAgXHRcdFx0X2N1cnJlbnRTY2lzc29yVGVzdCA9IHJlbmRlclRhcmdldC5zY2lzc29yVGVzdDtcblxuICAgIFx0XHRcdF9jdXJyZW50Vmlld3BvcnQuY29weSggcmVuZGVyVGFyZ2V0LnZpZXdwb3J0ICk7XG5cbiAgICBcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdGZyYW1lYnVmZmVyID0gbnVsbDtcblxuICAgIFx0XHRcdF9jdXJyZW50U2Npc3Nvci5jb3B5KCBfc2Npc3NvciApLm11bHRpcGx5U2NhbGFyKCBfcGl4ZWxSYXRpbyApO1xuICAgIFx0XHRcdF9jdXJyZW50U2Npc3NvclRlc3QgPSBfc2Npc3NvclRlc3Q7XG5cbiAgICBcdFx0XHRfY3VycmVudFZpZXdwb3J0LmNvcHkoIF92aWV3cG9ydCApLm11bHRpcGx5U2NhbGFyKCBfcGl4ZWxSYXRpbyApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoIF9jdXJyZW50RnJhbWVidWZmZXIgIT09IGZyYW1lYnVmZmVyICkge1xuXG4gICAgXHRcdFx0X2dsLmJpbmRGcmFtZWJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBmcmFtZWJ1ZmZlciApO1xuICAgIFx0XHRcdF9jdXJyZW50RnJhbWVidWZmZXIgPSBmcmFtZWJ1ZmZlcjtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0c3RhdGUuc2Npc3NvciggX2N1cnJlbnRTY2lzc29yICk7XG4gICAgXHRcdHN0YXRlLnNldFNjaXNzb3JUZXN0KCBfY3VycmVudFNjaXNzb3JUZXN0ICk7XG5cbiAgICBcdFx0c3RhdGUudmlld3BvcnQoIF9jdXJyZW50Vmlld3BvcnQgKTtcblxuICAgIFx0XHRpZiAoIGlzQ3ViZSApIHtcblxuICAgIFx0XHRcdHZhciB0ZXh0dXJlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQudGV4dHVyZSApO1xuICAgIFx0XHRcdF9nbC5mcmFtZWJ1ZmZlclRleHR1cmUyRCggX2dsLkZSQU1FQlVGRkVSLCBfZ2wuQ09MT1JfQVRUQUNITUVOVDAsIF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyByZW5kZXJUYXJnZXQuYWN0aXZlQ3ViZUZhY2UsIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlLCByZW5kZXJUYXJnZXQuYWN0aXZlTWlwTWFwTGV2ZWwgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdH07XG5cbiAgICBcdHRoaXMucmVhZFJlbmRlclRhcmdldFBpeGVscyA9IGZ1bmN0aW9uICggcmVuZGVyVGFyZ2V0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBidWZmZXIgKSB7XG5cbiAgICBcdFx0aWYgKCAoIHJlbmRlclRhcmdldCAmJiByZW5kZXJUYXJnZXQuaXNXZWJHTFJlbmRlclRhcmdldCApID09PSBmYWxzZSApIHtcblxuICAgIFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHM6IHJlbmRlclRhcmdldCBpcyBub3QgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQuJyApO1xuICAgIFx0XHRcdHJldHVybjtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0dmFyIGZyYW1lYnVmZmVyID0gcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldCApLl9fd2ViZ2xGcmFtZWJ1ZmZlcjtcblxuICAgIFx0XHRpZiAoIGZyYW1lYnVmZmVyICkge1xuXG4gICAgXHRcdFx0dmFyIHJlc3RvcmUgPSBmYWxzZTtcblxuICAgIFx0XHRcdGlmICggZnJhbWVidWZmZXIgIT09IF9jdXJyZW50RnJhbWVidWZmZXIgKSB7XG5cbiAgICBcdFx0XHRcdF9nbC5iaW5kRnJhbWVidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgZnJhbWVidWZmZXIgKTtcblxuICAgIFx0XHRcdFx0cmVzdG9yZSA9IHRydWU7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHR0cnkge1xuXG4gICAgXHRcdFx0XHR2YXIgdGV4dHVyZSA9IHJlbmRlclRhcmdldC50ZXh0dXJlO1xuICAgIFx0XHRcdFx0dmFyIHRleHR1cmVGb3JtYXQgPSB0ZXh0dXJlLmZvcm1hdDtcbiAgICBcdFx0XHRcdHZhciB0ZXh0dXJlVHlwZSA9IHRleHR1cmUudHlwZTtcblxuICAgIFx0XHRcdFx0aWYgKCB0ZXh0dXJlRm9ybWF0ICE9PSBSR0JBRm9ybWF0ICYmIHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlRm9ybWF0ICkgIT09IF9nbC5nZXRQYXJhbWV0ZXIoIF9nbC5JTVBMRU1FTlRBVElPTl9DT0xPUl9SRUFEX0ZPUk1BVCApICkge1xuXG4gICAgXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHM6IHJlbmRlclRhcmdldCBpcyBub3QgaW4gUkdCQSBvciBpbXBsZW1lbnRhdGlvbiBkZWZpbmVkIGZvcm1hdC4nICk7XG4gICAgXHRcdFx0XHRcdHJldHVybjtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRpZiAoIHRleHR1cmVUeXBlICE9PSBVbnNpZ25lZEJ5dGVUeXBlICYmIHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlVHlwZSApICE9PSBfZ2wuZ2V0UGFyYW1ldGVyKCBfZ2wuSU1QTEVNRU5UQVRJT05fQ09MT1JfUkVBRF9UWVBFICkgJiYgLy8gSUUxMSwgRWRnZSBhbmQgQ2hyb21lIE1hYyA8IDUyICgjOTUxMylcbiAgICBcdFx0XHRcdCAgICAgISAoIHRleHR1cmVUeXBlID09PSBGbG9hdFR5cGUgJiYgKCBleHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2Zsb2F0JyApIHx8IGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfY29sb3JfYnVmZmVyX2Zsb2F0JyApICkgKSAmJiAvLyBDaHJvbWUgTWFjID49IDUyIGFuZCBGaXJlZm94XG4gICAgXHRcdFx0XHQgICAgICEgKCB0ZXh0dXJlVHlwZSA9PT0gSGFsZkZsb2F0VHlwZSAmJiBleHRlbnNpb25zLmdldCggJ0VYVF9jb2xvcl9idWZmZXJfaGFsZl9mbG9hdCcgKSApICkge1xuXG4gICAgXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHM6IHJlbmRlclRhcmdldCBpcyBub3QgaW4gVW5zaWduZWRCeXRlVHlwZSBvciBpbXBsZW1lbnRhdGlvbiBkZWZpbmVkIHR5cGUuJyApO1xuICAgIFx0XHRcdFx0XHRyZXR1cm47XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0aWYgKCBfZ2wuY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cyggX2dsLkZSQU1FQlVGRkVSICkgPT09IF9nbC5GUkFNRUJVRkZFUl9DT01QTEVURSApIHtcblxuICAgIFx0XHRcdFx0XHQvLyB0aGUgZm9sbG93aW5nIGlmIHN0YXRlbWVudCBlbnN1cmVzIHZhbGlkIHJlYWQgcmVxdWVzdHMgKG5vIG91dC1vZi1ib3VuZHMgcGl4ZWxzLCBzZWUgIzg2MDQpXG5cbiAgICBcdFx0XHRcdFx0aWYgKCAoIHggPj0gMCAmJiB4IDw9ICggcmVuZGVyVGFyZ2V0LndpZHRoIC0gd2lkdGggKSApICYmICggeSA+PSAwICYmIHkgPD0gKCByZW5kZXJUYXJnZXQuaGVpZ2h0IC0gaGVpZ2h0ICkgKSApIHtcblxuICAgIFx0XHRcdFx0XHRcdF9nbC5yZWFkUGl4ZWxzKCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBwYXJhbVRocmVlVG9HTCggdGV4dHVyZUZvcm1hdCApLCBwYXJhbVRocmVlVG9HTCggdGV4dHVyZVR5cGUgKSwgYnVmZmVyICk7XG5cbiAgICBcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHM6IHJlYWRQaXhlbHMgZnJvbSByZW5kZXJUYXJnZXQgZmFpbGVkLiBGcmFtZWJ1ZmZlciBub3QgY29tcGxldGUuJyApO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9IGZpbmFsbHkge1xuXG4gICAgXHRcdFx0XHRpZiAoIHJlc3RvcmUgKSB7XG5cbiAgICBcdFx0XHRcdFx0X2dsLmJpbmRGcmFtZWJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBfY3VycmVudEZyYW1lYnVmZmVyICk7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdH07XG5cbiAgICBcdC8vIE1hcCB0aHJlZS5qcyBjb25zdGFudHMgdG8gV2ViR0wgY29uc3RhbnRzXG5cbiAgICBcdGZ1bmN0aW9uIHBhcmFtVGhyZWVUb0dMKCBwICkge1xuXG4gICAgXHRcdHZhciBleHRlbnNpb247XG5cbiAgICBcdFx0aWYgKCBwID09PSBSZXBlYXRXcmFwcGluZyApIHJldHVybiBfZ2wuUkVQRUFUO1xuICAgIFx0XHRpZiAoIHAgPT09IENsYW1wVG9FZGdlV3JhcHBpbmcgKSByZXR1cm4gX2dsLkNMQU1QX1RPX0VER0U7XG4gICAgXHRcdGlmICggcCA9PT0gTWlycm9yZWRSZXBlYXRXcmFwcGluZyApIHJldHVybiBfZ2wuTUlSUk9SRURfUkVQRUFUO1xuXG4gICAgXHRcdGlmICggcCA9PT0gTmVhcmVzdEZpbHRlciApIHJldHVybiBfZ2wuTkVBUkVTVDtcbiAgICBcdFx0aWYgKCBwID09PSBOZWFyZXN0TWlwTWFwTmVhcmVzdEZpbHRlciApIHJldHVybiBfZ2wuTkVBUkVTVF9NSVBNQVBfTkVBUkVTVDtcbiAgICBcdFx0aWYgKCBwID09PSBOZWFyZXN0TWlwTWFwTGluZWFyRmlsdGVyICkgcmV0dXJuIF9nbC5ORUFSRVNUX01JUE1BUF9MSU5FQVI7XG5cbiAgICBcdFx0aWYgKCBwID09PSBMaW5lYXJGaWx0ZXIgKSByZXR1cm4gX2dsLkxJTkVBUjtcbiAgICBcdFx0aWYgKCBwID09PSBMaW5lYXJNaXBNYXBOZWFyZXN0RmlsdGVyICkgcmV0dXJuIF9nbC5MSU5FQVJfTUlQTUFQX05FQVJFU1Q7XG4gICAgXHRcdGlmICggcCA9PT0gTGluZWFyTWlwTWFwTGluZWFyRmlsdGVyICkgcmV0dXJuIF9nbC5MSU5FQVJfTUlQTUFQX0xJTkVBUjtcblxuICAgIFx0XHRpZiAoIHAgPT09IFVuc2lnbmVkQnl0ZVR5cGUgKSByZXR1cm4gX2dsLlVOU0lHTkVEX0JZVEU7XG4gICAgXHRcdGlmICggcCA9PT0gVW5zaWduZWRTaG9ydDQ0NDRUeXBlICkgcmV0dXJuIF9nbC5VTlNJR05FRF9TSE9SVF80XzRfNF80O1xuICAgIFx0XHRpZiAoIHAgPT09IFVuc2lnbmVkU2hvcnQ1NTUxVHlwZSApIHJldHVybiBfZ2wuVU5TSUdORURfU0hPUlRfNV81XzVfMTtcbiAgICBcdFx0aWYgKCBwID09PSBVbnNpZ25lZFNob3J0NTY1VHlwZSApIHJldHVybiBfZ2wuVU5TSUdORURfU0hPUlRfNV82XzU7XG5cbiAgICBcdFx0aWYgKCBwID09PSBCeXRlVHlwZSApIHJldHVybiBfZ2wuQllURTtcbiAgICBcdFx0aWYgKCBwID09PSBTaG9ydFR5cGUgKSByZXR1cm4gX2dsLlNIT1JUO1xuICAgIFx0XHRpZiAoIHAgPT09IFVuc2lnbmVkU2hvcnRUeXBlICkgcmV0dXJuIF9nbC5VTlNJR05FRF9TSE9SVDtcbiAgICBcdFx0aWYgKCBwID09PSBJbnRUeXBlICkgcmV0dXJuIF9nbC5JTlQ7XG4gICAgXHRcdGlmICggcCA9PT0gVW5zaWduZWRJbnRUeXBlICkgcmV0dXJuIF9nbC5VTlNJR05FRF9JTlQ7XG4gICAgXHRcdGlmICggcCA9PT0gRmxvYXRUeXBlICkgcmV0dXJuIF9nbC5GTE9BVDtcblxuICAgIFx0XHRleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2hhbGZfZmxvYXQnICk7XG5cbiAgICBcdFx0aWYgKCBleHRlbnNpb24gIT09IG51bGwgKSB7XG5cbiAgICBcdFx0XHRpZiAoIHAgPT09IEhhbGZGbG9hdFR5cGUgKSByZXR1cm4gZXh0ZW5zaW9uLkhBTEZfRkxPQVRfT0VTO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoIHAgPT09IEFscGhhRm9ybWF0ICkgcmV0dXJuIF9nbC5BTFBIQTtcbiAgICBcdFx0aWYgKCBwID09PSBSR0JGb3JtYXQgKSByZXR1cm4gX2dsLlJHQjtcbiAgICBcdFx0aWYgKCBwID09PSBSR0JBRm9ybWF0ICkgcmV0dXJuIF9nbC5SR0JBO1xuICAgIFx0XHRpZiAoIHAgPT09IEx1bWluYW5jZUZvcm1hdCApIHJldHVybiBfZ2wuTFVNSU5BTkNFO1xuICAgIFx0XHRpZiAoIHAgPT09IEx1bWluYW5jZUFscGhhRm9ybWF0ICkgcmV0dXJuIF9nbC5MVU1JTkFOQ0VfQUxQSEE7XG4gICAgXHRcdGlmICggcCA9PT0gRGVwdGhGb3JtYXQgKSByZXR1cm4gX2dsLkRFUFRIX0NPTVBPTkVOVDtcbiAgICBcdFx0aWYgKCBwID09PSBEZXB0aFN0ZW5jaWxGb3JtYXQgKSByZXR1cm4gX2dsLkRFUFRIX1NURU5DSUw7XG5cbiAgICBcdFx0aWYgKCBwID09PSBBZGRFcXVhdGlvbiApIHJldHVybiBfZ2wuRlVOQ19BREQ7XG4gICAgXHRcdGlmICggcCA9PT0gU3VidHJhY3RFcXVhdGlvbiApIHJldHVybiBfZ2wuRlVOQ19TVUJUUkFDVDtcbiAgICBcdFx0aWYgKCBwID09PSBSZXZlcnNlU3VidHJhY3RFcXVhdGlvbiApIHJldHVybiBfZ2wuRlVOQ19SRVZFUlNFX1NVQlRSQUNUO1xuXG4gICAgXHRcdGlmICggcCA9PT0gWmVyb0ZhY3RvciApIHJldHVybiBfZ2wuWkVSTztcbiAgICBcdFx0aWYgKCBwID09PSBPbmVGYWN0b3IgKSByZXR1cm4gX2dsLk9ORTtcbiAgICBcdFx0aWYgKCBwID09PSBTcmNDb2xvckZhY3RvciApIHJldHVybiBfZ2wuU1JDX0NPTE9SO1xuICAgIFx0XHRpZiAoIHAgPT09IE9uZU1pbnVzU3JjQ29sb3JGYWN0b3IgKSByZXR1cm4gX2dsLk9ORV9NSU5VU19TUkNfQ09MT1I7XG4gICAgXHRcdGlmICggcCA9PT0gU3JjQWxwaGFGYWN0b3IgKSByZXR1cm4gX2dsLlNSQ19BTFBIQTtcbiAgICBcdFx0aWYgKCBwID09PSBPbmVNaW51c1NyY0FscGhhRmFjdG9yICkgcmV0dXJuIF9nbC5PTkVfTUlOVVNfU1JDX0FMUEhBO1xuICAgIFx0XHRpZiAoIHAgPT09IERzdEFscGhhRmFjdG9yICkgcmV0dXJuIF9nbC5EU1RfQUxQSEE7XG4gICAgXHRcdGlmICggcCA9PT0gT25lTWludXNEc3RBbHBoYUZhY3RvciApIHJldHVybiBfZ2wuT05FX01JTlVTX0RTVF9BTFBIQTtcblxuICAgIFx0XHRpZiAoIHAgPT09IERzdENvbG9yRmFjdG9yICkgcmV0dXJuIF9nbC5EU1RfQ09MT1I7XG4gICAgXHRcdGlmICggcCA9PT0gT25lTWludXNEc3RDb2xvckZhY3RvciApIHJldHVybiBfZ2wuT05FX01JTlVTX0RTVF9DT0xPUjtcbiAgICBcdFx0aWYgKCBwID09PSBTcmNBbHBoYVNhdHVyYXRlRmFjdG9yICkgcmV0dXJuIF9nbC5TUkNfQUxQSEFfU0FUVVJBVEU7XG5cbiAgICBcdFx0ZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YycgKTtcblxuICAgIFx0XHRpZiAoIGV4dGVuc2lvbiAhPT0gbnVsbCApIHtcblxuICAgIFx0XHRcdGlmICggcCA9PT0gUkdCX1MzVENfRFhUMV9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCX1MzVENfRFhUMV9FWFQ7XG4gICAgXHRcdFx0aWYgKCBwID09PSBSR0JBX1MzVENfRFhUMV9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDFfRVhUO1xuICAgIFx0XHRcdGlmICggcCA9PT0gUkdCQV9TM1RDX0RYVDNfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQzX0VYVDtcbiAgICBcdFx0XHRpZiAoIHAgPT09IFJHQkFfUzNUQ19EWFQ1X0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUNV9FWFQ7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjJyApO1xuXG4gICAgXHRcdGlmICggZXh0ZW5zaW9uICE9PSBudWxsICkge1xuXG4gICAgXHRcdFx0aWYgKCBwID09PSBSR0JfUFZSVENfNEJQUFYxX0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JfUFZSVENfNEJQUFYxX0lNRztcbiAgICBcdFx0XHRpZiAoIHAgPT09IFJHQl9QVlJUQ18yQlBQVjFfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQl9QVlJUQ18yQlBQVjFfSU1HO1xuICAgIFx0XHRcdGlmICggcCA9PT0gUkdCQV9QVlJUQ180QlBQVjFfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfUFZSVENfNEJQUFYxX0lNRztcbiAgICBcdFx0XHRpZiAoIHAgPT09IFJHQkFfUFZSVENfMkJQUFYxX0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX1BWUlRDXzJCUFBWMV9JTUc7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX2V0YzEnICk7XG5cbiAgICBcdFx0aWYgKCBleHRlbnNpb24gIT09IG51bGwgKSB7XG5cbiAgICBcdFx0XHRpZiAoIHAgPT09IFJHQl9FVEMxX0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JfRVRDMV9XRUJHTDtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0ZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdFWFRfYmxlbmRfbWlubWF4JyApO1xuXG4gICAgXHRcdGlmICggZXh0ZW5zaW9uICE9PSBudWxsICkge1xuXG4gICAgXHRcdFx0aWYgKCBwID09PSBNaW5FcXVhdGlvbiApIHJldHVybiBleHRlbnNpb24uTUlOX0VYVDtcbiAgICBcdFx0XHRpZiAoIHAgPT09IE1heEVxdWF0aW9uICkgcmV0dXJuIGV4dGVuc2lvbi5NQVhfRVhUO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ1dFQkdMX2RlcHRoX3RleHR1cmUnICk7XG5cbiAgICBcdFx0aWYgKCBleHRlbnNpb24gIT09IG51bGwgKXtcblxuICAgIFx0XHRcdGlmICggcCA9PT0gVW5zaWduZWRJbnQyNDhUeXBlICkgcmV0dXJuIGV4dGVuc2lvbi5VTlNJR05FRF9JTlRfMjRfOF9XRUJHTDtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIDA7XG5cbiAgICBcdH1cblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gICAgICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIEZvZ0V4cDIgKCBjb2xvciwgZGVuc2l0eSApIHtcblxuICAgIFx0dGhpcy5uYW1lID0gJyc7XG5cbiAgICBcdHRoaXMuY29sb3IgPSBuZXcgQ29sb3IoIGNvbG9yICk7XG4gICAgXHR0aGlzLmRlbnNpdHkgPSAoIGRlbnNpdHkgIT09IHVuZGVmaW5lZCApID8gZGVuc2l0eSA6IDAuMDAwMjU7XG5cbiAgICB9XG5cbiAgICBGb2dFeHAyLnByb3RvdHlwZS5pc0ZvZ0V4cDIgPSB0cnVlO1xuXG4gICAgRm9nRXhwMi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdHJldHVybiBuZXcgRm9nRXhwMiggdGhpcy5jb2xvci5nZXRIZXgoKSwgdGhpcy5kZW5zaXR5ICk7XG5cbiAgICB9O1xuXG4gICAgRm9nRXhwMi5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCBtZXRhICkge1xuXG4gICAgXHRyZXR1cm4ge1xuICAgIFx0XHR0eXBlOiAnRm9nRXhwMicsXG4gICAgXHRcdGNvbG9yOiB0aGlzLmNvbG9yLmdldEhleCgpLFxuICAgIFx0XHRkZW5zaXR5OiB0aGlzLmRlbnNpdHlcbiAgICBcdH07XG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAgICAgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gRm9nICggY29sb3IsIG5lYXIsIGZhciApIHtcblxuICAgIFx0dGhpcy5uYW1lID0gJyc7XG5cbiAgICBcdHRoaXMuY29sb3IgPSBuZXcgQ29sb3IoIGNvbG9yICk7XG5cbiAgICBcdHRoaXMubmVhciA9ICggbmVhciAhPT0gdW5kZWZpbmVkICkgPyBuZWFyIDogMTtcbiAgICBcdHRoaXMuZmFyID0gKCBmYXIgIT09IHVuZGVmaW5lZCApID8gZmFyIDogMTAwMDtcblxuICAgIH1cblxuICAgIEZvZy5wcm90b3R5cGUuaXNGb2cgPSB0cnVlO1xuXG4gICAgRm9nLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0cmV0dXJuIG5ldyBGb2coIHRoaXMuY29sb3IuZ2V0SGV4KCksIHRoaXMubmVhciwgdGhpcy5mYXIgKTtcblxuICAgIH07XG5cbiAgICBGb2cucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICggbWV0YSApIHtcblxuICAgIFx0cmV0dXJuIHtcbiAgICBcdFx0dHlwZTogJ0ZvZycsXG4gICAgXHRcdGNvbG9yOiB0aGlzLmNvbG9yLmdldEhleCgpLFxuICAgIFx0XHRuZWFyOiB0aGlzLm5lYXIsXG4gICAgXHRcdGZhcjogdGhpcy5mYXJcbiAgICBcdH07XG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIFNjZW5lICgpIHtcblxuICAgIFx0T2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG4gICAgXHR0aGlzLnR5cGUgPSAnU2NlbmUnO1xuXG4gICAgXHR0aGlzLmJhY2tncm91bmQgPSBudWxsO1xuICAgIFx0dGhpcy5mb2cgPSBudWxsO1xuICAgIFx0dGhpcy5vdmVycmlkZU1hdGVyaWFsID0gbnVsbDtcblxuICAgIFx0dGhpcy5hdXRvVXBkYXRlID0gdHJ1ZTsgLy8gY2hlY2tlZCBieSB0aGUgcmVuZGVyZXJcblxuICAgIH1cblxuICAgIFNjZW5lLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE9iamVjdDNELnByb3RvdHlwZSApO1xuXG4gICAgU2NlbmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2NlbmU7XG5cbiAgICBTY2VuZS5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlLCByZWN1cnNpdmUgKSB7XG5cbiAgICBcdE9iamVjdDNELnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSwgcmVjdXJzaXZlICk7XG5cbiAgICBcdGlmICggc291cmNlLmJhY2tncm91bmQgIT09IG51bGwgKSB0aGlzLmJhY2tncm91bmQgPSBzb3VyY2UuYmFja2dyb3VuZC5jbG9uZSgpO1xuICAgIFx0aWYgKCBzb3VyY2UuZm9nICE9PSBudWxsICkgdGhpcy5mb2cgPSBzb3VyY2UuZm9nLmNsb25lKCk7XG4gICAgXHRpZiAoIHNvdXJjZS5vdmVycmlkZU1hdGVyaWFsICE9PSBudWxsICkgdGhpcy5vdmVycmlkZU1hdGVyaWFsID0gc291cmNlLm92ZXJyaWRlTWF0ZXJpYWwuY2xvbmUoKTtcblxuICAgIFx0dGhpcy5hdXRvVXBkYXRlID0gc291cmNlLmF1dG9VcGRhdGU7XG4gICAgXHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBzb3VyY2UubWF0cml4QXV0b1VwZGF0ZTtcblxuICAgIFx0cmV0dXJuIHRoaXM7XG5cbiAgICB9O1xuXG4gICAgU2NlbmUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICggbWV0YSApIHtcblxuICAgIFx0dmFyIGRhdGEgPSBPYmplY3QzRC5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMsIG1ldGEgKTtcblxuICAgIFx0aWYgKCB0aGlzLmJhY2tncm91bmQgIT09IG51bGwgKSBkYXRhLm9iamVjdC5iYWNrZ3JvdW5kID0gdGhpcy5iYWNrZ3JvdW5kLnRvSlNPTiggbWV0YSApO1xuICAgIFx0aWYgKCB0aGlzLmZvZyAhPT0gbnVsbCApIGRhdGEub2JqZWN0LmZvZyA9IHRoaXMuZm9nLnRvSlNPTigpO1xuXG4gICAgXHRyZXR1cm4gZGF0YTtcblxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICAgICAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBMZW5zRmxhcmUoIHRleHR1cmUsIHNpemUsIGRpc3RhbmNlLCBibGVuZGluZywgY29sb3IgKSB7XG5cbiAgICBcdE9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuICAgIFx0dGhpcy5sZW5zRmxhcmVzID0gW107XG5cbiAgICBcdHRoaXMucG9zaXRpb25TY3JlZW4gPSBuZXcgVmVjdG9yMygpO1xuICAgIFx0dGhpcy5jdXN0b21VcGRhdGVDYWxsYmFjayA9IHVuZGVmaW5lZDtcblxuICAgIFx0aWYgKCB0ZXh0dXJlICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0dGhpcy5hZGQoIHRleHR1cmUsIHNpemUsIGRpc3RhbmNlLCBibGVuZGluZywgY29sb3IgKTtcblxuICAgIFx0fVxuXG4gICAgfVxuXG4gICAgTGVuc0ZsYXJlLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIE9iamVjdDNELnByb3RvdHlwZSApLCB7XG5cbiAgICBcdGNvbnN0cnVjdG9yOiBMZW5zRmxhcmUsXG5cbiAgICBcdGlzTGVuc0ZsYXJlOiB0cnVlLFxuXG4gICAgXHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuICAgIFx0XHRPYmplY3QzRC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuICAgIFx0XHR0aGlzLnBvc2l0aW9uU2NyZWVuLmNvcHkoIHNvdXJjZS5wb3NpdGlvblNjcmVlbiApO1xuICAgIFx0XHR0aGlzLmN1c3RvbVVwZGF0ZUNhbGxiYWNrID0gc291cmNlLmN1c3RvbVVwZGF0ZUNhbGxiYWNrO1xuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHNvdXJjZS5sZW5zRmxhcmVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICBcdFx0XHR0aGlzLmxlbnNGbGFyZXMucHVzaCggc291cmNlLmxlbnNGbGFyZXNbIGkgXSApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0YWRkOiBmdW5jdGlvbiAoIHRleHR1cmUsIHNpemUsIGRpc3RhbmNlLCBibGVuZGluZywgY29sb3IsIG9wYWNpdHkgKSB7XG5cbiAgICBcdFx0aWYgKCBzaXplID09PSB1bmRlZmluZWQgKSBzaXplID0gLSAxO1xuICAgIFx0XHRpZiAoIGRpc3RhbmNlID09PSB1bmRlZmluZWQgKSBkaXN0YW5jZSA9IDA7XG4gICAgXHRcdGlmICggb3BhY2l0eSA9PT0gdW5kZWZpbmVkICkgb3BhY2l0eSA9IDE7XG4gICAgXHRcdGlmICggY29sb3IgPT09IHVuZGVmaW5lZCApIGNvbG9yID0gbmV3IENvbG9yKCAweGZmZmZmZiApO1xuICAgIFx0XHRpZiAoIGJsZW5kaW5nID09PSB1bmRlZmluZWQgKSBibGVuZGluZyA9IE5vcm1hbEJsZW5kaW5nO1xuXG4gICAgXHRcdGRpc3RhbmNlID0gTWF0aC5taW4oIGRpc3RhbmNlLCBNYXRoLm1heCggMCwgZGlzdGFuY2UgKSApO1xuXG4gICAgXHRcdHRoaXMubGVuc0ZsYXJlcy5wdXNoKCB7XG4gICAgXHRcdFx0dGV4dHVyZTogdGV4dHVyZSxcdC8vIFRIUkVFLlRleHR1cmVcbiAgICBcdFx0XHRzaXplOiBzaXplLCBcdFx0Ly8gc2l6ZSBpbiBwaXhlbHMgKC0xID0gdXNlIHRleHR1cmUud2lkdGgpXG4gICAgXHRcdFx0ZGlzdGFuY2U6IGRpc3RhbmNlLCBcdC8vIGRpc3RhbmNlICgwLTEpIGZyb20gbGlnaHQgc291cmNlICgwPWF0IGxpZ2h0IHNvdXJjZSlcbiAgICBcdFx0XHR4OiAwLCB5OiAwLCB6OiAwLFx0Ly8gc2NyZWVuIHBvc2l0aW9uICgtMSA9PiAxKSB6ID0gMCBpcyBpbiBmcm9udCB6ID0gMSBpcyBiYWNrXG4gICAgXHRcdFx0c2NhbGU6IDEsIFx0XHQvLyBzY2FsZVxuICAgIFx0XHRcdHJvdGF0aW9uOiAwLCBcdFx0Ly8gcm90YXRpb25cbiAgICBcdFx0XHRvcGFjaXR5OiBvcGFjaXR5LFx0Ly8gb3BhY2l0eVxuICAgIFx0XHRcdGNvbG9yOiBjb2xvcixcdFx0Ly8gY29sb3JcbiAgICBcdFx0XHRibGVuZGluZzogYmxlbmRpbmdcdC8vIGJsZW5kaW5nXG4gICAgXHRcdH0gKTtcblxuICAgIFx0fSxcblxuICAgIFx0LypcbiAgICBcdCAqIFVwZGF0ZSBsZW5zIGZsYXJlcyB1cGRhdGUgcG9zaXRpb25zIG9uIGFsbCBmbGFyZXMgYmFzZWQgb24gdGhlIHNjcmVlbiBwb3NpdGlvblxuICAgIFx0ICogU2V0IG15TGVuc0ZsYXJlLmN1c3RvbVVwZGF0ZUNhbGxiYWNrIHRvIGFsdGVyIHRoZSBmbGFyZXMgaW4geW91ciBwcm9qZWN0IHNwZWNpZmljIHdheS5cbiAgICBcdCAqL1xuXG4gICAgXHR1cGRhdGVMZW5zRmxhcmVzOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dmFyIGYsIGZsID0gdGhpcy5sZW5zRmxhcmVzLmxlbmd0aDtcbiAgICBcdFx0dmFyIGZsYXJlO1xuICAgIFx0XHR2YXIgdmVjWCA9IC0gdGhpcy5wb3NpdGlvblNjcmVlbi54ICogMjtcbiAgICBcdFx0dmFyIHZlY1kgPSAtIHRoaXMucG9zaXRpb25TY3JlZW4ueSAqIDI7XG5cbiAgICBcdFx0Zm9yICggZiA9IDA7IGYgPCBmbDsgZiArKyApIHtcblxuICAgIFx0XHRcdGZsYXJlID0gdGhpcy5sZW5zRmxhcmVzWyBmIF07XG5cbiAgICBcdFx0XHRmbGFyZS54ID0gdGhpcy5wb3NpdGlvblNjcmVlbi54ICsgdmVjWCAqIGZsYXJlLmRpc3RhbmNlO1xuICAgIFx0XHRcdGZsYXJlLnkgPSB0aGlzLnBvc2l0aW9uU2NyZWVuLnkgKyB2ZWNZICogZmxhcmUuZGlzdGFuY2U7XG5cbiAgICBcdFx0XHRmbGFyZS53YW50ZWRSb3RhdGlvbiA9IGZsYXJlLnggKiBNYXRoLlBJICogMC4yNTtcbiAgICBcdFx0XHRmbGFyZS5yb3RhdGlvbiArPSAoIGZsYXJlLndhbnRlZFJvdGF0aW9uIC0gZmxhcmUucm90YXRpb24gKSAqIDAuMjU7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9XG5cbiAgICB9ICk7XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICAgICAqXG4gICAgICogcGFyYW1ldGVycyA9IHtcbiAgICAgKiAgY29sb3I6IDxoZXg+LFxuICAgICAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxuICAgICAqICBtYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gICAgICpcbiAgICAgKlx0dXZPZmZzZXQ6IG5ldyBUSFJFRS5WZWN0b3IyKCksXG4gICAgICpcdHV2U2NhbGU6IG5ldyBUSFJFRS5WZWN0b3IyKClcbiAgICAgKiB9XG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBTcHJpdGVNYXRlcmlhbCggcGFyYW1ldGVycyApIHtcblxuICAgIFx0TWF0ZXJpYWwuY2FsbCggdGhpcyApO1xuXG4gICAgXHR0aGlzLnR5cGUgPSAnU3ByaXRlTWF0ZXJpYWwnO1xuXG4gICAgXHR0aGlzLmNvbG9yID0gbmV3IENvbG9yKCAweGZmZmZmZiApO1xuICAgIFx0dGhpcy5tYXAgPSBudWxsO1xuXG4gICAgXHR0aGlzLnJvdGF0aW9uID0gMDtcblxuICAgIFx0dGhpcy5mb2cgPSBmYWxzZTtcbiAgICBcdHRoaXMubGlnaHRzID0gZmFsc2U7XG5cbiAgICBcdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XG5cbiAgICB9XG5cbiAgICBTcHJpdGVNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBNYXRlcmlhbC5wcm90b3R5cGUgKTtcbiAgICBTcHJpdGVNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTcHJpdGVNYXRlcmlhbDtcblxuICAgIFNwcml0ZU1hdGVyaWFsLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cbiAgICBcdE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG4gICAgXHR0aGlzLmNvbG9yLmNvcHkoIHNvdXJjZS5jb2xvciApO1xuICAgIFx0dGhpcy5tYXAgPSBzb3VyY2UubWFwO1xuXG4gICAgXHR0aGlzLnJvdGF0aW9uID0gc291cmNlLnJvdGF0aW9uO1xuXG4gICAgXHRyZXR1cm4gdGhpcztcblxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICAgICAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBTcHJpdGUoIG1hdGVyaWFsICkge1xuXG4gICAgXHRPYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cbiAgICBcdHRoaXMudHlwZSA9ICdTcHJpdGUnO1xuXG4gICAgXHR0aGlzLm1hdGVyaWFsID0gKCBtYXRlcmlhbCAhPT0gdW5kZWZpbmVkICkgPyBtYXRlcmlhbCA6IG5ldyBTcHJpdGVNYXRlcmlhbCgpO1xuXG4gICAgfVxuXG4gICAgU3ByaXRlLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIE9iamVjdDNELnByb3RvdHlwZSApLCB7XG5cbiAgICBcdGNvbnN0cnVjdG9yOiBTcHJpdGUsXG5cbiAgICBcdGlzU3ByaXRlOiB0cnVlLFxuXG4gICAgXHRyYXljYXN0OiAoIGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR2YXIgbWF0cml4UG9zaXRpb24gPSBuZXcgVmVjdG9yMygpO1xuXG4gICAgXHRcdHJldHVybiBmdW5jdGlvbiByYXljYXN0KCByYXljYXN0ZXIsIGludGVyc2VjdHMgKSB7XG5cbiAgICBcdFx0XHRtYXRyaXhQb3NpdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubWF0cml4V29ybGQgKTtcblxuICAgIFx0XHRcdHZhciBkaXN0YW5jZVNxID0gcmF5Y2FzdGVyLnJheS5kaXN0YW5jZVNxVG9Qb2ludCggbWF0cml4UG9zaXRpb24gKTtcbiAgICBcdFx0XHR2YXIgZ3Vlc3NTaXplU3EgPSB0aGlzLnNjYWxlLnggKiB0aGlzLnNjYWxlLnkgLyA0O1xuXG4gICAgXHRcdFx0aWYgKCBkaXN0YW5jZVNxID4gZ3Vlc3NTaXplU3EgKSB7XG5cbiAgICBcdFx0XHRcdHJldHVybjtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGludGVyc2VjdHMucHVzaCgge1xuXG4gICAgXHRcdFx0XHRkaXN0YW5jZTogTWF0aC5zcXJ0KCBkaXN0YW5jZVNxICksXG4gICAgXHRcdFx0XHRwb2ludDogdGhpcy5wb3NpdGlvbixcbiAgICBcdFx0XHRcdGZhY2U6IG51bGwsXG4gICAgXHRcdFx0XHRvYmplY3Q6IHRoaXNcblxuICAgIFx0XHRcdH0gKTtcblxuICAgIFx0XHR9O1xuXG4gICAgXHR9KCkgKSxcblxuICAgIFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMubWF0ZXJpYWwgKS5jb3B5KCB0aGlzICk7XG5cbiAgICBcdH1cblxuICAgIH0gKTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gICAgICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAgICAgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gTE9EKCkge1xuXG4gICAgXHRPYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cbiAgICBcdHRoaXMudHlwZSA9ICdMT0QnO1xuXG4gICAgXHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyggdGhpcywge1xuICAgIFx0XHRsZXZlbHM6IHtcbiAgICBcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuICAgIFx0XHRcdHZhbHVlOiBbXVxuICAgIFx0XHR9XG4gICAgXHR9ICk7XG5cbiAgICB9XG5cblxuICAgIExPRC5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBPYmplY3QzRC5wcm90b3R5cGUgKSwge1xuXG4gICAgXHRjb25zdHJ1Y3RvcjogTE9ELFxuXG4gICAgXHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuICAgIFx0XHRPYmplY3QzRC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UsIGZhbHNlICk7XG5cbiAgICBcdFx0dmFyIGxldmVscyA9IHNvdXJjZS5sZXZlbHM7XG5cbiAgICBcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gbGV2ZWxzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICBcdFx0XHR2YXIgbGV2ZWwgPSBsZXZlbHNbIGkgXTtcblxuICAgIFx0XHRcdHRoaXMuYWRkTGV2ZWwoIGxldmVsLm9iamVjdC5jbG9uZSgpLCBsZXZlbC5kaXN0YW5jZSApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0YWRkTGV2ZWw6IGZ1bmN0aW9uICggb2JqZWN0LCBkaXN0YW5jZSApIHtcblxuICAgIFx0XHRpZiAoIGRpc3RhbmNlID09PSB1bmRlZmluZWQgKSBkaXN0YW5jZSA9IDA7XG5cbiAgICBcdFx0ZGlzdGFuY2UgPSBNYXRoLmFicyggZGlzdGFuY2UgKTtcblxuICAgIFx0XHR2YXIgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XG5cbiAgICBcdFx0Zm9yICggdmFyIGwgPSAwOyBsIDwgbGV2ZWxzLmxlbmd0aDsgbCArKyApIHtcblxuICAgIFx0XHRcdGlmICggZGlzdGFuY2UgPCBsZXZlbHNbIGwgXS5kaXN0YW5jZSApIHtcblxuICAgIFx0XHRcdFx0YnJlYWs7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGxldmVscy5zcGxpY2UoIGwsIDAsIHsgZGlzdGFuY2U6IGRpc3RhbmNlLCBvYmplY3Q6IG9iamVjdCB9ICk7XG5cbiAgICBcdFx0dGhpcy5hZGQoIG9iamVjdCApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRnZXRPYmplY3RGb3JEaXN0YW5jZTogZnVuY3Rpb24gKCBkaXN0YW5jZSApIHtcblxuICAgIFx0XHR2YXIgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XG5cbiAgICBcdFx0Zm9yICggdmFyIGkgPSAxLCBsID0gbGV2ZWxzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICBcdFx0XHRpZiAoIGRpc3RhbmNlIDwgbGV2ZWxzWyBpIF0uZGlzdGFuY2UgKSB7XG5cbiAgICBcdFx0XHRcdGJyZWFrO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gbGV2ZWxzWyBpIC0gMSBdLm9iamVjdDtcblxuICAgIFx0fSxcblxuICAgIFx0cmF5Y2FzdDogKCBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dmFyIG1hdHJpeFBvc2l0aW9uID0gbmV3IFZlY3RvcjMoKTtcblxuICAgIFx0XHRyZXR1cm4gZnVuY3Rpb24gcmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICkge1xuXG4gICAgXHRcdFx0bWF0cml4UG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLm1hdHJpeFdvcmxkICk7XG5cbiAgICBcdFx0XHR2YXIgZGlzdGFuY2UgPSByYXljYXN0ZXIucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKCBtYXRyaXhQb3NpdGlvbiApO1xuXG4gICAgXHRcdFx0dGhpcy5nZXRPYmplY3RGb3JEaXN0YW5jZSggZGlzdGFuY2UgKS5yYXljYXN0KCByYXljYXN0ZXIsIGludGVyc2VjdHMgKTtcblxuICAgIFx0XHR9O1xuXG4gICAgXHR9KCkgKSxcblxuICAgIFx0dXBkYXRlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoKTtcbiAgICBcdFx0dmFyIHYyID0gbmV3IFZlY3RvcjMoKTtcblxuICAgIFx0XHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlKCBjYW1lcmEgKSB7XG5cbiAgICBcdFx0XHR2YXIgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XG5cbiAgICBcdFx0XHRpZiAoIGxldmVscy5sZW5ndGggPiAxICkge1xuXG4gICAgXHRcdFx0XHR2MS5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGNhbWVyYS5tYXRyaXhXb3JsZCApO1xuICAgIFx0XHRcdFx0djIuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLm1hdHJpeFdvcmxkICk7XG5cbiAgICBcdFx0XHRcdHZhciBkaXN0YW5jZSA9IHYxLmRpc3RhbmNlVG8oIHYyICk7XG5cbiAgICBcdFx0XHRcdGxldmVsc1sgMCBdLm9iamVjdC52aXNpYmxlID0gdHJ1ZTtcblxuICAgIFx0XHRcdFx0Zm9yICggdmFyIGkgPSAxLCBsID0gbGV2ZWxzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICBcdFx0XHRcdFx0aWYgKCBkaXN0YW5jZSA+PSBsZXZlbHNbIGkgXS5kaXN0YW5jZSApIHtcblxuICAgIFx0XHRcdFx0XHRcdGxldmVsc1sgaSAtIDEgXS5vYmplY3QudmlzaWJsZSA9IGZhbHNlO1xuICAgIFx0XHRcdFx0XHRcdGxldmVsc1sgaSBdLm9iamVjdC52aXNpYmxlID0gdHJ1ZTtcblxuICAgIFx0XHRcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRcdFx0YnJlYWs7XG5cbiAgICBcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdGZvciAoIDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICBcdFx0XHRcdFx0bGV2ZWxzWyBpIF0ub2JqZWN0LnZpc2libGUgPSBmYWxzZTtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH07XG5cbiAgICBcdH0oKSxcblxuICAgIFx0dG9KU09OOiBmdW5jdGlvbiAoIG1ldGEgKSB7XG5cbiAgICBcdFx0dmFyIGRhdGEgPSBPYmplY3QzRC5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMsIG1ldGEgKTtcblxuICAgIFx0XHRkYXRhLm9iamVjdC5sZXZlbHMgPSBbXTtcblxuICAgIFx0XHR2YXIgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XG5cbiAgICBcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gbGV2ZWxzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICBcdFx0XHR2YXIgbGV2ZWwgPSBsZXZlbHNbIGkgXTtcblxuICAgIFx0XHRcdGRhdGEub2JqZWN0LmxldmVscy5wdXNoKCB7XG4gICAgXHRcdFx0XHRvYmplY3Q6IGxldmVsLm9iamVjdC51dWlkLFxuICAgIFx0XHRcdFx0ZGlzdGFuY2U6IGxldmVsLmRpc3RhbmNlXG4gICAgXHRcdFx0fSApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gZGF0YTtcblxuICAgIFx0fVxuXG4gICAgfSApO1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIERhdGFUZXh0dXJlKCBkYXRhLCB3aWR0aCwgaGVpZ2h0LCBmb3JtYXQsIHR5cGUsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGFuaXNvdHJvcHksIGVuY29kaW5nICkge1xuXG4gICAgXHRUZXh0dXJlLmNhbGwoIHRoaXMsIG51bGwsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSwgZW5jb2RpbmcgKTtcblxuICAgIFx0dGhpcy5pbWFnZSA9IHsgZGF0YTogZGF0YSwgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9O1xuXG4gICAgXHR0aGlzLm1hZ0ZpbHRlciA9IG1hZ0ZpbHRlciAhPT0gdW5kZWZpbmVkID8gbWFnRmlsdGVyIDogTmVhcmVzdEZpbHRlcjtcbiAgICBcdHRoaXMubWluRmlsdGVyID0gbWluRmlsdGVyICE9PSB1bmRlZmluZWQgPyBtaW5GaWx0ZXIgOiBOZWFyZXN0RmlsdGVyO1xuXG4gICAgXHR0aGlzLmZsaXBZID0gZmFsc2U7XG4gICAgXHR0aGlzLmdlbmVyYXRlTWlwbWFwcyAgPSBmYWxzZTtcblxuICAgIH1cblxuICAgIERhdGFUZXh0dXJlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRleHR1cmUucHJvdG90eXBlICk7XG4gICAgRGF0YVRleHR1cmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRGF0YVRleHR1cmU7XG5cbiAgICBEYXRhVGV4dHVyZS5wcm90b3R5cGUuaXNEYXRhVGV4dHVyZSA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICAgICAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gICAgICogQGF1dGhvciBtaWNoYWVsIGd1ZXJyZXJvIC8gaHR0cDovL3JlYWxpdHltZWx0ZG93bi5jb21cbiAgICAgKiBAYXV0aG9yIGlrZXJyIC8gaHR0cDovL3Zlcm9sZC5jb21cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIFNrZWxldG9uKCBib25lcywgYm9uZUludmVyc2VzLCB1c2VWZXJ0ZXhUZXh0dXJlICkge1xuXG4gICAgXHR0aGlzLnVzZVZlcnRleFRleHR1cmUgPSB1c2VWZXJ0ZXhUZXh0dXJlICE9PSB1bmRlZmluZWQgPyB1c2VWZXJ0ZXhUZXh0dXJlIDogdHJ1ZTtcblxuICAgIFx0dGhpcy5pZGVudGl0eU1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XG5cbiAgICBcdC8vIGNvcHkgdGhlIGJvbmUgYXJyYXlcblxuICAgIFx0Ym9uZXMgPSBib25lcyB8fCBbXTtcblxuICAgIFx0dGhpcy5ib25lcyA9IGJvbmVzLnNsaWNlKCAwICk7XG5cbiAgICBcdC8vIGNyZWF0ZSBhIGJvbmUgdGV4dHVyZSBvciBhbiBhcnJheSBvZiBmbG9hdHNcblxuICAgIFx0aWYgKCB0aGlzLnVzZVZlcnRleFRleHR1cmUgKSB7XG5cbiAgICBcdFx0Ly8gbGF5b3V0ICgxIG1hdHJpeCA9IDQgcGl4ZWxzKVxuICAgIFx0XHQvLyAgICAgIFJHQkEgUkdCQSBSR0JBIFJHQkEgKD0+IGNvbHVtbjEsIGNvbHVtbjIsIGNvbHVtbjMsIGNvbHVtbjQpXG4gICAgXHRcdC8vICB3aXRoICA4eDggIHBpeGVsIHRleHR1cmUgbWF4ICAgMTYgYm9uZXMgKiA0IHBpeGVscyA9ICAoOCAqIDgpXG4gICAgXHRcdC8vICAgICAgIDE2eDE2IHBpeGVsIHRleHR1cmUgbWF4ICAgNjQgYm9uZXMgKiA0IHBpeGVscyA9ICgxNiAqIDE2KVxuICAgIFx0XHQvLyAgICAgICAzMngzMiBwaXhlbCB0ZXh0dXJlIG1heCAgMjU2IGJvbmVzICogNCBwaXhlbHMgPSAoMzIgKiAzMilcbiAgICBcdFx0Ly8gICAgICAgNjR4NjQgcGl4ZWwgdGV4dHVyZSBtYXggMTAyNCBib25lcyAqIDQgcGl4ZWxzID0gKDY0ICogNjQpXG5cblxuICAgIFx0XHR2YXIgc2l6ZSA9IE1hdGguc3FydCggdGhpcy5ib25lcy5sZW5ndGggKiA0ICk7IC8vIDQgcGl4ZWxzIG5lZWRlZCBmb3IgMSBtYXRyaXhcbiAgICBcdFx0c2l6ZSA9IGV4cG9ydHMuTWF0aC5uZXh0UG93ZXJPZlR3byggTWF0aC5jZWlsKCBzaXplICkgKTtcbiAgICBcdFx0c2l6ZSA9IE1hdGgubWF4KCBzaXplLCA0ICk7XG5cbiAgICBcdFx0dGhpcy5ib25lVGV4dHVyZVdpZHRoID0gc2l6ZTtcbiAgICBcdFx0dGhpcy5ib25lVGV4dHVyZUhlaWdodCA9IHNpemU7XG5cbiAgICBcdFx0dGhpcy5ib25lTWF0cmljZXMgPSBuZXcgRmxvYXQzMkFycmF5KCB0aGlzLmJvbmVUZXh0dXJlV2lkdGggKiB0aGlzLmJvbmVUZXh0dXJlSGVpZ2h0ICogNCApOyAvLyA0IGZsb2F0cyBwZXIgUkdCQSBwaXhlbFxuICAgIFx0XHR0aGlzLmJvbmVUZXh0dXJlID0gbmV3IERhdGFUZXh0dXJlKCB0aGlzLmJvbmVNYXRyaWNlcywgdGhpcy5ib25lVGV4dHVyZVdpZHRoLCB0aGlzLmJvbmVUZXh0dXJlSGVpZ2h0LCBSR0JBRm9ybWF0LCBGbG9hdFR5cGUgKTtcblxuICAgIFx0fSBlbHNlIHtcblxuICAgIFx0XHR0aGlzLmJvbmVNYXRyaWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIDE2ICogdGhpcy5ib25lcy5sZW5ndGggKTtcblxuICAgIFx0fVxuXG4gICAgXHQvLyB1c2UgdGhlIHN1cHBsaWVkIGJvbmUgaW52ZXJzZXMgb3IgY2FsY3VsYXRlIHRoZSBpbnZlcnNlc1xuXG4gICAgXHRpZiAoIGJvbmVJbnZlcnNlcyA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdHRoaXMuY2FsY3VsYXRlSW52ZXJzZXMoKTtcblxuICAgIFx0fSBlbHNlIHtcblxuICAgIFx0XHRpZiAoIHRoaXMuYm9uZXMubGVuZ3RoID09PSBib25lSW52ZXJzZXMubGVuZ3RoICkge1xuXG4gICAgXHRcdFx0dGhpcy5ib25lSW52ZXJzZXMgPSBib25lSW52ZXJzZXMuc2xpY2UoIDAgKTtcblxuICAgIFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuU2tlbGV0b24gYm9uSW52ZXJzZXMgaXMgdGhlIHdyb25nIGxlbmd0aC4nICk7XG5cbiAgICBcdFx0XHR0aGlzLmJvbmVJbnZlcnNlcyA9IFtdO1xuXG4gICAgXHRcdFx0Zm9yICggdmFyIGIgPSAwLCBibCA9IHRoaXMuYm9uZXMubGVuZ3RoOyBiIDwgYmw7IGIgKysgKSB7XG5cbiAgICBcdFx0XHRcdHRoaXMuYm9uZUludmVyc2VzLnB1c2goIG5ldyBNYXRyaXg0KCkgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdH1cblxuICAgIH1cblxuICAgIE9iamVjdC5hc3NpZ24oIFNrZWxldG9uLnByb3RvdHlwZSwge1xuXG4gICAgXHRjYWxjdWxhdGVJbnZlcnNlczogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHRoaXMuYm9uZUludmVyc2VzID0gW107XG5cbiAgICBcdFx0Zm9yICggdmFyIGIgPSAwLCBibCA9IHRoaXMuYm9uZXMubGVuZ3RoOyBiIDwgYmw7IGIgKysgKSB7XG5cbiAgICBcdFx0XHR2YXIgaW52ZXJzZSA9IG5ldyBNYXRyaXg0KCk7XG5cbiAgICBcdFx0XHRpZiAoIHRoaXMuYm9uZXNbIGIgXSApIHtcblxuICAgIFx0XHRcdFx0aW52ZXJzZS5nZXRJbnZlcnNlKCB0aGlzLmJvbmVzWyBiIF0ubWF0cml4V29ybGQgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdHRoaXMuYm9uZUludmVyc2VzLnB1c2goIGludmVyc2UgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdH0sXG5cbiAgICBcdHBvc2U6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR2YXIgYm9uZTtcblxuICAgIFx0XHQvLyByZWNvdmVyIHRoZSBiaW5kLXRpbWUgd29ybGQgbWF0cmljZXNcblxuICAgIFx0XHRmb3IgKCB2YXIgYiA9IDAsIGJsID0gdGhpcy5ib25lcy5sZW5ndGg7IGIgPCBibDsgYiArKyApIHtcblxuICAgIFx0XHRcdGJvbmUgPSB0aGlzLmJvbmVzWyBiIF07XG5cbiAgICBcdFx0XHRpZiAoIGJvbmUgKSB7XG5cbiAgICBcdFx0XHRcdGJvbmUubWF0cml4V29ybGQuZ2V0SW52ZXJzZSggdGhpcy5ib25lSW52ZXJzZXNbIGIgXSApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHQvLyBjb21wdXRlIHRoZSBsb2NhbCBtYXRyaWNlcywgcG9zaXRpb25zLCByb3RhdGlvbnMgYW5kIHNjYWxlc1xuXG4gICAgXHRcdGZvciAoIHZhciBiID0gMCwgYmwgPSB0aGlzLmJvbmVzLmxlbmd0aDsgYiA8IGJsOyBiICsrICkge1xuXG4gICAgXHRcdFx0Ym9uZSA9IHRoaXMuYm9uZXNbIGIgXTtcblxuICAgIFx0XHRcdGlmICggYm9uZSApIHtcblxuICAgIFx0XHRcdFx0aWYgKCAoYm9uZS5wYXJlbnQgJiYgYm9uZS5wYXJlbnQuaXNCb25lKSApIHtcblxuICAgIFx0XHRcdFx0XHRib25lLm1hdHJpeC5nZXRJbnZlcnNlKCBib25lLnBhcmVudC5tYXRyaXhXb3JsZCApO1xuICAgIFx0XHRcdFx0XHRib25lLm1hdHJpeC5tdWx0aXBseSggYm9uZS5tYXRyaXhXb3JsZCApO1xuXG4gICAgXHRcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRcdGJvbmUubWF0cml4LmNvcHkoIGJvbmUubWF0cml4V29ybGQgKTtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRib25lLm1hdHJpeC5kZWNvbXBvc2UoIGJvbmUucG9zaXRpb24sIGJvbmUucXVhdGVybmlvbiwgYm9uZS5zY2FsZSApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0fSxcblxuICAgIFx0dXBkYXRlOiAoIGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR2YXIgb2Zmc2V0TWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcblxuICAgIFx0XHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlKCkge1xuXG4gICAgXHRcdFx0Ly8gZmxhdHRlbiBib25lIG1hdHJpY2VzIHRvIGFycmF5XG5cbiAgICBcdFx0XHRmb3IgKCB2YXIgYiA9IDAsIGJsID0gdGhpcy5ib25lcy5sZW5ndGg7IGIgPCBibDsgYiArKyApIHtcblxuICAgIFx0XHRcdFx0Ly8gY29tcHV0ZSB0aGUgb2Zmc2V0IGJldHdlZW4gdGhlIGN1cnJlbnQgYW5kIHRoZSBvcmlnaW5hbCB0cmFuc2Zvcm1cblxuICAgIFx0XHRcdFx0dmFyIG1hdHJpeCA9IHRoaXMuYm9uZXNbIGIgXSA/IHRoaXMuYm9uZXNbIGIgXS5tYXRyaXhXb3JsZCA6IHRoaXMuaWRlbnRpdHlNYXRyaXg7XG5cbiAgICBcdFx0XHRcdG9mZnNldE1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBtYXRyaXgsIHRoaXMuYm9uZUludmVyc2VzWyBiIF0gKTtcbiAgICBcdFx0XHRcdG9mZnNldE1hdHJpeC50b0FycmF5KCB0aGlzLmJvbmVNYXRyaWNlcywgYiAqIDE2ICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRpZiAoIHRoaXMudXNlVmVydGV4VGV4dHVyZSApIHtcblxuICAgIFx0XHRcdFx0dGhpcy5ib25lVGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fTtcblxuICAgIFx0fSApKCksXG5cbiAgICBcdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0cmV0dXJuIG5ldyBTa2VsZXRvbiggdGhpcy5ib25lcywgdGhpcy5ib25lSW52ZXJzZXMsIHRoaXMudXNlVmVydGV4VGV4dHVyZSApO1xuXG4gICAgXHR9XG5cbiAgICB9ICk7XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICAgICAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gICAgICogQGF1dGhvciBpa2VyciAvIGh0dHA6Ly92ZXJvbGQuY29tXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBCb25lKCBza2luICkge1xuXG4gICAgXHRPYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cbiAgICBcdHRoaXMudHlwZSA9ICdCb25lJztcblxuICAgIFx0dGhpcy5za2luID0gc2tpbjtcblxuICAgIH1cblxuICAgIEJvbmUucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggT2JqZWN0M0QucHJvdG90eXBlICksIHtcblxuICAgIFx0Y29uc3RydWN0b3I6IEJvbmUsXG5cbiAgICBcdGlzQm9uZTogdHJ1ZSxcblxuICAgIFx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cbiAgICBcdFx0T2JqZWN0M0QucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cbiAgICBcdFx0dGhpcy5za2luID0gc291cmNlLnNraW47XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH1cblxuICAgIH0gKTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gICAgICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAgICAgKiBAYXV0aG9yIGlrZXJyIC8gaHR0cDovL3Zlcm9sZC5jb21cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIFNraW5uZWRNZXNoKCBnZW9tZXRyeSwgbWF0ZXJpYWwsIHVzZVZlcnRleFRleHR1cmUgKSB7XG5cbiAgICBcdE1lc2guY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cbiAgICBcdHRoaXMudHlwZSA9ICdTa2lubmVkTWVzaCc7XG5cbiAgICBcdHRoaXMuYmluZE1vZGUgPSBcImF0dGFjaGVkXCI7XG4gICAgXHR0aGlzLmJpbmRNYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuICAgIFx0dGhpcy5iaW5kTWF0cml4SW52ZXJzZSA9IG5ldyBNYXRyaXg0KCk7XG5cbiAgICBcdC8vIGluaXQgYm9uZXNcblxuICAgIFx0Ly8gVE9ETzogcmVtb3ZlIGJvbmUgY3JlYXRpb24gYXMgdGhlcmUgaXMgbm8gcmVhc29uIChvdGhlciB0aGFuXG4gICAgXHQvLyBjb252ZW5pZW5jZSkgZm9yIFRIUkVFLlNraW5uZWRNZXNoIHRvIGRvIHRoaXMuXG5cbiAgICBcdHZhciBib25lcyA9IFtdO1xuXG4gICAgXHRpZiAoIHRoaXMuZ2VvbWV0cnkgJiYgdGhpcy5nZW9tZXRyeS5ib25lcyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdHZhciBib25lLCBnYm9uZTtcblxuICAgIFx0XHRmb3IgKCB2YXIgYiA9IDAsIGJsID0gdGhpcy5nZW9tZXRyeS5ib25lcy5sZW5ndGg7IGIgPCBibDsgKysgYiApIHtcblxuICAgIFx0XHRcdGdib25lID0gdGhpcy5nZW9tZXRyeS5ib25lc1sgYiBdO1xuXG4gICAgXHRcdFx0Ym9uZSA9IG5ldyBCb25lKCB0aGlzICk7XG4gICAgXHRcdFx0Ym9uZXMucHVzaCggYm9uZSApO1xuXG4gICAgXHRcdFx0Ym9uZS5uYW1lID0gZ2JvbmUubmFtZTtcbiAgICBcdFx0XHRib25lLnBvc2l0aW9uLmZyb21BcnJheSggZ2JvbmUucG9zICk7XG4gICAgXHRcdFx0Ym9uZS5xdWF0ZXJuaW9uLmZyb21BcnJheSggZ2JvbmUucm90cSApO1xuICAgIFx0XHRcdGlmICggZ2JvbmUuc2NsICE9PSB1bmRlZmluZWQgKSBib25lLnNjYWxlLmZyb21BcnJheSggZ2JvbmUuc2NsICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGZvciAoIHZhciBiID0gMCwgYmwgPSB0aGlzLmdlb21ldHJ5LmJvbmVzLmxlbmd0aDsgYiA8IGJsOyArKyBiICkge1xuXG4gICAgXHRcdFx0Z2JvbmUgPSB0aGlzLmdlb21ldHJ5LmJvbmVzWyBiIF07XG5cbiAgICBcdFx0XHRpZiAoIGdib25lLnBhcmVudCAhPT0gLSAxICYmIGdib25lLnBhcmVudCAhPT0gbnVsbCAmJlxuICAgIFx0XHRcdFx0XHRib25lc1sgZ2JvbmUucGFyZW50IF0gIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0Ym9uZXNbIGdib25lLnBhcmVudCBdLmFkZCggYm9uZXNbIGIgXSApO1xuXG4gICAgXHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0dGhpcy5hZGQoIGJvbmVzWyBiIF0gKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdH1cblxuICAgIFx0dGhpcy5ub3JtYWxpemVTa2luV2VpZ2h0cygpO1xuXG4gICAgXHR0aGlzLnVwZGF0ZU1hdHJpeFdvcmxkKCB0cnVlICk7XG4gICAgXHR0aGlzLmJpbmQoIG5ldyBTa2VsZXRvbiggYm9uZXMsIHVuZGVmaW5lZCwgdXNlVmVydGV4VGV4dHVyZSApLCB0aGlzLm1hdHJpeFdvcmxkICk7XG5cbiAgICB9XG5cblxuICAgIFNraW5uZWRNZXNoLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIE1lc2gucHJvdG90eXBlICksIHtcblxuICAgIFx0Y29uc3RydWN0b3I6IFNraW5uZWRNZXNoLFxuXG4gICAgXHRpc1NraW5uZWRNZXNoOiB0cnVlLFxuXG4gICAgXHRiaW5kOiBmdW5jdGlvbiggc2tlbGV0b24sIGJpbmRNYXRyaXggKSB7XG5cbiAgICBcdFx0dGhpcy5za2VsZXRvbiA9IHNrZWxldG9uO1xuXG4gICAgXHRcdGlmICggYmluZE1hdHJpeCA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0dGhpcy51cGRhdGVNYXRyaXhXb3JsZCggdHJ1ZSApO1xuXG4gICAgXHRcdFx0dGhpcy5za2VsZXRvbi5jYWxjdWxhdGVJbnZlcnNlcygpO1xuXG4gICAgXHRcdFx0YmluZE1hdHJpeCA9IHRoaXMubWF0cml4V29ybGQ7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHRoaXMuYmluZE1hdHJpeC5jb3B5KCBiaW5kTWF0cml4ICk7XG4gICAgXHRcdHRoaXMuYmluZE1hdHJpeEludmVyc2UuZ2V0SW52ZXJzZSggYmluZE1hdHJpeCApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRwb3NlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dGhpcy5za2VsZXRvbi5wb3NlKCk7XG5cbiAgICBcdH0sXG5cbiAgICBcdG5vcm1hbGl6ZVNraW5XZWlnaHRzOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0aWYgKCAodGhpcy5nZW9tZXRyeSAmJiB0aGlzLmdlb21ldHJ5LmlzR2VvbWV0cnkpICkge1xuXG4gICAgXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5nZW9tZXRyeS5za2luV2VpZ2h0cy5sZW5ndGg7IGkgKysgKSB7XG5cbiAgICBcdFx0XHRcdHZhciBzdyA9IHRoaXMuZ2VvbWV0cnkuc2tpbldlaWdodHNbIGkgXTtcblxuICAgIFx0XHRcdFx0dmFyIHNjYWxlID0gMS4wIC8gc3cubGVuZ3RoTWFuaGF0dGFuKCk7XG5cbiAgICBcdFx0XHRcdGlmICggc2NhbGUgIT09IEluZmluaXR5ICkge1xuXG4gICAgXHRcdFx0XHRcdHN3Lm11bHRpcGx5U2NhbGFyKCBzY2FsZSApO1xuXG4gICAgXHRcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRcdHN3LnNldCggMSwgMCwgMCwgMCApOyAvLyBkbyBzb21ldGhpbmcgcmVhc29uYWJsZVxuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fSBlbHNlIGlmICggKHRoaXMuZ2VvbWV0cnkgJiYgdGhpcy5nZW9tZXRyeS5pc0J1ZmZlckdlb21ldHJ5KSApIHtcblxuICAgIFx0XHRcdHZhciB2ZWMgPSBuZXcgVmVjdG9yNCgpO1xuXG4gICAgXHRcdFx0dmFyIHNraW5XZWlnaHQgPSB0aGlzLmdlb21ldHJ5LmF0dHJpYnV0ZXMuc2tpbldlaWdodDtcblxuICAgIFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHNraW5XZWlnaHQuY291bnQ7IGkgKysgKSB7XG5cbiAgICBcdFx0XHRcdHZlYy54ID0gc2tpbldlaWdodC5nZXRYKCBpICk7XG4gICAgXHRcdFx0XHR2ZWMueSA9IHNraW5XZWlnaHQuZ2V0WSggaSApO1xuICAgIFx0XHRcdFx0dmVjLnogPSBza2luV2VpZ2h0LmdldFooIGkgKTtcbiAgICBcdFx0XHRcdHZlYy53ID0gc2tpbldlaWdodC5nZXRXKCBpICk7XG5cbiAgICBcdFx0XHRcdHZhciBzY2FsZSA9IDEuMCAvIHZlYy5sZW5ndGhNYW5oYXR0YW4oKTtcblxuICAgIFx0XHRcdFx0aWYgKCBzY2FsZSAhPT0gSW5maW5pdHkgKSB7XG5cbiAgICBcdFx0XHRcdFx0dmVjLm11bHRpcGx5U2NhbGFyKCBzY2FsZSApO1xuXG4gICAgXHRcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRcdHZlYy5zZXQoIDEsIDAsIDAsIDAgKTsgLy8gZG8gc29tZXRoaW5nIHJlYXNvbmFibGVcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRza2luV2VpZ2h0LnNldFhZWlcoIGksIHZlYy54LCB2ZWMueSwgdmVjLnosIHZlYy53ICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9LFxuXG4gICAgXHR1cGRhdGVNYXRyaXhXb3JsZDogZnVuY3Rpb24oIGZvcmNlICkge1xuXG4gICAgXHRcdE1lc2gucHJvdG90eXBlLnVwZGF0ZU1hdHJpeFdvcmxkLmNhbGwoIHRoaXMsIHRydWUgKTtcblxuICAgIFx0XHRpZiAoIHRoaXMuYmluZE1vZGUgPT09IFwiYXR0YWNoZWRcIiApIHtcblxuICAgIFx0XHRcdHRoaXMuYmluZE1hdHJpeEludmVyc2UuZ2V0SW52ZXJzZSggdGhpcy5tYXRyaXhXb3JsZCApO1xuXG4gICAgXHRcdH0gZWxzZSBpZiAoIHRoaXMuYmluZE1vZGUgPT09IFwiZGV0YWNoZWRcIiApIHtcblxuICAgIFx0XHRcdHRoaXMuYmluZE1hdHJpeEludmVyc2UuZ2V0SW52ZXJzZSggdGhpcy5iaW5kTWF0cml4ICk7XG5cbiAgICBcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlNraW5uZWRNZXNoIHVucmVjb2duaXplZCBiaW5kTW9kZTogJyArIHRoaXMuYmluZE1vZGUgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdH0sXG5cbiAgICBcdGNsb25lOiBmdW5jdGlvbigpIHtcblxuICAgIFx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMuZ2VvbWV0cnksIHRoaXMubWF0ZXJpYWwsIHRoaXMuc2tlbGV0b24udXNlVmVydGV4VGV4dHVyZSApLmNvcHkoIHRoaXMgKTtcblxuICAgIFx0fVxuXG4gICAgfSApO1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAgICAgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICAgICAqXG4gICAgICogcGFyYW1ldGVycyA9IHtcbiAgICAgKiAgY29sb3I6IDxoZXg+LFxuICAgICAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxuICAgICAqXG4gICAgICogIGxpbmV3aWR0aDogPGZsb2F0PixcbiAgICAgKiAgbGluZWNhcDogXCJyb3VuZFwiLFxuICAgICAqICBsaW5lam9pbjogXCJyb3VuZFwiXG4gICAgICogfVxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gTGluZUJhc2ljTWF0ZXJpYWwoIHBhcmFtZXRlcnMgKSB7XG5cbiAgICBcdE1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcblxuICAgIFx0dGhpcy50eXBlID0gJ0xpbmVCYXNpY01hdGVyaWFsJztcblxuICAgIFx0dGhpcy5jb2xvciA9IG5ldyBDb2xvciggMHhmZmZmZmYgKTtcblxuICAgIFx0dGhpcy5saW5ld2lkdGggPSAxO1xuICAgIFx0dGhpcy5saW5lY2FwID0gJ3JvdW5kJztcbiAgICBcdHRoaXMubGluZWpvaW4gPSAncm91bmQnO1xuXG4gICAgXHR0aGlzLmxpZ2h0cyA9IGZhbHNlO1xuXG4gICAgXHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xuXG4gICAgfVxuXG4gICAgTGluZUJhc2ljTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTWF0ZXJpYWwucHJvdG90eXBlICk7XG4gICAgTGluZUJhc2ljTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGluZUJhc2ljTWF0ZXJpYWw7XG5cbiAgICBMaW5lQmFzaWNNYXRlcmlhbC5wcm90b3R5cGUuaXNMaW5lQmFzaWNNYXRlcmlhbCA9IHRydWU7XG5cbiAgICBMaW5lQmFzaWNNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xuXG4gICAgXHRNYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuICAgIFx0dGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcblxuICAgIFx0dGhpcy5saW5ld2lkdGggPSBzb3VyY2UubGluZXdpZHRoO1xuICAgIFx0dGhpcy5saW5lY2FwID0gc291cmNlLmxpbmVjYXA7XG4gICAgXHR0aGlzLmxpbmVqb2luID0gc291cmNlLmxpbmVqb2luO1xuXG4gICAgXHRyZXR1cm4gdGhpcztcblxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gTGluZSggZ2VvbWV0cnksIG1hdGVyaWFsLCBtb2RlICkge1xuXG4gICAgXHRpZiAoIG1vZGUgPT09IDEgKSB7XG5cbiAgICBcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTGluZTogcGFyYW1ldGVyIFRIUkVFLkxpbmVQaWVjZXMgbm8gbG9uZ2VyIHN1cHBvcnRlZC4gQ3JlYXRlZCBUSFJFRS5MaW5lU2VnbWVudHMgaW5zdGVhZC4nICk7XG4gICAgXHRcdHJldHVybiBuZXcgTGluZVNlZ21lbnRzKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblxuICAgIFx0fVxuXG4gICAgXHRPYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cbiAgICBcdHRoaXMudHlwZSA9ICdMaW5lJztcblxuICAgIFx0dGhpcy5nZW9tZXRyeSA9IGdlb21ldHJ5ICE9PSB1bmRlZmluZWQgPyBnZW9tZXRyeSA6IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuICAgIFx0dGhpcy5tYXRlcmlhbCA9IG1hdGVyaWFsICE9PSB1bmRlZmluZWQgPyBtYXRlcmlhbCA6IG5ldyBMaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmIH0gKTtcblxuICAgIH1cblxuICAgIExpbmUucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggT2JqZWN0M0QucHJvdG90eXBlICksIHtcblxuICAgIFx0Y29uc3RydWN0b3I6IExpbmUsXG5cbiAgICBcdGlzTGluZTogdHJ1ZSxcblxuICAgIFx0cmF5Y2FzdDogKCBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dmFyIGludmVyc2VNYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuICAgIFx0XHR2YXIgcmF5ID0gbmV3IFJheSgpO1xuICAgIFx0XHR2YXIgc3BoZXJlID0gbmV3IFNwaGVyZSgpO1xuXG4gICAgXHRcdHJldHVybiBmdW5jdGlvbiByYXljYXN0KCByYXljYXN0ZXIsIGludGVyc2VjdHMgKSB7XG5cbiAgICBcdFx0XHR2YXIgcHJlY2lzaW9uID0gcmF5Y2FzdGVyLmxpbmVQcmVjaXNpb247XG4gICAgXHRcdFx0dmFyIHByZWNpc2lvblNxID0gcHJlY2lzaW9uICogcHJlY2lzaW9uO1xuXG4gICAgXHRcdFx0dmFyIGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcbiAgICBcdFx0XHR2YXIgbWF0cml4V29ybGQgPSB0aGlzLm1hdHJpeFdvcmxkO1xuXG4gICAgXHRcdFx0Ly8gQ2hlY2tpbmcgYm91bmRpbmdTcGhlcmUgZGlzdGFuY2UgdG8gcmF5XG5cbiAgICBcdFx0XHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlID09PSBudWxsICkgZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cbiAgICBcdFx0XHRzcGhlcmUuY29weSggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgKTtcbiAgICBcdFx0XHRzcGhlcmUuYXBwbHlNYXRyaXg0KCBtYXRyaXhXb3JsZCApO1xuXG4gICAgXHRcdFx0aWYgKCByYXljYXN0ZXIucmF5LmludGVyc2VjdHNTcGhlcmUoIHNwaGVyZSApID09PSBmYWxzZSApIHJldHVybjtcblxuICAgIFx0XHRcdC8vXG5cbiAgICBcdFx0XHRpbnZlcnNlTWF0cml4LmdldEludmVyc2UoIG1hdHJpeFdvcmxkICk7XG4gICAgXHRcdFx0cmF5LmNvcHkoIHJheWNhc3Rlci5yYXkgKS5hcHBseU1hdHJpeDQoIGludmVyc2VNYXRyaXggKTtcblxuICAgIFx0XHRcdHZhciB2U3RhcnQgPSBuZXcgVmVjdG9yMygpO1xuICAgIFx0XHRcdHZhciB2RW5kID0gbmV3IFZlY3RvcjMoKTtcbiAgICBcdFx0XHR2YXIgaW50ZXJTZWdtZW50ID0gbmV3IFZlY3RvcjMoKTtcbiAgICBcdFx0XHR2YXIgaW50ZXJSYXkgPSBuZXcgVmVjdG9yMygpO1xuICAgIFx0XHRcdHZhciBzdGVwID0gKHRoaXMgJiYgdGhpcy5pc0xpbmVTZWdtZW50cykgPyAyIDogMTtcblxuICAgIFx0XHRcdGlmICggKGdlb21ldHJ5ICYmIGdlb21ldHJ5LmlzQnVmZmVyR2VvbWV0cnkpICkge1xuXG4gICAgXHRcdFx0XHR2YXIgaW5kZXggPSBnZW9tZXRyeS5pbmRleDtcbiAgICBcdFx0XHRcdHZhciBhdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcbiAgICBcdFx0XHRcdHZhciBwb3NpdGlvbnMgPSBhdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xuXG4gICAgXHRcdFx0XHRpZiAoIGluZGV4ICE9PSBudWxsICkge1xuXG4gICAgXHRcdFx0XHRcdHZhciBpbmRpY2VzID0gaW5kZXguYXJyYXk7XG5cbiAgICBcdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gaW5kaWNlcy5sZW5ndGggLSAxOyBpIDwgbDsgaSArPSBzdGVwICkge1xuXG4gICAgXHRcdFx0XHRcdFx0dmFyIGEgPSBpbmRpY2VzWyBpIF07XG4gICAgXHRcdFx0XHRcdFx0dmFyIGIgPSBpbmRpY2VzWyBpICsgMSBdO1xuXG4gICAgXHRcdFx0XHRcdFx0dlN0YXJ0LmZyb21BcnJheSggcG9zaXRpb25zLCBhICogMyApO1xuICAgIFx0XHRcdFx0XHRcdHZFbmQuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGIgKiAzICk7XG5cbiAgICBcdFx0XHRcdFx0XHR2YXIgZGlzdFNxID0gcmF5LmRpc3RhbmNlU3FUb1NlZ21lbnQoIHZTdGFydCwgdkVuZCwgaW50ZXJSYXksIGludGVyU2VnbWVudCApO1xuXG4gICAgXHRcdFx0XHRcdFx0aWYgKCBkaXN0U3EgPiBwcmVjaXNpb25TcSApIGNvbnRpbnVlO1xuXG4gICAgXHRcdFx0XHRcdFx0aW50ZXJSYXkuYXBwbHlNYXRyaXg0KCB0aGlzLm1hdHJpeFdvcmxkICk7IC8vTW92ZSBiYWNrIHRvIHdvcmxkIHNwYWNlIGZvciBkaXN0YW5jZSBjYWxjdWxhdGlvblxuXG4gICAgXHRcdFx0XHRcdFx0dmFyIGRpc3RhbmNlID0gcmF5Y2FzdGVyLnJheS5vcmlnaW4uZGlzdGFuY2VUbyggaW50ZXJSYXkgKTtcblxuICAgIFx0XHRcdFx0XHRcdGlmICggZGlzdGFuY2UgPCByYXljYXN0ZXIubmVhciB8fCBkaXN0YW5jZSA+IHJheWNhc3Rlci5mYXIgKSBjb250aW51ZTtcblxuICAgIFx0XHRcdFx0XHRcdGludGVyc2VjdHMucHVzaCgge1xuXG4gICAgXHRcdFx0XHRcdFx0XHRkaXN0YW5jZTogZGlzdGFuY2UsXG4gICAgXHRcdFx0XHRcdFx0XHQvLyBXaGF0IGRvIHdlIHdhbnQ/IGludGVyc2VjdGlvbiBwb2ludCBvbiB0aGUgcmF5IG9yIG9uIHRoZSBzZWdtZW50Pz9cbiAgICBcdFx0XHRcdFx0XHRcdC8vIHBvaW50OiByYXljYXN0ZXIucmF5LmF0KCBkaXN0YW5jZSApLFxuICAgIFx0XHRcdFx0XHRcdFx0cG9pbnQ6IGludGVyU2VnbWVudC5jbG9uZSgpLmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApLFxuICAgIFx0XHRcdFx0XHRcdFx0aW5kZXg6IGksXG4gICAgXHRcdFx0XHRcdFx0XHRmYWNlOiBudWxsLFxuICAgIFx0XHRcdFx0XHRcdFx0ZmFjZUluZGV4OiBudWxsLFxuICAgIFx0XHRcdFx0XHRcdFx0b2JqZWN0OiB0aGlzXG5cbiAgICBcdFx0XHRcdFx0XHR9ICk7XG5cbiAgICBcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHBvc2l0aW9ucy5sZW5ndGggLyAzIC0gMTsgaSA8IGw7IGkgKz0gc3RlcCApIHtcblxuICAgIFx0XHRcdFx0XHRcdHZTdGFydC5mcm9tQXJyYXkoIHBvc2l0aW9ucywgMyAqIGkgKTtcbiAgICBcdFx0XHRcdFx0XHR2RW5kLmZyb21BcnJheSggcG9zaXRpb25zLCAzICogaSArIDMgKTtcblxuICAgIFx0XHRcdFx0XHRcdHZhciBkaXN0U3EgPSByYXkuZGlzdGFuY2VTcVRvU2VnbWVudCggdlN0YXJ0LCB2RW5kLCBpbnRlclJheSwgaW50ZXJTZWdtZW50ICk7XG5cbiAgICBcdFx0XHRcdFx0XHRpZiAoIGRpc3RTcSA+IHByZWNpc2lvblNxICkgY29udGludWU7XG5cbiAgICBcdFx0XHRcdFx0XHRpbnRlclJheS5hcHBseU1hdHJpeDQoIHRoaXMubWF0cml4V29ybGQgKTsgLy9Nb3ZlIGJhY2sgdG8gd29ybGQgc3BhY2UgZm9yIGRpc3RhbmNlIGNhbGN1bGF0aW9uXG5cbiAgICBcdFx0XHRcdFx0XHR2YXIgZGlzdGFuY2UgPSByYXljYXN0ZXIucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKCBpbnRlclJheSApO1xuXG4gICAgXHRcdFx0XHRcdFx0aWYgKCBkaXN0YW5jZSA8IHJheWNhc3Rlci5uZWFyIHx8IGRpc3RhbmNlID4gcmF5Y2FzdGVyLmZhciApIGNvbnRpbnVlO1xuXG4gICAgXHRcdFx0XHRcdFx0aW50ZXJzZWN0cy5wdXNoKCB7XG5cbiAgICBcdFx0XHRcdFx0XHRcdGRpc3RhbmNlOiBkaXN0YW5jZSxcbiAgICBcdFx0XHRcdFx0XHRcdC8vIFdoYXQgZG8gd2Ugd2FudD8gaW50ZXJzZWN0aW9uIHBvaW50IG9uIHRoZSByYXkgb3Igb24gdGhlIHNlZ21lbnQ/P1xuICAgIFx0XHRcdFx0XHRcdFx0Ly8gcG9pbnQ6IHJheWNhc3Rlci5yYXkuYXQoIGRpc3RhbmNlICksXG4gICAgXHRcdFx0XHRcdFx0XHRwb2ludDogaW50ZXJTZWdtZW50LmNsb25lKCkuYXBwbHlNYXRyaXg0KCB0aGlzLm1hdHJpeFdvcmxkICksXG4gICAgXHRcdFx0XHRcdFx0XHRpbmRleDogaSxcbiAgICBcdFx0XHRcdFx0XHRcdGZhY2U6IG51bGwsXG4gICAgXHRcdFx0XHRcdFx0XHRmYWNlSW5kZXg6IG51bGwsXG4gICAgXHRcdFx0XHRcdFx0XHRvYmplY3Q6IHRoaXNcblxuICAgIFx0XHRcdFx0XHRcdH0gKTtcblxuICAgIFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH0gZWxzZSBpZiAoIChnZW9tZXRyeSAmJiBnZW9tZXRyeS5pc0dlb21ldHJ5KSApIHtcblxuICAgIFx0XHRcdFx0dmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXM7XG4gICAgXHRcdFx0XHR2YXIgbmJWZXJ0aWNlcyA9IHZlcnRpY2VzLmxlbmd0aDtcblxuICAgIFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbmJWZXJ0aWNlcyAtIDE7IGkgKz0gc3RlcCApIHtcblxuICAgIFx0XHRcdFx0XHR2YXIgZGlzdFNxID0gcmF5LmRpc3RhbmNlU3FUb1NlZ21lbnQoIHZlcnRpY2VzWyBpIF0sIHZlcnRpY2VzWyBpICsgMSBdLCBpbnRlclJheSwgaW50ZXJTZWdtZW50ICk7XG5cbiAgICBcdFx0XHRcdFx0aWYgKCBkaXN0U3EgPiBwcmVjaXNpb25TcSApIGNvbnRpbnVlO1xuXG4gICAgXHRcdFx0XHRcdGludGVyUmF5LmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApOyAvL01vdmUgYmFjayB0byB3b3JsZCBzcGFjZSBmb3IgZGlzdGFuY2UgY2FsY3VsYXRpb25cblxuICAgIFx0XHRcdFx0XHR2YXIgZGlzdGFuY2UgPSByYXljYXN0ZXIucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKCBpbnRlclJheSApO1xuXG4gICAgXHRcdFx0XHRcdGlmICggZGlzdGFuY2UgPCByYXljYXN0ZXIubmVhciB8fCBkaXN0YW5jZSA+IHJheWNhc3Rlci5mYXIgKSBjb250aW51ZTtcblxuICAgIFx0XHRcdFx0XHRpbnRlcnNlY3RzLnB1c2goIHtcblxuICAgIFx0XHRcdFx0XHRcdGRpc3RhbmNlOiBkaXN0YW5jZSxcbiAgICBcdFx0XHRcdFx0XHQvLyBXaGF0IGRvIHdlIHdhbnQ/IGludGVyc2VjdGlvbiBwb2ludCBvbiB0aGUgcmF5IG9yIG9uIHRoZSBzZWdtZW50Pz9cbiAgICBcdFx0XHRcdFx0XHQvLyBwb2ludDogcmF5Y2FzdGVyLnJheS5hdCggZGlzdGFuY2UgKSxcbiAgICBcdFx0XHRcdFx0XHRwb2ludDogaW50ZXJTZWdtZW50LmNsb25lKCkuYXBwbHlNYXRyaXg0KCB0aGlzLm1hdHJpeFdvcmxkICksXG4gICAgXHRcdFx0XHRcdFx0aW5kZXg6IGksXG4gICAgXHRcdFx0XHRcdFx0ZmFjZTogbnVsbCxcbiAgICBcdFx0XHRcdFx0XHRmYWNlSW5kZXg6IG51bGwsXG4gICAgXHRcdFx0XHRcdFx0b2JqZWN0OiB0aGlzXG5cbiAgICBcdFx0XHRcdFx0fSApO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fTtcblxuICAgIFx0fSgpICksXG5cbiAgICBcdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLmdlb21ldHJ5LCB0aGlzLm1hdGVyaWFsICkuY29weSggdGhpcyApO1xuXG4gICAgXHR9XG5cbiAgICB9ICk7XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gTGluZVNlZ21lbnRzKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKSB7XG5cbiAgICBcdExpbmUuY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cbiAgICBcdHRoaXMudHlwZSA9ICdMaW5lU2VnbWVudHMnO1xuXG4gICAgfVxuXG4gICAgTGluZVNlZ21lbnRzLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIExpbmUucHJvdG90eXBlICksIHtcblxuICAgIFx0Y29uc3RydWN0b3I6IExpbmVTZWdtZW50cyxcblxuICAgIFx0aXNMaW5lU2VnbWVudHM6IHRydWVcblxuICAgIH0gKTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gICAgICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAgICAgKlxuICAgICAqIHBhcmFtZXRlcnMgPSB7XG4gICAgICogIGNvbG9yOiA8aGV4PixcbiAgICAgKiAgb3BhY2l0eTogPGZsb2F0PixcbiAgICAgKiAgbWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICAgICAqXG4gICAgICogIHNpemU6IDxmbG9hdD4sXG4gICAgICogIHNpemVBdHRlbnVhdGlvbjogPGJvb2w+XG4gICAgICogfVxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gUG9pbnRzTWF0ZXJpYWwoIHBhcmFtZXRlcnMgKSB7XG5cbiAgICBcdE1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcblxuICAgIFx0dGhpcy50eXBlID0gJ1BvaW50c01hdGVyaWFsJztcblxuICAgIFx0dGhpcy5jb2xvciA9IG5ldyBDb2xvciggMHhmZmZmZmYgKTtcblxuICAgIFx0dGhpcy5tYXAgPSBudWxsO1xuXG4gICAgXHR0aGlzLnNpemUgPSAxO1xuICAgIFx0dGhpcy5zaXplQXR0ZW51YXRpb24gPSB0cnVlO1xuXG4gICAgXHR0aGlzLmxpZ2h0cyA9IGZhbHNlO1xuXG4gICAgXHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xuXG4gICAgfVxuXG4gICAgUG9pbnRzTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTWF0ZXJpYWwucHJvdG90eXBlICk7XG4gICAgUG9pbnRzTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUG9pbnRzTWF0ZXJpYWw7XG5cbiAgICBQb2ludHNNYXRlcmlhbC5wcm90b3R5cGUuaXNQb2ludHNNYXRlcmlhbCA9IHRydWU7XG5cbiAgICBQb2ludHNNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xuXG4gICAgXHRNYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuICAgIFx0dGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcblxuICAgIFx0dGhpcy5tYXAgPSBzb3VyY2UubWFwO1xuXG4gICAgXHR0aGlzLnNpemUgPSBzb3VyY2Uuc2l6ZTtcbiAgICBcdHRoaXMuc2l6ZUF0dGVudWF0aW9uID0gc291cmNlLnNpemVBdHRlbnVhdGlvbjtcblxuICAgIFx0cmV0dXJuIHRoaXM7XG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIFBvaW50cyggZ2VvbWV0cnksIG1hdGVyaWFsICkge1xuXG4gICAgXHRPYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cbiAgICBcdHRoaXMudHlwZSA9ICdQb2ludHMnO1xuXG4gICAgXHR0aGlzLmdlb21ldHJ5ID0gZ2VvbWV0cnkgIT09IHVuZGVmaW5lZCA/IGdlb21ldHJ5IDogbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG4gICAgXHR0aGlzLm1hdGVyaWFsID0gbWF0ZXJpYWwgIT09IHVuZGVmaW5lZCA/IG1hdGVyaWFsIDogbmV3IFBvaW50c01hdGVyaWFsKCB7IGNvbG9yOiBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmYgfSApO1xuXG4gICAgfVxuXG4gICAgUG9pbnRzLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIE9iamVjdDNELnByb3RvdHlwZSApLCB7XG5cbiAgICBcdGNvbnN0cnVjdG9yOiBQb2ludHMsXG5cbiAgICBcdGlzUG9pbnRzOiB0cnVlLFxuXG4gICAgXHRyYXljYXN0OiAoIGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR2YXIgaW52ZXJzZU1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XG4gICAgXHRcdHZhciByYXkgPSBuZXcgUmF5KCk7XG4gICAgXHRcdHZhciBzcGhlcmUgPSBuZXcgU3BoZXJlKCk7XG5cbiAgICBcdFx0cmV0dXJuIGZ1bmN0aW9uIHJheWNhc3QoIHJheWNhc3RlciwgaW50ZXJzZWN0cyApIHtcblxuICAgIFx0XHRcdHZhciBvYmplY3QgPSB0aGlzO1xuICAgIFx0XHRcdHZhciBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG4gICAgXHRcdFx0dmFyIG1hdHJpeFdvcmxkID0gdGhpcy5tYXRyaXhXb3JsZDtcbiAgICBcdFx0XHR2YXIgdGhyZXNob2xkID0gcmF5Y2FzdGVyLnBhcmFtcy5Qb2ludHMudGhyZXNob2xkO1xuXG4gICAgXHRcdFx0Ly8gQ2hlY2tpbmcgYm91bmRpbmdTcGhlcmUgZGlzdGFuY2UgdG8gcmF5XG5cbiAgICBcdFx0XHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlID09PSBudWxsICkgZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cbiAgICBcdFx0XHRzcGhlcmUuY29weSggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgKTtcbiAgICBcdFx0XHRzcGhlcmUuYXBwbHlNYXRyaXg0KCBtYXRyaXhXb3JsZCApO1xuXG4gICAgXHRcdFx0aWYgKCByYXljYXN0ZXIucmF5LmludGVyc2VjdHNTcGhlcmUoIHNwaGVyZSApID09PSBmYWxzZSApIHJldHVybjtcblxuICAgIFx0XHRcdC8vXG5cbiAgICBcdFx0XHRpbnZlcnNlTWF0cml4LmdldEludmVyc2UoIG1hdHJpeFdvcmxkICk7XG4gICAgXHRcdFx0cmF5LmNvcHkoIHJheWNhc3Rlci5yYXkgKS5hcHBseU1hdHJpeDQoIGludmVyc2VNYXRyaXggKTtcblxuICAgIFx0XHRcdHZhciBsb2NhbFRocmVzaG9sZCA9IHRocmVzaG9sZCAvICggKCB0aGlzLnNjYWxlLnggKyB0aGlzLnNjYWxlLnkgKyB0aGlzLnNjYWxlLnogKSAvIDMgKTtcbiAgICBcdFx0XHR2YXIgbG9jYWxUaHJlc2hvbGRTcSA9IGxvY2FsVGhyZXNob2xkICogbG9jYWxUaHJlc2hvbGQ7XG4gICAgXHRcdFx0dmFyIHBvc2l0aW9uID0gbmV3IFZlY3RvcjMoKTtcblxuICAgIFx0XHRcdGZ1bmN0aW9uIHRlc3RQb2ludCggcG9pbnQsIGluZGV4ICkge1xuXG4gICAgXHRcdFx0XHR2YXIgcmF5UG9pbnREaXN0YW5jZVNxID0gcmF5LmRpc3RhbmNlU3FUb1BvaW50KCBwb2ludCApO1xuXG4gICAgXHRcdFx0XHRpZiAoIHJheVBvaW50RGlzdGFuY2VTcSA8IGxvY2FsVGhyZXNob2xkU3EgKSB7XG5cbiAgICBcdFx0XHRcdFx0dmFyIGludGVyc2VjdFBvaW50ID0gcmF5LmNsb3Nlc3RQb2ludFRvUG9pbnQoIHBvaW50ICk7XG4gICAgXHRcdFx0XHRcdGludGVyc2VjdFBvaW50LmFwcGx5TWF0cml4NCggbWF0cml4V29ybGQgKTtcblxuICAgIFx0XHRcdFx0XHR2YXIgZGlzdGFuY2UgPSByYXljYXN0ZXIucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKCBpbnRlcnNlY3RQb2ludCApO1xuXG4gICAgXHRcdFx0XHRcdGlmICggZGlzdGFuY2UgPCByYXljYXN0ZXIubmVhciB8fCBkaXN0YW5jZSA+IHJheWNhc3Rlci5mYXIgKSByZXR1cm47XG5cbiAgICBcdFx0XHRcdFx0aW50ZXJzZWN0cy5wdXNoKCB7XG5cbiAgICBcdFx0XHRcdFx0XHRkaXN0YW5jZTogZGlzdGFuY2UsXG4gICAgXHRcdFx0XHRcdFx0ZGlzdGFuY2VUb1JheTogTWF0aC5zcXJ0KCByYXlQb2ludERpc3RhbmNlU3EgKSxcbiAgICBcdFx0XHRcdFx0XHRwb2ludDogaW50ZXJzZWN0UG9pbnQuY2xvbmUoKSxcbiAgICBcdFx0XHRcdFx0XHRpbmRleDogaW5kZXgsXG4gICAgXHRcdFx0XHRcdFx0ZmFjZTogbnVsbCxcbiAgICBcdFx0XHRcdFx0XHRvYmplY3Q6IG9iamVjdFxuXG4gICAgXHRcdFx0XHRcdH0gKTtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0aWYgKCAoZ2VvbWV0cnkgJiYgZ2VvbWV0cnkuaXNCdWZmZXJHZW9tZXRyeSkgKSB7XG5cbiAgICBcdFx0XHRcdHZhciBpbmRleCA9IGdlb21ldHJ5LmluZGV4O1xuICAgIFx0XHRcdFx0dmFyIGF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzO1xuICAgIFx0XHRcdFx0dmFyIHBvc2l0aW9ucyA9IGF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XG5cbiAgICBcdFx0XHRcdGlmICggaW5kZXggIT09IG51bGwgKSB7XG5cbiAgICBcdFx0XHRcdFx0dmFyIGluZGljZXMgPSBpbmRleC5hcnJheTtcblxuICAgIFx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gaW5kaWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgIFx0XHRcdFx0XHRcdHZhciBhID0gaW5kaWNlc1sgaSBdO1xuXG4gICAgXHRcdFx0XHRcdFx0cG9zaXRpb24uZnJvbUFycmF5KCBwb3NpdGlvbnMsIGEgKiAzICk7XG5cbiAgICBcdFx0XHRcdFx0XHR0ZXN0UG9pbnQoIHBvc2l0aW9uLCBhICk7XG5cbiAgICBcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHBvc2l0aW9ucy5sZW5ndGggLyAzOyBpIDwgbDsgaSArKyApIHtcblxuICAgIFx0XHRcdFx0XHRcdHBvc2l0aW9uLmZyb21BcnJheSggcG9zaXRpb25zLCBpICogMyApO1xuXG4gICAgXHRcdFx0XHRcdFx0dGVzdFBvaW50KCBwb3NpdGlvbiwgaSApO1xuXG4gICAgXHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0dmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXM7XG5cbiAgICBcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHZlcnRpY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICBcdFx0XHRcdFx0dGVzdFBvaW50KCB2ZXJ0aWNlc1sgaSBdLCBpICk7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9O1xuXG4gICAgXHR9KCkgKSxcblxuICAgIFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMuZ2VvbWV0cnksIHRoaXMubWF0ZXJpYWwgKS5jb3B5KCB0aGlzICk7XG5cbiAgICBcdH1cblxuICAgIH0gKTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBHcm91cCgpIHtcblxuICAgIFx0T2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG4gICAgXHR0aGlzLnR5cGUgPSAnR3JvdXAnO1xuXG4gICAgfVxuXG4gICAgR3JvdXAucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggT2JqZWN0M0QucHJvdG90eXBlICksIHtcblxuICAgIFx0Y29uc3RydWN0b3I6IEdyb3VwXG5cbiAgICB9ICk7XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gVmlkZW9UZXh0dXJlKCB2aWRlbywgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5ICkge1xuXG4gICAgXHRUZXh0dXJlLmNhbGwoIHRoaXMsIHZpZGVvLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHkgKTtcblxuICAgIFx0dGhpcy5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcblxuICAgIFx0dmFyIHNjb3BlID0gdGhpcztcblxuICAgIFx0ZnVuY3Rpb24gdXBkYXRlKCkge1xuXG4gICAgXHRcdHJlcXVlc3RBbmltYXRpb25GcmFtZSggdXBkYXRlICk7XG5cbiAgICBcdFx0aWYgKCB2aWRlby5yZWFkeVN0YXRlID49IHZpZGVvLkhBVkVfQ1VSUkVOVF9EQVRBICkge1xuXG4gICAgXHRcdFx0c2NvcGUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgXHRcdH1cblxuICAgIFx0fVxuXG4gICAgXHR1cGRhdGUoKTtcblxuICAgIH1cblxuICAgIFZpZGVvVGV4dHVyZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUZXh0dXJlLnByb3RvdHlwZSApO1xuICAgIFZpZGVvVGV4dHVyZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBWaWRlb1RleHR1cmU7XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gQ29tcHJlc3NlZFRleHR1cmUoIG1pcG1hcHMsIHdpZHRoLCBoZWlnaHQsIGZvcm1hdCwgdHlwZSwgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgYW5pc290cm9weSwgZW5jb2RpbmcgKSB7XG5cbiAgICBcdFRleHR1cmUuY2FsbCggdGhpcywgbnVsbCwgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5LCBlbmNvZGluZyApO1xuXG4gICAgXHR0aGlzLmltYWdlID0geyB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH07XG4gICAgXHR0aGlzLm1pcG1hcHMgPSBtaXBtYXBzO1xuXG4gICAgXHQvLyBubyBmbGlwcGluZyBmb3IgY3ViZSB0ZXh0dXJlc1xuICAgIFx0Ly8gKGFsc28gZmxpcHBpbmcgZG9lc24ndCB3b3JrIGZvciBjb21wcmVzc2VkIHRleHR1cmVzIClcblxuICAgIFx0dGhpcy5mbGlwWSA9IGZhbHNlO1xuXG4gICAgXHQvLyBjYW4ndCBnZW5lcmF0ZSBtaXBtYXBzIGZvciBjb21wcmVzc2VkIHRleHR1cmVzXG4gICAgXHQvLyBtaXBzIG11c3QgYmUgZW1iZWRkZWQgaW4gRERTIGZpbGVzXG5cbiAgICBcdHRoaXMuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XG5cbiAgICB9XG5cbiAgICBDb21wcmVzc2VkVGV4dHVyZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUZXh0dXJlLnByb3RvdHlwZSApO1xuICAgIENvbXByZXNzZWRUZXh0dXJlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbXByZXNzZWRUZXh0dXJlO1xuXG4gICAgQ29tcHJlc3NlZFRleHR1cmUucHJvdG90eXBlLmlzQ29tcHJlc3NlZFRleHR1cmUgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIENhbnZhc1RleHR1cmUoIGNhbnZhcywgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5ICkge1xuXG4gICAgXHRUZXh0dXJlLmNhbGwoIHRoaXMsIGNhbnZhcywgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5ICk7XG5cbiAgICBcdHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgfVxuXG4gICAgQ2FudmFzVGV4dHVyZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUZXh0dXJlLnByb3RvdHlwZSApO1xuICAgIENhbnZhc1RleHR1cmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2FudmFzVGV4dHVyZTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgTWF0dCBEZXNMYXVyaWVycyAvIEBtYXR0ZGVzbFxuICAgICAqIEBhdXRob3IgYXRpeCAvIGFydGh1cnNpbGJlci5kZVxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gRGVwdGhUZXh0dXJlKCB3aWR0aCwgaGVpZ2h0LCB0eXBlLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBhbmlzb3Ryb3B5LCBmb3JtYXQgKSB7XG5cbiAgICBcdGZvcm1hdCA9IGZvcm1hdCAhPT0gdW5kZWZpbmVkID8gZm9ybWF0IDogRGVwdGhGb3JtYXQ7XG5cbiAgICBcdGlmICggZm9ybWF0ICE9PSBEZXB0aEZvcm1hdCAmJiBmb3JtYXQgIT09IERlcHRoU3RlbmNpbEZvcm1hdCApIHtcblxuICAgIFx0XHR0aHJvdyBuZXcgRXJyb3IoICdEZXB0aFRleHR1cmUgZm9ybWF0IG11c3QgYmUgZWl0aGVyIFRIUkVFLkRlcHRoRm9ybWF0IG9yIFRIUkVFLkRlcHRoU3RlbmNpbEZvcm1hdCcgKVxuXG4gICAgXHR9XG5cbiAgICBcdFRleHR1cmUuY2FsbCggdGhpcywgbnVsbCwgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5ICk7XG5cbiAgICBcdHRoaXMuaW1hZ2UgPSB7IHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfTtcblxuICAgIFx0dGhpcy50eXBlID0gdHlwZSAhPT0gdW5kZWZpbmVkID8gdHlwZSA6IFVuc2lnbmVkU2hvcnRUeXBlO1xuXG4gICAgXHR0aGlzLm1hZ0ZpbHRlciA9IG1hZ0ZpbHRlciAhPT0gdW5kZWZpbmVkID8gbWFnRmlsdGVyIDogTmVhcmVzdEZpbHRlcjtcbiAgICBcdHRoaXMubWluRmlsdGVyID0gbWluRmlsdGVyICE9PSB1bmRlZmluZWQgPyBtaW5GaWx0ZXIgOiBOZWFyZXN0RmlsdGVyO1xuXG4gICAgXHR0aGlzLmZsaXBZID0gZmFsc2U7XG4gICAgXHR0aGlzLmdlbmVyYXRlTWlwbWFwc1x0PSBmYWxzZTtcblxuICAgIH1cblxuICAgIERlcHRoVGV4dHVyZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUZXh0dXJlLnByb3RvdHlwZSApO1xuICAgIERlcHRoVGV4dHVyZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBEZXB0aFRleHR1cmU7XG4gICAgRGVwdGhUZXh0dXJlLnByb3RvdHlwZS5pc0RlcHRoVGV4dHVyZSA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gV2lyZWZyYW1lR2VvbWV0cnkoIGdlb21ldHJ5ICkge1xuXG4gICAgXHRCdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cbiAgICBcdHZhciBlZGdlID0gWyAwLCAwIF0sIGhhc2ggPSB7fTtcblxuICAgIFx0ZnVuY3Rpb24gc29ydEZ1bmN0aW9uKCBhLCBiICkge1xuXG4gICAgXHRcdHJldHVybiBhIC0gYjtcblxuICAgIFx0fVxuXG4gICAgXHR2YXIga2V5cyA9IFsgJ2EnLCAnYicsICdjJyBdO1xuXG4gICAgXHRpZiAoIChnZW9tZXRyeSAmJiBnZW9tZXRyeS5pc0dlb21ldHJ5KSApIHtcblxuICAgIFx0XHR2YXIgdmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcztcbiAgICBcdFx0dmFyIGZhY2VzID0gZ2VvbWV0cnkuZmFjZXM7XG4gICAgXHRcdHZhciBudW1FZGdlcyA9IDA7XG5cbiAgICBcdFx0Ly8gYWxsb2NhdGUgbWF4aW1hbCBzaXplXG4gICAgXHRcdHZhciBlZGdlcyA9IG5ldyBVaW50MzJBcnJheSggNiAqIGZhY2VzLmxlbmd0aCApO1xuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGZhY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICBcdFx0XHR2YXIgZmFjZSA9IGZhY2VzWyBpIF07XG5cbiAgICBcdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCAzOyBqICsrICkge1xuXG4gICAgXHRcdFx0XHRlZGdlWyAwIF0gPSBmYWNlWyBrZXlzWyBqIF0gXTtcbiAgICBcdFx0XHRcdGVkZ2VbIDEgXSA9IGZhY2VbIGtleXNbICggaiArIDEgKSAlIDMgXSBdO1xuICAgIFx0XHRcdFx0ZWRnZS5zb3J0KCBzb3J0RnVuY3Rpb24gKTtcblxuICAgIFx0XHRcdFx0dmFyIGtleSA9IGVkZ2UudG9TdHJpbmcoKTtcblxuICAgIFx0XHRcdFx0aWYgKCBoYXNoWyBrZXkgXSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0XHRcdGVkZ2VzWyAyICogbnVtRWRnZXMgXSA9IGVkZ2VbIDAgXTtcbiAgICBcdFx0XHRcdFx0ZWRnZXNbIDIgKiBudW1FZGdlcyArIDEgXSA9IGVkZ2VbIDEgXTtcbiAgICBcdFx0XHRcdFx0aGFzaFsga2V5IF0gPSB0cnVlO1xuICAgIFx0XHRcdFx0XHRudW1FZGdlcyArKztcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHR2YXIgY29vcmRzID0gbmV3IEZsb2F0MzJBcnJheSggbnVtRWRnZXMgKiAyICogMyApO1xuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IG51bUVkZ2VzOyBpIDwgbDsgaSArKyApIHtcblxuICAgIFx0XHRcdGZvciAoIHZhciBqID0gMDsgaiA8IDI7IGogKysgKSB7XG5cbiAgICBcdFx0XHRcdHZhciB2ZXJ0ZXggPSB2ZXJ0aWNlc1sgZWRnZXMgWyAyICogaSArIGogXSBdO1xuXG4gICAgXHRcdFx0XHR2YXIgaW5kZXggPSA2ICogaSArIDMgKiBqO1xuICAgIFx0XHRcdFx0Y29vcmRzWyBpbmRleCArIDAgXSA9IHZlcnRleC54O1xuICAgIFx0XHRcdFx0Y29vcmRzWyBpbmRleCArIDEgXSA9IHZlcnRleC55O1xuICAgIFx0XHRcdFx0Y29vcmRzWyBpbmRleCArIDIgXSA9IHZlcnRleC56O1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEJ1ZmZlckF0dHJpYnV0ZSggY29vcmRzLCAzICkgKTtcblxuICAgIFx0fSBlbHNlIGlmICggKGdlb21ldHJ5ICYmIGdlb21ldHJ5LmlzQnVmZmVyR2VvbWV0cnkpICkge1xuXG4gICAgXHRcdGlmICggZ2VvbWV0cnkuaW5kZXggIT09IG51bGwgKSB7XG5cbiAgICBcdFx0XHQvLyBJbmRleGVkIEJ1ZmZlckdlb21ldHJ5XG5cbiAgICBcdFx0XHR2YXIgaW5kaWNlcyA9IGdlb21ldHJ5LmluZGV4LmFycmF5O1xuICAgIFx0XHRcdHZhciB2ZXJ0aWNlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG4gICAgXHRcdFx0dmFyIGdyb3VwcyA9IGdlb21ldHJ5Lmdyb3VwcztcbiAgICBcdFx0XHR2YXIgbnVtRWRnZXMgPSAwO1xuXG4gICAgXHRcdFx0aWYgKCBncm91cHMubGVuZ3RoID09PSAwICkge1xuXG4gICAgXHRcdFx0XHRnZW9tZXRyeS5hZGRHcm91cCggMCwgaW5kaWNlcy5sZW5ndGggKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdC8vIGFsbG9jYXRlIG1heGltYWwgc2l6ZVxuICAgIFx0XHRcdHZhciBlZGdlcyA9IG5ldyBVaW50MzJBcnJheSggMiAqIGluZGljZXMubGVuZ3RoICk7XG5cbiAgICBcdFx0XHRmb3IgKCB2YXIgbyA9IDAsIG9sID0gZ3JvdXBzLmxlbmd0aDsgbyA8IG9sOyArKyBvICkge1xuXG4gICAgXHRcdFx0XHR2YXIgZ3JvdXAgPSBncm91cHNbIG8gXTtcblxuICAgIFx0XHRcdFx0dmFyIHN0YXJ0ID0gZ3JvdXAuc3RhcnQ7XG4gICAgXHRcdFx0XHR2YXIgY291bnQgPSBncm91cC5jb3VudDtcblxuICAgIFx0XHRcdFx0Zm9yICggdmFyIGkgPSBzdGFydCwgaWwgPSBzdGFydCArIGNvdW50OyBpIDwgaWw7IGkgKz0gMyApIHtcblxuICAgIFx0XHRcdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCAzOyBqICsrICkge1xuXG4gICAgXHRcdFx0XHRcdFx0ZWRnZVsgMCBdID0gaW5kaWNlc1sgaSArIGogXTtcbiAgICBcdFx0XHRcdFx0XHRlZGdlWyAxIF0gPSBpbmRpY2VzWyBpICsgKCBqICsgMSApICUgMyBdO1xuICAgIFx0XHRcdFx0XHRcdGVkZ2Uuc29ydCggc29ydEZ1bmN0aW9uICk7XG5cbiAgICBcdFx0XHRcdFx0XHR2YXIga2V5ID0gZWRnZS50b1N0cmluZygpO1xuXG4gICAgXHRcdFx0XHRcdFx0aWYgKCBoYXNoWyBrZXkgXSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0XHRcdFx0XHRlZGdlc1sgMiAqIG51bUVkZ2VzIF0gPSBlZGdlWyAwIF07XG4gICAgXHRcdFx0XHRcdFx0XHRlZGdlc1sgMiAqIG51bUVkZ2VzICsgMSBdID0gZWRnZVsgMSBdO1xuICAgIFx0XHRcdFx0XHRcdFx0aGFzaFsga2V5IF0gPSB0cnVlO1xuICAgIFx0XHRcdFx0XHRcdFx0bnVtRWRnZXMgKys7XG5cbiAgICBcdFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHR2YXIgY29vcmRzID0gbmV3IEZsb2F0MzJBcnJheSggbnVtRWRnZXMgKiAyICogMyApO1xuXG4gICAgXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gbnVtRWRnZXM7IGkgPCBsOyBpICsrICkge1xuXG4gICAgXHRcdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCAyOyBqICsrICkge1xuXG4gICAgXHRcdFx0XHRcdHZhciBpbmRleCA9IDYgKiBpICsgMyAqIGo7XG4gICAgXHRcdFx0XHRcdHZhciBpbmRleDIgPSBlZGdlc1sgMiAqIGkgKyBqIF07XG5cbiAgICBcdFx0XHRcdFx0Y29vcmRzWyBpbmRleCArIDAgXSA9IHZlcnRpY2VzLmdldFgoIGluZGV4MiApO1xuICAgIFx0XHRcdFx0XHRjb29yZHNbIGluZGV4ICsgMSBdID0gdmVydGljZXMuZ2V0WSggaW5kZXgyICk7XG4gICAgXHRcdFx0XHRcdGNvb3Jkc1sgaW5kZXggKyAyIF0gPSB2ZXJ0aWNlcy5nZXRaKCBpbmRleDIgKTtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIGNvb3JkcywgMyApICk7XG5cbiAgICBcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdC8vIG5vbi1pbmRleGVkIEJ1ZmZlckdlb21ldHJ5XG5cbiAgICBcdFx0XHR2YXIgdmVydGljZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xuICAgIFx0XHRcdHZhciBudW1FZGdlcyA9IHZlcnRpY2VzLmxlbmd0aCAvIDM7XG4gICAgXHRcdFx0dmFyIG51bVRyaXMgPSBudW1FZGdlcyAvIDM7XG5cbiAgICBcdFx0XHR2YXIgY29vcmRzID0gbmV3IEZsb2F0MzJBcnJheSggbnVtRWRnZXMgKiAyICogMyApO1xuXG4gICAgXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gbnVtVHJpczsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICBcdFx0XHRcdGZvciAoIHZhciBqID0gMDsgaiA8IDM7IGogKysgKSB7XG5cbiAgICBcdFx0XHRcdFx0dmFyIGluZGV4ID0gMTggKiBpICsgNiAqIGo7XG5cbiAgICBcdFx0XHRcdFx0dmFyIGluZGV4MSA9IDkgKiBpICsgMyAqIGo7XG4gICAgXHRcdFx0XHRcdGNvb3Jkc1sgaW5kZXggKyAwIF0gPSB2ZXJ0aWNlc1sgaW5kZXgxIF07XG4gICAgXHRcdFx0XHRcdGNvb3Jkc1sgaW5kZXggKyAxIF0gPSB2ZXJ0aWNlc1sgaW5kZXgxICsgMSBdO1xuICAgIFx0XHRcdFx0XHRjb29yZHNbIGluZGV4ICsgMiBdID0gdmVydGljZXNbIGluZGV4MSArIDIgXTtcblxuICAgIFx0XHRcdFx0XHR2YXIgaW5kZXgyID0gOSAqIGkgKyAzICogKCAoIGogKyAxICkgJSAzICk7XG4gICAgXHRcdFx0XHRcdGNvb3Jkc1sgaW5kZXggKyAzIF0gPSB2ZXJ0aWNlc1sgaW5kZXgyIF07XG4gICAgXHRcdFx0XHRcdGNvb3Jkc1sgaW5kZXggKyA0IF0gPSB2ZXJ0aWNlc1sgaW5kZXgyICsgMSBdO1xuICAgIFx0XHRcdFx0XHRjb29yZHNbIGluZGV4ICsgNSBdID0gdmVydGljZXNbIGluZGV4MiArIDIgXTtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIGNvb3JkcywgMyApICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9XG5cbiAgICB9XG5cbiAgICBXaXJlZnJhbWVHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcbiAgICBXaXJlZnJhbWVHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBXaXJlZnJhbWVHZW9tZXRyeTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3Igeno4NSAvIGh0dHBzOi8vZ2l0aHViLmNvbS96ejg1XG4gICAgICogUGFyYW1ldHJpYyBTdXJmYWNlcyBHZW9tZXRyeVxuICAgICAqIGJhc2VkIG9uIHRoZSBicmlsbGlhbnQgYXJ0aWNsZSBieSBAcHJpZGVvdXQgaHR0cDovL3ByaWRlb3V0Lm5ldC9ibG9nLz9wPTQ0XG4gICAgICpcbiAgICAgKiBuZXcgVEhSRUUuUGFyYW1ldHJpY0dlb21ldHJ5KCBwYXJhbWV0cmljRnVuY3Rpb24sIHVTZWdtZW50cywgeVNlZ2VtZW50cyApO1xuICAgICAqXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBQYXJhbWV0cmljR2VvbWV0cnkoIGZ1bmMsIHNsaWNlcywgc3RhY2tzICkge1xuXG4gICAgXHRHZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cbiAgICBcdHRoaXMudHlwZSA9ICdQYXJhbWV0cmljR2VvbWV0cnknO1xuXG4gICAgXHR0aGlzLnBhcmFtZXRlcnMgPSB7XG4gICAgXHRcdGZ1bmM6IGZ1bmMsXG4gICAgXHRcdHNsaWNlczogc2xpY2VzLFxuICAgIFx0XHRzdGFja3M6IHN0YWNrc1xuICAgIFx0fTtcblxuICAgIFx0dmFyIHZlcnRzID0gdGhpcy52ZXJ0aWNlcztcbiAgICBcdHZhciBmYWNlcyA9IHRoaXMuZmFjZXM7XG4gICAgXHR2YXIgdXZzID0gdGhpcy5mYWNlVmVydGV4VXZzWyAwIF07XG5cbiAgICBcdHZhciBpLCBqLCBwO1xuICAgIFx0dmFyIHUsIHY7XG5cbiAgICBcdHZhciBzbGljZUNvdW50ID0gc2xpY2VzICsgMTtcblxuICAgIFx0Zm9yICggaSA9IDA7IGkgPD0gc3RhY2tzOyBpICsrICkge1xuXG4gICAgXHRcdHYgPSBpIC8gc3RhY2tzO1xuXG4gICAgXHRcdGZvciAoIGogPSAwOyBqIDw9IHNsaWNlczsgaiArKyApIHtcblxuICAgIFx0XHRcdHUgPSBqIC8gc2xpY2VzO1xuXG4gICAgXHRcdFx0cCA9IGZ1bmMoIHUsIHYgKTtcbiAgICBcdFx0XHR2ZXJ0cy5wdXNoKCBwICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9XG5cbiAgICBcdHZhciBhLCBiLCBjLCBkO1xuICAgIFx0dmFyIHV2YSwgdXZiLCB1dmMsIHV2ZDtcblxuICAgIFx0Zm9yICggaSA9IDA7IGkgPCBzdGFja3M7IGkgKysgKSB7XG5cbiAgICBcdFx0Zm9yICggaiA9IDA7IGogPCBzbGljZXM7IGogKysgKSB7XG5cbiAgICBcdFx0XHRhID0gaSAqIHNsaWNlQ291bnQgKyBqO1xuICAgIFx0XHRcdGIgPSBpICogc2xpY2VDb3VudCArIGogKyAxO1xuICAgIFx0XHRcdGMgPSAoIGkgKyAxICkgKiBzbGljZUNvdW50ICsgaiArIDE7XG4gICAgXHRcdFx0ZCA9ICggaSArIDEgKSAqIHNsaWNlQ291bnQgKyBqO1xuXG4gICAgXHRcdFx0dXZhID0gbmV3IFZlY3RvcjIoIGogLyBzbGljZXMsIGkgLyBzdGFja3MgKTtcbiAgICBcdFx0XHR1dmIgPSBuZXcgVmVjdG9yMiggKCBqICsgMSApIC8gc2xpY2VzLCBpIC8gc3RhY2tzICk7XG4gICAgXHRcdFx0dXZjID0gbmV3IFZlY3RvcjIoICggaiArIDEgKSAvIHNsaWNlcywgKCBpICsgMSApIC8gc3RhY2tzICk7XG4gICAgXHRcdFx0dXZkID0gbmV3IFZlY3RvcjIoIGogLyBzbGljZXMsICggaSArIDEgKSAvIHN0YWNrcyApO1xuXG4gICAgXHRcdFx0ZmFjZXMucHVzaCggbmV3IEZhY2UzKCBhLCBiLCBkICkgKTtcbiAgICBcdFx0XHR1dnMucHVzaCggWyB1dmEsIHV2YiwgdXZkIF0gKTtcblxuICAgIFx0XHRcdGZhY2VzLnB1c2goIG5ldyBGYWNlMyggYiwgYywgZCApICk7XG4gICAgXHRcdFx0dXZzLnB1c2goIFsgdXZiLmNsb25lKCksIHV2YywgdXZkLmNsb25lKCkgXSApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0fVxuXG4gICAgXHQvLyBjb25zb2xlLmxvZyh0aGlzKTtcblxuICAgIFx0Ly8gbWFnaWMgYnVsbGV0XG4gICAgXHQvLyB2YXIgZGlmZiA9IHRoaXMubWVyZ2VWZXJ0aWNlcygpO1xuICAgIFx0Ly8gY29uc29sZS5sb2coJ3JlbW92ZWQgJywgZGlmZiwgJyB2ZXJ0aWNlcyBieSBtZXJnaW5nJyk7XG5cbiAgICBcdHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XG4gICAgXHR0aGlzLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7XG5cbiAgICB9XG5cbiAgICBQYXJhbWV0cmljR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggR2VvbWV0cnkucHJvdG90eXBlICk7XG4gICAgUGFyYW1ldHJpY0dlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBhcmFtZXRyaWNHZW9tZXRyeTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgY2xvY2t3b3JrZ2VlayAvIGh0dHBzOi8vZ2l0aHViLmNvbS9jbG9ja3dvcmtnZWVrXG4gICAgICogQGF1dGhvciB0aW1vdGh5cHJhdGxleSAvIGh0dHBzOi8vZ2l0aHViLmNvbS90aW1vdGh5cHJhdGxleVxuICAgICAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuICAgICovXG5cbiAgICBmdW5jdGlvbiBQb2x5aGVkcm9uR2VvbWV0cnkoIHZlcnRpY2VzLCBpbmRpY2VzLCByYWRpdXMsIGRldGFpbCApIHtcblxuICAgIFx0R2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG4gICAgXHR0aGlzLnR5cGUgPSAnUG9seWhlZHJvbkdlb21ldHJ5JztcblxuICAgIFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuICAgIFx0XHR2ZXJ0aWNlczogdmVydGljZXMsXG4gICAgXHRcdGluZGljZXM6IGluZGljZXMsXG4gICAgXHRcdHJhZGl1czogcmFkaXVzLFxuICAgIFx0XHRkZXRhaWw6IGRldGFpbFxuICAgIFx0fTtcblxuICAgIFx0cmFkaXVzID0gcmFkaXVzIHx8IDE7XG4gICAgXHRkZXRhaWwgPSBkZXRhaWwgfHwgMDtcblxuICAgIFx0dmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB2ZXJ0aWNlcy5sZW5ndGg7IGkgPCBsOyBpICs9IDMgKSB7XG5cbiAgICBcdFx0cHJlcGFyZSggbmV3IFZlY3RvcjMoIHZlcnRpY2VzWyBpIF0sIHZlcnRpY2VzWyBpICsgMSBdLCB2ZXJ0aWNlc1sgaSArIDIgXSApICk7XG5cbiAgICBcdH1cblxuICAgIFx0dmFyIHAgPSB0aGlzLnZlcnRpY2VzO1xuXG4gICAgXHR2YXIgZmFjZXMgPSBbXTtcblxuICAgIFx0Zm9yICggdmFyIGkgPSAwLCBqID0gMCwgbCA9IGluZGljZXMubGVuZ3RoOyBpIDwgbDsgaSArPSAzLCBqICsrICkge1xuXG4gICAgXHRcdHZhciB2MSA9IHBbIGluZGljZXNbIGkgXSBdO1xuICAgIFx0XHR2YXIgdjIgPSBwWyBpbmRpY2VzWyBpICsgMSBdIF07XG4gICAgXHRcdHZhciB2MyA9IHBbIGluZGljZXNbIGkgKyAyIF0gXTtcblxuICAgIFx0XHRmYWNlc1sgaiBdID0gbmV3IEZhY2UzKCB2MS5pbmRleCwgdjIuaW5kZXgsIHYzLmluZGV4LCBbIHYxLmNsb25lKCksIHYyLmNsb25lKCksIHYzLmNsb25lKCkgXSApO1xuXG4gICAgXHR9XG5cbiAgICBcdHZhciBjZW50cm9pZCA9IG5ldyBWZWN0b3IzKCk7XG5cbiAgICBcdGZvciAoIHZhciBpID0gMCwgbCA9IGZhY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICBcdFx0c3ViZGl2aWRlKCBmYWNlc1sgaSBdLCBkZXRhaWwgKTtcblxuICAgIFx0fVxuXG5cbiAgICBcdC8vIEhhbmRsZSBjYXNlIHdoZW4gZmFjZSBzdHJhZGRsZXMgdGhlIHNlYW1cblxuICAgIFx0Zm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgIFx0XHR2YXIgdXZzID0gdGhpcy5mYWNlVmVydGV4VXZzWyAwIF1bIGkgXTtcblxuICAgIFx0XHR2YXIgeDAgPSB1dnNbIDAgXS54O1xuICAgIFx0XHR2YXIgeDEgPSB1dnNbIDEgXS54O1xuICAgIFx0XHR2YXIgeDIgPSB1dnNbIDIgXS54O1xuXG4gICAgXHRcdHZhciBtYXggPSBNYXRoLm1heCggeDAsIHgxLCB4MiApO1xuICAgIFx0XHR2YXIgbWluID0gTWF0aC5taW4oIHgwLCB4MSwgeDIgKTtcblxuICAgIFx0XHRpZiAoIG1heCA+IDAuOSAmJiBtaW4gPCAwLjEgKSB7XG5cbiAgICBcdFx0XHQvLyAwLjkgaXMgc29tZXdoYXQgYXJiaXRyYXJ5XG5cbiAgICBcdFx0XHRpZiAoIHgwIDwgMC4yICkgdXZzWyAwIF0ueCArPSAxO1xuICAgIFx0XHRcdGlmICggeDEgPCAwLjIgKSB1dnNbIDEgXS54ICs9IDE7XG4gICAgXHRcdFx0aWYgKCB4MiA8IDAuMiApIHV2c1sgMiBdLnggKz0gMTtcblxuICAgIFx0XHR9XG5cbiAgICBcdH1cblxuXG4gICAgXHQvLyBBcHBseSByYWRpdXNcblxuICAgIFx0Zm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgXHRcdHRoaXMudmVydGljZXNbIGkgXS5tdWx0aXBseVNjYWxhciggcmFkaXVzICk7XG5cbiAgICBcdH1cblxuXG4gICAgXHQvLyBNZXJnZSB2ZXJ0aWNlc1xuXG4gICAgXHR0aGlzLm1lcmdlVmVydGljZXMoKTtcblxuICAgIFx0dGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcblxuICAgIFx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG5ldyBTcGhlcmUoIG5ldyBWZWN0b3IzKCksIHJhZGl1cyApO1xuXG5cbiAgICBcdC8vIFByb2plY3QgdmVjdG9yIG9udG8gc3BoZXJlJ3Mgc3VyZmFjZVxuXG4gICAgXHRmdW5jdGlvbiBwcmVwYXJlKCB2ZWN0b3IgKSB7XG5cbiAgICBcdFx0dmFyIHZlcnRleCA9IHZlY3Rvci5ub3JtYWxpemUoKS5jbG9uZSgpO1xuICAgIFx0XHR2ZXJ0ZXguaW5kZXggPSB0aGF0LnZlcnRpY2VzLnB1c2goIHZlcnRleCApIC0gMTtcblxuICAgIFx0XHQvLyBUZXh0dXJlIGNvb3JkcyBhcmUgZXF1aXZhbGVudCB0byBtYXAgY29vcmRzLCBjYWxjdWxhdGUgYW5nbGUgYW5kIGNvbnZlcnQgdG8gZnJhY3Rpb24gb2YgYSBjaXJjbGUuXG5cbiAgICBcdFx0dmFyIHUgPSBhemltdXRoKCB2ZWN0b3IgKSAvIDIgLyBNYXRoLlBJICsgMC41O1xuICAgIFx0XHR2YXIgdiA9IGluY2xpbmF0aW9uKCB2ZWN0b3IgKSAvIE1hdGguUEkgKyAwLjU7XG4gICAgXHRcdHZlcnRleC51diA9IG5ldyBWZWN0b3IyKCB1LCAxIC0gdiApO1xuXG4gICAgXHRcdHJldHVybiB2ZXJ0ZXg7XG5cbiAgICBcdH1cblxuXG4gICAgXHQvLyBBcHByb3hpbWF0ZSBhIGN1cnZlZCBmYWNlIHdpdGggcmVjdXJzaXZlbHkgc3ViLWRpdmlkZWQgdHJpYW5nbGVzLlxuXG4gICAgXHRmdW5jdGlvbiBtYWtlKCB2MSwgdjIsIHYzICkge1xuXG4gICAgXHRcdHZhciBmYWNlID0gbmV3IEZhY2UzKCB2MS5pbmRleCwgdjIuaW5kZXgsIHYzLmluZGV4LCBbIHYxLmNsb25lKCksIHYyLmNsb25lKCksIHYzLmNsb25lKCkgXSApO1xuICAgIFx0XHR0aGF0LmZhY2VzLnB1c2goIGZhY2UgKTtcblxuICAgIFx0XHRjZW50cm9pZC5jb3B5KCB2MSApLmFkZCggdjIgKS5hZGQoIHYzICkuZGl2aWRlU2NhbGFyKCAzICk7XG5cbiAgICBcdFx0dmFyIGF6aSA9IGF6aW11dGgoIGNlbnRyb2lkICk7XG5cbiAgICBcdFx0dGhhdC5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggW1xuICAgIFx0XHRcdGNvcnJlY3RVViggdjEudXYsIHYxLCBhemkgKSxcbiAgICBcdFx0XHRjb3JyZWN0VVYoIHYyLnV2LCB2MiwgYXppICksXG4gICAgXHRcdFx0Y29ycmVjdFVWKCB2My51diwgdjMsIGF6aSApXG4gICAgXHRcdF0gKTtcblxuICAgIFx0fVxuXG5cbiAgICBcdC8vIEFuYWx5dGljYWxseSBzdWJkaXZpZGUgYSBmYWNlIHRvIHRoZSByZXF1aXJlZCBkZXRhaWwgbGV2ZWwuXG5cbiAgICBcdGZ1bmN0aW9uIHN1YmRpdmlkZSggZmFjZSwgZGV0YWlsICkge1xuXG4gICAgXHRcdHZhciBjb2xzID0gTWF0aC5wb3coIDIsIGRldGFpbCApO1xuICAgIFx0XHR2YXIgYSA9IHByZXBhcmUoIHRoYXQudmVydGljZXNbIGZhY2UuYSBdICk7XG4gICAgXHRcdHZhciBiID0gcHJlcGFyZSggdGhhdC52ZXJ0aWNlc1sgZmFjZS5iIF0gKTtcbiAgICBcdFx0dmFyIGMgPSBwcmVwYXJlKCB0aGF0LnZlcnRpY2VzWyBmYWNlLmMgXSApO1xuICAgIFx0XHR2YXIgdiA9IFtdO1xuXG4gICAgXHRcdC8vIENvbnN0cnVjdCBhbGwgb2YgdGhlIHZlcnRpY2VzIGZvciB0aGlzIHN1YmRpdmlzaW9uLlxuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMCA7IGkgPD0gY29sczsgaSArKyApIHtcblxuICAgIFx0XHRcdHZbIGkgXSA9IFtdO1xuXG4gICAgXHRcdFx0dmFyIGFqID0gcHJlcGFyZSggYS5jbG9uZSgpLmxlcnAoIGMsIGkgLyBjb2xzICkgKTtcbiAgICBcdFx0XHR2YXIgYmogPSBwcmVwYXJlKCBiLmNsb25lKCkubGVycCggYywgaSAvIGNvbHMgKSApO1xuICAgIFx0XHRcdHZhciByb3dzID0gY29scyAtIGk7XG5cbiAgICBcdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPD0gcm93czsgaiArKyApIHtcblxuICAgIFx0XHRcdFx0aWYgKCBqID09PSAwICYmIGkgPT09IGNvbHMgKSB7XG5cbiAgICBcdFx0XHRcdFx0dlsgaSBdWyBqIF0gPSBhajtcblxuICAgIFx0XHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0XHR2WyBpIF1bIGogXSA9IHByZXBhcmUoIGFqLmNsb25lKCkubGVycCggYmosIGogLyByb3dzICkgKTtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHQvLyBDb25zdHJ1Y3QgYWxsIG9mIHRoZSBmYWNlcy5cblxuICAgIFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBjb2xzIDsgaSArKyApIHtcblxuICAgIFx0XHRcdGZvciAoIHZhciBqID0gMDsgaiA8IDIgKiAoIGNvbHMgLSBpICkgLSAxOyBqICsrICkge1xuXG4gICAgXHRcdFx0XHR2YXIgayA9IE1hdGguZmxvb3IoIGogLyAyICk7XG5cbiAgICBcdFx0XHRcdGlmICggaiAlIDIgPT09IDAgKSB7XG5cbiAgICBcdFx0XHRcdFx0bWFrZShcbiAgICBcdFx0XHRcdFx0XHR2WyBpIF1bIGsgKyAxIF0sXG4gICAgXHRcdFx0XHRcdFx0dlsgaSArIDEgXVsgayBdLFxuICAgIFx0XHRcdFx0XHRcdHZbIGkgXVsgayBdXG4gICAgXHRcdFx0XHRcdCk7XG5cbiAgICBcdFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdFx0bWFrZShcbiAgICBcdFx0XHRcdFx0XHR2WyBpIF1bIGsgKyAxIF0sXG4gICAgXHRcdFx0XHRcdFx0dlsgaSArIDEgXVsgayArIDEgXSxcbiAgICBcdFx0XHRcdFx0XHR2WyBpICsgMSBdWyBrIF1cbiAgICBcdFx0XHRcdFx0KTtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0fVxuXG5cbiAgICBcdC8vIEFuZ2xlIGFyb3VuZCB0aGUgWSBheGlzLCBjb3VudGVyLWNsb2Nrd2lzZSB3aGVuIGxvb2tpbmcgZnJvbSBhYm92ZS5cblxuICAgIFx0ZnVuY3Rpb24gYXppbXV0aCggdmVjdG9yICkge1xuXG4gICAgXHRcdHJldHVybiBNYXRoLmF0YW4yKCB2ZWN0b3IueiwgLSB2ZWN0b3IueCApO1xuXG4gICAgXHR9XG5cblxuICAgIFx0Ly8gQW5nbGUgYWJvdmUgdGhlIFhaIHBsYW5lLlxuXG4gICAgXHRmdW5jdGlvbiBpbmNsaW5hdGlvbiggdmVjdG9yICkge1xuXG4gICAgXHRcdHJldHVybiBNYXRoLmF0YW4yKCAtIHZlY3Rvci55LCBNYXRoLnNxcnQoICggdmVjdG9yLnggKiB2ZWN0b3IueCApICsgKCB2ZWN0b3IueiAqIHZlY3Rvci56ICkgKSApO1xuXG4gICAgXHR9XG5cblxuICAgIFx0Ly8gVGV4dHVyZSBmaXhpbmcgaGVscGVyLiBTcGhlcmVzIGhhdmUgc29tZSBvZGQgYmVoYXZpb3Vycy5cblxuICAgIFx0ZnVuY3Rpb24gY29ycmVjdFVWKCB1diwgdmVjdG9yLCBhemltdXRoICkge1xuXG4gICAgXHRcdGlmICggKCBhemltdXRoIDwgMCApICYmICggdXYueCA9PT0gMSApICkgdXYgPSBuZXcgVmVjdG9yMiggdXYueCAtIDEsIHV2LnkgKTtcbiAgICBcdFx0aWYgKCAoIHZlY3Rvci54ID09PSAwICkgJiYgKCB2ZWN0b3IueiA9PT0gMCApICkgdXYgPSBuZXcgVmVjdG9yMiggYXppbXV0aCAvIDIgLyBNYXRoLlBJICsgMC41LCB1di55ICk7XG4gICAgXHRcdHJldHVybiB1di5jbG9uZSgpO1xuXG4gICAgXHR9XG5cbiAgICB9XG5cbiAgICBQb2x5aGVkcm9uR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggR2VvbWV0cnkucHJvdG90eXBlICk7XG4gICAgUG9seWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBvbHloZWRyb25HZW9tZXRyeTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgdGltb3RoeXByYXRsZXkgLyBodHRwczovL2dpdGh1Yi5jb20vdGltb3RoeXByYXRsZXlcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIFRldHJhaGVkcm9uR2VvbWV0cnkoIHJhZGl1cywgZGV0YWlsICkge1xuXG4gICAgXHR2YXIgdmVydGljZXMgPSBbXG4gICAgXHRcdCAxLCAgMSwgIDEsICAgLSAxLCAtIDEsICAxLCAgIC0gMSwgIDEsIC0gMSwgICAgMSwgLSAxLCAtIDFcbiAgICBcdF07XG5cbiAgICBcdHZhciBpbmRpY2VzID0gW1xuICAgIFx0XHQgMiwgIDEsICAwLCAgICAwLCAgMywgIDIsICAgIDEsICAzLCAgMCwgICAgMiwgIDMsICAxXG4gICAgXHRdO1xuXG4gICAgXHRQb2x5aGVkcm9uR2VvbWV0cnkuY2FsbCggdGhpcywgdmVydGljZXMsIGluZGljZXMsIHJhZGl1cywgZGV0YWlsICk7XG5cbiAgICBcdHRoaXMudHlwZSA9ICdUZXRyYWhlZHJvbkdlb21ldHJ5JztcblxuICAgIFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuICAgIFx0XHRyYWRpdXM6IHJhZGl1cyxcbiAgICBcdFx0ZGV0YWlsOiBkZXRhaWxcbiAgICBcdH07XG5cbiAgICB9XG5cbiAgICBUZXRyYWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFBvbHloZWRyb25HZW9tZXRyeS5wcm90b3R5cGUgKTtcbiAgICBUZXRyYWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRldHJhaGVkcm9uR2VvbWV0cnk7XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIHRpbW90aHlwcmF0bGV5IC8gaHR0cHM6Ly9naXRodWIuY29tL3RpbW90aHlwcmF0bGV5XG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBPY3RhaGVkcm9uR2VvbWV0cnkoIHJhZGl1cywgZGV0YWlsICkge1xuXG4gICAgXHR2YXIgdmVydGljZXMgPSBbXG4gICAgXHRcdDEsIDAsIDAsICAgLSAxLCAwLCAwLCAgICAwLCAxLCAwLCAgICAwLCAtIDEsIDAsICAgIDAsIDAsIDEsICAgIDAsIDAsIC0gMVxuICAgIFx0XTtcblxuICAgIFx0dmFyIGluZGljZXMgPSBbXG4gICAgXHRcdDAsIDIsIDQsICAgIDAsIDQsIDMsICAgIDAsIDMsIDUsICAgIDAsIDUsIDIsICAgIDEsIDIsIDUsICAgIDEsIDUsIDMsICAgIDEsIDMsIDQsICAgIDEsIDQsIDJcbiAgICBcdF07XG5cbiAgICBcdFBvbHloZWRyb25HZW9tZXRyeS5jYWxsKCB0aGlzLCB2ZXJ0aWNlcywgaW5kaWNlcywgcmFkaXVzLCBkZXRhaWwgKTtcblxuICAgIFx0dGhpcy50eXBlID0gJ09jdGFoZWRyb25HZW9tZXRyeSc7XG5cbiAgICBcdHRoaXMucGFyYW1ldGVycyA9IHtcbiAgICBcdFx0cmFkaXVzOiByYWRpdXMsXG4gICAgXHRcdGRldGFpbDogZGV0YWlsXG4gICAgXHR9O1xuXG4gICAgfVxuXG4gICAgT2N0YWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFBvbHloZWRyb25HZW9tZXRyeS5wcm90b3R5cGUgKTtcbiAgICBPY3RhaGVkcm9uR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gT2N0YWhlZHJvbkdlb21ldHJ5O1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciB0aW1vdGh5cHJhdGxleSAvIGh0dHBzOi8vZ2l0aHViLmNvbS90aW1vdGh5cHJhdGxleVxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gSWNvc2FoZWRyb25HZW9tZXRyeSggcmFkaXVzLCBkZXRhaWwgKSB7XG5cbiAgICBcdHZhciB0ID0gKCAxICsgTWF0aC5zcXJ0KCA1ICkgKSAvIDI7XG5cbiAgICBcdHZhciB2ZXJ0aWNlcyA9IFtcbiAgICBcdFx0LSAxLCAgdCwgIDAsICAgIDEsICB0LCAgMCwgICAtIDEsIC0gdCwgIDAsICAgIDEsIC0gdCwgIDAsXG4gICAgXHRcdCAwLCAtIDEsICB0LCAgICAwLCAgMSwgIHQsICAgIDAsIC0gMSwgLSB0LCAgICAwLCAgMSwgLSB0LFxuICAgIFx0XHQgdCwgIDAsIC0gMSwgICAgdCwgIDAsICAxLCAgIC0gdCwgIDAsIC0gMSwgICAtIHQsICAwLCAgMVxuICAgIFx0XTtcblxuICAgIFx0dmFyIGluZGljZXMgPSBbXG4gICAgXHRcdCAwLCAxMSwgIDUsICAgIDAsICA1LCAgMSwgICAgMCwgIDEsICA3LCAgICAwLCAgNywgMTAsICAgIDAsIDEwLCAxMSxcbiAgICBcdFx0IDEsICA1LCAgOSwgICAgNSwgMTEsICA0LCAgIDExLCAxMCwgIDIsICAgMTAsICA3LCAgNiwgICAgNywgIDEsICA4LFxuICAgIFx0XHQgMywgIDksICA0LCAgICAzLCAgNCwgIDIsICAgIDMsICAyLCAgNiwgICAgMywgIDYsICA4LCAgICAzLCAgOCwgIDksXG4gICAgXHRcdCA0LCAgOSwgIDUsICAgIDIsICA0LCAxMSwgICAgNiwgIDIsIDEwLCAgICA4LCAgNiwgIDcsICAgIDksICA4LCAgMVxuICAgIFx0XTtcblxuICAgIFx0UG9seWhlZHJvbkdlb21ldHJ5LmNhbGwoIHRoaXMsIHZlcnRpY2VzLCBpbmRpY2VzLCByYWRpdXMsIGRldGFpbCApO1xuXG4gICAgXHR0aGlzLnR5cGUgPSAnSWNvc2FoZWRyb25HZW9tZXRyeSc7XG5cbiAgICBcdHRoaXMucGFyYW1ldGVycyA9IHtcbiAgICBcdFx0cmFkaXVzOiByYWRpdXMsXG4gICAgXHRcdGRldGFpbDogZGV0YWlsXG4gICAgXHR9O1xuXG4gICAgfVxuXG4gICAgSWNvc2FoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBQb2x5aGVkcm9uR2VvbWV0cnkucHJvdG90eXBlICk7XG4gICAgSWNvc2FoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBJY29zYWhlZHJvbkdlb21ldHJ5O1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBBYmUgUGF6b3MgLyBodHRwczovL2hhbW9pZC5jb21cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIERvZGVjYWhlZHJvbkdlb21ldHJ5KCByYWRpdXMsIGRldGFpbCApIHtcblxuICAgIFx0dmFyIHQgPSAoIDEgKyBNYXRoLnNxcnQoIDUgKSApIC8gMjtcbiAgICBcdHZhciByID0gMSAvIHQ7XG5cbiAgICBcdHZhciB2ZXJ0aWNlcyA9IFtcblxuICAgIFx0XHQvLyAowrExLCDCsTEsIMKxMSlcbiAgICBcdFx0LSAxLCAtIDEsIC0gMSwgICAgLSAxLCAtIDEsICAxLFxuICAgIFx0XHQtIDEsICAxLCAtIDEsICAgIC0gMSwgIDEsICAxLFxuICAgIFx0XHQgMSwgLSAxLCAtIDEsICAgICAxLCAtIDEsICAxLFxuICAgIFx0XHQgMSwgIDEsIC0gMSwgICAgIDEsICAxLCAgMSxcblxuICAgIFx0XHQvLyAoMCwgwrExL8+GLCDCsc+GKVxuICAgIFx0XHQgMCwgLSByLCAtIHQsICAgICAwLCAtIHIsICB0LFxuICAgIFx0XHQgMCwgIHIsIC0gdCwgICAgIDAsICByLCAgdCxcblxuICAgIFx0XHQvLyAowrExL8+GLCDCsc+GLCAwKVxuICAgIFx0XHQtIHIsIC0gdCwgIDAsICAgIC0gciwgIHQsICAwLFxuICAgIFx0XHQgciwgLSB0LCAgMCwgICAgIHIsICB0LCAgMCxcblxuICAgIFx0XHQvLyAowrHPhiwgMCwgwrExL8+GKVxuICAgIFx0XHQtIHQsICAwLCAtIHIsICAgICB0LCAgMCwgLSByLFxuICAgIFx0XHQtIHQsICAwLCAgciwgICAgIHQsICAwLCAgclxuICAgIFx0XTtcblxuICAgIFx0dmFyIGluZGljZXMgPSBbXG4gICAgXHRcdCAzLCAxMSwgIDcsICAgICAgMywgIDcsIDE1LCAgICAgIDMsIDE1LCAxMyxcbiAgICBcdFx0IDcsIDE5LCAxNywgICAgICA3LCAxNywgIDYsICAgICAgNywgIDYsIDE1LFxuICAgIFx0XHQxNywgIDQsICA4LCAgICAgMTcsICA4LCAxMCwgICAgIDE3LCAxMCwgIDYsXG4gICAgXHRcdCA4LCAgMCwgMTYsICAgICAgOCwgMTYsICAyLCAgICAgIDgsICAyLCAxMCxcbiAgICBcdFx0IDAsIDEyLCAgMSwgICAgICAwLCAgMSwgMTgsICAgICAgMCwgMTgsIDE2LFxuICAgIFx0XHQgNiwgMTAsICAyLCAgICAgIDYsICAyLCAxMywgICAgICA2LCAxMywgMTUsXG4gICAgXHRcdCAyLCAxNiwgMTgsICAgICAgMiwgMTgsICAzLCAgICAgIDIsICAzLCAxMyxcbiAgICBcdFx0MTgsICAxLCAgOSwgICAgIDE4LCAgOSwgMTEsICAgICAxOCwgMTEsICAzLFxuICAgIFx0XHQgNCwgMTQsIDEyLCAgICAgIDQsIDEyLCAgMCwgICAgICA0LCAgMCwgIDgsXG4gICAgXHRcdDExLCAgOSwgIDUsICAgICAxMSwgIDUsIDE5LCAgICAgMTEsIDE5LCAgNyxcbiAgICBcdFx0MTksICA1LCAxNCwgICAgIDE5LCAxNCwgIDQsICAgICAxOSwgIDQsIDE3LFxuICAgIFx0XHQgMSwgMTIsIDE0LCAgICAgIDEsIDE0LCAgNSwgICAgICAxLCAgNSwgIDlcbiAgICBcdF07XG5cbiAgICBcdFBvbHloZWRyb25HZW9tZXRyeS5jYWxsKCB0aGlzLCB2ZXJ0aWNlcywgaW5kaWNlcywgcmFkaXVzLCBkZXRhaWwgKTtcblxuICAgIFx0dGhpcy50eXBlID0gJ0RvZGVjYWhlZHJvbkdlb21ldHJ5JztcblxuICAgIFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuICAgIFx0XHRyYWRpdXM6IHJhZGl1cyxcbiAgICBcdFx0ZGV0YWlsOiBkZXRhaWxcbiAgICBcdH07XG5cbiAgICB9XG5cbiAgICBEb2RlY2FoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBQb2x5aGVkcm9uR2VvbWV0cnkucHJvdG90eXBlICk7XG4gICAgRG9kZWNhaGVkcm9uR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRG9kZWNhaGVkcm9uR2VvbWV0cnk7XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cHM6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4gICAgICogQGF1dGhvciB6ejg1IC8gaHR0cHM6Ly9naXRodWIuY29tL3p6ODVcbiAgICAgKiBAYXV0aG9yIG1pbmluZ29sZCAvIGh0dHBzOi8vZ2l0aHViLmNvbS9taW5pbmdvbGRcbiAgICAgKiBAYXV0aG9yIGpvbm9icjEgLyBodHRwczovL2dpdGh1Yi5jb20vam9ub2JyMVxuICAgICAqXG4gICAgICogTW9kaWZpZWQgZnJvbSB0aGUgVG9ydXNLbm90R2VvbWV0cnkgYnkgQG9vc21veGllY29kZVxuICAgICAqXG4gICAgICogQ3JlYXRlcyBhIHR1YmUgd2hpY2ggZXh0cnVkZXMgYWxvbmcgYSAzZCBzcGxpbmVcbiAgICAgKlxuICAgICAqIFVzZXMgcGFyYWxsZWwgdHJhbnNwb3J0IGZyYW1lcyBhcyBkZXNjcmliZWQgaW5cbiAgICAgKiBodHRwOi8vd3d3LmNzLmluZGlhbmEuZWR1L3B1Yi90ZWNocmVwb3J0cy9UUjQyNS5wZGZcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIFR1YmVHZW9tZXRyeSggcGF0aCwgc2VnbWVudHMsIHJhZGl1cywgcmFkaWFsU2VnbWVudHMsIGNsb3NlZCwgdGFwZXIgKSB7XG5cbiAgICBcdEdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuICAgIFx0dGhpcy50eXBlID0gJ1R1YmVHZW9tZXRyeSc7XG5cbiAgICBcdHRoaXMucGFyYW1ldGVycyA9IHtcbiAgICBcdFx0cGF0aDogcGF0aCxcbiAgICBcdFx0c2VnbWVudHM6IHNlZ21lbnRzLFxuICAgIFx0XHRyYWRpdXM6IHJhZGl1cyxcbiAgICBcdFx0cmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxuICAgIFx0XHRjbG9zZWQ6IGNsb3NlZCxcbiAgICBcdFx0dGFwZXI6IHRhcGVyXG4gICAgXHR9O1xuXG4gICAgXHRzZWdtZW50cyA9IHNlZ21lbnRzIHx8IDY0O1xuICAgIFx0cmFkaXVzID0gcmFkaXVzIHx8IDE7XG4gICAgXHRyYWRpYWxTZWdtZW50cyA9IHJhZGlhbFNlZ21lbnRzIHx8IDg7XG4gICAgXHRjbG9zZWQgPSBjbG9zZWQgfHwgZmFsc2U7XG4gICAgXHR0YXBlciA9IHRhcGVyIHx8IFR1YmVHZW9tZXRyeS5Ob1RhcGVyO1xuXG4gICAgXHR2YXIgZ3JpZCA9IFtdO1xuXG4gICAgXHR2YXIgc2NvcGUgPSB0aGlzLFxuXG4gICAgXHRcdHRhbmdlbnQsXG4gICAgXHRcdG5vcm1hbCxcbiAgICBcdFx0Ymlub3JtYWwsXG5cbiAgICBcdFx0bnVtcG9pbnRzID0gc2VnbWVudHMgKyAxLFxuXG4gICAgXHRcdHUsIHYsIHIsXG5cbiAgICBcdFx0Y3gsIGN5LFxuICAgIFx0XHRwb3MsIHBvczIgPSBuZXcgVmVjdG9yMygpLFxuICAgIFx0XHRpLCBqLFxuICAgIFx0XHRpcCwganAsXG4gICAgXHRcdGEsIGIsIGMsIGQsXG4gICAgXHRcdHV2YSwgdXZiLCB1dmMsIHV2ZDtcblxuICAgIFx0dmFyIGZyYW1lcyA9IG5ldyBUdWJlR2VvbWV0cnkuRnJlbmV0RnJhbWVzKCBwYXRoLCBzZWdtZW50cywgY2xvc2VkICksXG4gICAgXHRcdHRhbmdlbnRzID0gZnJhbWVzLnRhbmdlbnRzLFxuICAgIFx0XHRub3JtYWxzID0gZnJhbWVzLm5vcm1hbHMsXG4gICAgXHRcdGJpbm9ybWFscyA9IGZyYW1lcy5iaW5vcm1hbHM7XG5cbiAgICBcdC8vIHByb3h5IGludGVybmFsc1xuICAgIFx0dGhpcy50YW5nZW50cyA9IHRhbmdlbnRzO1xuICAgIFx0dGhpcy5ub3JtYWxzID0gbm9ybWFscztcbiAgICBcdHRoaXMuYmlub3JtYWxzID0gYmlub3JtYWxzO1xuXG4gICAgXHRmdW5jdGlvbiB2ZXJ0KCB4LCB5LCB6ICkge1xuXG4gICAgXHRcdHJldHVybiBzY29wZS52ZXJ0aWNlcy5wdXNoKCBuZXcgVmVjdG9yMyggeCwgeSwgeiApICkgLSAxO1xuXG4gICAgXHR9XG5cbiAgICBcdC8vIGNvbnN0cnVjdCB0aGUgZ3JpZFxuXG4gICAgXHRmb3IgKCBpID0gMDsgaSA8IG51bXBvaW50czsgaSArKyApIHtcblxuICAgIFx0XHRncmlkWyBpIF0gPSBbXTtcblxuICAgIFx0XHR1ID0gaSAvICggbnVtcG9pbnRzIC0gMSApO1xuXG4gICAgXHRcdHBvcyA9IHBhdGguZ2V0UG9pbnRBdCggdSApO1xuXG4gICAgXHRcdHRhbmdlbnQgPSB0YW5nZW50c1sgaSBdO1xuICAgIFx0XHRub3JtYWwgPSBub3JtYWxzWyBpIF07XG4gICAgXHRcdGJpbm9ybWFsID0gYmlub3JtYWxzWyBpIF07XG5cbiAgICBcdFx0ciA9IHJhZGl1cyAqIHRhcGVyKCB1ICk7XG5cbiAgICBcdFx0Zm9yICggaiA9IDA7IGogPCByYWRpYWxTZWdtZW50czsgaiArKyApIHtcblxuICAgIFx0XHRcdHYgPSBqIC8gcmFkaWFsU2VnbWVudHMgKiAyICogTWF0aC5QSTtcblxuICAgIFx0XHRcdGN4ID0gLSByICogTWF0aC5jb3MoIHYgKTsgLy8gVE9ETzogSGFjazogTmVnYXRpbmcgaXQgc28gaXQgZmFjZXMgb3V0c2lkZS5cbiAgICBcdFx0XHRjeSA9IHIgKiBNYXRoLnNpbiggdiApO1xuXG4gICAgXHRcdFx0cG9zMi5jb3B5KCBwb3MgKTtcbiAgICBcdFx0XHRwb3MyLnggKz0gY3ggKiBub3JtYWwueCArIGN5ICogYmlub3JtYWwueDtcbiAgICBcdFx0XHRwb3MyLnkgKz0gY3ggKiBub3JtYWwueSArIGN5ICogYmlub3JtYWwueTtcbiAgICBcdFx0XHRwb3MyLnogKz0gY3ggKiBub3JtYWwueiArIGN5ICogYmlub3JtYWwuejtcblxuICAgIFx0XHRcdGdyaWRbIGkgXVsgaiBdID0gdmVydCggcG9zMi54LCBwb3MyLnksIHBvczIueiApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0fVxuXG5cbiAgICBcdC8vIGNvbnN0cnVjdCB0aGUgbWVzaFxuXG4gICAgXHRmb3IgKCBpID0gMDsgaSA8IHNlZ21lbnRzOyBpICsrICkge1xuXG4gICAgXHRcdGZvciAoIGogPSAwOyBqIDwgcmFkaWFsU2VnbWVudHM7IGogKysgKSB7XG5cbiAgICBcdFx0XHRpcCA9ICggY2xvc2VkICkgPyAoIGkgKyAxICkgJSBzZWdtZW50cyA6IGkgKyAxO1xuICAgIFx0XHRcdGpwID0gKCBqICsgMSApICUgcmFkaWFsU2VnbWVudHM7XG5cbiAgICBcdFx0XHRhID0gZ3JpZFsgaSBdWyBqIF07XHRcdC8vICoqKiBOT1QgTkVDRVNTQVJJTFkgUExBTkFSICEgKioqXG4gICAgXHRcdFx0YiA9IGdyaWRbIGlwIF1bIGogXTtcbiAgICBcdFx0XHRjID0gZ3JpZFsgaXAgXVsganAgXTtcbiAgICBcdFx0XHRkID0gZ3JpZFsgaSBdWyBqcCBdO1xuXG4gICAgXHRcdFx0dXZhID0gbmV3IFZlY3RvcjIoIGkgLyBzZWdtZW50cywgaiAvIHJhZGlhbFNlZ21lbnRzICk7XG4gICAgXHRcdFx0dXZiID0gbmV3IFZlY3RvcjIoICggaSArIDEgKSAvIHNlZ21lbnRzLCBqIC8gcmFkaWFsU2VnbWVudHMgKTtcbiAgICBcdFx0XHR1dmMgPSBuZXcgVmVjdG9yMiggKCBpICsgMSApIC8gc2VnbWVudHMsICggaiArIDEgKSAvIHJhZGlhbFNlZ21lbnRzICk7XG4gICAgXHRcdFx0dXZkID0gbmV3IFZlY3RvcjIoIGkgLyBzZWdtZW50cywgKCBqICsgMSApIC8gcmFkaWFsU2VnbWVudHMgKTtcblxuICAgIFx0XHRcdHRoaXMuZmFjZXMucHVzaCggbmV3IEZhY2UzKCBhLCBiLCBkICkgKTtcbiAgICBcdFx0XHR0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2YSwgdXZiLCB1dmQgXSApO1xuXG4gICAgXHRcdFx0dGhpcy5mYWNlcy5wdXNoKCBuZXcgRmFjZTMoIGIsIGMsIGQgKSApO1xuICAgIFx0XHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZiLmNsb25lKCksIHV2YywgdXZkLmNsb25lKCkgXSApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0fVxuXG4gICAgXHR0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xuICAgIFx0dGhpcy5jb21wdXRlVmVydGV4Tm9ybWFscygpO1xuXG4gICAgfVxuXG4gICAgVHViZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEdlb21ldHJ5LnByb3RvdHlwZSApO1xuICAgIFR1YmVHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUdWJlR2VvbWV0cnk7XG5cbiAgICBUdWJlR2VvbWV0cnkuTm9UYXBlciA9IGZ1bmN0aW9uICggdSApIHtcblxuICAgIFx0cmV0dXJuIDE7XG5cbiAgICB9O1xuXG4gICAgVHViZUdlb21ldHJ5LlNpbnVzb2lkYWxUYXBlciA9IGZ1bmN0aW9uICggdSApIHtcblxuICAgIFx0cmV0dXJuIE1hdGguc2luKCBNYXRoLlBJICogdSApO1xuXG4gICAgfTtcblxuICAgIC8vIEZvciBjb21wdXRpbmcgb2YgRnJlbmV0IGZyYW1lcywgZXhwb3NpbmcgdGhlIHRhbmdlbnRzLCBub3JtYWxzIGFuZCBiaW5vcm1hbHMgdGhlIHNwbGluZVxuICAgIFR1YmVHZW9tZXRyeS5GcmVuZXRGcmFtZXMgPSBmdW5jdGlvbiAoIHBhdGgsIHNlZ21lbnRzLCBjbG9zZWQgKSB7XG5cbiAgICBcdHZhclx0bm9ybWFsID0gbmV3IFZlY3RvcjMoKSxcblxuICAgIFx0XHR0YW5nZW50cyA9IFtdLFxuICAgIFx0XHRub3JtYWxzID0gW10sXG4gICAgXHRcdGJpbm9ybWFscyA9IFtdLFxuXG4gICAgXHRcdHZlYyA9IG5ldyBWZWN0b3IzKCksXG4gICAgXHRcdG1hdCA9IG5ldyBNYXRyaXg0KCksXG5cbiAgICBcdFx0bnVtcG9pbnRzID0gc2VnbWVudHMgKyAxLFxuICAgIFx0XHR0aGV0YSxcbiAgICBcdFx0c21hbGxlc3QsXG5cbiAgICBcdFx0dHgsIHR5LCB0eixcbiAgICBcdFx0aSwgdTtcblxuXG4gICAgXHQvLyBleHBvc2UgaW50ZXJuYWxzXG4gICAgXHR0aGlzLnRhbmdlbnRzID0gdGFuZ2VudHM7XG4gICAgXHR0aGlzLm5vcm1hbHMgPSBub3JtYWxzO1xuICAgIFx0dGhpcy5iaW5vcm1hbHMgPSBiaW5vcm1hbHM7XG5cbiAgICBcdC8vIGNvbXB1dGUgdGhlIHRhbmdlbnQgdmVjdG9ycyBmb3IgZWFjaCBzZWdtZW50IG9uIHRoZSBwYXRoXG5cbiAgICBcdGZvciAoIGkgPSAwOyBpIDwgbnVtcG9pbnRzOyBpICsrICkge1xuXG4gICAgXHRcdHUgPSBpIC8gKCBudW1wb2ludHMgLSAxICk7XG5cbiAgICBcdFx0dGFuZ2VudHNbIGkgXSA9IHBhdGguZ2V0VGFuZ2VudEF0KCB1ICk7XG4gICAgXHRcdHRhbmdlbnRzWyBpIF0ubm9ybWFsaXplKCk7XG5cbiAgICBcdH1cblxuICAgIFx0aW5pdGlhbE5vcm1hbDMoKTtcblxuICAgIFx0LypcbiAgICBcdGZ1bmN0aW9uIGluaXRpYWxOb3JtYWwxKGxhc3RCaW5vcm1hbCkge1xuICAgIFx0XHQvLyBmaXhlZCBzdGFydCBiaW5vcm1hbC4gSGFzIGRhbmdlcnMgb2YgMCB2ZWN0b3JzXG4gICAgXHRcdG5vcm1hbHNbIDAgXSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgXHRcdGJpbm9ybWFsc1sgMCBdID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICBcdFx0aWYgKGxhc3RCaW5vcm1hbD09PXVuZGVmaW5lZCkgbGFzdEJpbm9ybWFsID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDAsIDEgKTtcbiAgICBcdFx0bm9ybWFsc1sgMCBdLmNyb3NzVmVjdG9ycyggbGFzdEJpbm9ybWFsLCB0YW5nZW50c1sgMCBdICkubm9ybWFsaXplKCk7XG4gICAgXHRcdGJpbm9ybWFsc1sgMCBdLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIDAgXSwgbm9ybWFsc1sgMCBdICkubm9ybWFsaXplKCk7XG4gICAgXHR9XG5cbiAgICBcdGZ1bmN0aW9uIGluaXRpYWxOb3JtYWwyKCkge1xuXG4gICAgXHRcdC8vIFRoaXMgdXNlcyB0aGUgRnJlbmV0LVNlcnJldCBmb3JtdWxhIGZvciBkZXJpdmluZyBiaW5vcm1hbFxuICAgIFx0XHR2YXIgdDIgPSBwYXRoLmdldFRhbmdlbnRBdCggZXBzaWxvbiApO1xuXG4gICAgXHRcdG5vcm1hbHNbIDAgXSA9IG5ldyBUSFJFRS5WZWN0b3IzKCkuc3ViVmVjdG9ycyggdDIsIHRhbmdlbnRzWyAwIF0gKS5ub3JtYWxpemUoKTtcbiAgICBcdFx0Ymlub3JtYWxzWyAwIF0gPSBuZXcgVEhSRUUuVmVjdG9yMygpLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIDAgXSwgbm9ybWFsc1sgMCBdICk7XG5cbiAgICBcdFx0bm9ybWFsc1sgMCBdLmNyb3NzVmVjdG9ycyggYmlub3JtYWxzWyAwIF0sIHRhbmdlbnRzWyAwIF0gKS5ub3JtYWxpemUoKTsgLy8gbGFzdCBiaW5vcm1hbCB4IHRhbmdlbnRcbiAgICBcdFx0Ymlub3JtYWxzWyAwIF0uY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgMCBdLCBub3JtYWxzWyAwIF0gKS5ub3JtYWxpemUoKTtcblxuICAgIFx0fVxuICAgIFx0Ki9cblxuICAgIFx0ZnVuY3Rpb24gaW5pdGlhbE5vcm1hbDMoKSB7XG5cbiAgICBcdFx0Ly8gc2VsZWN0IGFuIGluaXRpYWwgbm9ybWFsIHZlY3RvciBwZXJwZW5kaWN1bGFyIHRvIHRoZSBmaXJzdCB0YW5nZW50IHZlY3RvcixcbiAgICBcdFx0Ly8gYW5kIGluIHRoZSBkaXJlY3Rpb24gb2YgdGhlIHNtYWxsZXN0IHRhbmdlbnQgeHl6IGNvbXBvbmVudFxuXG4gICAgXHRcdG5vcm1hbHNbIDAgXSA9IG5ldyBWZWN0b3IzKCk7XG4gICAgXHRcdGJpbm9ybWFsc1sgMCBdID0gbmV3IFZlY3RvcjMoKTtcbiAgICBcdFx0c21hbGxlc3QgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgIFx0XHR0eCA9IE1hdGguYWJzKCB0YW5nZW50c1sgMCBdLnggKTtcbiAgICBcdFx0dHkgPSBNYXRoLmFicyggdGFuZ2VudHNbIDAgXS55ICk7XG4gICAgXHRcdHR6ID0gTWF0aC5hYnMoIHRhbmdlbnRzWyAwIF0ueiApO1xuXG4gICAgXHRcdGlmICggdHggPD0gc21hbGxlc3QgKSB7XG5cbiAgICBcdFx0XHRzbWFsbGVzdCA9IHR4O1xuICAgIFx0XHRcdG5vcm1hbC5zZXQoIDEsIDAsIDAgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKCB0eSA8PSBzbWFsbGVzdCApIHtcblxuICAgIFx0XHRcdHNtYWxsZXN0ID0gdHk7XG4gICAgXHRcdFx0bm9ybWFsLnNldCggMCwgMSwgMCApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoIHR6IDw9IHNtYWxsZXN0ICkge1xuXG4gICAgXHRcdFx0bm9ybWFsLnNldCggMCwgMCwgMSApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHR2ZWMuY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgMCBdLCBub3JtYWwgKS5ub3JtYWxpemUoKTtcblxuICAgIFx0XHRub3JtYWxzWyAwIF0uY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgMCBdLCB2ZWMgKTtcbiAgICBcdFx0Ymlub3JtYWxzWyAwIF0uY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgMCBdLCBub3JtYWxzWyAwIF0gKTtcblxuICAgIFx0fVxuXG5cbiAgICBcdC8vIGNvbXB1dGUgdGhlIHNsb3dseS12YXJ5aW5nIG5vcm1hbCBhbmQgYmlub3JtYWwgdmVjdG9ycyBmb3IgZWFjaCBzZWdtZW50IG9uIHRoZSBwYXRoXG5cbiAgICBcdGZvciAoIGkgPSAxOyBpIDwgbnVtcG9pbnRzOyBpICsrICkge1xuXG4gICAgXHRcdG5vcm1hbHNbIGkgXSA9IG5vcm1hbHNbIGkgLSAxIF0uY2xvbmUoKTtcblxuICAgIFx0XHRiaW5vcm1hbHNbIGkgXSA9IGJpbm9ybWFsc1sgaSAtIDEgXS5jbG9uZSgpO1xuXG4gICAgXHRcdHZlYy5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyBpIC0gMSBdLCB0YW5nZW50c1sgaSBdICk7XG5cbiAgICBcdFx0aWYgKCB2ZWMubGVuZ3RoKCkgPiBOdW1iZXIuRVBTSUxPTiApIHtcblxuICAgIFx0XHRcdHZlYy5ub3JtYWxpemUoKTtcblxuICAgIFx0XHRcdHRoZXRhID0gTWF0aC5hY29zKCBleHBvcnRzLk1hdGguY2xhbXAoIHRhbmdlbnRzWyBpIC0gMSBdLmRvdCggdGFuZ2VudHNbIGkgXSApLCAtIDEsIDEgKSApOyAvLyBjbGFtcCBmb3IgZmxvYXRpbmcgcHQgZXJyb3JzXG5cbiAgICBcdFx0XHRub3JtYWxzWyBpIF0uYXBwbHlNYXRyaXg0KCBtYXQubWFrZVJvdGF0aW9uQXhpcyggdmVjLCB0aGV0YSApICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGJpbm9ybWFsc1sgaSBdLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIGkgXSwgbm9ybWFsc1sgaSBdICk7XG5cbiAgICBcdH1cblxuXG4gICAgXHQvLyBpZiB0aGUgY3VydmUgaXMgY2xvc2VkLCBwb3N0cHJvY2VzcyB0aGUgdmVjdG9ycyBzbyB0aGUgZmlyc3QgYW5kIGxhc3Qgbm9ybWFsIHZlY3RvcnMgYXJlIHRoZSBzYW1lXG5cbiAgICBcdGlmICggY2xvc2VkICkge1xuXG4gICAgXHRcdHRoZXRhID0gTWF0aC5hY29zKCBleHBvcnRzLk1hdGguY2xhbXAoIG5vcm1hbHNbIDAgXS5kb3QoIG5vcm1hbHNbIG51bXBvaW50cyAtIDEgXSApLCAtIDEsIDEgKSApO1xuICAgIFx0XHR0aGV0YSAvPSAoIG51bXBvaW50cyAtIDEgKTtcblxuICAgIFx0XHRpZiAoIHRhbmdlbnRzWyAwIF0uZG90KCB2ZWMuY3Jvc3NWZWN0b3JzKCBub3JtYWxzWyAwIF0sIG5vcm1hbHNbIG51bXBvaW50cyAtIDEgXSApICkgPiAwICkge1xuXG4gICAgXHRcdFx0dGhldGEgPSAtIHRoZXRhO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRmb3IgKCBpID0gMTsgaSA8IG51bXBvaW50czsgaSArKyApIHtcblxuICAgIFx0XHRcdC8vIHR3aXN0IGEgbGl0dGxlLi4uXG4gICAgXHRcdFx0bm9ybWFsc1sgaSBdLmFwcGx5TWF0cml4NCggbWF0Lm1ha2VSb3RhdGlvbkF4aXMoIHRhbmdlbnRzWyBpIF0sIHRoZXRhICogaSApICk7XG4gICAgXHRcdFx0Ymlub3JtYWxzWyBpIF0uY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgaSBdLCBub3JtYWxzWyBpIF0gKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdH1cblxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIE11Z2VuODcgLyBodHRwczovL2dpdGh1Yi5jb20vTXVnZW44N1xuICAgICAqXG4gICAgICogc2VlOiBodHRwOi8vd3d3LmJsYWNrcGF3bi5jb20vdGV4dHMvcHF0b3J1cy9cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBUb3J1c0tub3RCdWZmZXJHZW9tZXRyeSggcmFkaXVzLCB0dWJlLCB0dWJ1bGFyU2VnbWVudHMsIHJhZGlhbFNlZ21lbnRzLCBwLCBxICkge1xuXG4gICAgXHRCdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cbiAgICBcdHRoaXMudHlwZSA9ICdUb3J1c0tub3RCdWZmZXJHZW9tZXRyeSc7XG5cbiAgICBcdHRoaXMucGFyYW1ldGVycyA9IHtcbiAgICBcdFx0cmFkaXVzOiByYWRpdXMsXG4gICAgXHRcdHR1YmU6IHR1YmUsXG4gICAgXHRcdHR1YnVsYXJTZWdtZW50czogdHVidWxhclNlZ21lbnRzLFxuICAgIFx0XHRyYWRpYWxTZWdtZW50czogcmFkaWFsU2VnbWVudHMsXG4gICAgXHRcdHA6IHAsXG4gICAgXHRcdHE6IHFcbiAgICBcdH07XG5cbiAgICBcdHJhZGl1cyA9IHJhZGl1cyB8fCAxMDA7XG4gICAgXHR0dWJlID0gdHViZSB8fCA0MDtcbiAgICBcdHR1YnVsYXJTZWdtZW50cyA9IE1hdGguZmxvb3IoIHR1YnVsYXJTZWdtZW50cyApIHx8IDY0O1xuICAgIFx0cmFkaWFsU2VnbWVudHMgPSBNYXRoLmZsb29yKCByYWRpYWxTZWdtZW50cyApIHx8IDg7XG4gICAgXHRwID0gcCB8fCAyO1xuICAgIFx0cSA9IHEgfHwgMztcblxuICAgIFx0Ly8gdXNlZCB0byBjYWxjdWxhdGUgYnVmZmVyIGxlbmd0aFxuICAgIFx0dmFyIHZlcnRleENvdW50ID0gKCAoIHJhZGlhbFNlZ21lbnRzICsgMSApICogKCB0dWJ1bGFyU2VnbWVudHMgKyAxICkgKTtcbiAgICBcdHZhciBpbmRleENvdW50ID0gcmFkaWFsU2VnbWVudHMgKiB0dWJ1bGFyU2VnbWVudHMgKiAyICogMztcblxuICAgIFx0Ly8gYnVmZmVyc1xuICAgIFx0dmFyIGluZGljZXMgPSBuZXcgQnVmZmVyQXR0cmlidXRlKCBuZXcgKCBpbmRleENvdW50ID4gNjU1MzUgPyBVaW50MzJBcnJheSA6IFVpbnQxNkFycmF5ICkoIGluZGV4Q291bnQgKSAsIDEgKTtcbiAgICBcdHZhciB2ZXJ0aWNlcyA9IG5ldyBCdWZmZXJBdHRyaWJ1dGUoIG5ldyBGbG9hdDMyQXJyYXkoIHZlcnRleENvdW50ICogMyApLCAzICk7XG4gICAgXHR2YXIgbm9ybWFscyA9IG5ldyBCdWZmZXJBdHRyaWJ1dGUoIG5ldyBGbG9hdDMyQXJyYXkoIHZlcnRleENvdW50ICogMyApLCAzICk7XG4gICAgXHR2YXIgdXZzID0gbmV3IEJ1ZmZlckF0dHJpYnV0ZSggbmV3IEZsb2F0MzJBcnJheSggdmVydGV4Q291bnQgKiAyICksIDIgKTtcblxuICAgIFx0Ly8gaGVscGVyIHZhcmlhYmxlc1xuICAgIFx0dmFyIGksIGosIGluZGV4ID0gMCwgaW5kZXhPZmZzZXQgPSAwO1xuXG4gICAgXHR2YXIgdmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcbiAgICBcdHZhciBub3JtYWwgPSBuZXcgVmVjdG9yMygpO1xuICAgIFx0dmFyIHV2ID0gbmV3IFZlY3RvcjIoKTtcblxuICAgIFx0dmFyIFAxID0gbmV3IFZlY3RvcjMoKTtcbiAgICBcdHZhciBQMiA9IG5ldyBWZWN0b3IzKCk7XG5cbiAgICBcdHZhciBCID0gbmV3IFZlY3RvcjMoKTtcbiAgICBcdHZhciBUID0gbmV3IFZlY3RvcjMoKTtcbiAgICBcdHZhciBOID0gbmV3IFZlY3RvcjMoKTtcblxuICAgIFx0Ly8gZ2VuZXJhdGUgdmVydGljZXMsIG5vcm1hbHMgYW5kIHV2c1xuXG4gICAgXHRmb3IgKCBpID0gMDsgaSA8PSB0dWJ1bGFyU2VnbWVudHM7ICsrIGkgKSB7XG5cbiAgICBcdFx0Ly8gdGhlIHJhZGlhbiBcInVcIiBpcyB1c2VkIHRvIGNhbGN1bGF0ZSB0aGUgcG9zaXRpb24gb24gdGhlIHRvcnVzIGN1cnZlIG9mIHRoZSBjdXJyZW50IHR1YnVsYXIgc2VnZW1lbnRcblxuICAgIFx0XHR2YXIgdSA9IGkgLyB0dWJ1bGFyU2VnbWVudHMgKiBwICogTWF0aC5QSSAqIDI7XG5cbiAgICBcdFx0Ly8gbm93IHdlIGNhbGN1bGF0ZSB0d28gcG9pbnRzLiBQMSBpcyBvdXIgY3VycmVudCBwb3NpdGlvbiBvbiB0aGUgY3VydmUsIFAyIGlzIGEgbGl0dGxlIGZhcnRoZXIgYWhlYWQuXG4gICAgXHRcdC8vIHRoZXNlIHBvaW50cyBhcmUgdXNlZCB0byBjcmVhdGUgYSBzcGVjaWFsIFwiY29vcmRpbmF0ZSBzcGFjZVwiLCB3aGljaCBpcyBuZWNlc3NhcnkgdG8gY2FsY3VsYXRlIHRoZSBjb3JyZWN0IHZlcnRleCBwb3NpdGlvbnNcblxuICAgIFx0XHRjYWxjdWxhdGVQb3NpdGlvbk9uQ3VydmUoIHUsIHAsIHEsIHJhZGl1cywgUDEgKTtcbiAgICBcdFx0Y2FsY3VsYXRlUG9zaXRpb25PbkN1cnZlKCB1ICsgMC4wMSwgcCwgcSwgcmFkaXVzLCBQMiApO1xuXG4gICAgXHRcdC8vIGNhbGN1bGF0ZSBvcnRob25vcm1hbCBiYXNpc1xuXG4gICAgXHRcdFQuc3ViVmVjdG9ycyggUDIsIFAxICk7XG4gICAgXHRcdE4uYWRkVmVjdG9ycyggUDIsIFAxICk7XG4gICAgXHRcdEIuY3Jvc3NWZWN0b3JzKCBULCBOICk7XG4gICAgXHRcdE4uY3Jvc3NWZWN0b3JzKCBCLCBUICk7XG5cbiAgICBcdFx0Ly8gbm9ybWFsaXplIEIsIE4uIFQgY2FuIGJlIGlnbm9yZWQsIHdlIGRvbid0IHVzZSBpdFxuXG4gICAgXHRcdEIubm9ybWFsaXplKCk7XG4gICAgXHRcdE4ubm9ybWFsaXplKCk7XG5cbiAgICBcdFx0Zm9yICggaiA9IDA7IGogPD0gcmFkaWFsU2VnbWVudHM7ICsrIGogKSB7XG5cbiAgICBcdFx0XHQvLyBub3cgY2FsY3VsYXRlIHRoZSB2ZXJ0aWNlcy4gdGhleSBhcmUgbm90aGluZyBtb3JlIHRoYW4gYW4gZXh0cnVzaW9uIG9mIHRoZSB0b3J1cyBjdXJ2ZS5cbiAgICBcdFx0XHQvLyBiZWNhdXNlIHdlIGV4dHJ1ZGUgYSBzaGFwZSBpbiB0aGUgeHktcGxhbmUsIHRoZXJlIGlzIG5vIG5lZWQgdG8gY2FsY3VsYXRlIGEgei12YWx1ZS5cblxuICAgIFx0XHRcdHZhciB2ID0gaiAvIHJhZGlhbFNlZ21lbnRzICogTWF0aC5QSSAqIDI7XG4gICAgXHRcdFx0dmFyIGN4ID0gLSB0dWJlICogTWF0aC5jb3MoIHYgKTtcbiAgICBcdFx0XHR2YXIgY3kgPSB0dWJlICogTWF0aC5zaW4oIHYgKTtcblxuICAgIFx0XHRcdC8vIG5vdyBjYWxjdWxhdGUgdGhlIGZpbmFsIHZlcnRleCBwb3NpdGlvbi5cbiAgICBcdFx0XHQvLyBmaXJzdCB3ZSBvcmllbnQgdGhlIGV4dHJ1c2lvbiB3aXRoIG91ciBiYXNpcyB2ZWN0b3MsIHRoZW4gd2UgYWRkIGl0IHRvIHRoZSBjdXJyZW50IHBvc2l0aW9uIG9uIHRoZSBjdXJ2ZVxuXG4gICAgXHRcdFx0dmVydGV4LnggPSBQMS54ICsgKCBjeCAqIE4ueCArIGN5ICogQi54ICk7XG4gICAgXHRcdFx0dmVydGV4LnkgPSBQMS55ICsgKCBjeCAqIE4ueSArIGN5ICogQi55ICk7XG4gICAgXHRcdFx0dmVydGV4LnogPSBQMS56ICsgKCBjeCAqIE4ueiArIGN5ICogQi56ICk7XG5cbiAgICBcdFx0XHQvLyB2ZXJ0ZXhcbiAgICBcdFx0XHR2ZXJ0aWNlcy5zZXRYWVooIGluZGV4LCB2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56ICk7XG5cbiAgICBcdFx0XHQvLyBub3JtYWwgKFAxIGlzIGFsd2F5cyB0aGUgY2VudGVyL29yaWdpbiBvZiB0aGUgZXh0cnVzaW9uLCB0aHVzIHdlIGNhbiB1c2UgaXQgdG8gY2FsY3VsYXRlIHRoZSBub3JtYWwpXG4gICAgXHRcdFx0bm9ybWFsLnN1YlZlY3RvcnMoIHZlcnRleCwgUDEgKS5ub3JtYWxpemUoKTtcbiAgICBcdFx0XHRub3JtYWxzLnNldFhZWiggaW5kZXgsIG5vcm1hbC54LCBub3JtYWwueSwgbm9ybWFsLnogKTtcblxuICAgIFx0XHRcdC8vIHV2XG4gICAgXHRcdFx0dXYueCA9IGkgLyB0dWJ1bGFyU2VnbWVudHM7XG4gICAgXHRcdFx0dXYueSA9IGogLyByYWRpYWxTZWdtZW50cztcbiAgICBcdFx0XHR1dnMuc2V0WFkoIGluZGV4LCB1di54LCB1di55ICk7XG5cbiAgICBcdFx0XHQvLyBpbmNyZWFzZSBpbmRleFxuICAgIFx0XHRcdGluZGV4ICsrO1xuXG4gICAgXHRcdH1cblxuICAgIFx0fVxuXG4gICAgXHQvLyBnZW5lcmF0ZSBpbmRpY2VzXG5cbiAgICBcdGZvciAoIGogPSAxOyBqIDw9IHR1YnVsYXJTZWdtZW50czsgaiArKyApIHtcblxuICAgIFx0XHRmb3IgKCBpID0gMTsgaSA8PSByYWRpYWxTZWdtZW50czsgaSArKyApIHtcblxuICAgIFx0XHRcdC8vIGluZGljZXNcbiAgICBcdFx0XHR2YXIgYSA9ICggcmFkaWFsU2VnbWVudHMgKyAxICkgKiAoIGogLSAxICkgKyAoIGkgLSAxICk7XG4gICAgXHRcdFx0dmFyIGIgPSAoIHJhZGlhbFNlZ21lbnRzICsgMSApICogaiArICggaSAtIDEgKTtcbiAgICBcdFx0XHR2YXIgYyA9ICggcmFkaWFsU2VnbWVudHMgKyAxICkgKiBqICsgaTtcbiAgICBcdFx0XHR2YXIgZCA9ICggcmFkaWFsU2VnbWVudHMgKyAxICkgKiAoIGogLSAxICkgKyBpO1xuXG4gICAgXHRcdFx0Ly8gZmFjZSBvbmVcbiAgICBcdFx0XHRpbmRpY2VzLnNldFgoIGluZGV4T2Zmc2V0LCBhICk7IGluZGV4T2Zmc2V0Kys7XG4gICAgXHRcdFx0aW5kaWNlcy5zZXRYKCBpbmRleE9mZnNldCwgYiApOyBpbmRleE9mZnNldCsrO1xuICAgIFx0XHRcdGluZGljZXMuc2V0WCggaW5kZXhPZmZzZXQsIGQgKTsgaW5kZXhPZmZzZXQrKztcblxuICAgIFx0XHRcdC8vIGZhY2UgdHdvXG4gICAgXHRcdFx0aW5kaWNlcy5zZXRYKCBpbmRleE9mZnNldCwgYiApOyBpbmRleE9mZnNldCsrO1xuICAgIFx0XHRcdGluZGljZXMuc2V0WCggaW5kZXhPZmZzZXQsIGMgKTsgaW5kZXhPZmZzZXQrKztcbiAgICBcdFx0XHRpbmRpY2VzLnNldFgoIGluZGV4T2Zmc2V0LCBkICk7IGluZGV4T2Zmc2V0Kys7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9XG5cbiAgICBcdC8vIGJ1aWxkIGdlb21ldHJ5XG5cbiAgICBcdHRoaXMuc2V0SW5kZXgoIGluZGljZXMgKTtcbiAgICBcdHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCB2ZXJ0aWNlcyApO1xuICAgIFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdub3JtYWwnLCBub3JtYWxzICk7XG4gICAgXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3V2JywgdXZzICk7XG5cbiAgICBcdC8vIHRoaXMgZnVuY3Rpb24gY2FsY3VsYXRlcyB0aGUgY3VycmVudCBwb3NpdGlvbiBvbiB0aGUgdG9ydXMgY3VydmVcblxuICAgIFx0ZnVuY3Rpb24gY2FsY3VsYXRlUG9zaXRpb25PbkN1cnZlKCB1LCBwLCBxLCByYWRpdXMsIHBvc2l0aW9uICkge1xuXG4gICAgXHRcdHZhciBjdSA9IE1hdGguY29zKCB1ICk7XG4gICAgXHRcdHZhciBzdSA9IE1hdGguc2luKCB1ICk7XG4gICAgXHRcdHZhciBxdU92ZXJQID0gcSAvIHAgKiB1O1xuICAgIFx0XHR2YXIgY3MgPSBNYXRoLmNvcyggcXVPdmVyUCApO1xuXG4gICAgXHRcdHBvc2l0aW9uLnggPSByYWRpdXMgKiAoIDIgKyBjcyApICogMC41ICogY3U7XG4gICAgXHRcdHBvc2l0aW9uLnkgPSByYWRpdXMgKiAoIDIgKyBjcyApICogc3UgKiAwLjU7XG4gICAgXHRcdHBvc2l0aW9uLnogPSByYWRpdXMgKiBNYXRoLnNpbiggcXVPdmVyUCApICogMC41O1xuXG4gICAgXHR9XG5cbiAgICB9XG5cbiAgICBUb3J1c0tub3RCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcbiAgICBUb3J1c0tub3RCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUb3J1c0tub3RCdWZmZXJHZW9tZXRyeTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3Igb29zbW94aWVjb2RlXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBUb3J1c0tub3RHZW9tZXRyeSggcmFkaXVzLCB0dWJlLCB0dWJ1bGFyU2VnbWVudHMsIHJhZGlhbFNlZ21lbnRzLCBwLCBxLCBoZWlnaHRTY2FsZSApIHtcblxuICAgIFx0R2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG4gICAgXHR0aGlzLnR5cGUgPSAnVG9ydXNLbm90R2VvbWV0cnknO1xuXG4gICAgXHR0aGlzLnBhcmFtZXRlcnMgPSB7XG4gICAgXHRcdHJhZGl1czogcmFkaXVzLFxuICAgIFx0XHR0dWJlOiB0dWJlLFxuICAgIFx0XHR0dWJ1bGFyU2VnbWVudHM6IHR1YnVsYXJTZWdtZW50cyxcbiAgICBcdFx0cmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxuICAgIFx0XHRwOiBwLFxuICAgIFx0XHRxOiBxXG4gICAgXHR9O1xuXG4gICAgXHRpZiggaGVpZ2h0U2NhbGUgIT09IHVuZGVmaW5lZCApIGNvbnNvbGUud2FybiggJ1RIUkVFLlRvcnVzS25vdEdlb21ldHJ5OiBoZWlnaHRTY2FsZSBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgLnNjYWxlKCB4LCB5LCB6ICkgaW5zdGVhZC4nICk7XG5cbiAgICBcdHRoaXMuZnJvbUJ1ZmZlckdlb21ldHJ5KCBuZXcgVG9ydXNLbm90QnVmZmVyR2VvbWV0cnkoIHJhZGl1cywgdHViZSwgdHVidWxhclNlZ21lbnRzLCByYWRpYWxTZWdtZW50cywgcCwgcSApICk7XG4gICAgXHR0aGlzLm1lcmdlVmVydGljZXMoKTtcblxuICAgIH1cblxuICAgIFRvcnVzS25vdEdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEdlb21ldHJ5LnByb3RvdHlwZSApO1xuICAgIFRvcnVzS25vdEdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRvcnVzS25vdEdlb21ldHJ5O1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBNdWdlbjg3IC8gaHR0cHM6Ly9naXRodWIuY29tL011Z2VuODdcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIFRvcnVzQnVmZmVyR2VvbWV0cnkoIHJhZGl1cywgdHViZSwgcmFkaWFsU2VnbWVudHMsIHR1YnVsYXJTZWdtZW50cywgYXJjICkge1xuXG4gICAgXHRCdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cbiAgICBcdHRoaXMudHlwZSA9ICdUb3J1c0J1ZmZlckdlb21ldHJ5JztcblxuICAgIFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuICAgIFx0XHRyYWRpdXM6IHJhZGl1cyxcbiAgICBcdFx0dHViZTogdHViZSxcbiAgICBcdFx0cmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxuICAgIFx0XHR0dWJ1bGFyU2VnbWVudHM6IHR1YnVsYXJTZWdtZW50cyxcbiAgICBcdFx0YXJjOiBhcmNcbiAgICBcdH07XG5cbiAgICBcdHJhZGl1cyA9IHJhZGl1cyB8fCAxMDA7XG4gICAgXHR0dWJlID0gdHViZSB8fCA0MDtcbiAgICBcdHJhZGlhbFNlZ21lbnRzID0gTWF0aC5mbG9vciggcmFkaWFsU2VnbWVudHMgKSB8fCA4O1xuICAgIFx0dHVidWxhclNlZ21lbnRzID0gTWF0aC5mbG9vciggdHVidWxhclNlZ21lbnRzICkgfHwgNjtcbiAgICBcdGFyYyA9IGFyYyB8fCBNYXRoLlBJICogMjtcblxuICAgIFx0Ly8gdXNlZCB0byBjYWxjdWxhdGUgYnVmZmVyIGxlbmd0aFxuICAgIFx0dmFyIHZlcnRleENvdW50ID0gKCAoIHJhZGlhbFNlZ21lbnRzICsgMSApICogKCB0dWJ1bGFyU2VnbWVudHMgKyAxICkgKTtcbiAgICBcdHZhciBpbmRleENvdW50ID0gcmFkaWFsU2VnbWVudHMgKiB0dWJ1bGFyU2VnbWVudHMgKiAyICogMztcblxuICAgIFx0Ly8gYnVmZmVyc1xuICAgIFx0dmFyIGluZGljZXMgPSBuZXcgKCBpbmRleENvdW50ID4gNjU1MzUgPyBVaW50MzJBcnJheSA6IFVpbnQxNkFycmF5ICkoIGluZGV4Q291bnQgKTtcbiAgICBcdHZhciB2ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIHZlcnRleENvdW50ICogMyApO1xuICAgIFx0dmFyIG5vcm1hbHMgPSBuZXcgRmxvYXQzMkFycmF5KCB2ZXJ0ZXhDb3VudCAqIDMgKTtcbiAgICBcdHZhciB1dnMgPSBuZXcgRmxvYXQzMkFycmF5KCB2ZXJ0ZXhDb3VudCAqIDIgKTtcblxuICAgIFx0Ly8gb2Zmc2V0IHZhcmlhYmxlc1xuICAgIFx0dmFyIHZlcnRleEJ1ZmZlck9mZnNldCA9IDA7XG4gICAgXHR2YXIgdXZCdWZmZXJPZmZzZXQgPSAwO1xuICAgIFx0dmFyIGluZGV4QnVmZmVyT2Zmc2V0ID0gMDtcblxuICAgIFx0Ly8gaGVscGVyIHZhcmlhYmxlc1xuICAgIFx0dmFyIGNlbnRlciA9IG5ldyBWZWN0b3IzKCk7XG4gICAgXHR2YXIgdmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcbiAgICBcdHZhciBub3JtYWwgPSBuZXcgVmVjdG9yMygpO1xuXG4gICAgXHR2YXIgaiwgaTtcblxuICAgIFx0Ly8gZ2VuZXJhdGUgdmVydGljZXMsIG5vcm1hbHMgYW5kIHV2c1xuXG4gICAgXHRmb3IgKCBqID0gMDsgaiA8PSByYWRpYWxTZWdtZW50czsgaiArKyApIHtcblxuICAgIFx0XHRmb3IgKCBpID0gMDsgaSA8PSB0dWJ1bGFyU2VnbWVudHM7IGkgKysgKSB7XG5cbiAgICBcdFx0XHR2YXIgdSA9IGkgLyB0dWJ1bGFyU2VnbWVudHMgKiBhcmM7XG4gICAgXHRcdFx0dmFyIHYgPSBqIC8gcmFkaWFsU2VnbWVudHMgKiBNYXRoLlBJICogMjtcblxuICAgIFx0XHRcdC8vIHZlcnRleFxuICAgIFx0XHRcdHZlcnRleC54ID0gKCByYWRpdXMgKyB0dWJlICogTWF0aC5jb3MoIHYgKSApICogTWF0aC5jb3MoIHUgKTtcbiAgICBcdFx0XHR2ZXJ0ZXgueSA9ICggcmFkaXVzICsgdHViZSAqIE1hdGguY29zKCB2ICkgKSAqIE1hdGguc2luKCB1ICk7XG4gICAgXHRcdFx0dmVydGV4LnogPSB0dWJlICogTWF0aC5zaW4oIHYgKTtcblxuICAgIFx0XHRcdHZlcnRpY2VzWyB2ZXJ0ZXhCdWZmZXJPZmZzZXQgXSA9IHZlcnRleC54O1xuICAgIFx0XHRcdHZlcnRpY2VzWyB2ZXJ0ZXhCdWZmZXJPZmZzZXQgKyAxIF0gPSB2ZXJ0ZXgueTtcbiAgICBcdFx0XHR2ZXJ0aWNlc1sgdmVydGV4QnVmZmVyT2Zmc2V0ICsgMiBdID0gdmVydGV4Lno7XG5cbiAgICBcdFx0XHQvLyB0aGlzIHZlY3RvciBpcyB1c2VkIHRvIGNhbGN1bGF0ZSB0aGUgbm9ybWFsXG4gICAgXHRcdFx0Y2VudGVyLnggPSByYWRpdXMgKiBNYXRoLmNvcyggdSApO1xuICAgIFx0XHRcdGNlbnRlci55ID0gcmFkaXVzICogTWF0aC5zaW4oIHUgKTtcblxuICAgIFx0XHRcdC8vIG5vcm1hbFxuICAgIFx0XHRcdG5vcm1hbC5zdWJWZWN0b3JzKCB2ZXJ0ZXgsIGNlbnRlciApLm5vcm1hbGl6ZSgpO1xuXG4gICAgXHRcdFx0bm9ybWFsc1sgdmVydGV4QnVmZmVyT2Zmc2V0IF0gPSBub3JtYWwueDtcbiAgICBcdFx0XHRub3JtYWxzWyB2ZXJ0ZXhCdWZmZXJPZmZzZXQgKyAxIF0gPSBub3JtYWwueTtcbiAgICBcdFx0XHRub3JtYWxzWyB2ZXJ0ZXhCdWZmZXJPZmZzZXQgKyAyIF0gPSBub3JtYWwuejtcblxuICAgIFx0XHRcdC8vIHV2XG4gICAgXHRcdFx0dXZzWyB1dkJ1ZmZlck9mZnNldCBdID0gaSAvIHR1YnVsYXJTZWdtZW50cztcbiAgICBcdFx0XHR1dnNbIHV2QnVmZmVyT2Zmc2V0ICsgMSBdID0gaiAvIHJhZGlhbFNlZ21lbnRzO1xuXG4gICAgXHRcdFx0Ly8gdXBkYXRlIG9mZnNldHNcbiAgICBcdFx0XHR2ZXJ0ZXhCdWZmZXJPZmZzZXQgKz0gMztcbiAgICBcdFx0XHR1dkJ1ZmZlck9mZnNldCArPSAyO1xuXG4gICAgXHRcdH1cblxuICAgIFx0fVxuXG4gICAgXHQvLyBnZW5lcmF0ZSBpbmRpY2VzXG5cbiAgICBcdGZvciAoIGogPSAxOyBqIDw9IHJhZGlhbFNlZ21lbnRzOyBqICsrICkge1xuXG4gICAgXHRcdGZvciAoIGkgPSAxOyBpIDw9IHR1YnVsYXJTZWdtZW50czsgaSArKyApIHtcblxuICAgIFx0XHRcdC8vIGluZGljZXNcbiAgICBcdFx0XHR2YXIgYSA9ICggdHVidWxhclNlZ21lbnRzICsgMSApICogaiArIGkgLSAxO1xuICAgIFx0XHRcdHZhciBiID0gKCB0dWJ1bGFyU2VnbWVudHMgKyAxICkgKiAoIGogLSAxICkgKyBpIC0gMTtcbiAgICBcdFx0XHR2YXIgYyA9ICggdHVidWxhclNlZ21lbnRzICsgMSApICogKCBqIC0gMSApICsgaTtcbiAgICBcdFx0XHR2YXIgZCA9ICggdHVidWxhclNlZ21lbnRzICsgMSApICogaiArIGk7XG5cbiAgICBcdFx0XHQvLyBmYWNlIG9uZVxuICAgIFx0XHRcdGluZGljZXNbIGluZGV4QnVmZmVyT2Zmc2V0IF0gPSBhO1xuICAgIFx0XHRcdGluZGljZXNbIGluZGV4QnVmZmVyT2Zmc2V0ICsgMSBdID0gYjtcbiAgICBcdFx0XHRpbmRpY2VzWyBpbmRleEJ1ZmZlck9mZnNldCArIDIgXSA9IGQ7XG5cbiAgICBcdFx0XHQvLyBmYWNlIHR3b1xuICAgIFx0XHRcdGluZGljZXNbIGluZGV4QnVmZmVyT2Zmc2V0ICsgMyBdID0gYjtcbiAgICBcdFx0XHRpbmRpY2VzWyBpbmRleEJ1ZmZlck9mZnNldCArIDQgXSA9IGM7XG4gICAgXHRcdFx0aW5kaWNlc1sgaW5kZXhCdWZmZXJPZmZzZXQgKyA1IF0gPSBkO1xuXG4gICAgXHRcdFx0Ly8gdXBkYXRlIG9mZnNldFxuICAgIFx0XHRcdGluZGV4QnVmZmVyT2Zmc2V0ICs9IDY7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9XG5cbiAgICBcdC8vIGJ1aWxkIGdlb21ldHJ5XG4gICAgXHR0aGlzLnNldEluZGV4KCBuZXcgQnVmZmVyQXR0cmlidXRlKCBpbmRpY2VzLCAxICkgKTtcbiAgICBcdHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XG4gICAgXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKSApO1xuICAgIFx0dGhpcy5hZGRBdHRyaWJ1dGUoICd1dicsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIHV2cywgMiApICk7XG5cbiAgICB9XG5cbiAgICBUb3J1c0J1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xuICAgIFRvcnVzQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVG9ydXNCdWZmZXJHZW9tZXRyeTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3Igb29zbW94aWVjb2RlXG4gICAgICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAgICAgKiBiYXNlZCBvbiBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvYXdheTNkL3NvdXJjZS9icm93c2UvdHJ1bmsvZnAxMC9Bd2F5M0RMaXRlL3NyYy9hd2F5M2RsaXRlL3ByaW1pdGl2ZXMvVG9ydXMuYXM/cj0yODg4XG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBUb3J1c0dlb21ldHJ5KCByYWRpdXMsIHR1YmUsIHJhZGlhbFNlZ21lbnRzLCB0dWJ1bGFyU2VnbWVudHMsIGFyYyApIHtcblxuICAgIFx0R2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG4gICAgXHR0aGlzLnR5cGUgPSAnVG9ydXNHZW9tZXRyeSc7XG5cbiAgICBcdHRoaXMucGFyYW1ldGVycyA9IHtcbiAgICBcdFx0cmFkaXVzOiByYWRpdXMsXG4gICAgXHRcdHR1YmU6IHR1YmUsXG4gICAgXHRcdHJhZGlhbFNlZ21lbnRzOiByYWRpYWxTZWdtZW50cyxcbiAgICBcdFx0dHVidWxhclNlZ21lbnRzOiB0dWJ1bGFyU2VnbWVudHMsXG4gICAgXHRcdGFyYzogYXJjXG4gICAgXHR9O1xuXG4gICAgXHR0aGlzLmZyb21CdWZmZXJHZW9tZXRyeSggbmV3IFRvcnVzQnVmZmVyR2VvbWV0cnkoIHJhZGl1cywgdHViZSwgcmFkaWFsU2VnbWVudHMsIHR1YnVsYXJTZWdtZW50cywgYXJjICkgKTtcblxuICAgIH1cblxuICAgIFRvcnVzR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggR2VvbWV0cnkucHJvdG90eXBlICk7XG4gICAgVG9ydXNHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUb3J1c0dlb21ldHJ5O1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xuICAgICAqL1xuXG4gICAgZXhwb3J0cy5TaGFwZVV0aWxzID0ge1xuXG4gICAgXHQvLyBjYWxjdWxhdGUgYXJlYSBvZiB0aGUgY29udG91ciBwb2x5Z29uXG5cbiAgICBcdGFyZWE6IGZ1bmN0aW9uICggY29udG91ciApIHtcblxuICAgIFx0XHR2YXIgbiA9IGNvbnRvdXIubGVuZ3RoO1xuICAgIFx0XHR2YXIgYSA9IDAuMDtcblxuICAgIFx0XHRmb3IgKCB2YXIgcCA9IG4gLSAxLCBxID0gMDsgcSA8IG47IHAgPSBxICsrICkge1xuXG4gICAgXHRcdFx0YSArPSBjb250b3VyWyBwIF0ueCAqIGNvbnRvdXJbIHEgXS55IC0gY29udG91clsgcSBdLnggKiBjb250b3VyWyBwIF0ueTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIGEgKiAwLjU7XG5cbiAgICBcdH0sXG5cbiAgICBcdHRyaWFuZ3VsYXRlOiAoIGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHQvKipcbiAgICBcdFx0ICogVGhpcyBjb2RlIGlzIGEgcXVpY2sgcG9ydCBvZiBjb2RlIHdyaXR0ZW4gaW4gQysrIHdoaWNoIHdhcyBzdWJtaXR0ZWQgdG9cbiAgICBcdFx0ICogZmxpcGNvZGUuY29tIGJ5IEpvaG4gVy4gUmF0Y2xpZmYgIC8vIEp1bHkgMjIsIDIwMDBcbiAgICBcdFx0ICogU2VlIG9yaWdpbmFsIGNvZGUgYW5kIG1vcmUgaW5mb3JtYXRpb24gaGVyZTpcbiAgICBcdFx0ICogaHR0cDovL3d3dy5mbGlwY29kZS5jb20vYXJjaGl2ZXMvRWZmaWNpZW50X1BvbHlnb25fVHJpYW5ndWxhdGlvbi5zaHRtbFxuICAgIFx0XHQgKlxuICAgIFx0XHQgKiBwb3J0ZWQgdG8gYWN0aW9uc2NyaXB0IGJ5IFpldmFuIFJvc3NlclxuICAgIFx0XHQgKiB3d3cuYWN0aW9uc25pcHBldC5jb21cbiAgICBcdFx0ICpcbiAgICBcdFx0ICogcG9ydGVkIHRvIGphdmFzY3JpcHQgYnkgSm9zaHVhIEtvb1xuICAgIFx0XHQgKiBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXG4gICAgXHRcdCAqXG4gICAgXHRcdCAqL1xuXG4gICAgXHRcdGZ1bmN0aW9uIHNuaXAoIGNvbnRvdXIsIHUsIHYsIHcsIG4sIHZlcnRzICkge1xuXG4gICAgXHRcdFx0dmFyIHA7XG4gICAgXHRcdFx0dmFyIGF4LCBheSwgYngsIGJ5O1xuICAgIFx0XHRcdHZhciBjeCwgY3ksIHB4LCBweTtcblxuICAgIFx0XHRcdGF4ID0gY29udG91clsgdmVydHNbIHUgXSBdLng7XG4gICAgXHRcdFx0YXkgPSBjb250b3VyWyB2ZXJ0c1sgdSBdIF0ueTtcblxuICAgIFx0XHRcdGJ4ID0gY29udG91clsgdmVydHNbIHYgXSBdLng7XG4gICAgXHRcdFx0YnkgPSBjb250b3VyWyB2ZXJ0c1sgdiBdIF0ueTtcblxuICAgIFx0XHRcdGN4ID0gY29udG91clsgdmVydHNbIHcgXSBdLng7XG4gICAgXHRcdFx0Y3kgPSBjb250b3VyWyB2ZXJ0c1sgdyBdIF0ueTtcblxuICAgIFx0XHRcdGlmICggTnVtYmVyLkVQU0lMT04gPiAoICggKCBieCAtIGF4ICkgKiAoIGN5IC0gYXkgKSApIC0gKCAoIGJ5IC0gYXkgKSAqICggY3ggLSBheCApICkgKSApIHJldHVybiBmYWxzZTtcblxuICAgIFx0XHRcdHZhciBhWCwgYVksIGJYLCBiWSwgY1gsIGNZO1xuICAgIFx0XHRcdHZhciBhcHgsIGFweSwgYnB4LCBicHksIGNweCwgY3B5O1xuICAgIFx0XHRcdHZhciBjQ1JPU1NhcCwgYkNST1NTY3AsIGFDUk9TU2JwO1xuXG4gICAgXHRcdFx0YVggPSBjeCAtIGJ4OyAgYVkgPSBjeSAtIGJ5O1xuICAgIFx0XHRcdGJYID0gYXggLSBjeDsgIGJZID0gYXkgLSBjeTtcbiAgICBcdFx0XHRjWCA9IGJ4IC0gYXg7ICBjWSA9IGJ5IC0gYXk7XG5cbiAgICBcdFx0XHRmb3IgKCBwID0gMDsgcCA8IG47IHAgKysgKSB7XG5cbiAgICBcdFx0XHRcdHB4ID0gY29udG91clsgdmVydHNbIHAgXSBdLng7XG4gICAgXHRcdFx0XHRweSA9IGNvbnRvdXJbIHZlcnRzWyBwIF0gXS55O1xuXG4gICAgXHRcdFx0XHRpZiAoICggKCBweCA9PT0gYXggKSAmJiAoIHB5ID09PSBheSApICkgfHxcbiAgICBcdFx0XHRcdFx0ICggKCBweCA9PT0gYnggKSAmJiAoIHB5ID09PSBieSApICkgfHxcbiAgICBcdFx0XHRcdFx0ICggKCBweCA9PT0gY3ggKSAmJiAoIHB5ID09PSBjeSApICkgKVx0Y29udGludWU7XG5cbiAgICBcdFx0XHRcdGFweCA9IHB4IC0gYXg7ICBhcHkgPSBweSAtIGF5O1xuICAgIFx0XHRcdFx0YnB4ID0gcHggLSBieDsgIGJweSA9IHB5IC0gYnk7XG4gICAgXHRcdFx0XHRjcHggPSBweCAtIGN4OyAgY3B5ID0gcHkgLSBjeTtcblxuICAgIFx0XHRcdFx0Ly8gc2VlIGlmIHAgaXMgaW5zaWRlIHRyaWFuZ2xlIGFiY1xuXG4gICAgXHRcdFx0XHRhQ1JPU1NicCA9IGFYICogYnB5IC0gYVkgKiBicHg7XG4gICAgXHRcdFx0XHRjQ1JPU1NhcCA9IGNYICogYXB5IC0gY1kgKiBhcHg7XG4gICAgXHRcdFx0XHRiQ1JPU1NjcCA9IGJYICogY3B5IC0gYlkgKiBjcHg7XG5cbiAgICBcdFx0XHRcdGlmICggKCBhQ1JPU1NicCA+PSAtIE51bWJlci5FUFNJTE9OICkgJiYgKCBiQ1JPU1NjcCA+PSAtIE51bWJlci5FUFNJTE9OICkgJiYgKCBjQ1JPU1NhcCA+PSAtIE51bWJlci5FUFNJTE9OICkgKSByZXR1cm4gZmFsc2U7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRyZXR1cm4gdHJ1ZTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0Ly8gdGFrZXMgaW4gYW4gY29udG91ciBhcnJheSBhbmQgcmV0dXJuc1xuXG4gICAgXHRcdHJldHVybiBmdW5jdGlvbiB0cmlhbmd1bGF0ZSggY29udG91ciwgaW5kaWNlcyApIHtcblxuICAgIFx0XHRcdHZhciBuID0gY29udG91ci5sZW5ndGg7XG5cbiAgICBcdFx0XHRpZiAoIG4gPCAzICkgcmV0dXJuIG51bGw7XG5cbiAgICBcdFx0XHR2YXIgcmVzdWx0ID0gW10sXG4gICAgXHRcdFx0XHR2ZXJ0cyA9IFtdLFxuICAgIFx0XHRcdFx0dmVydEluZGljZXMgPSBbXTtcblxuICAgIFx0XHRcdC8qIHdlIHdhbnQgYSBjb3VudGVyLWNsb2Nrd2lzZSBwb2x5Z29uIGluIHZlcnRzICovXG5cbiAgICBcdFx0XHR2YXIgdSwgdiwgdztcblxuICAgIFx0XHRcdGlmICggZXhwb3J0cy5TaGFwZVV0aWxzLmFyZWEoIGNvbnRvdXIgKSA+IDAuMCApIHtcblxuICAgIFx0XHRcdFx0Zm9yICggdiA9IDA7IHYgPCBuOyB2ICsrICkgdmVydHNbIHYgXSA9IHY7XG5cbiAgICBcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRmb3IgKCB2ID0gMDsgdiA8IG47IHYgKysgKSB2ZXJ0c1sgdiBdID0gKCBuIC0gMSApIC0gdjtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdHZhciBudiA9IG47XG5cbiAgICBcdFx0XHQvKiAgcmVtb3ZlIG52IC0gMiB2ZXJ0aWNlcywgY3JlYXRpbmcgMSB0cmlhbmdsZSBldmVyeSB0aW1lICovXG5cbiAgICBcdFx0XHR2YXIgY291bnQgPSAyICogbnY7ICAgLyogZXJyb3IgZGV0ZWN0aW9uICovXG5cbiAgICBcdFx0XHRmb3IgKCB2ID0gbnYgLSAxOyBudiA+IDI7ICkge1xuXG4gICAgXHRcdFx0XHQvKiBpZiB3ZSBsb29wLCBpdCBpcyBwcm9iYWJseSBhIG5vbi1zaW1wbGUgcG9seWdvbiAqL1xuXG4gICAgXHRcdFx0XHRpZiAoICggY291bnQgLS0gKSA8PSAwICkge1xuXG4gICAgXHRcdFx0XHRcdC8vKiogVHJpYW5ndWxhdGU6IEVSUk9SIC0gcHJvYmFibGUgYmFkIHBvbHlnb24hXG5cbiAgICBcdFx0XHRcdFx0Ly90aHJvdyAoIFwiV2FybmluZywgdW5hYmxlIHRvIHRyaWFuZ3VsYXRlIHBvbHlnb24hXCIgKTtcbiAgICBcdFx0XHRcdFx0Ly9yZXR1cm4gbnVsbDtcbiAgICBcdFx0XHRcdFx0Ly8gU29tZXRpbWVzIHdhcm5pbmcgaXMgZmluZSwgZXNwZWNpYWxseSBwb2x5Z29ucyBhcmUgdHJpYW5ndWxhdGVkIGluIHJldmVyc2UuXG4gICAgXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlNoYXBlVXRpbHM6IFVuYWJsZSB0byB0cmlhbmd1bGF0ZSBwb2x5Z29uISBpbiB0cmlhbmd1bGF0ZSgpJyApO1xuXG4gICAgXHRcdFx0XHRcdGlmICggaW5kaWNlcyApIHJldHVybiB2ZXJ0SW5kaWNlcztcbiAgICBcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHQvKiB0aHJlZSBjb25zZWN1dGl2ZSB2ZXJ0aWNlcyBpbiBjdXJyZW50IHBvbHlnb24sIDx1LHYsdz4gKi9cblxuICAgIFx0XHRcdFx0dSA9IHY7IFx0IFx0aWYgKCBudiA8PSB1ICkgdSA9IDA7ICAgICAvKiBwcmV2aW91cyAqL1xuICAgIFx0XHRcdFx0diA9IHUgKyAxOyAgaWYgKCBudiA8PSB2ICkgdiA9IDA7ICAgICAvKiBuZXcgdiAgICAqL1xuICAgIFx0XHRcdFx0dyA9IHYgKyAxOyAgaWYgKCBudiA8PSB3ICkgdyA9IDA7ICAgICAvKiBuZXh0ICAgICAqL1xuXG4gICAgXHRcdFx0XHRpZiAoIHNuaXAoIGNvbnRvdXIsIHUsIHYsIHcsIG52LCB2ZXJ0cyApICkge1xuXG4gICAgXHRcdFx0XHRcdHZhciBhLCBiLCBjLCBzLCB0O1xuXG4gICAgXHRcdFx0XHRcdC8qIHRydWUgbmFtZXMgb2YgdGhlIHZlcnRpY2VzICovXG5cbiAgICBcdFx0XHRcdFx0YSA9IHZlcnRzWyB1IF07XG4gICAgXHRcdFx0XHRcdGIgPSB2ZXJ0c1sgdiBdO1xuICAgIFx0XHRcdFx0XHRjID0gdmVydHNbIHcgXTtcblxuICAgIFx0XHRcdFx0XHQvKiBvdXRwdXQgVHJpYW5nbGUgKi9cblxuICAgIFx0XHRcdFx0XHRyZXN1bHQucHVzaCggWyBjb250b3VyWyBhIF0sXG4gICAgXHRcdFx0XHRcdFx0Y29udG91clsgYiBdLFxuICAgIFx0XHRcdFx0XHRcdGNvbnRvdXJbIGMgXSBdICk7XG5cblxuICAgIFx0XHRcdFx0XHR2ZXJ0SW5kaWNlcy5wdXNoKCBbIHZlcnRzWyB1IF0sIHZlcnRzWyB2IF0sIHZlcnRzWyB3IF0gXSApO1xuXG4gICAgXHRcdFx0XHRcdC8qIHJlbW92ZSB2IGZyb20gdGhlIHJlbWFpbmluZyBwb2x5Z29uICovXG5cbiAgICBcdFx0XHRcdFx0Zm9yICggcyA9IHYsIHQgPSB2ICsgMTsgdCA8IG52OyBzICsrLCB0ICsrICkge1xuXG4gICAgXHRcdFx0XHRcdFx0dmVydHNbIHMgXSA9IHZlcnRzWyB0IF07XG5cbiAgICBcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRcdG52IC0tO1xuXG4gICAgXHRcdFx0XHRcdC8qIHJlc2V0IGVycm9yIGRldGVjdGlvbiBjb3VudGVyICovXG5cbiAgICBcdFx0XHRcdFx0Y291bnQgPSAyICogbnY7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGlmICggaW5kaWNlcyApIHJldHVybiB2ZXJ0SW5kaWNlcztcbiAgICBcdFx0XHRyZXR1cm4gcmVzdWx0O1xuXG4gICAgXHRcdH1cblxuICAgIFx0fSApKCksXG5cbiAgICBcdHRyaWFuZ3VsYXRlU2hhcGU6IGZ1bmN0aW9uICggY29udG91ciwgaG9sZXMgKSB7XG5cbiAgICBcdFx0ZnVuY3Rpb24gcmVtb3ZlRHVwRW5kUHRzKHBvaW50cykge1xuXG4gICAgXHRcdFx0dmFyIGwgPSBwb2ludHMubGVuZ3RoO1xuXG4gICAgXHRcdFx0aWYgKCBsID4gMiAmJiBwb2ludHNbIGwgLSAxIF0uZXF1YWxzKCBwb2ludHNbIDAgXSApICkge1xuXG4gICAgXHRcdFx0XHRwb2ludHMucG9wKCk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJlbW92ZUR1cEVuZFB0cyggY29udG91ciApO1xuICAgIFx0XHRob2xlcy5mb3JFYWNoKCByZW1vdmVEdXBFbmRQdHMgKTtcblxuICAgIFx0XHRmdW5jdGlvbiBwb2ludF9pbl9zZWdtZW50XzJEX2NvbGluKCBpblNlZ1B0MSwgaW5TZWdQdDIsIGluT3RoZXJQdCApIHtcblxuICAgIFx0XHRcdC8vIGluT3RoZXJQdCBuZWVkcyB0byBiZSBjb2xsaW5lYXIgdG8gdGhlIGluU2VnbWVudFxuICAgIFx0XHRcdGlmICggaW5TZWdQdDEueCAhPT0gaW5TZWdQdDIueCApIHtcblxuICAgIFx0XHRcdFx0aWYgKCBpblNlZ1B0MS54IDwgaW5TZWdQdDIueCApIHtcblxuICAgIFx0XHRcdFx0XHRyZXR1cm5cdCggKCBpblNlZ1B0MS54IDw9IGluT3RoZXJQdC54ICkgJiYgKCBpbk90aGVyUHQueCA8PSBpblNlZ1B0Mi54ICkgKTtcblxuICAgIFx0XHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0XHRyZXR1cm5cdCggKCBpblNlZ1B0Mi54IDw9IGluT3RoZXJQdC54ICkgJiYgKCBpbk90aGVyUHQueCA8PSBpblNlZ1B0MS54ICkgKTtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0aWYgKCBpblNlZ1B0MS55IDwgaW5TZWdQdDIueSApIHtcblxuICAgIFx0XHRcdFx0XHRyZXR1cm5cdCggKCBpblNlZ1B0MS55IDw9IGluT3RoZXJQdC55ICkgJiYgKCBpbk90aGVyUHQueSA8PSBpblNlZ1B0Mi55ICkgKTtcblxuICAgIFx0XHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0XHRyZXR1cm5cdCggKCBpblNlZ1B0Mi55IDw9IGluT3RoZXJQdC55ICkgJiYgKCBpbk90aGVyUHQueSA8PSBpblNlZ1B0MS55ICkgKTtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHRmdW5jdGlvbiBpbnRlcnNlY3Rfc2VnbWVudHNfMkQoIGluU2VnMVB0MSwgaW5TZWcxUHQyLCBpblNlZzJQdDEsIGluU2VnMlB0MiwgaW5FeGNsdWRlQWRqYWNlbnRTZWdzICkge1xuXG4gICAgXHRcdFx0dmFyIHNlZzFkeCA9IGluU2VnMVB0Mi54IC0gaW5TZWcxUHQxLngsICAgc2VnMWR5ID0gaW5TZWcxUHQyLnkgLSBpblNlZzFQdDEueTtcbiAgICBcdFx0XHR2YXIgc2VnMmR4ID0gaW5TZWcyUHQyLnggLSBpblNlZzJQdDEueCwgICBzZWcyZHkgPSBpblNlZzJQdDIueSAtIGluU2VnMlB0MS55O1xuXG4gICAgXHRcdFx0dmFyIHNlZzFzZWcyZHggPSBpblNlZzFQdDEueCAtIGluU2VnMlB0MS54O1xuICAgIFx0XHRcdHZhciBzZWcxc2VnMmR5ID0gaW5TZWcxUHQxLnkgLSBpblNlZzJQdDEueTtcblxuICAgIFx0XHRcdHZhciBsaW1pdFx0XHQ9IHNlZzFkeSAqIHNlZzJkeCAtIHNlZzFkeCAqIHNlZzJkeTtcbiAgICBcdFx0XHR2YXIgcGVycFNlZzFcdD0gc2VnMWR5ICogc2VnMXNlZzJkeCAtIHNlZzFkeCAqIHNlZzFzZWcyZHk7XG5cbiAgICBcdFx0XHRpZiAoIE1hdGguYWJzKCBsaW1pdCApID4gTnVtYmVyLkVQU0lMT04gKSB7XG5cbiAgICBcdFx0XHRcdC8vIG5vdCBwYXJhbGxlbFxuXG4gICAgXHRcdFx0XHR2YXIgcGVycFNlZzI7XG4gICAgXHRcdFx0XHRpZiAoIGxpbWl0ID4gMCApIHtcblxuICAgIFx0XHRcdFx0XHRpZiAoICggcGVycFNlZzEgPCAwICkgfHwgKCBwZXJwU2VnMSA+IGxpbWl0ICkgKSBcdFx0cmV0dXJuIFtdO1xuICAgIFx0XHRcdFx0XHRwZXJwU2VnMiA9IHNlZzJkeSAqIHNlZzFzZWcyZHggLSBzZWcyZHggKiBzZWcxc2VnMmR5O1xuICAgIFx0XHRcdFx0XHRpZiAoICggcGVycFNlZzIgPCAwICkgfHwgKCBwZXJwU2VnMiA+IGxpbWl0ICkgKSBcdFx0cmV0dXJuIFtdO1xuXG4gICAgXHRcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRcdGlmICggKCBwZXJwU2VnMSA+IDAgKSB8fCAoIHBlcnBTZWcxIDwgbGltaXQgKSApIFx0XHRyZXR1cm4gW107XG4gICAgXHRcdFx0XHRcdHBlcnBTZWcyID0gc2VnMmR5ICogc2VnMXNlZzJkeCAtIHNlZzJkeCAqIHNlZzFzZWcyZHk7XG4gICAgXHRcdFx0XHRcdGlmICggKCBwZXJwU2VnMiA+IDAgKSB8fCAoIHBlcnBTZWcyIDwgbGltaXQgKSApIFx0XHRyZXR1cm4gW107XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0Ly8gaS5lLiB0byByZWR1Y2Ugcm91bmRpbmcgZXJyb3JzXG4gICAgXHRcdFx0XHQvLyBpbnRlcnNlY3Rpb24gYXQgZW5kcG9pbnQgb2Ygc2VnbWVudCMxP1xuICAgIFx0XHRcdFx0aWYgKCBwZXJwU2VnMiA9PT0gMCApIHtcblxuICAgIFx0XHRcdFx0XHRpZiAoICggaW5FeGNsdWRlQWRqYWNlbnRTZWdzICkgJiZcbiAgICBcdFx0XHRcdFx0XHQgKCAoIHBlcnBTZWcxID09PSAwICkgfHwgKCBwZXJwU2VnMSA9PT0gbGltaXQgKSApIClcdFx0cmV0dXJuIFtdO1xuICAgIFx0XHRcdFx0XHRyZXR1cm4gWyBpblNlZzFQdDEgXTtcblxuICAgIFx0XHRcdFx0fVxuICAgIFx0XHRcdFx0aWYgKCBwZXJwU2VnMiA9PT0gbGltaXQgKSB7XG5cbiAgICBcdFx0XHRcdFx0aWYgKCAoIGluRXhjbHVkZUFkamFjZW50U2VncyApICYmXG4gICAgXHRcdFx0XHRcdFx0ICggKCBwZXJwU2VnMSA9PT0gMCApIHx8ICggcGVycFNlZzEgPT09IGxpbWl0ICkgKSApXHRcdHJldHVybiBbXTtcbiAgICBcdFx0XHRcdFx0cmV0dXJuIFsgaW5TZWcxUHQyIF07XG5cbiAgICBcdFx0XHRcdH1cbiAgICBcdFx0XHRcdC8vIGludGVyc2VjdGlvbiBhdCBlbmRwb2ludCBvZiBzZWdtZW50IzI/XG4gICAgXHRcdFx0XHRpZiAoIHBlcnBTZWcxID09PSAwIClcdFx0cmV0dXJuIFsgaW5TZWcyUHQxIF07XG4gICAgXHRcdFx0XHRpZiAoIHBlcnBTZWcxID09PSBsaW1pdCApXHRyZXR1cm4gWyBpblNlZzJQdDIgXTtcblxuICAgIFx0XHRcdFx0Ly8gcmV0dXJuIHJlYWwgaW50ZXJzZWN0aW9uIHBvaW50XG4gICAgXHRcdFx0XHR2YXIgZmFjdG9yU2VnMSA9IHBlcnBTZWcyIC8gbGltaXQ7XG4gICAgXHRcdFx0XHRyZXR1cm5cdFsgeyB4OiBpblNlZzFQdDEueCArIGZhY3RvclNlZzEgKiBzZWcxZHgsXG4gICAgXHRcdFx0XHRcdFx0XHR5OiBpblNlZzFQdDEueSArIGZhY3RvclNlZzEgKiBzZWcxZHkgfSBdO1xuXG4gICAgXHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0Ly8gcGFyYWxsZWwgb3IgY29sbGluZWFyXG4gICAgXHRcdFx0XHRpZiAoICggcGVycFNlZzEgIT09IDAgKSB8fFxuICAgIFx0XHRcdFx0XHQgKCBzZWcyZHkgKiBzZWcxc2VnMmR4ICE9PSBzZWcyZHggKiBzZWcxc2VnMmR5ICkgKSBcdFx0XHRyZXR1cm4gW107XG5cbiAgICBcdFx0XHRcdC8vIHRoZXkgYXJlIGNvbGxpbmVhciBvciBkZWdlbmVyYXRlXG4gICAgXHRcdFx0XHR2YXIgc2VnMVB0ID0gKCAoIHNlZzFkeCA9PT0gMCApICYmICggc2VnMWR5ID09PSAwICkgKTtcdC8vIHNlZ21lbnQxIGlzIGp1c3QgYSBwb2ludD9cbiAgICBcdFx0XHRcdHZhciBzZWcyUHQgPSAoICggc2VnMmR4ID09PSAwICkgJiYgKCBzZWcyZHkgPT09IDAgKSApO1x0Ly8gc2VnbWVudDIgaXMganVzdCBhIHBvaW50P1xuICAgIFx0XHRcdFx0Ly8gYm90aCBzZWdtZW50cyBhcmUgcG9pbnRzXG4gICAgXHRcdFx0XHRpZiAoIHNlZzFQdCAmJiBzZWcyUHQgKSB7XG5cbiAgICBcdFx0XHRcdFx0aWYgKCAoIGluU2VnMVB0MS54ICE9PSBpblNlZzJQdDEueCApIHx8XG4gICAgXHRcdFx0XHRcdFx0ICggaW5TZWcxUHQxLnkgIT09IGluU2VnMlB0MS55ICkgKVx0XHRyZXR1cm4gW107XHQvLyB0aGV5IGFyZSBkaXN0aW5jdCAgcG9pbnRzXG4gICAgXHRcdFx0XHRcdHJldHVybiBbIGluU2VnMVB0MSBdOyAgICAgICAgICAgICAgICAgXHRcdFx0XHRcdFx0Ly8gdGhleSBhcmUgdGhlIHNhbWUgcG9pbnRcblxuICAgIFx0XHRcdFx0fVxuICAgIFx0XHRcdFx0Ly8gc2VnbWVudCMxICBpcyBhIHNpbmdsZSBwb2ludFxuICAgIFx0XHRcdFx0aWYgKCBzZWcxUHQgKSB7XG5cbiAgICBcdFx0XHRcdFx0aWYgKCAhIHBvaW50X2luX3NlZ21lbnRfMkRfY29saW4oIGluU2VnMlB0MSwgaW5TZWcyUHQyLCBpblNlZzFQdDEgKSApXHRcdHJldHVybiBbXTtcdFx0Ly8gYnV0IG5vdCBpbiBzZWdtZW50IzJcbiAgICBcdFx0XHRcdFx0cmV0dXJuIFsgaW5TZWcxUHQxIF07XG5cbiAgICBcdFx0XHRcdH1cbiAgICBcdFx0XHRcdC8vIHNlZ21lbnQjMiAgaXMgYSBzaW5nbGUgcG9pbnRcbiAgICBcdFx0XHRcdGlmICggc2VnMlB0ICkge1xuXG4gICAgXHRcdFx0XHRcdGlmICggISBwb2ludF9pbl9zZWdtZW50XzJEX2NvbGluKCBpblNlZzFQdDEsIGluU2VnMVB0MiwgaW5TZWcyUHQxICkgKVx0XHRyZXR1cm4gW107XHRcdC8vIGJ1dCBub3QgaW4gc2VnbWVudCMxXG4gICAgXHRcdFx0XHRcdHJldHVybiBbIGluU2VnMlB0MSBdO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdC8vIHRoZXkgYXJlIGNvbGxpbmVhciBzZWdtZW50cywgd2hpY2ggbWlnaHQgb3ZlcmxhcFxuICAgIFx0XHRcdFx0dmFyIHNlZzFtaW4sIHNlZzFtYXgsIHNlZzFtaW5WYWwsIHNlZzFtYXhWYWw7XG4gICAgXHRcdFx0XHR2YXIgc2VnMm1pbiwgc2VnMm1heCwgc2VnMm1pblZhbCwgc2VnMm1heFZhbDtcbiAgICBcdFx0XHRcdGlmICggc2VnMWR4ICE9PSAwICkge1xuXG4gICAgXHRcdFx0XHRcdC8vIHRoZSBzZWdtZW50cyBhcmUgTk9UIG9uIGEgdmVydGljYWwgbGluZVxuICAgIFx0XHRcdFx0XHRpZiAoIGluU2VnMVB0MS54IDwgaW5TZWcxUHQyLnggKSB7XG5cbiAgICBcdFx0XHRcdFx0XHRzZWcxbWluID0gaW5TZWcxUHQxOyBzZWcxbWluVmFsID0gaW5TZWcxUHQxLng7XG4gICAgXHRcdFx0XHRcdFx0c2VnMW1heCA9IGluU2VnMVB0Mjsgc2VnMW1heFZhbCA9IGluU2VnMVB0Mi54O1xuXG4gICAgXHRcdFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdFx0XHRzZWcxbWluID0gaW5TZWcxUHQyOyBzZWcxbWluVmFsID0gaW5TZWcxUHQyLng7XG4gICAgXHRcdFx0XHRcdFx0c2VnMW1heCA9IGluU2VnMVB0MTsgc2VnMW1heFZhbCA9IGluU2VnMVB0MS54O1xuXG4gICAgXHRcdFx0XHRcdH1cbiAgICBcdFx0XHRcdFx0aWYgKCBpblNlZzJQdDEueCA8IGluU2VnMlB0Mi54ICkge1xuXG4gICAgXHRcdFx0XHRcdFx0c2VnMm1pbiA9IGluU2VnMlB0MTsgc2VnMm1pblZhbCA9IGluU2VnMlB0MS54O1xuICAgIFx0XHRcdFx0XHRcdHNlZzJtYXggPSBpblNlZzJQdDI7IHNlZzJtYXhWYWwgPSBpblNlZzJQdDIueDtcblxuICAgIFx0XHRcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRcdFx0c2VnMm1pbiA9IGluU2VnMlB0Mjsgc2VnMm1pblZhbCA9IGluU2VnMlB0Mi54O1xuICAgIFx0XHRcdFx0XHRcdHNlZzJtYXggPSBpblNlZzJQdDE7IHNlZzJtYXhWYWwgPSBpblNlZzJQdDEueDtcblxuICAgIFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdFx0Ly8gdGhlIHNlZ21lbnRzIGFyZSBvbiBhIHZlcnRpY2FsIGxpbmVcbiAgICBcdFx0XHRcdFx0aWYgKCBpblNlZzFQdDEueSA8IGluU2VnMVB0Mi55ICkge1xuXG4gICAgXHRcdFx0XHRcdFx0c2VnMW1pbiA9IGluU2VnMVB0MTsgc2VnMW1pblZhbCA9IGluU2VnMVB0MS55O1xuICAgIFx0XHRcdFx0XHRcdHNlZzFtYXggPSBpblNlZzFQdDI7IHNlZzFtYXhWYWwgPSBpblNlZzFQdDIueTtcblxuICAgIFx0XHRcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRcdFx0c2VnMW1pbiA9IGluU2VnMVB0Mjsgc2VnMW1pblZhbCA9IGluU2VnMVB0Mi55O1xuICAgIFx0XHRcdFx0XHRcdHNlZzFtYXggPSBpblNlZzFQdDE7IHNlZzFtYXhWYWwgPSBpblNlZzFQdDEueTtcblxuICAgIFx0XHRcdFx0XHR9XG4gICAgXHRcdFx0XHRcdGlmICggaW5TZWcyUHQxLnkgPCBpblNlZzJQdDIueSApIHtcblxuICAgIFx0XHRcdFx0XHRcdHNlZzJtaW4gPSBpblNlZzJQdDE7IHNlZzJtaW5WYWwgPSBpblNlZzJQdDEueTtcbiAgICBcdFx0XHRcdFx0XHRzZWcybWF4ID0gaW5TZWcyUHQyOyBzZWcybWF4VmFsID0gaW5TZWcyUHQyLnk7XG5cbiAgICBcdFx0XHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0XHRcdHNlZzJtaW4gPSBpblNlZzJQdDI7IHNlZzJtaW5WYWwgPSBpblNlZzJQdDIueTtcbiAgICBcdFx0XHRcdFx0XHRzZWcybWF4ID0gaW5TZWcyUHQxOyBzZWcybWF4VmFsID0gaW5TZWcyUHQxLnk7XG5cbiAgICBcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHR9XG4gICAgXHRcdFx0XHRpZiAoIHNlZzFtaW5WYWwgPD0gc2VnMm1pblZhbCApIHtcblxuICAgIFx0XHRcdFx0XHRpZiAoIHNlZzFtYXhWYWwgPCAgc2VnMm1pblZhbCApXHRyZXR1cm4gW107XG4gICAgXHRcdFx0XHRcdGlmICggc2VnMW1heFZhbCA9PT0gc2VnMm1pblZhbCApXHR7XG5cbiAgICBcdFx0XHRcdFx0XHRpZiAoIGluRXhjbHVkZUFkamFjZW50U2VncyApXHRcdHJldHVybiBbXTtcbiAgICBcdFx0XHRcdFx0XHRyZXR1cm4gWyBzZWcybWluIF07XG5cbiAgICBcdFx0XHRcdFx0fVxuICAgIFx0XHRcdFx0XHRpZiAoIHNlZzFtYXhWYWwgPD0gc2VnMm1heFZhbCApXHRyZXR1cm4gWyBzZWcybWluLCBzZWcxbWF4IF07XG4gICAgXHRcdFx0XHRcdHJldHVyblx0WyBzZWcybWluLCBzZWcybWF4IF07XG5cbiAgICBcdFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdFx0aWYgKCBzZWcxbWluVmFsID4gIHNlZzJtYXhWYWwgKVx0cmV0dXJuIFtdO1xuICAgIFx0XHRcdFx0XHRpZiAoIHNlZzFtaW5WYWwgPT09IHNlZzJtYXhWYWwgKVx0e1xuXG4gICAgXHRcdFx0XHRcdFx0aWYgKCBpbkV4Y2x1ZGVBZGphY2VudFNlZ3MgKVx0XHRyZXR1cm4gW107XG4gICAgXHRcdFx0XHRcdFx0cmV0dXJuIFsgc2VnMW1pbiBdO1xuXG4gICAgXHRcdFx0XHRcdH1cbiAgICBcdFx0XHRcdFx0aWYgKCBzZWcxbWF4VmFsIDw9IHNlZzJtYXhWYWwgKVx0cmV0dXJuIFsgc2VnMW1pbiwgc2VnMW1heCBdO1xuICAgIFx0XHRcdFx0XHRyZXR1cm5cdFsgc2VnMW1pbiwgc2VnMm1heCBdO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGZ1bmN0aW9uIGlzUG9pbnRJbnNpZGVBbmdsZSggaW5WZXJ0ZXgsIGluTGVnRnJvbVB0LCBpbkxlZ1RvUHQsIGluT3RoZXJQdCApIHtcblxuICAgIFx0XHRcdC8vIFRoZSBvcmRlciBvZiBsZWdzIGlzIGltcG9ydGFudFxuXG4gICAgXHRcdFx0Ly8gdHJhbnNsYXRpb24gb2YgYWxsIHBvaW50cywgc28gdGhhdCBWZXJ0ZXggaXMgYXQgKDAsMClcbiAgICBcdFx0XHR2YXIgbGVnRnJvbVB0WFx0PSBpbkxlZ0Zyb21QdC54IC0gaW5WZXJ0ZXgueCwgIGxlZ0Zyb21QdFlcdD0gaW5MZWdGcm9tUHQueSAtIGluVmVydGV4Lnk7XG4gICAgXHRcdFx0dmFyIGxlZ1RvUHRYXHQ9IGluTGVnVG9QdC54XHQtIGluVmVydGV4LngsICBsZWdUb1B0WVx0XHQ9IGluTGVnVG9QdC55XHQtIGluVmVydGV4Lnk7XG4gICAgXHRcdFx0dmFyIG90aGVyUHRYXHQ9IGluT3RoZXJQdC54XHQtIGluVmVydGV4LngsICBvdGhlclB0WVx0XHQ9IGluT3RoZXJQdC55XHQtIGluVmVydGV4Lnk7XG5cbiAgICBcdFx0XHQvLyBtYWluIGFuZ2xlID4wOiA8IDE4MCBkZWcuOyAwOiAxODAgZGVnLjsgPDA6ID4gMTgwIGRlZy5cbiAgICBcdFx0XHR2YXIgZnJvbTJ0b0FuZ2xlXHQ9IGxlZ0Zyb21QdFggKiBsZWdUb1B0WSAtIGxlZ0Zyb21QdFkgKiBsZWdUb1B0WDtcbiAgICBcdFx0XHR2YXIgZnJvbTJvdGhlckFuZ2xlXHQ9IGxlZ0Zyb21QdFggKiBvdGhlclB0WSAtIGxlZ0Zyb21QdFkgKiBvdGhlclB0WDtcblxuICAgIFx0XHRcdGlmICggTWF0aC5hYnMoIGZyb20ydG9BbmdsZSApID4gTnVtYmVyLkVQU0lMT04gKSB7XG5cbiAgICBcdFx0XHRcdC8vIGFuZ2xlICE9IDE4MCBkZWcuXG5cbiAgICBcdFx0XHRcdHZhciBvdGhlcjJ0b0FuZ2xlXHRcdD0gb3RoZXJQdFggKiBsZWdUb1B0WSAtIG90aGVyUHRZICogbGVnVG9QdFg7XG4gICAgXHRcdFx0XHQvLyBjb25zb2xlLmxvZyggXCJmcm9tMnRvOiBcIiArIGZyb20ydG9BbmdsZSArIFwiLCBmcm9tMm90aGVyOiBcIiArIGZyb20yb3RoZXJBbmdsZSArIFwiLCBvdGhlcjJ0bzogXCIgKyBvdGhlcjJ0b0FuZ2xlICk7XG5cbiAgICBcdFx0XHRcdGlmICggZnJvbTJ0b0FuZ2xlID4gMCApIHtcblxuICAgIFx0XHRcdFx0XHQvLyBtYWluIGFuZ2xlIDwgMTgwIGRlZy5cbiAgICBcdFx0XHRcdFx0cmV0dXJuXHQoICggZnJvbTJvdGhlckFuZ2xlID49IDAgKSAmJiAoIG90aGVyMnRvQW5nbGUgPj0gMCApICk7XG5cbiAgICBcdFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdFx0Ly8gbWFpbiBhbmdsZSA+IDE4MCBkZWcuXG4gICAgXHRcdFx0XHRcdHJldHVyblx0KCAoIGZyb20yb3RoZXJBbmdsZSA+PSAwICkgfHwgKCBvdGhlcjJ0b0FuZ2xlID49IDAgKSApO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHQvLyBhbmdsZSA9PSAxODAgZGVnLlxuICAgIFx0XHRcdFx0Ly8gY29uc29sZS5sb2coIFwiZnJvbTJ0bzogMTgwIGRlZy4sIGZyb20yb3RoZXI6IFwiICsgZnJvbTJvdGhlckFuZ2xlICApO1xuICAgIFx0XHRcdFx0cmV0dXJuXHQoIGZyb20yb3RoZXJBbmdsZSA+IDAgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cblxuICAgIFx0XHRmdW5jdGlvbiByZW1vdmVIb2xlcyggY29udG91ciwgaG9sZXMgKSB7XG5cbiAgICBcdFx0XHR2YXIgc2hhcGUgPSBjb250b3VyLmNvbmNhdCgpOyAvLyB3b3JrIG9uIHRoaXMgc2hhcGVcbiAgICBcdFx0XHR2YXIgaG9sZTtcblxuICAgIFx0XHRcdGZ1bmN0aW9uIGlzQ3V0TGluZUluc2lkZUFuZ2xlcyggaW5TaGFwZUlkeCwgaW5Ib2xlSWR4ICkge1xuXG4gICAgXHRcdFx0XHQvLyBDaGVjayBpZiBob2xlIHBvaW50IGxpZXMgd2l0aGluIGFuZ2xlIGFyb3VuZCBzaGFwZSBwb2ludFxuICAgIFx0XHRcdFx0dmFyIGxhc3RTaGFwZUlkeCA9IHNoYXBlLmxlbmd0aCAtIDE7XG5cbiAgICBcdFx0XHRcdHZhciBwcmV2U2hhcGVJZHggPSBpblNoYXBlSWR4IC0gMTtcbiAgICBcdFx0XHRcdGlmICggcHJldlNoYXBlSWR4IDwgMCApXHRcdFx0cHJldlNoYXBlSWR4ID0gbGFzdFNoYXBlSWR4O1xuXG4gICAgXHRcdFx0XHR2YXIgbmV4dFNoYXBlSWR4ID0gaW5TaGFwZUlkeCArIDE7XG4gICAgXHRcdFx0XHRpZiAoIG5leHRTaGFwZUlkeCA+IGxhc3RTaGFwZUlkeCApXHRuZXh0U2hhcGVJZHggPSAwO1xuXG4gICAgXHRcdFx0XHR2YXIgaW5zaWRlQW5nbGUgPSBpc1BvaW50SW5zaWRlQW5nbGUoIHNoYXBlWyBpblNoYXBlSWR4IF0sIHNoYXBlWyBwcmV2U2hhcGVJZHggXSwgc2hhcGVbIG5leHRTaGFwZUlkeCBdLCBob2xlWyBpbkhvbGVJZHggXSApO1xuICAgIFx0XHRcdFx0aWYgKCAhIGluc2lkZUFuZ2xlICkge1xuXG4gICAgXHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nKCBcIlZlcnRleCAoU2hhcGUpOiBcIiArIGluU2hhcGVJZHggKyBcIiwgUG9pbnQ6IFwiICsgaG9sZVtpbkhvbGVJZHhdLnggKyBcIi9cIiArIGhvbGVbaW5Ib2xlSWR4XS55ICk7XG4gICAgXHRcdFx0XHRcdHJldHVyblx0ZmFsc2U7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0Ly8gQ2hlY2sgaWYgc2hhcGUgcG9pbnQgbGllcyB3aXRoaW4gYW5nbGUgYXJvdW5kIGhvbGUgcG9pbnRcbiAgICBcdFx0XHRcdHZhciBsYXN0SG9sZUlkeCA9IGhvbGUubGVuZ3RoIC0gMTtcblxuICAgIFx0XHRcdFx0dmFyIHByZXZIb2xlSWR4ID0gaW5Ib2xlSWR4IC0gMTtcbiAgICBcdFx0XHRcdGlmICggcHJldkhvbGVJZHggPCAwIClcdFx0XHRwcmV2SG9sZUlkeCA9IGxhc3RIb2xlSWR4O1xuXG4gICAgXHRcdFx0XHR2YXIgbmV4dEhvbGVJZHggPSBpbkhvbGVJZHggKyAxO1xuICAgIFx0XHRcdFx0aWYgKCBuZXh0SG9sZUlkeCA+IGxhc3RIb2xlSWR4IClcdG5leHRIb2xlSWR4ID0gMDtcblxuICAgIFx0XHRcdFx0aW5zaWRlQW5nbGUgPSBpc1BvaW50SW5zaWRlQW5nbGUoIGhvbGVbIGluSG9sZUlkeCBdLCBob2xlWyBwcmV2SG9sZUlkeCBdLCBob2xlWyBuZXh0SG9sZUlkeCBdLCBzaGFwZVsgaW5TaGFwZUlkeCBdICk7XG4gICAgXHRcdFx0XHRpZiAoICEgaW5zaWRlQW5nbGUgKSB7XG5cbiAgICBcdFx0XHRcdFx0Ly8gY29uc29sZS5sb2coIFwiVmVydGV4IChIb2xlKTogXCIgKyBpbkhvbGVJZHggKyBcIiwgUG9pbnQ6IFwiICsgc2hhcGVbaW5TaGFwZUlkeF0ueCArIFwiL1wiICsgc2hhcGVbaW5TaGFwZUlkeF0ueSApO1xuICAgIFx0XHRcdFx0XHRyZXR1cm5cdGZhbHNlO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdHJldHVyblx0dHJ1ZTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGZ1bmN0aW9uIGludGVyc2VjdHNTaGFwZUVkZ2UoIGluU2hhcGVQdCwgaW5Ib2xlUHQgKSB7XG5cbiAgICBcdFx0XHRcdC8vIGNoZWNrcyBmb3IgaW50ZXJzZWN0aW9ucyB3aXRoIHNoYXBlIGVkZ2VzXG4gICAgXHRcdFx0XHR2YXIgc0lkeCwgbmV4dElkeCwgaW50ZXJzZWN0aW9uO1xuICAgIFx0XHRcdFx0Zm9yICggc0lkeCA9IDA7IHNJZHggPCBzaGFwZS5sZW5ndGg7IHNJZHggKysgKSB7XG5cbiAgICBcdFx0XHRcdFx0bmV4dElkeCA9IHNJZHggKyAxOyBuZXh0SWR4ICU9IHNoYXBlLmxlbmd0aDtcbiAgICBcdFx0XHRcdFx0aW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0X3NlZ21lbnRzXzJEKCBpblNoYXBlUHQsIGluSG9sZVB0LCBzaGFwZVsgc0lkeCBdLCBzaGFwZVsgbmV4dElkeCBdLCB0cnVlICk7XG4gICAgXHRcdFx0XHRcdGlmICggaW50ZXJzZWN0aW9uLmxlbmd0aCA+IDAgKVx0XHRyZXR1cm5cdHRydWU7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0cmV0dXJuXHRmYWxzZTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdHZhciBpbmRlcEhvbGVzID0gW107XG5cbiAgICBcdFx0XHRmdW5jdGlvbiBpbnRlcnNlY3RzSG9sZUVkZ2UoIGluU2hhcGVQdCwgaW5Ib2xlUHQgKSB7XG5cbiAgICBcdFx0XHRcdC8vIGNoZWNrcyBmb3IgaW50ZXJzZWN0aW9ucyB3aXRoIGhvbGUgZWRnZXNcbiAgICBcdFx0XHRcdHZhciBpaElkeCwgY2hrSG9sZSxcbiAgICBcdFx0XHRcdFx0aElkeCwgbmV4dElkeCwgaW50ZXJzZWN0aW9uO1xuICAgIFx0XHRcdFx0Zm9yICggaWhJZHggPSAwOyBpaElkeCA8IGluZGVwSG9sZXMubGVuZ3RoOyBpaElkeCArKyApIHtcblxuICAgIFx0XHRcdFx0XHRjaGtIb2xlID0gaG9sZXNbIGluZGVwSG9sZXNbIGloSWR4IF1dO1xuICAgIFx0XHRcdFx0XHRmb3IgKCBoSWR4ID0gMDsgaElkeCA8IGNoa0hvbGUubGVuZ3RoOyBoSWR4ICsrICkge1xuXG4gICAgXHRcdFx0XHRcdFx0bmV4dElkeCA9IGhJZHggKyAxOyBuZXh0SWR4ICU9IGNoa0hvbGUubGVuZ3RoO1xuICAgIFx0XHRcdFx0XHRcdGludGVyc2VjdGlvbiA9IGludGVyc2VjdF9zZWdtZW50c18yRCggaW5TaGFwZVB0LCBpbkhvbGVQdCwgY2hrSG9sZVsgaElkeCBdLCBjaGtIb2xlWyBuZXh0SWR4IF0sIHRydWUgKTtcbiAgICBcdFx0XHRcdFx0XHRpZiAoIGludGVyc2VjdGlvbi5sZW5ndGggPiAwIClcdFx0cmV0dXJuXHR0cnVlO1xuXG4gICAgXHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0fVxuICAgIFx0XHRcdFx0cmV0dXJuXHRmYWxzZTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdHZhciBob2xlSW5kZXgsIHNoYXBlSW5kZXgsXG4gICAgXHRcdFx0XHRzaGFwZVB0LCBob2xlUHQsXG4gICAgXHRcdFx0XHRob2xlSWR4LCBjdXRLZXksIGZhaWxlZEN1dHMgPSBbXSxcbiAgICBcdFx0XHRcdHRtcFNoYXBlMSwgdG1wU2hhcGUyLFxuICAgIFx0XHRcdFx0dG1wSG9sZTEsIHRtcEhvbGUyO1xuXG4gICAgXHRcdFx0Zm9yICggdmFyIGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xuXG4gICAgXHRcdFx0XHRpbmRlcEhvbGVzLnB1c2goIGggKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdHZhciBtaW5TaGFwZUluZGV4ID0gMDtcbiAgICBcdFx0XHR2YXIgY291bnRlciA9IGluZGVwSG9sZXMubGVuZ3RoICogMjtcbiAgICBcdFx0XHR3aGlsZSAoIGluZGVwSG9sZXMubGVuZ3RoID4gMCApIHtcblxuICAgIFx0XHRcdFx0Y291bnRlciAtLTtcbiAgICBcdFx0XHRcdGlmICggY291bnRlciA8IDAgKSB7XG5cbiAgICBcdFx0XHRcdFx0Y29uc29sZS5sb2coIFwiSW5maW5pdGUgTG9vcCEgSG9sZXMgbGVmdDpcIiArIGluZGVwSG9sZXMubGVuZ3RoICsgXCIsIFByb2JhYmx5IEhvbGUgb3V0c2lkZSBTaGFwZSFcIiApO1xuICAgIFx0XHRcdFx0XHRicmVhaztcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHQvLyBzZWFyY2ggZm9yIHNoYXBlLXZlcnRleCBhbmQgaG9sZS12ZXJ0ZXgsXG4gICAgXHRcdFx0XHQvLyB3aGljaCBjYW4gYmUgY29ubmVjdGVkIHdpdGhvdXQgaW50ZXJzZWN0aW9uc1xuICAgIFx0XHRcdFx0Zm9yICggc2hhcGVJbmRleCA9IG1pblNoYXBlSW5kZXg7IHNoYXBlSW5kZXggPCBzaGFwZS5sZW5ndGg7IHNoYXBlSW5kZXggKysgKSB7XG5cbiAgICBcdFx0XHRcdFx0c2hhcGVQdCA9IHNoYXBlWyBzaGFwZUluZGV4IF07XG4gICAgXHRcdFx0XHRcdGhvbGVJbmRleFx0PSAtIDE7XG5cbiAgICBcdFx0XHRcdFx0Ly8gc2VhcmNoIGZvciBob2xlIHdoaWNoIGNhbiBiZSByZWFjaGVkIHdpdGhvdXQgaW50ZXJzZWN0aW9uc1xuICAgIFx0XHRcdFx0XHRmb3IgKCB2YXIgaCA9IDA7IGggPCBpbmRlcEhvbGVzLmxlbmd0aDsgaCArKyApIHtcblxuICAgIFx0XHRcdFx0XHRcdGhvbGVJZHggPSBpbmRlcEhvbGVzWyBoIF07XG5cbiAgICBcdFx0XHRcdFx0XHQvLyBwcmV2ZW50IG11bHRpcGxlIGNoZWNrc1xuICAgIFx0XHRcdFx0XHRcdGN1dEtleSA9IHNoYXBlUHQueCArIFwiOlwiICsgc2hhcGVQdC55ICsgXCI6XCIgKyBob2xlSWR4O1xuICAgIFx0XHRcdFx0XHRcdGlmICggZmFpbGVkQ3V0c1sgY3V0S2V5IF0gIT09IHVuZGVmaW5lZCApXHRcdFx0Y29udGludWU7XG5cbiAgICBcdFx0XHRcdFx0XHRob2xlID0gaG9sZXNbIGhvbGVJZHggXTtcbiAgICBcdFx0XHRcdFx0XHRmb3IgKCB2YXIgaDIgPSAwOyBoMiA8IGhvbGUubGVuZ3RoOyBoMiArKyApIHtcblxuICAgIFx0XHRcdFx0XHRcdFx0aG9sZVB0ID0gaG9sZVsgaDIgXTtcbiAgICBcdFx0XHRcdFx0XHRcdGlmICggISBpc0N1dExpbmVJbnNpZGVBbmdsZXMoIHNoYXBlSW5kZXgsIGgyICkgKVx0XHRjb250aW51ZTtcbiAgICBcdFx0XHRcdFx0XHRcdGlmICggaW50ZXJzZWN0c1NoYXBlRWRnZSggc2hhcGVQdCwgaG9sZVB0ICkgKVx0XHRjb250aW51ZTtcbiAgICBcdFx0XHRcdFx0XHRcdGlmICggaW50ZXJzZWN0c0hvbGVFZGdlKCBzaGFwZVB0LCBob2xlUHQgKSApXHRcdGNvbnRpbnVlO1xuXG4gICAgXHRcdFx0XHRcdFx0XHRob2xlSW5kZXggPSBoMjtcbiAgICBcdFx0XHRcdFx0XHRcdGluZGVwSG9sZXMuc3BsaWNlKCBoLCAxICk7XG5cbiAgICBcdFx0XHRcdFx0XHRcdHRtcFNoYXBlMSA9IHNoYXBlLnNsaWNlKCAwLCBzaGFwZUluZGV4ICsgMSApO1xuICAgIFx0XHRcdFx0XHRcdFx0dG1wU2hhcGUyID0gc2hhcGUuc2xpY2UoIHNoYXBlSW5kZXggKTtcbiAgICBcdFx0XHRcdFx0XHRcdHRtcEhvbGUxID0gaG9sZS5zbGljZSggaG9sZUluZGV4ICk7XG4gICAgXHRcdFx0XHRcdFx0XHR0bXBIb2xlMiA9IGhvbGUuc2xpY2UoIDAsIGhvbGVJbmRleCArIDEgKTtcblxuICAgIFx0XHRcdFx0XHRcdFx0c2hhcGUgPSB0bXBTaGFwZTEuY29uY2F0KCB0bXBIb2xlMSApLmNvbmNhdCggdG1wSG9sZTIgKS5jb25jYXQoIHRtcFNoYXBlMiApO1xuXG4gICAgXHRcdFx0XHRcdFx0XHRtaW5TaGFwZUluZGV4ID0gc2hhcGVJbmRleDtcblxuICAgIFx0XHRcdFx0XHRcdFx0Ly8gRGVidWcgb25seSwgdG8gc2hvdyB0aGUgc2VsZWN0ZWQgY3V0c1xuICAgIFx0XHRcdFx0XHRcdFx0Ly8gZ2xvYl9DdXRMaW5lcy5wdXNoKCBbIHNoYXBlUHQsIGhvbGVQdCBdICk7XG5cbiAgICBcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG4gICAgXHRcdFx0XHRcdFx0fVxuICAgIFx0XHRcdFx0XHRcdGlmICggaG9sZUluZGV4ID49IDAgKVx0YnJlYWs7XHRcdC8vIGhvbGUtdmVydGV4IGZvdW5kXG5cbiAgICBcdFx0XHRcdFx0XHRmYWlsZWRDdXRzWyBjdXRLZXkgXSA9IHRydWU7XHRcdFx0Ly8gcmVtZW1iZXIgZmFpbHVyZVxuXG4gICAgXHRcdFx0XHRcdH1cbiAgICBcdFx0XHRcdFx0aWYgKCBob2xlSW5kZXggPj0gMCApXHRicmVhaztcdFx0Ly8gaG9sZS12ZXJ0ZXggZm91bmRcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0cmV0dXJuIHNoYXBlOyBcdFx0XHQvKiBzaGFwZSB3aXRoIG5vIGhvbGVzICovXG5cbiAgICBcdFx0fVxuXG5cbiAgICBcdFx0dmFyIGksIGlsLCBmLCBmYWNlLFxuICAgIFx0XHRcdGtleSwgaW5kZXgsXG4gICAgXHRcdFx0YWxsUG9pbnRzTWFwID0ge307XG5cbiAgICBcdFx0Ly8gVG8gbWFpbnRhaW4gcmVmZXJlbmNlIHRvIG9sZCBzaGFwZSwgb25lIG11c3QgbWF0Y2ggY29vcmRpbmF0ZXMsIG9yIG9mZnNldCB0aGUgaW5kaWNlcyBmcm9tIG9yaWdpbmFsIGFycmF5cy4gSXQncyBwcm9iYWJseSBlYXNpZXIgdG8gZG8gdGhlIGZpcnN0LlxuXG4gICAgXHRcdHZhciBhbGxwb2ludHMgPSBjb250b3VyLmNvbmNhdCgpO1xuXG4gICAgXHRcdGZvciAoIHZhciBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcblxuICAgIFx0XHRcdEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KCBhbGxwb2ludHMsIGhvbGVzWyBoIF0gKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0Ly9jb25zb2xlLmxvZyggXCJhbGxwb2ludHNcIixhbGxwb2ludHMsIGFsbHBvaW50cy5sZW5ndGggKTtcblxuICAgIFx0XHQvLyBwcmVwYXJlIGFsbCBwb2ludHMgbWFwXG5cbiAgICBcdFx0Zm9yICggaSA9IDAsIGlsID0gYWxscG9pbnRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgXHRcdFx0a2V5ID0gYWxscG9pbnRzWyBpIF0ueCArIFwiOlwiICsgYWxscG9pbnRzWyBpIF0ueTtcblxuICAgIFx0XHRcdGlmICggYWxsUG9pbnRzTWFwWyBrZXkgXSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0XHRjb25zb2xlLndhcm4oIFwiVEhSRUUuU2hhcGVVdGlsczogRHVwbGljYXRlIHBvaW50XCIsIGtleSwgaSApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0YWxsUG9pbnRzTWFwWyBrZXkgXSA9IGk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdC8vIHJlbW92ZSBob2xlcyBieSBjdXR0aW5nIHBhdGhzIHRvIGhvbGVzIGFuZCBhZGRpbmcgdGhlbSB0byB0aGUgc2hhcGVcbiAgICBcdFx0dmFyIHNoYXBlV2l0aG91dEhvbGVzID0gcmVtb3ZlSG9sZXMoIGNvbnRvdXIsIGhvbGVzICk7XG5cbiAgICBcdFx0dmFyIHRyaWFuZ2xlcyA9IGV4cG9ydHMuU2hhcGVVdGlscy50cmlhbmd1bGF0ZSggc2hhcGVXaXRob3V0SG9sZXMsIGZhbHNlICk7IC8vIFRydWUgcmV0dXJucyBpbmRpY2VzIGZvciBwb2ludHMgb2Ygc3Bvb2xlZCBzaGFwZVxuICAgIFx0XHQvL2NvbnNvbGUubG9nKCBcInRyaWFuZ2xlc1wiLHRyaWFuZ2xlcywgdHJpYW5nbGVzLmxlbmd0aCApO1xuXG4gICAgXHRcdC8vIGNoZWNrIGFsbCBmYWNlIHZlcnRpY2VzIGFnYWluc3QgYWxsIHBvaW50cyBtYXBcblxuICAgIFx0XHRmb3IgKCBpID0gMCwgaWwgPSB0cmlhbmdsZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICBcdFx0XHRmYWNlID0gdHJpYW5nbGVzWyBpIF07XG5cbiAgICBcdFx0XHRmb3IgKCBmID0gMDsgZiA8IDM7IGYgKysgKSB7XG5cbiAgICBcdFx0XHRcdGtleSA9IGZhY2VbIGYgXS54ICsgXCI6XCIgKyBmYWNlWyBmIF0ueTtcblxuICAgIFx0XHRcdFx0aW5kZXggPSBhbGxQb2ludHNNYXBbIGtleSBdO1xuXG4gICAgXHRcdFx0XHRpZiAoIGluZGV4ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRcdFx0ZmFjZVsgZiBdID0gaW5kZXg7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIHRyaWFuZ2xlcy5jb25jYXQoKTtcblxuICAgIFx0fSxcblxuICAgIFx0aXNDbG9ja1dpc2U6IGZ1bmN0aW9uICggcHRzICkge1xuXG4gICAgXHRcdHJldHVybiBleHBvcnRzLlNoYXBlVXRpbHMuYXJlYSggcHRzICkgPCAwO1xuXG4gICAgXHR9LFxuXG4gICAgXHQvLyBCZXppZXIgQ3VydmVzIGZvcm11bGFzIG9idGFpbmVkIGZyb21cbiAgICBcdC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQiVDMyVBOXppZXJfY3VydmVcblxuICAgIFx0Ly8gUXVhZCBCZXppZXIgRnVuY3Rpb25zXG5cbiAgICBcdGIyOiAoIGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHRmdW5jdGlvbiBiMnAwKCB0LCBwICkge1xuXG4gICAgXHRcdFx0dmFyIGsgPSAxIC0gdDtcbiAgICBcdFx0XHRyZXR1cm4gayAqIGsgKiBwO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRmdW5jdGlvbiBiMnAxKCB0LCBwICkge1xuXG4gICAgXHRcdFx0cmV0dXJuIDIgKiAoIDEgLSB0ICkgKiB0ICogcDtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0ZnVuY3Rpb24gYjJwMiggdCwgcCApIHtcblxuICAgIFx0XHRcdHJldHVybiB0ICogdCAqIHA7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiBmdW5jdGlvbiBiMiggdCwgcDAsIHAxLCBwMiApIHtcblxuICAgIFx0XHRcdHJldHVybiBiMnAwKCB0LCBwMCApICsgYjJwMSggdCwgcDEgKSArIGIycDIoIHQsIHAyICk7XG5cbiAgICBcdFx0fTtcblxuICAgIFx0fSApKCksXG5cbiAgICBcdC8vIEN1YmljIEJlemllciBGdW5jdGlvbnNcblxuICAgIFx0YjM6ICggZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdGZ1bmN0aW9uIGIzcDAoIHQsIHAgKSB7XG5cbiAgICBcdFx0XHR2YXIgayA9IDEgLSB0O1xuICAgIFx0XHRcdHJldHVybiBrICogayAqIGsgKiBwO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRmdW5jdGlvbiBiM3AxKCB0LCBwICkge1xuXG4gICAgXHRcdFx0dmFyIGsgPSAxIC0gdDtcbiAgICBcdFx0XHRyZXR1cm4gMyAqIGsgKiBrICogdCAqIHA7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGZ1bmN0aW9uIGIzcDIoIHQsIHAgKSB7XG5cbiAgICBcdFx0XHR2YXIgayA9IDEgLSB0O1xuICAgIFx0XHRcdHJldHVybiAzICogayAqIHQgKiB0ICogcDtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0ZnVuY3Rpb24gYjNwMyggdCwgcCApIHtcblxuICAgIFx0XHRcdHJldHVybiB0ICogdCAqIHQgKiBwO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gZnVuY3Rpb24gYjMoIHQsIHAwLCBwMSwgcDIsIHAzICkge1xuXG4gICAgXHRcdFx0cmV0dXJuIGIzcDAoIHQsIHAwICkgKyBiM3AxKCB0LCBwMSApICsgYjNwMiggdCwgcDIgKSArIGIzcDMoIHQsIHAzICk7XG5cbiAgICBcdFx0fTtcblxuICAgIFx0fSApKClcblxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXG4gICAgICpcbiAgICAgKiBDcmVhdGVzIGV4dHJ1ZGVkIGdlb21ldHJ5IGZyb20gYSBwYXRoIHNoYXBlLlxuICAgICAqXG4gICAgICogcGFyYW1ldGVycyA9IHtcbiAgICAgKlxuICAgICAqICBjdXJ2ZVNlZ21lbnRzOiA8aW50PiwgLy8gbnVtYmVyIG9mIHBvaW50cyBvbiB0aGUgY3VydmVzXG4gICAgICogIHN0ZXBzOiA8aW50PiwgLy8gbnVtYmVyIG9mIHBvaW50cyBmb3Igei1zaWRlIGV4dHJ1c2lvbnMgLyB1c2VkIGZvciBzdWJkaXZpZGluZyBzZWdtZW50cyBvZiBleHRydWRlIHNwbGluZSB0b29cbiAgICAgKiAgYW1vdW50OiA8aW50PiwgLy8gRGVwdGggdG8gZXh0cnVkZSB0aGUgc2hhcGVcbiAgICAgKlxuICAgICAqICBiZXZlbEVuYWJsZWQ6IDxib29sPiwgLy8gdHVybiBvbiBiZXZlbFxuICAgICAqICBiZXZlbFRoaWNrbmVzczogPGZsb2F0PiwgLy8gaG93IGRlZXAgaW50byB0aGUgb3JpZ2luYWwgc2hhcGUgYmV2ZWwgZ29lc1xuICAgICAqICBiZXZlbFNpemU6IDxmbG9hdD4sIC8vIGhvdyBmYXIgZnJvbSBzaGFwZSBvdXRsaW5lIGlzIGJldmVsXG4gICAgICogIGJldmVsU2VnbWVudHM6IDxpbnQ+LCAvLyBudW1iZXIgb2YgYmV2ZWwgbGF5ZXJzXG4gICAgICpcbiAgICAgKiAgZXh0cnVkZVBhdGg6IDxUSFJFRS5DdXJ2ZVBhdGg+IC8vIDNkIHNwbGluZSBwYXRoIHRvIGV4dHJ1ZGUgc2hhcGUgYWxvbmcuIChjcmVhdGVzIEZyYW1lcyBpZiAuZnJhbWVzIGFyZW4ndCBkZWZpbmVkKVxuICAgICAqICBmcmFtZXM6IDxUSFJFRS5UdWJlR2VvbWV0cnkuRnJlbmV0RnJhbWVzPiAvLyBjb250YWluaW5nIGFycmF5cyBvZiB0YW5nZW50cywgbm9ybWFscywgYmlub3JtYWxzXG4gICAgICpcbiAgICAgKiAgdXZHZW5lcmF0b3I6IDxPYmplY3Q+IC8vIG9iamVjdCB0aGF0IHByb3ZpZGVzIFVWIGdlbmVyYXRvciBmdW5jdGlvbnNcbiAgICAgKlxuICAgICAqIH1cbiAgICAgKiovXG5cbiAgICBmdW5jdGlvbiBFeHRydWRlR2VvbWV0cnkoIHNoYXBlcywgb3B0aW9ucyApIHtcblxuICAgIFx0aWYgKCB0eXBlb2YoIHNoYXBlcyApID09PSBcInVuZGVmaW5lZFwiICkge1xuXG4gICAgXHRcdHNoYXBlcyA9IFtdO1xuICAgIFx0XHRyZXR1cm47XG5cbiAgICBcdH1cblxuICAgIFx0R2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG4gICAgXHR0aGlzLnR5cGUgPSAnRXh0cnVkZUdlb21ldHJ5JztcblxuICAgIFx0c2hhcGVzID0gQXJyYXkuaXNBcnJheSggc2hhcGVzICkgPyBzaGFwZXMgOiBbIHNoYXBlcyBdO1xuXG4gICAgXHR0aGlzLmFkZFNoYXBlTGlzdCggc2hhcGVzLCBvcHRpb25zICk7XG5cbiAgICBcdHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XG5cbiAgICBcdC8vIGNhbid0IHJlYWxseSB1c2UgYXV0b21hdGljIHZlcnRleCBub3JtYWxzXG4gICAgXHQvLyBhcyB0aGVuIGZyb250IGFuZCBiYWNrIHNpZGVzIGdldCBzbW9vdGhlZCB0b29cbiAgICBcdC8vIHNob3VsZCBkbyBzZXBhcmF0ZSBzbW9vdGhpbmcganVzdCBmb3Igc2lkZXNcblxuICAgIFx0Ly90aGlzLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7XG5cbiAgICBcdC8vY29uc29sZS5sb2coIFwidG9va1wiLCAoIERhdGUubm93KCkgLSBzdGFydFRpbWUgKSApO1xuXG4gICAgfVxuXG4gICAgRXh0cnVkZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEdlb21ldHJ5LnByb3RvdHlwZSApO1xuICAgIEV4dHJ1ZGVHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBFeHRydWRlR2VvbWV0cnk7XG5cbiAgICBFeHRydWRlR2VvbWV0cnkucHJvdG90eXBlLmFkZFNoYXBlTGlzdCA9IGZ1bmN0aW9uICggc2hhcGVzLCBvcHRpb25zICkge1xuXG4gICAgXHR2YXIgc2wgPSBzaGFwZXMubGVuZ3RoO1xuXG4gICAgXHRmb3IgKCB2YXIgcyA9IDA7IHMgPCBzbDsgcyArKyApIHtcblxuICAgIFx0XHR2YXIgc2hhcGUgPSBzaGFwZXNbIHMgXTtcbiAgICBcdFx0dGhpcy5hZGRTaGFwZSggc2hhcGUsIG9wdGlvbnMgKTtcblxuICAgIFx0fVxuXG4gICAgfTtcblxuICAgIEV4dHJ1ZGVHZW9tZXRyeS5wcm90b3R5cGUuYWRkU2hhcGUgPSBmdW5jdGlvbiAoIHNoYXBlLCBvcHRpb25zICkge1xuXG4gICAgXHR2YXIgYW1vdW50ID0gb3B0aW9ucy5hbW91bnQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYW1vdW50IDogMTAwO1xuXG4gICAgXHR2YXIgYmV2ZWxUaGlja25lc3MgPSBvcHRpb25zLmJldmVsVGhpY2tuZXNzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmJldmVsVGhpY2tuZXNzIDogNjsgLy8gMTBcbiAgICBcdHZhciBiZXZlbFNpemUgPSBvcHRpb25zLmJldmVsU2l6ZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5iZXZlbFNpemUgOiBiZXZlbFRoaWNrbmVzcyAtIDI7IC8vIDhcbiAgICBcdHZhciBiZXZlbFNlZ21lbnRzID0gb3B0aW9ucy5iZXZlbFNlZ21lbnRzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmJldmVsU2VnbWVudHMgOiAzO1xuXG4gICAgXHR2YXIgYmV2ZWxFbmFibGVkID0gb3B0aW9ucy5iZXZlbEVuYWJsZWQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYmV2ZWxFbmFibGVkIDogdHJ1ZTsgLy8gZmFsc2VcblxuICAgIFx0dmFyIGN1cnZlU2VnbWVudHMgPSBvcHRpb25zLmN1cnZlU2VnbWVudHMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY3VydmVTZWdtZW50cyA6IDEyO1xuXG4gICAgXHR2YXIgc3RlcHMgPSBvcHRpb25zLnN0ZXBzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnN0ZXBzIDogMTtcblxuICAgIFx0dmFyIGV4dHJ1ZGVQYXRoID0gb3B0aW9ucy5leHRydWRlUGF0aDtcbiAgICBcdHZhciBleHRydWRlUHRzLCBleHRydWRlQnlQYXRoID0gZmFsc2U7XG5cbiAgICBcdC8vIFVzZSBkZWZhdWx0IFdvcmxkVVZHZW5lcmF0b3IgaWYgbm8gVVYgZ2VuZXJhdG9ycyBhcmUgc3BlY2lmaWVkLlxuICAgIFx0dmFyIHV2Z2VuID0gb3B0aW9ucy5VVkdlbmVyYXRvciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5VVkdlbmVyYXRvciA6IEV4dHJ1ZGVHZW9tZXRyeS5Xb3JsZFVWR2VuZXJhdG9yO1xuXG4gICAgXHR2YXIgc3BsaW5lVHViZSwgYmlub3JtYWwsIG5vcm1hbCwgcG9zaXRpb24yO1xuICAgIFx0aWYgKCBleHRydWRlUGF0aCApIHtcblxuICAgIFx0XHRleHRydWRlUHRzID0gZXh0cnVkZVBhdGguZ2V0U3BhY2VkUG9pbnRzKCBzdGVwcyApO1xuXG4gICAgXHRcdGV4dHJ1ZGVCeVBhdGggPSB0cnVlO1xuICAgIFx0XHRiZXZlbEVuYWJsZWQgPSBmYWxzZTsgLy8gYmV2ZWxzIG5vdCBzdXBwb3J0ZWQgZm9yIHBhdGggZXh0cnVzaW9uXG5cbiAgICBcdFx0Ly8gU0VUVVAgVE5CIHZhcmlhYmxlc1xuXG4gICAgXHRcdC8vIFJldXNlIFROQiBmcm9tIFR1YmVHZW9tdHJ5IGZvciBub3cuXG4gICAgXHRcdC8vIFRPRE8xIC0gaGF2ZSBhIC5pc0Nsb3NlZCBpbiBzcGxpbmU/XG5cbiAgICBcdFx0c3BsaW5lVHViZSA9IG9wdGlvbnMuZnJhbWVzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmZyYW1lcyA6IG5ldyBUdWJlR2VvbWV0cnkuRnJlbmV0RnJhbWVzKCBleHRydWRlUGF0aCwgc3RlcHMsIGZhbHNlICk7XG5cbiAgICBcdFx0Ly8gY29uc29sZS5sb2coc3BsaW5lVHViZSwgJ3NwbGluZVR1YmUnLCBzcGxpbmVUdWJlLm5vcm1hbHMubGVuZ3RoLCAnc3RlcHMnLCBzdGVwcywgJ2V4dHJ1ZGVQdHMnLCBleHRydWRlUHRzLmxlbmd0aCk7XG5cbiAgICBcdFx0Ymlub3JtYWwgPSBuZXcgVmVjdG9yMygpO1xuICAgIFx0XHRub3JtYWwgPSBuZXcgVmVjdG9yMygpO1xuICAgIFx0XHRwb3NpdGlvbjIgPSBuZXcgVmVjdG9yMygpO1xuXG4gICAgXHR9XG5cbiAgICBcdC8vIFNhZmVndWFyZHMgaWYgYmV2ZWxzIGFyZSBub3QgZW5hYmxlZFxuXG4gICAgXHRpZiAoICEgYmV2ZWxFbmFibGVkICkge1xuXG4gICAgXHRcdGJldmVsU2VnbWVudHMgPSAwO1xuICAgIFx0XHRiZXZlbFRoaWNrbmVzcyA9IDA7XG4gICAgXHRcdGJldmVsU2l6ZSA9IDA7XG5cbiAgICBcdH1cblxuICAgIFx0Ly8gVmFyaWFibGVzIGluaXRpYWxpemF0aW9uXG5cbiAgICBcdHZhciBhaG9sZSwgaCwgaGw7IC8vIGxvb3Bpbmcgb2YgaG9sZXNcbiAgICBcdHZhciBzY29wZSA9IHRoaXM7XG5cbiAgICBcdHZhciBzaGFwZXNPZmZzZXQgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDtcblxuICAgIFx0dmFyIHNoYXBlUG9pbnRzID0gc2hhcGUuZXh0cmFjdFBvaW50cyggY3VydmVTZWdtZW50cyApO1xuXG4gICAgXHR2YXIgdmVydGljZXMgPSBzaGFwZVBvaW50cy5zaGFwZTtcbiAgICBcdHZhciBob2xlcyA9IHNoYXBlUG9pbnRzLmhvbGVzO1xuXG4gICAgXHR2YXIgcmV2ZXJzZSA9ICEgZXhwb3J0cy5TaGFwZVV0aWxzLmlzQ2xvY2tXaXNlKCB2ZXJ0aWNlcyApO1xuXG4gICAgXHRpZiAoIHJldmVyc2UgKSB7XG5cbiAgICBcdFx0dmVydGljZXMgPSB2ZXJ0aWNlcy5yZXZlcnNlKCk7XG5cbiAgICBcdFx0Ly8gTWF5YmUgd2Ugc2hvdWxkIGFsc28gY2hlY2sgaWYgaG9sZXMgYXJlIGluIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb24sIGp1c3QgdG8gYmUgc2FmZSAuLi5cblxuICAgIFx0XHRmb3IgKCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcblxuICAgIFx0XHRcdGFob2xlID0gaG9sZXNbIGggXTtcblxuICAgIFx0XHRcdGlmICggZXhwb3J0cy5TaGFwZVV0aWxzLmlzQ2xvY2tXaXNlKCBhaG9sZSApICkge1xuXG4gICAgXHRcdFx0XHRob2xlc1sgaCBdID0gYWhvbGUucmV2ZXJzZSgpO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXZlcnNlID0gZmFsc2U7IC8vIElmIHZlcnRpY2VzIGFyZSBpbiBvcmRlciBub3csIHdlIHNob3VsZG4ndCBuZWVkIHRvIHdvcnJ5IGFib3V0IHRoZW0gYWdhaW4gKGhvcGVmdWxseSkhXG5cbiAgICBcdH1cblxuXG4gICAgXHR2YXIgZmFjZXMgPSBleHBvcnRzLlNoYXBlVXRpbHMudHJpYW5ndWxhdGVTaGFwZSggdmVydGljZXMsIGhvbGVzICk7XG5cbiAgICBcdC8qIFZlcnRpY2VzICovXG5cbiAgICBcdHZhciBjb250b3VyID0gdmVydGljZXM7IC8vIHZlcnRpY2VzIGhhcyBhbGwgcG9pbnRzIGJ1dCBjb250b3VyIGhhcyBvbmx5IHBvaW50cyBvZiBjaXJjdW1mZXJlbmNlXG5cbiAgICBcdGZvciAoIGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xuXG4gICAgXHRcdGFob2xlID0gaG9sZXNbIGggXTtcblxuICAgIFx0XHR2ZXJ0aWNlcyA9IHZlcnRpY2VzLmNvbmNhdCggYWhvbGUgKTtcblxuICAgIFx0fVxuXG5cbiAgICBcdGZ1bmN0aW9uIHNjYWxlUHQyKCBwdCwgdmVjLCBzaXplICkge1xuXG4gICAgXHRcdGlmICggISB2ZWMgKSBjb25zb2xlLmVycm9yKCBcIlRIUkVFLkV4dHJ1ZGVHZW9tZXRyeTogdmVjIGRvZXMgbm90IGV4aXN0XCIgKTtcblxuICAgIFx0XHRyZXR1cm4gdmVjLmNsb25lKCkubXVsdGlwbHlTY2FsYXIoIHNpemUgKS5hZGQoIHB0ICk7XG5cbiAgICBcdH1cblxuICAgIFx0dmFyIGIsIGJzLCB0LCB6LFxuICAgIFx0XHR2ZXJ0LCB2bGVuID0gdmVydGljZXMubGVuZ3RoLFxuICAgIFx0XHRmYWNlLCBmbGVuID0gZmFjZXMubGVuZ3RoO1xuXG5cbiAgICBcdC8vIEZpbmQgZGlyZWN0aW9ucyBmb3IgcG9pbnQgbW92ZW1lbnRcblxuXG4gICAgXHRmdW5jdGlvbiBnZXRCZXZlbFZlYyggaW5QdCwgaW5QcmV2LCBpbk5leHQgKSB7XG5cbiAgICBcdFx0Ly8gY29tcHV0ZXMgZm9yIGluUHQgdGhlIGNvcnJlc3BvbmRpbmcgcG9pbnQgaW5QdCcgb24gYSBuZXcgY29udG91clxuICAgIFx0XHQvLyAgIHNoaWZ0ZWQgYnkgMSB1bml0IChsZW5ndGggb2Ygbm9ybWFsaXplZCB2ZWN0b3IpIHRvIHRoZSBsZWZ0XG4gICAgXHRcdC8vIGlmIHdlIHdhbGsgYWxvbmcgY29udG91ciBjbG9ja3dpc2UsIHRoaXMgbmV3IGNvbnRvdXIgaXMgb3V0c2lkZSB0aGUgb2xkIG9uZVxuICAgIFx0XHQvL1xuICAgIFx0XHQvLyBpblB0JyBpcyB0aGUgaW50ZXJzZWN0aW9uIG9mIHRoZSB0d28gbGluZXMgcGFyYWxsZWwgdG8gdGhlIHR3b1xuICAgIFx0XHQvLyAgYWRqYWNlbnQgZWRnZXMgb2YgaW5QdCBhdCBhIGRpc3RhbmNlIG9mIDEgdW5pdCBvbiB0aGUgbGVmdCBzaWRlLlxuXG4gICAgXHRcdHZhciB2X3RyYW5zX3gsIHZfdHJhbnNfeSwgc2hyaW5rX2J5ID0gMTtcdFx0Ly8gcmVzdWx0aW5nIHRyYW5zbGF0aW9uIHZlY3RvciBmb3IgaW5QdFxuXG4gICAgXHRcdC8vIGdvb2QgcmVhZGluZyBmb3IgZ2VvbWV0cnkgYWxnb3JpdGhtcyAoaGVyZTogbGluZS1saW5lIGludGVyc2VjdGlvbilcbiAgICBcdFx0Ly8gaHR0cDovL2dlb21hbGdvcml0aG1zLmNvbS9hMDUtX2ludGVyc2VjdC0xLmh0bWxcblxuICAgIFx0XHR2YXIgdl9wcmV2X3ggPSBpblB0LnggLSBpblByZXYueCwgdl9wcmV2X3kgPSBpblB0LnkgLSBpblByZXYueTtcbiAgICBcdFx0dmFyIHZfbmV4dF94ID0gaW5OZXh0LnggLSBpblB0LngsIHZfbmV4dF95ID0gaW5OZXh0LnkgLSBpblB0Lnk7XG5cbiAgICBcdFx0dmFyIHZfcHJldl9sZW5zcSA9ICggdl9wcmV2X3ggKiB2X3ByZXZfeCArIHZfcHJldl95ICogdl9wcmV2X3kgKTtcblxuICAgIFx0XHQvLyBjaGVjayBmb3IgY29sbGluZWFyIGVkZ2VzXG4gICAgXHRcdHZhciBjb2xsaW5lYXIwID0gKCB2X3ByZXZfeCAqIHZfbmV4dF95IC0gdl9wcmV2X3kgKiB2X25leHRfeCApO1xuXG4gICAgXHRcdGlmICggTWF0aC5hYnMoIGNvbGxpbmVhcjAgKSA+IE51bWJlci5FUFNJTE9OICkge1xuXG4gICAgXHRcdFx0Ly8gbm90IGNvbGxpbmVhclxuXG4gICAgXHRcdFx0Ly8gbGVuZ3RoIG9mIHZlY3RvcnMgZm9yIG5vcm1hbGl6aW5nXG5cbiAgICBcdFx0XHR2YXIgdl9wcmV2X2xlbiA9IE1hdGguc3FydCggdl9wcmV2X2xlbnNxICk7XG4gICAgXHRcdFx0dmFyIHZfbmV4dF9sZW4gPSBNYXRoLnNxcnQoIHZfbmV4dF94ICogdl9uZXh0X3ggKyB2X25leHRfeSAqIHZfbmV4dF95ICk7XG5cbiAgICBcdFx0XHQvLyBzaGlmdCBhZGphY2VudCBwb2ludHMgYnkgdW5pdCB2ZWN0b3JzIHRvIHRoZSBsZWZ0XG5cbiAgICBcdFx0XHR2YXIgcHRQcmV2U2hpZnRfeCA9ICggaW5QcmV2LnggLSB2X3ByZXZfeSAvIHZfcHJldl9sZW4gKTtcbiAgICBcdFx0XHR2YXIgcHRQcmV2U2hpZnRfeSA9ICggaW5QcmV2LnkgKyB2X3ByZXZfeCAvIHZfcHJldl9sZW4gKTtcblxuICAgIFx0XHRcdHZhciBwdE5leHRTaGlmdF94ID0gKCBpbk5leHQueCAtIHZfbmV4dF95IC8gdl9uZXh0X2xlbiApO1xuICAgIFx0XHRcdHZhciBwdE5leHRTaGlmdF95ID0gKCBpbk5leHQueSArIHZfbmV4dF94IC8gdl9uZXh0X2xlbiApO1xuXG4gICAgXHRcdFx0Ly8gc2NhbGluZyBmYWN0b3IgZm9yIHZfcHJldiB0byBpbnRlcnNlY3Rpb24gcG9pbnRcblxuICAgIFx0XHRcdHZhciBzZiA9ICggICggcHROZXh0U2hpZnRfeCAtIHB0UHJldlNoaWZ0X3ggKSAqIHZfbmV4dF95IC1cbiAgICBcdFx0XHRcdFx0XHQoIHB0TmV4dFNoaWZ0X3kgLSBwdFByZXZTaGlmdF95ICkgKiB2X25leHRfeCAgICApIC9cbiAgICBcdFx0XHRcdFx0ICAoIHZfcHJldl94ICogdl9uZXh0X3kgLSB2X3ByZXZfeSAqIHZfbmV4dF94ICk7XG5cbiAgICBcdFx0XHQvLyB2ZWN0b3IgZnJvbSBpblB0IHRvIGludGVyc2VjdGlvbiBwb2ludFxuXG4gICAgXHRcdFx0dl90cmFuc194ID0gKCBwdFByZXZTaGlmdF94ICsgdl9wcmV2X3ggKiBzZiAtIGluUHQueCApO1xuICAgIFx0XHRcdHZfdHJhbnNfeSA9ICggcHRQcmV2U2hpZnRfeSArIHZfcHJldl95ICogc2YgLSBpblB0LnkgKTtcblxuICAgIFx0XHRcdC8vIERvbid0IG5vcm1hbGl6ZSEsIG90aGVyd2lzZSBzaGFycCBjb3JuZXJzIGJlY29tZSB1Z2x5XG4gICAgXHRcdFx0Ly8gIGJ1dCBwcmV2ZW50IGNyYXp5IHNwaWtlc1xuICAgIFx0XHRcdHZhciB2X3RyYW5zX2xlbnNxID0gKCB2X3RyYW5zX3ggKiB2X3RyYW5zX3ggKyB2X3RyYW5zX3kgKiB2X3RyYW5zX3kgKTtcbiAgICBcdFx0XHRpZiAoIHZfdHJhbnNfbGVuc3EgPD0gMiApIHtcblxuICAgIFx0XHRcdFx0cmV0dXJuXHRuZXcgVmVjdG9yMiggdl90cmFuc194LCB2X3RyYW5zX3kgKTtcblxuICAgIFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdHNocmlua19ieSA9IE1hdGguc3FydCggdl90cmFuc19sZW5zcSAvIDIgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0Ly8gaGFuZGxlIHNwZWNpYWwgY2FzZSBvZiBjb2xsaW5lYXIgZWRnZXNcblxuICAgIFx0XHRcdHZhciBkaXJlY3Rpb25fZXEgPSBmYWxzZTtcdFx0Ly8gYXNzdW1lczogb3Bwb3NpdGVcbiAgICBcdFx0XHRpZiAoIHZfcHJldl94ID4gTnVtYmVyLkVQU0lMT04gKSB7XG5cbiAgICBcdFx0XHRcdGlmICggdl9uZXh0X3ggPiBOdW1iZXIuRVBTSUxPTiApIHtcblxuICAgIFx0XHRcdFx0XHRkaXJlY3Rpb25fZXEgPSB0cnVlO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRpZiAoIHZfcHJldl94IDwgLSBOdW1iZXIuRVBTSUxPTiApIHtcblxuICAgIFx0XHRcdFx0XHRpZiAoIHZfbmV4dF94IDwgLSBOdW1iZXIuRVBTSUxPTiApIHtcblxuICAgIFx0XHRcdFx0XHRcdGRpcmVjdGlvbl9lcSA9IHRydWU7XG5cbiAgICBcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRcdGlmICggTWF0aC5zaWduKCB2X3ByZXZfeSApID09PSBNYXRoLnNpZ24oIHZfbmV4dF95ICkgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHRkaXJlY3Rpb25fZXEgPSB0cnVlO1xuXG4gICAgXHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0aWYgKCBkaXJlY3Rpb25fZXEgKSB7XG5cbiAgICBcdFx0XHRcdC8vIGNvbnNvbGUubG9nKFwiV2FybmluZzogbGluZXMgYXJlIGEgc3RyYWlnaHQgc2VxdWVuY2VcIik7XG4gICAgXHRcdFx0XHR2X3RyYW5zX3ggPSAtIHZfcHJldl95O1xuICAgIFx0XHRcdFx0dl90cmFuc195ID0gIHZfcHJldl94O1xuICAgIFx0XHRcdFx0c2hyaW5rX2J5ID0gTWF0aC5zcXJ0KCB2X3ByZXZfbGVuc3EgKTtcblxuICAgIFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdC8vIGNvbnNvbGUubG9nKFwiV2FybmluZzogbGluZXMgYXJlIGEgc3RyYWlnaHQgc3Bpa2VcIik7XG4gICAgXHRcdFx0XHR2X3RyYW5zX3ggPSB2X3ByZXZfeDtcbiAgICBcdFx0XHRcdHZfdHJhbnNfeSA9IHZfcHJldl95O1xuICAgIFx0XHRcdFx0c2hyaW5rX2J5ID0gTWF0aC5zcXJ0KCB2X3ByZXZfbGVuc3EgLyAyICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVyblx0bmV3IFZlY3RvcjIoIHZfdHJhbnNfeCAvIHNocmlua19ieSwgdl90cmFuc195IC8gc2hyaW5rX2J5ICk7XG5cbiAgICBcdH1cblxuXG4gICAgXHR2YXIgY29udG91ck1vdmVtZW50cyA9IFtdO1xuXG4gICAgXHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gY29udG91ci5sZW5ndGgsIGogPSBpbCAtIDEsIGsgPSBpICsgMTsgaSA8IGlsOyBpICsrLCBqICsrLCBrICsrICkge1xuXG4gICAgXHRcdGlmICggaiA9PT0gaWwgKSBqID0gMDtcbiAgICBcdFx0aWYgKCBrID09PSBpbCApIGsgPSAwO1xuXG4gICAgXHRcdC8vICAoaiktLS0oaSktLS0oaylcbiAgICBcdFx0Ly8gY29uc29sZS5sb2coJ2ksaixrJywgaSwgaiAsIGspXG5cbiAgICBcdFx0Y29udG91ck1vdmVtZW50c1sgaSBdID0gZ2V0QmV2ZWxWZWMoIGNvbnRvdXJbIGkgXSwgY29udG91clsgaiBdLCBjb250b3VyWyBrIF0gKTtcblxuICAgIFx0fVxuXG4gICAgXHR2YXIgaG9sZXNNb3ZlbWVudHMgPSBbXSwgb25lSG9sZU1vdmVtZW50cywgdmVydGljZXNNb3ZlbWVudHMgPSBjb250b3VyTW92ZW1lbnRzLmNvbmNhdCgpO1xuXG4gICAgXHRmb3IgKCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcblxuICAgIFx0XHRhaG9sZSA9IGhvbGVzWyBoIF07XG5cbiAgICBcdFx0b25lSG9sZU1vdmVtZW50cyA9IFtdO1xuXG4gICAgXHRcdGZvciAoIGkgPSAwLCBpbCA9IGFob2xlLmxlbmd0aCwgaiA9IGlsIC0gMSwgayA9IGkgKyAxOyBpIDwgaWw7IGkgKyssIGogKyssIGsgKysgKSB7XG5cbiAgICBcdFx0XHRpZiAoIGogPT09IGlsICkgaiA9IDA7XG4gICAgXHRcdFx0aWYgKCBrID09PSBpbCApIGsgPSAwO1xuXG4gICAgXHRcdFx0Ly8gIChqKS0tLShpKS0tLShrKVxuICAgIFx0XHRcdG9uZUhvbGVNb3ZlbWVudHNbIGkgXSA9IGdldEJldmVsVmVjKCBhaG9sZVsgaSBdLCBhaG9sZVsgaiBdLCBhaG9sZVsgayBdICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGhvbGVzTW92ZW1lbnRzLnB1c2goIG9uZUhvbGVNb3ZlbWVudHMgKTtcbiAgICBcdFx0dmVydGljZXNNb3ZlbWVudHMgPSB2ZXJ0aWNlc01vdmVtZW50cy5jb25jYXQoIG9uZUhvbGVNb3ZlbWVudHMgKTtcblxuICAgIFx0fVxuXG5cbiAgICBcdC8vIExvb3AgYmV2ZWxTZWdtZW50cywgMSBmb3IgdGhlIGZyb250LCAxIGZvciB0aGUgYmFja1xuXG4gICAgXHRmb3IgKCBiID0gMDsgYiA8IGJldmVsU2VnbWVudHM7IGIgKysgKSB7XG5cbiAgICBcdFx0Ly9mb3IgKCBiID0gYmV2ZWxTZWdtZW50czsgYiA+IDA7IGIgLS0gKSB7XG5cbiAgICBcdFx0dCA9IGIgLyBiZXZlbFNlZ21lbnRzO1xuICAgIFx0XHR6ID0gYmV2ZWxUaGlja25lc3MgKiBNYXRoLmNvcyggdCAqIE1hdGguUEkgLyAyICk7XG4gICAgXHRcdGJzID0gYmV2ZWxTaXplICogTWF0aC5zaW4oIHQgKiBNYXRoLlBJIC8gMiApO1xuXG4gICAgXHRcdC8vIGNvbnRyYWN0IHNoYXBlXG5cbiAgICBcdFx0Zm9yICggaSA9IDAsIGlsID0gY29udG91ci5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgIFx0XHRcdHZlcnQgPSBzY2FsZVB0MiggY29udG91clsgaSBdLCBjb250b3VyTW92ZW1lbnRzWyBpIF0sIGJzICk7XG5cbiAgICBcdFx0XHR2KCB2ZXJ0LngsIHZlcnQueSwgIC0geiApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHQvLyBleHBhbmQgaG9sZXNcblxuICAgIFx0XHRmb3IgKCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcblxuICAgIFx0XHRcdGFob2xlID0gaG9sZXNbIGggXTtcbiAgICBcdFx0XHRvbmVIb2xlTW92ZW1lbnRzID0gaG9sZXNNb3ZlbWVudHNbIGggXTtcblxuICAgIFx0XHRcdGZvciAoIGkgPSAwLCBpbCA9IGFob2xlLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgXHRcdFx0XHR2ZXJ0ID0gc2NhbGVQdDIoIGFob2xlWyBpIF0sIG9uZUhvbGVNb3ZlbWVudHNbIGkgXSwgYnMgKTtcblxuICAgIFx0XHRcdFx0diggdmVydC54LCB2ZXJ0LnksICAtIHogKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdH1cblxuICAgIFx0YnMgPSBiZXZlbFNpemU7XG5cbiAgICBcdC8vIEJhY2sgZmFjaW5nIHZlcnRpY2VzXG5cbiAgICBcdGZvciAoIGkgPSAwOyBpIDwgdmxlbjsgaSArKyApIHtcblxuICAgIFx0XHR2ZXJ0ID0gYmV2ZWxFbmFibGVkID8gc2NhbGVQdDIoIHZlcnRpY2VzWyBpIF0sIHZlcnRpY2VzTW92ZW1lbnRzWyBpIF0sIGJzICkgOiB2ZXJ0aWNlc1sgaSBdO1xuXG4gICAgXHRcdGlmICggISBleHRydWRlQnlQYXRoICkge1xuXG4gICAgXHRcdFx0diggdmVydC54LCB2ZXJ0LnksIDAgKTtcblxuICAgIFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0Ly8gdiggdmVydC54LCB2ZXJ0LnkgKyBleHRydWRlUHRzWyAwIF0ueSwgZXh0cnVkZVB0c1sgMCBdLnggKTtcblxuICAgIFx0XHRcdG5vcm1hbC5jb3B5KCBzcGxpbmVUdWJlLm5vcm1hbHNbIDAgXSApLm11bHRpcGx5U2NhbGFyKCB2ZXJ0LnggKTtcbiAgICBcdFx0XHRiaW5vcm1hbC5jb3B5KCBzcGxpbmVUdWJlLmJpbm9ybWFsc1sgMCBdICkubXVsdGlwbHlTY2FsYXIoIHZlcnQueSApO1xuXG4gICAgXHRcdFx0cG9zaXRpb24yLmNvcHkoIGV4dHJ1ZGVQdHNbIDAgXSApLmFkZCggbm9ybWFsICkuYWRkKCBiaW5vcm1hbCApO1xuXG4gICAgXHRcdFx0diggcG9zaXRpb24yLngsIHBvc2l0aW9uMi55LCBwb3NpdGlvbjIueiApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0fVxuXG4gICAgXHQvLyBBZGQgc3RlcHBlZCB2ZXJ0aWNlcy4uLlxuICAgIFx0Ly8gSW5jbHVkaW5nIGZyb250IGZhY2luZyB2ZXJ0aWNlc1xuXG4gICAgXHR2YXIgcztcblxuICAgIFx0Zm9yICggcyA9IDE7IHMgPD0gc3RlcHM7IHMgKysgKSB7XG5cbiAgICBcdFx0Zm9yICggaSA9IDA7IGkgPCB2bGVuOyBpICsrICkge1xuXG4gICAgXHRcdFx0dmVydCA9IGJldmVsRW5hYmxlZCA/IHNjYWxlUHQyKCB2ZXJ0aWNlc1sgaSBdLCB2ZXJ0aWNlc01vdmVtZW50c1sgaSBdLCBicyApIDogdmVydGljZXNbIGkgXTtcblxuICAgIFx0XHRcdGlmICggISBleHRydWRlQnlQYXRoICkge1xuXG4gICAgXHRcdFx0XHR2KCB2ZXJ0LngsIHZlcnQueSwgYW1vdW50IC8gc3RlcHMgKiBzICk7XG5cbiAgICBcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHQvLyB2KCB2ZXJ0LngsIHZlcnQueSArIGV4dHJ1ZGVQdHNbIHMgLSAxIF0ueSwgZXh0cnVkZVB0c1sgcyAtIDEgXS54ICk7XG5cbiAgICBcdFx0XHRcdG5vcm1hbC5jb3B5KCBzcGxpbmVUdWJlLm5vcm1hbHNbIHMgXSApLm11bHRpcGx5U2NhbGFyKCB2ZXJ0LnggKTtcbiAgICBcdFx0XHRcdGJpbm9ybWFsLmNvcHkoIHNwbGluZVR1YmUuYmlub3JtYWxzWyBzIF0gKS5tdWx0aXBseVNjYWxhciggdmVydC55ICk7XG5cbiAgICBcdFx0XHRcdHBvc2l0aW9uMi5jb3B5KCBleHRydWRlUHRzWyBzIF0gKS5hZGQoIG5vcm1hbCApLmFkZCggYmlub3JtYWwgKTtcblxuICAgIFx0XHRcdFx0diggcG9zaXRpb24yLngsIHBvc2l0aW9uMi55LCBwb3NpdGlvbjIueiApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0fVxuXG5cbiAgICBcdC8vIEFkZCBiZXZlbCBzZWdtZW50cyBwbGFuZXNcblxuICAgIFx0Ly9mb3IgKCBiID0gMTsgYiA8PSBiZXZlbFNlZ21lbnRzOyBiICsrICkge1xuICAgIFx0Zm9yICggYiA9IGJldmVsU2VnbWVudHMgLSAxOyBiID49IDA7IGIgLS0gKSB7XG5cbiAgICBcdFx0dCA9IGIgLyBiZXZlbFNlZ21lbnRzO1xuICAgIFx0XHR6ID0gYmV2ZWxUaGlja25lc3MgKiBNYXRoLmNvcyAoIHQgKiBNYXRoLlBJIC8gMiApO1xuICAgIFx0XHRicyA9IGJldmVsU2l6ZSAqIE1hdGguc2luKCB0ICogTWF0aC5QSSAvIDIgKTtcblxuICAgIFx0XHQvLyBjb250cmFjdCBzaGFwZVxuXG4gICAgXHRcdGZvciAoIGkgPSAwLCBpbCA9IGNvbnRvdXIubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICBcdFx0XHR2ZXJ0ID0gc2NhbGVQdDIoIGNvbnRvdXJbIGkgXSwgY29udG91ck1vdmVtZW50c1sgaSBdLCBicyApO1xuICAgIFx0XHRcdHYoIHZlcnQueCwgdmVydC55LCAgYW1vdW50ICsgeiApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHQvLyBleHBhbmQgaG9sZXNcblxuICAgIFx0XHRmb3IgKCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcblxuICAgIFx0XHRcdGFob2xlID0gaG9sZXNbIGggXTtcbiAgICBcdFx0XHRvbmVIb2xlTW92ZW1lbnRzID0gaG9sZXNNb3ZlbWVudHNbIGggXTtcblxuICAgIFx0XHRcdGZvciAoIGkgPSAwLCBpbCA9IGFob2xlLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgXHRcdFx0XHR2ZXJ0ID0gc2NhbGVQdDIoIGFob2xlWyBpIF0sIG9uZUhvbGVNb3ZlbWVudHNbIGkgXSwgYnMgKTtcblxuICAgIFx0XHRcdFx0aWYgKCAhIGV4dHJ1ZGVCeVBhdGggKSB7XG5cbiAgICBcdFx0XHRcdFx0diggdmVydC54LCB2ZXJ0LnksICBhbW91bnQgKyB6ICk7XG5cbiAgICBcdFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdFx0diggdmVydC54LCB2ZXJ0LnkgKyBleHRydWRlUHRzWyBzdGVwcyAtIDEgXS55LCBleHRydWRlUHRzWyBzdGVwcyAtIDEgXS54ICsgeiApO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9XG5cbiAgICBcdC8qIEZhY2VzICovXG5cbiAgICBcdC8vIFRvcCBhbmQgYm90dG9tIGZhY2VzXG5cbiAgICBcdGJ1aWxkTGlkRmFjZXMoKTtcblxuICAgIFx0Ly8gU2lkZXMgZmFjZXNcblxuICAgIFx0YnVpbGRTaWRlRmFjZXMoKTtcblxuXG4gICAgXHQvLy8vLyAgSW50ZXJuYWwgZnVuY3Rpb25zXG5cbiAgICBcdGZ1bmN0aW9uIGJ1aWxkTGlkRmFjZXMoKSB7XG5cbiAgICBcdFx0aWYgKCBiZXZlbEVuYWJsZWQgKSB7XG5cbiAgICBcdFx0XHR2YXIgbGF5ZXIgPSAwOyAvLyBzdGVwcyArIDFcbiAgICBcdFx0XHR2YXIgb2Zmc2V0ID0gdmxlbiAqIGxheWVyO1xuXG4gICAgXHRcdFx0Ly8gQm90dG9tIGZhY2VzXG5cbiAgICBcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGZsZW47IGkgKysgKSB7XG5cbiAgICBcdFx0XHRcdGZhY2UgPSBmYWNlc1sgaSBdO1xuICAgIFx0XHRcdFx0ZjMoIGZhY2VbIDIgXSArIG9mZnNldCwgZmFjZVsgMSBdICsgb2Zmc2V0LCBmYWNlWyAwIF0gKyBvZmZzZXQgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGxheWVyID0gc3RlcHMgKyBiZXZlbFNlZ21lbnRzICogMjtcbiAgICBcdFx0XHRvZmZzZXQgPSB2bGVuICogbGF5ZXI7XG5cbiAgICBcdFx0XHQvLyBUb3AgZmFjZXNcblxuICAgIFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgZmxlbjsgaSArKyApIHtcblxuICAgIFx0XHRcdFx0ZmFjZSA9IGZhY2VzWyBpIF07XG4gICAgXHRcdFx0XHRmMyggZmFjZVsgMCBdICsgb2Zmc2V0LCBmYWNlWyAxIF0gKyBvZmZzZXQsIGZhY2VbIDIgXSArIG9mZnNldCApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHQvLyBCb3R0b20gZmFjZXNcblxuICAgIFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgZmxlbjsgaSArKyApIHtcblxuICAgIFx0XHRcdFx0ZmFjZSA9IGZhY2VzWyBpIF07XG4gICAgXHRcdFx0XHRmMyggZmFjZVsgMiBdLCBmYWNlWyAxIF0sIGZhY2VbIDAgXSApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0Ly8gVG9wIGZhY2VzXG5cbiAgICBcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGZsZW47IGkgKysgKSB7XG5cbiAgICBcdFx0XHRcdGZhY2UgPSBmYWNlc1sgaSBdO1xuICAgIFx0XHRcdFx0ZjMoIGZhY2VbIDAgXSArIHZsZW4gKiBzdGVwcywgZmFjZVsgMSBdICsgdmxlbiAqIHN0ZXBzLCBmYWNlWyAyIF0gKyB2bGVuICogc3RlcHMgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdH1cblxuICAgIFx0Ly8gQ3JlYXRlIGZhY2VzIGZvciB0aGUgei1zaWRlcyBvZiB0aGUgc2hhcGVcblxuICAgIFx0ZnVuY3Rpb24gYnVpbGRTaWRlRmFjZXMoKSB7XG5cbiAgICBcdFx0dmFyIGxheWVyb2Zmc2V0ID0gMDtcbiAgICBcdFx0c2lkZXdhbGxzKCBjb250b3VyLCBsYXllcm9mZnNldCApO1xuICAgIFx0XHRsYXllcm9mZnNldCArPSBjb250b3VyLmxlbmd0aDtcblxuICAgIFx0XHRmb3IgKCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcblxuICAgIFx0XHRcdGFob2xlID0gaG9sZXNbIGggXTtcbiAgICBcdFx0XHRzaWRld2FsbHMoIGFob2xlLCBsYXllcm9mZnNldCApO1xuXG4gICAgXHRcdFx0Ly8sIHRydWVcbiAgICBcdFx0XHRsYXllcm9mZnNldCArPSBhaG9sZS5sZW5ndGg7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9XG5cbiAgICBcdGZ1bmN0aW9uIHNpZGV3YWxscyggY29udG91ciwgbGF5ZXJvZmZzZXQgKSB7XG5cbiAgICBcdFx0dmFyIGosIGs7XG4gICAgXHRcdGkgPSBjb250b3VyLmxlbmd0aDtcblxuICAgIFx0XHR3aGlsZSAoIC0tIGkgPj0gMCApIHtcblxuICAgIFx0XHRcdGogPSBpO1xuICAgIFx0XHRcdGsgPSBpIC0gMTtcbiAgICBcdFx0XHRpZiAoIGsgPCAwICkgayA9IGNvbnRvdXIubGVuZ3RoIC0gMTtcblxuICAgIFx0XHRcdC8vY29uc29sZS5sb2coJ2InLCBpLGosIGktMSwgayx2ZXJ0aWNlcy5sZW5ndGgpO1xuXG4gICAgXHRcdFx0dmFyIHMgPSAwLCBzbCA9IHN0ZXBzICArIGJldmVsU2VnbWVudHMgKiAyO1xuXG4gICAgXHRcdFx0Zm9yICggcyA9IDA7IHMgPCBzbDsgcyArKyApIHtcblxuICAgIFx0XHRcdFx0dmFyIHNsZW4xID0gdmxlbiAqIHM7XG4gICAgXHRcdFx0XHR2YXIgc2xlbjIgPSB2bGVuICogKCBzICsgMSApO1xuXG4gICAgXHRcdFx0XHR2YXIgYSA9IGxheWVyb2Zmc2V0ICsgaiArIHNsZW4xLFxuICAgIFx0XHRcdFx0XHRiID0gbGF5ZXJvZmZzZXQgKyBrICsgc2xlbjEsXG4gICAgXHRcdFx0XHRcdGMgPSBsYXllcm9mZnNldCArIGsgKyBzbGVuMixcbiAgICBcdFx0XHRcdFx0ZCA9IGxheWVyb2Zmc2V0ICsgaiArIHNsZW4yO1xuXG4gICAgXHRcdFx0XHRmNCggYSwgYiwgYywgZCwgY29udG91ciwgcywgc2wsIGosIGsgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdH1cblxuXG4gICAgXHRmdW5jdGlvbiB2KCB4LCB5LCB6ICkge1xuXG4gICAgXHRcdHNjb3BlLnZlcnRpY2VzLnB1c2goIG5ldyBWZWN0b3IzKCB4LCB5LCB6ICkgKTtcblxuICAgIFx0fVxuXG4gICAgXHRmdW5jdGlvbiBmMyggYSwgYiwgYyApIHtcblxuICAgIFx0XHRhICs9IHNoYXBlc09mZnNldDtcbiAgICBcdFx0YiArPSBzaGFwZXNPZmZzZXQ7XG4gICAgXHRcdGMgKz0gc2hhcGVzT2Zmc2V0O1xuXG4gICAgXHRcdHNjb3BlLmZhY2VzLnB1c2goIG5ldyBGYWNlMyggYSwgYiwgYywgbnVsbCwgbnVsbCwgMCApICk7XG5cbiAgICBcdFx0dmFyIHV2cyA9IHV2Z2VuLmdlbmVyYXRlVG9wVVYoIHNjb3BlLCBhLCBiLCBjICk7XG5cbiAgICBcdFx0c2NvcGUuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIHV2cyApO1xuXG4gICAgXHR9XG5cbiAgICBcdGZ1bmN0aW9uIGY0KCBhLCBiLCBjLCBkLCB3YWxsQ29udG91ciwgc3RlcEluZGV4LCBzdGVwc0xlbmd0aCwgY29udG91ckluZGV4MSwgY29udG91ckluZGV4MiApIHtcblxuICAgIFx0XHRhICs9IHNoYXBlc09mZnNldDtcbiAgICBcdFx0YiArPSBzaGFwZXNPZmZzZXQ7XG4gICAgXHRcdGMgKz0gc2hhcGVzT2Zmc2V0O1xuICAgIFx0XHRkICs9IHNoYXBlc09mZnNldDtcblxuICAgIFx0XHRzY29wZS5mYWNlcy5wdXNoKCBuZXcgRmFjZTMoIGEsIGIsIGQsIG51bGwsIG51bGwsIDEgKSApO1xuICAgIFx0XHRzY29wZS5mYWNlcy5wdXNoKCBuZXcgRmFjZTMoIGIsIGMsIGQsIG51bGwsIG51bGwsIDEgKSApO1xuXG4gICAgXHRcdHZhciB1dnMgPSB1dmdlbi5nZW5lcmF0ZVNpZGVXYWxsVVYoIHNjb3BlLCBhLCBiLCBjLCBkICk7XG5cbiAgICBcdFx0c2NvcGUuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZzWyAwIF0sIHV2c1sgMSBdLCB1dnNbIDMgXSBdICk7XG4gICAgXHRcdHNjb3BlLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2c1sgMSBdLCB1dnNbIDIgXSwgdXZzWyAzIF0gXSApO1xuXG4gICAgXHR9XG5cbiAgICB9O1xuXG4gICAgRXh0cnVkZUdlb21ldHJ5LldvcmxkVVZHZW5lcmF0b3IgPSB7XG5cbiAgICBcdGdlbmVyYXRlVG9wVVY6IGZ1bmN0aW9uICggZ2VvbWV0cnksIGluZGV4QSwgaW5kZXhCLCBpbmRleEMgKSB7XG5cbiAgICBcdFx0dmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXM7XG5cbiAgICBcdFx0dmFyIGEgPSB2ZXJ0aWNlc1sgaW5kZXhBIF07XG4gICAgXHRcdHZhciBiID0gdmVydGljZXNbIGluZGV4QiBdO1xuICAgIFx0XHR2YXIgYyA9IHZlcnRpY2VzWyBpbmRleEMgXTtcblxuICAgIFx0XHRyZXR1cm4gW1xuICAgIFx0XHRcdG5ldyBWZWN0b3IyKCBhLngsIGEueSApLFxuICAgIFx0XHRcdG5ldyBWZWN0b3IyKCBiLngsIGIueSApLFxuICAgIFx0XHRcdG5ldyBWZWN0b3IyKCBjLngsIGMueSApXG4gICAgXHRcdF07XG5cbiAgICBcdH0sXG5cbiAgICBcdGdlbmVyYXRlU2lkZVdhbGxVVjogZnVuY3Rpb24gKCBnZW9tZXRyeSwgaW5kZXhBLCBpbmRleEIsIGluZGV4QywgaW5kZXhEICkge1xuXG4gICAgXHRcdHZhciB2ZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzO1xuXG4gICAgXHRcdHZhciBhID0gdmVydGljZXNbIGluZGV4QSBdO1xuICAgIFx0XHR2YXIgYiA9IHZlcnRpY2VzWyBpbmRleEIgXTtcbiAgICBcdFx0dmFyIGMgPSB2ZXJ0aWNlc1sgaW5kZXhDIF07XG4gICAgXHRcdHZhciBkID0gdmVydGljZXNbIGluZGV4RCBdO1xuXG4gICAgXHRcdGlmICggTWF0aC5hYnMoIGEueSAtIGIueSApIDwgMC4wMSApIHtcblxuICAgIFx0XHRcdHJldHVybiBbXG4gICAgXHRcdFx0XHRuZXcgVmVjdG9yMiggYS54LCAxIC0gYS56ICksXG4gICAgXHRcdFx0XHRuZXcgVmVjdG9yMiggYi54LCAxIC0gYi56ICksXG4gICAgXHRcdFx0XHRuZXcgVmVjdG9yMiggYy54LCAxIC0gYy56ICksXG4gICAgXHRcdFx0XHRuZXcgVmVjdG9yMiggZC54LCAxIC0gZC56IClcbiAgICBcdFx0XHRdO1xuXG4gICAgXHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRyZXR1cm4gW1xuICAgIFx0XHRcdFx0bmV3IFZlY3RvcjIoIGEueSwgMSAtIGEueiApLFxuICAgIFx0XHRcdFx0bmV3IFZlY3RvcjIoIGIueSwgMSAtIGIueiApLFxuICAgIFx0XHRcdFx0bmV3IFZlY3RvcjIoIGMueSwgMSAtIGMueiApLFxuICAgIFx0XHRcdFx0bmV3IFZlY3RvcjIoIGQueSwgMSAtIGQueiApXG4gICAgXHRcdFx0XTtcblxuICAgIFx0XHR9XG5cbiAgICBcdH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xuICAgICAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gICAgICpcbiAgICAgKiBUZXh0ID0gM0QgVGV4dFxuICAgICAqXG4gICAgICogcGFyYW1ldGVycyA9IHtcbiAgICAgKiAgZm9udDogPFRIUkVFLkZvbnQ+LCAvLyBmb250XG4gICAgICpcbiAgICAgKiAgc2l6ZTogPGZsb2F0PiwgLy8gc2l6ZSBvZiB0aGUgdGV4dFxuICAgICAqICBoZWlnaHQ6IDxmbG9hdD4sIC8vIHRoaWNrbmVzcyB0byBleHRydWRlIHRleHRcbiAgICAgKiAgY3VydmVTZWdtZW50czogPGludD4sIC8vIG51bWJlciBvZiBwb2ludHMgb24gdGhlIGN1cnZlc1xuICAgICAqXG4gICAgICogIGJldmVsRW5hYmxlZDogPGJvb2w+LCAvLyB0dXJuIG9uIGJldmVsXG4gICAgICogIGJldmVsVGhpY2tuZXNzOiA8ZmxvYXQ+LCAvLyBob3cgZGVlcCBpbnRvIHRleHQgYmV2ZWwgZ29lc1xuICAgICAqICBiZXZlbFNpemU6IDxmbG9hdD4gLy8gaG93IGZhciBmcm9tIHRleHQgb3V0bGluZSBpcyBiZXZlbFxuICAgICAqIH1cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIFRleHRHZW9tZXRyeSggdGV4dCwgcGFyYW1ldGVycyApIHtcblxuICAgIFx0cGFyYW1ldGVycyA9IHBhcmFtZXRlcnMgfHwge307XG5cbiAgICBcdHZhciBmb250ID0gcGFyYW1ldGVycy5mb250O1xuXG4gICAgXHRpZiAoIChmb250ICYmIGZvbnQuaXNGb250KSA9PT0gZmFsc2UgKSB7XG5cbiAgICBcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlRleHRHZW9tZXRyeTogZm9udCBwYXJhbWV0ZXIgaXMgbm90IGFuIGluc3RhbmNlIG9mIFRIUkVFLkZvbnQuJyApO1xuICAgIFx0XHRyZXR1cm4gbmV3IEdlb21ldHJ5KCk7XG5cbiAgICBcdH1cblxuICAgIFx0dmFyIHNoYXBlcyA9IGZvbnQuZ2VuZXJhdGVTaGFwZXMoIHRleHQsIHBhcmFtZXRlcnMuc2l6ZSwgcGFyYW1ldGVycy5jdXJ2ZVNlZ21lbnRzICk7XG5cbiAgICBcdC8vIHRyYW5zbGF0ZSBwYXJhbWV0ZXJzIHRvIEV4dHJ1ZGVHZW9tZXRyeSBBUElcblxuICAgIFx0cGFyYW1ldGVycy5hbW91bnQgPSBwYXJhbWV0ZXJzLmhlaWdodCAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5oZWlnaHQgOiA1MDtcblxuICAgIFx0Ly8gZGVmYXVsdHNcblxuICAgIFx0aWYgKCBwYXJhbWV0ZXJzLmJldmVsVGhpY2tuZXNzID09PSB1bmRlZmluZWQgKSBwYXJhbWV0ZXJzLmJldmVsVGhpY2tuZXNzID0gMTA7XG4gICAgXHRpZiAoIHBhcmFtZXRlcnMuYmV2ZWxTaXplID09PSB1bmRlZmluZWQgKSBwYXJhbWV0ZXJzLmJldmVsU2l6ZSA9IDg7XG4gICAgXHRpZiAoIHBhcmFtZXRlcnMuYmV2ZWxFbmFibGVkID09PSB1bmRlZmluZWQgKSBwYXJhbWV0ZXJzLmJldmVsRW5hYmxlZCA9IGZhbHNlO1xuXG4gICAgXHRFeHRydWRlR2VvbWV0cnkuY2FsbCggdGhpcywgc2hhcGVzLCBwYXJhbWV0ZXJzICk7XG5cbiAgICBcdHRoaXMudHlwZSA9ICdUZXh0R2VvbWV0cnknO1xuXG4gICAgfVxuXG4gICAgVGV4dEdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEV4dHJ1ZGVHZW9tZXRyeS5wcm90b3R5cGUgKTtcbiAgICBUZXh0R2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVGV4dEdlb21ldHJ5O1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBiZW5hYWRhbXMgLyBodHRwczovL3R3aXR0ZXIuY29tL2Jlbl9hX2FkYW1zXG4gICAgICogYmFzZWQgb24gVEhSRUUuU3BoZXJlR2VvbWV0cnlcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIFNwaGVyZUJ1ZmZlckdlb21ldHJ5KCByYWRpdXMsIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCBwaGlTdGFydCwgcGhpTGVuZ3RoLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApIHtcblxuICAgIFx0QnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG4gICAgXHR0aGlzLnR5cGUgPSAnU3BoZXJlQnVmZmVyR2VvbWV0cnknO1xuXG4gICAgXHR0aGlzLnBhcmFtZXRlcnMgPSB7XG4gICAgXHRcdHJhZGl1czogcmFkaXVzLFxuICAgIFx0XHR3aWR0aFNlZ21lbnRzOiB3aWR0aFNlZ21lbnRzLFxuICAgIFx0XHRoZWlnaHRTZWdtZW50czogaGVpZ2h0U2VnbWVudHMsXG4gICAgXHRcdHBoaVN0YXJ0OiBwaGlTdGFydCxcbiAgICBcdFx0cGhpTGVuZ3RoOiBwaGlMZW5ndGgsXG4gICAgXHRcdHRoZXRhU3RhcnQ6IHRoZXRhU3RhcnQsXG4gICAgXHRcdHRoZXRhTGVuZ3RoOiB0aGV0YUxlbmd0aFxuICAgIFx0fTtcblxuICAgIFx0cmFkaXVzID0gcmFkaXVzIHx8IDUwO1xuXG4gICAgXHR3aWR0aFNlZ21lbnRzID0gTWF0aC5tYXgoIDMsIE1hdGguZmxvb3IoIHdpZHRoU2VnbWVudHMgKSB8fCA4ICk7XG4gICAgXHRoZWlnaHRTZWdtZW50cyA9IE1hdGgubWF4KCAyLCBNYXRoLmZsb29yKCBoZWlnaHRTZWdtZW50cyApIHx8IDYgKTtcblxuICAgIFx0cGhpU3RhcnQgPSBwaGlTdGFydCAhPT0gdW5kZWZpbmVkID8gcGhpU3RhcnQgOiAwO1xuICAgIFx0cGhpTGVuZ3RoID0gcGhpTGVuZ3RoICE9PSB1bmRlZmluZWQgPyBwaGlMZW5ndGggOiBNYXRoLlBJICogMjtcblxuICAgIFx0dGhldGFTdGFydCA9IHRoZXRhU3RhcnQgIT09IHVuZGVmaW5lZCA/IHRoZXRhU3RhcnQgOiAwO1xuICAgIFx0dGhldGFMZW5ndGggPSB0aGV0YUxlbmd0aCAhPT0gdW5kZWZpbmVkID8gdGhldGFMZW5ndGggOiBNYXRoLlBJO1xuXG4gICAgXHR2YXIgdGhldGFFbmQgPSB0aGV0YVN0YXJ0ICsgdGhldGFMZW5ndGg7XG5cbiAgICBcdHZhciB2ZXJ0ZXhDb3VudCA9ICggKCB3aWR0aFNlZ21lbnRzICsgMSApICogKCBoZWlnaHRTZWdtZW50cyArIDEgKSApO1xuXG4gICAgXHR2YXIgcG9zaXRpb25zID0gbmV3IEJ1ZmZlckF0dHJpYnV0ZSggbmV3IEZsb2F0MzJBcnJheSggdmVydGV4Q291bnQgKiAzICksIDMgKTtcbiAgICBcdHZhciBub3JtYWxzID0gbmV3IEJ1ZmZlckF0dHJpYnV0ZSggbmV3IEZsb2F0MzJBcnJheSggdmVydGV4Q291bnQgKiAzICksIDMgKTtcbiAgICBcdHZhciB1dnMgPSBuZXcgQnVmZmVyQXR0cmlidXRlKCBuZXcgRmxvYXQzMkFycmF5KCB2ZXJ0ZXhDb3VudCAqIDIgKSwgMiApO1xuXG4gICAgXHR2YXIgaW5kZXggPSAwLCB2ZXJ0aWNlcyA9IFtdLCBub3JtYWwgPSBuZXcgVmVjdG9yMygpO1xuXG4gICAgXHRmb3IgKCB2YXIgeSA9IDA7IHkgPD0gaGVpZ2h0U2VnbWVudHM7IHkgKysgKSB7XG5cbiAgICBcdFx0dmFyIHZlcnRpY2VzUm93ID0gW107XG5cbiAgICBcdFx0dmFyIHYgPSB5IC8gaGVpZ2h0U2VnbWVudHM7XG5cbiAgICBcdFx0Zm9yICggdmFyIHggPSAwOyB4IDw9IHdpZHRoU2VnbWVudHM7IHggKysgKSB7XG5cbiAgICBcdFx0XHR2YXIgdSA9IHggLyB3aWR0aFNlZ21lbnRzO1xuXG4gICAgXHRcdFx0dmFyIHB4ID0gLSByYWRpdXMgKiBNYXRoLmNvcyggcGhpU3RhcnQgKyB1ICogcGhpTGVuZ3RoICkgKiBNYXRoLnNpbiggdGhldGFTdGFydCArIHYgKiB0aGV0YUxlbmd0aCApO1xuICAgIFx0XHRcdHZhciBweSA9IHJhZGl1cyAqIE1hdGguY29zKCB0aGV0YVN0YXJ0ICsgdiAqIHRoZXRhTGVuZ3RoICk7XG4gICAgXHRcdFx0dmFyIHB6ID0gcmFkaXVzICogTWF0aC5zaW4oIHBoaVN0YXJ0ICsgdSAqIHBoaUxlbmd0aCApICogTWF0aC5zaW4oIHRoZXRhU3RhcnQgKyB2ICogdGhldGFMZW5ndGggKTtcblxuICAgIFx0XHRcdG5vcm1hbC5zZXQoIHB4LCBweSwgcHogKS5ub3JtYWxpemUoKTtcblxuICAgIFx0XHRcdHBvc2l0aW9ucy5zZXRYWVooIGluZGV4LCBweCwgcHksIHB6ICk7XG4gICAgXHRcdFx0bm9ybWFscy5zZXRYWVooIGluZGV4LCBub3JtYWwueCwgbm9ybWFsLnksIG5vcm1hbC56ICk7XG4gICAgXHRcdFx0dXZzLnNldFhZKCBpbmRleCwgdSwgMSAtIHYgKTtcblxuICAgIFx0XHRcdHZlcnRpY2VzUm93LnB1c2goIGluZGV4ICk7XG5cbiAgICBcdFx0XHRpbmRleCArKztcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0dmVydGljZXMucHVzaCggdmVydGljZXNSb3cgKTtcblxuICAgIFx0fVxuXG4gICAgXHR2YXIgaW5kaWNlcyA9IFtdO1xuXG4gICAgXHRmb3IgKCB2YXIgeSA9IDA7IHkgPCBoZWlnaHRTZWdtZW50czsgeSArKyApIHtcblxuICAgIFx0XHRmb3IgKCB2YXIgeCA9IDA7IHggPCB3aWR0aFNlZ21lbnRzOyB4ICsrICkge1xuXG4gICAgXHRcdFx0dmFyIHYxID0gdmVydGljZXNbIHkgXVsgeCArIDEgXTtcbiAgICBcdFx0XHR2YXIgdjIgPSB2ZXJ0aWNlc1sgeSBdWyB4IF07XG4gICAgXHRcdFx0dmFyIHYzID0gdmVydGljZXNbIHkgKyAxIF1bIHggXTtcbiAgICBcdFx0XHR2YXIgdjQgPSB2ZXJ0aWNlc1sgeSArIDEgXVsgeCArIDEgXTtcblxuICAgIFx0XHRcdGlmICggeSAhPT0gMCB8fCB0aGV0YVN0YXJ0ID4gMCApIGluZGljZXMucHVzaCggdjEsIHYyLCB2NCApO1xuICAgIFx0XHRcdGlmICggeSAhPT0gaGVpZ2h0U2VnbWVudHMgLSAxIHx8IHRoZXRhRW5kIDwgTWF0aC5QSSApIGluZGljZXMucHVzaCggdjIsIHYzLCB2NCApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0fVxuXG4gICAgXHR0aGlzLnNldEluZGV4KCBuZXcgKCBwb3NpdGlvbnMuY291bnQgPiA2NTUzNSA/IFVpbnQzMkF0dHJpYnV0ZSA6IFVpbnQxNkF0dHJpYnV0ZSApKCBpbmRpY2VzLCAxICkgKTtcbiAgICBcdHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBwb3NpdGlvbnMgKTtcbiAgICBcdHRoaXMuYWRkQXR0cmlidXRlKCAnbm9ybWFsJywgbm9ybWFscyApO1xuICAgIFx0dGhpcy5hZGRBdHRyaWJ1dGUoICd1dicsIHV2cyApO1xuXG4gICAgXHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gbmV3IFNwaGVyZSggbmV3IFZlY3RvcjMoKSwgcmFkaXVzICk7XG5cbiAgICB9XG5cbiAgICBTcGhlcmVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcbiAgICBTcGhlcmVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTcGhlcmVCdWZmZXJHZW9tZXRyeTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBTcGhlcmVHZW9tZXRyeSggcmFkaXVzLCB3aWR0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgcGhpU3RhcnQsIHBoaUxlbmd0aCwgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKSB7XG5cbiAgICBcdEdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuICAgIFx0dGhpcy50eXBlID0gJ1NwaGVyZUdlb21ldHJ5JztcblxuICAgIFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuICAgIFx0XHRyYWRpdXM6IHJhZGl1cyxcbiAgICBcdFx0d2lkdGhTZWdtZW50czogd2lkdGhTZWdtZW50cyxcbiAgICBcdFx0aGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzLFxuICAgIFx0XHRwaGlTdGFydDogcGhpU3RhcnQsXG4gICAgXHRcdHBoaUxlbmd0aDogcGhpTGVuZ3RoLFxuICAgIFx0XHR0aGV0YVN0YXJ0OiB0aGV0YVN0YXJ0LFxuICAgIFx0XHR0aGV0YUxlbmd0aDogdGhldGFMZW5ndGhcbiAgICBcdH07XG5cbiAgICBcdHRoaXMuZnJvbUJ1ZmZlckdlb21ldHJ5KCBuZXcgU3BoZXJlQnVmZmVyR2VvbWV0cnkoIHJhZGl1cywgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIHBoaVN0YXJ0LCBwaGlMZW5ndGgsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICkgKTtcblxuICAgIH1cblxuICAgIFNwaGVyZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEdlb21ldHJ5LnByb3RvdHlwZSApO1xuICAgIFNwaGVyZUdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNwaGVyZUdlb21ldHJ5O1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBNdWdlbjg3IC8gaHR0cHM6Ly9naXRodWIuY29tL011Z2VuODdcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIFJpbmdCdWZmZXJHZW9tZXRyeSggaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzLCB0aGV0YVNlZ21lbnRzLCBwaGlTZWdtZW50cywgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKSB7XG5cbiAgICBcdEJ1ZmZlckdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuICAgIFx0dGhpcy50eXBlID0gJ1JpbmdCdWZmZXJHZW9tZXRyeSc7XG5cbiAgICBcdHRoaXMucGFyYW1ldGVycyA9IHtcbiAgICBcdFx0aW5uZXJSYWRpdXM6IGlubmVyUmFkaXVzLFxuICAgIFx0XHRvdXRlclJhZGl1czogb3V0ZXJSYWRpdXMsXG4gICAgXHRcdHRoZXRhU2VnbWVudHM6IHRoZXRhU2VnbWVudHMsXG4gICAgXHRcdHBoaVNlZ21lbnRzOiBwaGlTZWdtZW50cyxcbiAgICBcdFx0dGhldGFTdGFydDogdGhldGFTdGFydCxcbiAgICBcdFx0dGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoXG4gICAgXHR9O1xuXG4gICAgXHRpbm5lclJhZGl1cyA9IGlubmVyUmFkaXVzIHx8IDIwO1xuICAgIFx0b3V0ZXJSYWRpdXMgPSBvdXRlclJhZGl1cyB8fCA1MDtcblxuICAgIFx0dGhldGFTdGFydCA9IHRoZXRhU3RhcnQgIT09IHVuZGVmaW5lZCA/IHRoZXRhU3RhcnQgOiAwO1xuICAgIFx0dGhldGFMZW5ndGggPSB0aGV0YUxlbmd0aCAhPT0gdW5kZWZpbmVkID8gdGhldGFMZW5ndGggOiBNYXRoLlBJICogMjtcblxuICAgIFx0dGhldGFTZWdtZW50cyA9IHRoZXRhU2VnbWVudHMgIT09IHVuZGVmaW5lZCA/IE1hdGgubWF4KCAzLCB0aGV0YVNlZ21lbnRzICkgOiA4O1xuICAgIFx0cGhpU2VnbWVudHMgPSBwaGlTZWdtZW50cyAhPT0gdW5kZWZpbmVkID8gTWF0aC5tYXgoIDEsIHBoaVNlZ21lbnRzICkgOiAxO1xuXG4gICAgXHQvLyB0aGVzZSBhcmUgdXNlZCB0byBjYWxjdWxhdGUgYnVmZmVyIGxlbmd0aFxuICAgIFx0dmFyIHZlcnRleENvdW50ID0gKCB0aGV0YVNlZ21lbnRzICsgMSApICogKCBwaGlTZWdtZW50cyArIDEgKTtcbiAgICBcdHZhciBpbmRleENvdW50ID0gdGhldGFTZWdtZW50cyAqIHBoaVNlZ21lbnRzICogMiAqIDM7XG5cbiAgICBcdC8vIGJ1ZmZlcnNcbiAgICBcdHZhciBpbmRpY2VzID0gbmV3IEJ1ZmZlckF0dHJpYnV0ZSggbmV3ICggaW5kZXhDb3VudCA+IDY1NTM1ID8gVWludDMyQXJyYXkgOiBVaW50MTZBcnJheSApKCBpbmRleENvdW50ICkgLCAxICk7XG4gICAgXHR2YXIgdmVydGljZXMgPSBuZXcgQnVmZmVyQXR0cmlidXRlKCBuZXcgRmxvYXQzMkFycmF5KCB2ZXJ0ZXhDb3VudCAqIDMgKSwgMyApO1xuICAgIFx0dmFyIG5vcm1hbHMgPSBuZXcgQnVmZmVyQXR0cmlidXRlKCBuZXcgRmxvYXQzMkFycmF5KCB2ZXJ0ZXhDb3VudCAqIDMgKSwgMyApO1xuICAgIFx0dmFyIHV2cyA9IG5ldyBCdWZmZXJBdHRyaWJ1dGUoIG5ldyBGbG9hdDMyQXJyYXkoIHZlcnRleENvdW50ICogMiApLCAyICk7XG5cbiAgICBcdC8vIHNvbWUgaGVscGVyIHZhcmlhYmxlc1xuICAgIFx0dmFyIGluZGV4ID0gMCwgaW5kZXhPZmZzZXQgPSAwLCBzZWdtZW50O1xuICAgIFx0dmFyIHJhZGl1cyA9IGlubmVyUmFkaXVzO1xuICAgIFx0dmFyIHJhZGl1c1N0ZXAgPSAoICggb3V0ZXJSYWRpdXMgLSBpbm5lclJhZGl1cyApIC8gcGhpU2VnbWVudHMgKTtcbiAgICBcdHZhciB2ZXJ0ZXggPSBuZXcgVmVjdG9yMygpO1xuICAgIFx0dmFyIHV2ID0gbmV3IFZlY3RvcjIoKTtcbiAgICBcdHZhciBqLCBpO1xuXG4gICAgXHQvLyBnZW5lcmF0ZSB2ZXJ0aWNlcywgbm9ybWFscyBhbmQgdXZzXG5cbiAgICBcdC8vIHZhbHVlcyBhcmUgZ2VuZXJhdGUgZnJvbSB0aGUgaW5zaWRlIG9mIHRoZSByaW5nIHRvIHRoZSBvdXRzaWRlXG5cbiAgICBcdGZvciAoIGogPSAwOyBqIDw9IHBoaVNlZ21lbnRzOyBqICsrICkge1xuXG4gICAgXHRcdGZvciAoIGkgPSAwOyBpIDw9IHRoZXRhU2VnbWVudHM7IGkgKysgKSB7XG5cbiAgICBcdFx0XHRzZWdtZW50ID0gdGhldGFTdGFydCArIGkgLyB0aGV0YVNlZ21lbnRzICogdGhldGFMZW5ndGg7XG5cbiAgICBcdFx0XHQvLyB2ZXJ0ZXhcbiAgICBcdFx0XHR2ZXJ0ZXgueCA9IHJhZGl1cyAqIE1hdGguY29zKCBzZWdtZW50ICk7XG4gICAgXHRcdFx0dmVydGV4LnkgPSByYWRpdXMgKiBNYXRoLnNpbiggc2VnbWVudCApO1xuICAgIFx0XHRcdHZlcnRpY2VzLnNldFhZWiggaW5kZXgsIHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnogKTtcblxuICAgIFx0XHRcdC8vIG5vcm1hbFxuICAgIFx0XHRcdG5vcm1hbHMuc2V0WFlaKCBpbmRleCwgMCwgMCwgMSApO1xuXG4gICAgXHRcdFx0Ly8gdXZcbiAgICBcdFx0XHR1di54ID0gKCB2ZXJ0ZXgueCAvIG91dGVyUmFkaXVzICsgMSApIC8gMjtcbiAgICBcdFx0XHR1di55ID0gKCB2ZXJ0ZXgueSAvIG91dGVyUmFkaXVzICsgMSApIC8gMjtcbiAgICBcdFx0XHR1dnMuc2V0WFkoIGluZGV4LCB1di54LCB1di55ICk7XG5cbiAgICBcdFx0XHQvLyBpbmNyZWFzZSBpbmRleFxuICAgIFx0XHRcdGluZGV4Kys7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdC8vIGluY3JlYXNlIHRoZSByYWRpdXMgZm9yIG5leHQgcm93IG9mIHZlcnRpY2VzXG4gICAgXHRcdHJhZGl1cyArPSByYWRpdXNTdGVwO1xuXG4gICAgXHR9XG5cbiAgICBcdC8vIGdlbmVyYXRlIGluZGljZXNcblxuICAgIFx0Zm9yICggaiA9IDA7IGogPCBwaGlTZWdtZW50czsgaiArKyApIHtcblxuICAgIFx0XHR2YXIgdGhldGFTZWdtZW50TGV2ZWwgPSBqICogKCB0aGV0YVNlZ21lbnRzICsgMSApO1xuXG4gICAgXHRcdGZvciAoIGkgPSAwOyBpIDwgdGhldGFTZWdtZW50czsgaSArKyApIHtcblxuICAgIFx0XHRcdHNlZ21lbnQgPSBpICsgdGhldGFTZWdtZW50TGV2ZWw7XG5cbiAgICBcdFx0XHQvLyBpbmRpY2VzXG4gICAgXHRcdFx0dmFyIGEgPSBzZWdtZW50O1xuICAgIFx0XHRcdHZhciBiID0gc2VnbWVudCArIHRoZXRhU2VnbWVudHMgKyAxO1xuICAgIFx0XHRcdHZhciBjID0gc2VnbWVudCArIHRoZXRhU2VnbWVudHMgKyAyO1xuICAgIFx0XHRcdHZhciBkID0gc2VnbWVudCArIDE7XG5cbiAgICBcdFx0XHQvLyBmYWNlIG9uZVxuICAgIFx0XHRcdGluZGljZXMuc2V0WCggaW5kZXhPZmZzZXQsIGEgKTsgaW5kZXhPZmZzZXQrKztcbiAgICBcdFx0XHRpbmRpY2VzLnNldFgoIGluZGV4T2Zmc2V0LCBiICk7IGluZGV4T2Zmc2V0Kys7XG4gICAgXHRcdFx0aW5kaWNlcy5zZXRYKCBpbmRleE9mZnNldCwgYyApOyBpbmRleE9mZnNldCsrO1xuXG4gICAgXHRcdFx0Ly8gZmFjZSB0d29cbiAgICBcdFx0XHRpbmRpY2VzLnNldFgoIGluZGV4T2Zmc2V0LCBhICk7IGluZGV4T2Zmc2V0Kys7XG4gICAgXHRcdFx0aW5kaWNlcy5zZXRYKCBpbmRleE9mZnNldCwgYyApOyBpbmRleE9mZnNldCsrO1xuICAgIFx0XHRcdGluZGljZXMuc2V0WCggaW5kZXhPZmZzZXQsIGQgKTsgaW5kZXhPZmZzZXQrKztcblxuICAgIFx0XHR9XG5cbiAgICBcdH1cblxuICAgIFx0Ly8gYnVpbGQgZ2VvbWV0cnlcblxuICAgIFx0dGhpcy5zZXRJbmRleCggaW5kaWNlcyApO1xuICAgIFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIHZlcnRpY2VzICk7XG4gICAgXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5vcm1hbHMgKTtcbiAgICBcdHRoaXMuYWRkQXR0cmlidXRlKCAndXYnLCB1dnMgKTtcblxuICAgIH1cblxuICAgIFJpbmdCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcbiAgICBSaW5nQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmluZ0J1ZmZlckdlb21ldHJ5O1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBLYWxlYiBNdXJwaHlcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIFJpbmdHZW9tZXRyeSggaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzLCB0aGV0YVNlZ21lbnRzLCBwaGlTZWdtZW50cywgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKSB7XG5cbiAgICBcdEdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuICAgIFx0dGhpcy50eXBlID0gJ1JpbmdHZW9tZXRyeSc7XG5cbiAgICBcdHRoaXMucGFyYW1ldGVycyA9IHtcbiAgICBcdFx0aW5uZXJSYWRpdXM6IGlubmVyUmFkaXVzLFxuICAgIFx0XHRvdXRlclJhZGl1czogb3V0ZXJSYWRpdXMsXG4gICAgXHRcdHRoZXRhU2VnbWVudHM6IHRoZXRhU2VnbWVudHMsXG4gICAgXHRcdHBoaVNlZ21lbnRzOiBwaGlTZWdtZW50cyxcbiAgICBcdFx0dGhldGFTdGFydDogdGhldGFTdGFydCxcbiAgICBcdFx0dGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoXG4gICAgXHR9O1xuXG4gICAgXHR0aGlzLmZyb21CdWZmZXJHZW9tZXRyeSggbmV3IFJpbmdCdWZmZXJHZW9tZXRyeSggaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzLCB0aGV0YVNlZ21lbnRzLCBwaGlTZWdtZW50cywgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKSApO1xuXG4gICAgfVxuXG4gICAgUmluZ0dlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEdlb21ldHJ5LnByb3RvdHlwZSApO1xuICAgIFJpbmdHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSaW5nR2VvbWV0cnk7XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICAgICAqIGJhc2VkIG9uIGh0dHA6Ly9wYXBlcnZpc2lvbjNkLmdvb2dsZWNvZGUuY29tL3N2bi90cnVuay9hczMvdHJ1bmsvc3JjL29yZy9wYXBlcnZpc2lvbjNkL29iamVjdHMvcHJpbWl0aXZlcy9QbGFuZS5hc1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gUGxhbmVHZW9tZXRyeSggd2lkdGgsIGhlaWdodCwgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMgKSB7XG5cbiAgICBcdEdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuICAgIFx0dGhpcy50eXBlID0gJ1BsYW5lR2VvbWV0cnknO1xuXG4gICAgXHR0aGlzLnBhcmFtZXRlcnMgPSB7XG4gICAgXHRcdHdpZHRoOiB3aWR0aCxcbiAgICBcdFx0aGVpZ2h0OiBoZWlnaHQsXG4gICAgXHRcdHdpZHRoU2VnbWVudHM6IHdpZHRoU2VnbWVudHMsXG4gICAgXHRcdGhlaWdodFNlZ21lbnRzOiBoZWlnaHRTZWdtZW50c1xuICAgIFx0fTtcblxuICAgIFx0dGhpcy5mcm9tQnVmZmVyR2VvbWV0cnkoIG5ldyBQbGFuZUJ1ZmZlckdlb21ldHJ5KCB3aWR0aCwgaGVpZ2h0LCB3aWR0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cyApICk7XG5cbiAgICB9XG5cbiAgICBQbGFuZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEdlb21ldHJ5LnByb3RvdHlwZSApO1xuICAgIFBsYW5lR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUGxhbmVHZW9tZXRyeTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgTXVnZW44NyAvIGh0dHBzOi8vZ2l0aHViLmNvbS9NdWdlbjg3XG4gICAgICovXG5cbiAgICAgLy8gcG9pbnRzIC0gdG8gY3JlYXRlIGEgY2xvc2VkIHRvcnVzLCBvbmUgbXVzdCB1c2UgYSBzZXQgb2YgcG9pbnRzXG4gICAgIC8vICAgIGxpa2Ugc286IFsgYSwgYiwgYywgZCwgYSBdLCBzZWUgZmlyc3QgaXMgdGhlIHNhbWUgYXMgbGFzdC5cbiAgICAgLy8gc2VnbWVudHMgLSB0aGUgbnVtYmVyIG9mIGNpcmN1bWZlcmVuY2Ugc2VnbWVudHMgdG8gY3JlYXRlXG4gICAgIC8vIHBoaVN0YXJ0IC0gdGhlIHN0YXJ0aW5nIHJhZGlhblxuICAgICAvLyBwaGlMZW5ndGggLSB0aGUgcmFkaWFuICgwIHRvIDJQSSkgcmFuZ2Ugb2YgdGhlIGxhdGhlZCBzZWN0aW9uXG4gICAgIC8vICAgIDJQSSBpcyBhIGNsb3NlZCBsYXRoZSwgbGVzcyB0aGFuIDJQSSBpcyBhIHBvcnRpb24uXG5cbiAgICBmdW5jdGlvbiBMYXRoZUJ1ZmZlckdlb21ldHJ5KCBwb2ludHMsIHNlZ21lbnRzLCBwaGlTdGFydCwgcGhpTGVuZ3RoICkge1xuXG4gICAgXHRCdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cbiAgICBcdHRoaXMudHlwZSA9ICdMYXRoZUJ1ZmZlckdlb21ldHJ5JztcblxuICAgIFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuICAgIFx0XHRwb2ludHM6IHBvaW50cyxcbiAgICBcdFx0c2VnbWVudHM6IHNlZ21lbnRzLFxuICAgIFx0XHRwaGlTdGFydDogcGhpU3RhcnQsXG4gICAgXHRcdHBoaUxlbmd0aDogcGhpTGVuZ3RoXG4gICAgXHR9O1xuXG4gICAgXHRzZWdtZW50cyA9IE1hdGguZmxvb3IoIHNlZ21lbnRzICkgfHwgMTI7XG4gICAgXHRwaGlTdGFydCA9IHBoaVN0YXJ0IHx8IDA7XG4gICAgXHRwaGlMZW5ndGggPSBwaGlMZW5ndGggfHwgTWF0aC5QSSAqIDI7XG5cbiAgICBcdC8vIGNsYW1wIHBoaUxlbmd0aCBzbyBpdCdzIGluIHJhbmdlIG9mIFsgMCwgMlBJIF1cbiAgICBcdHBoaUxlbmd0aCA9IGV4cG9ydHMuTWF0aC5jbGFtcCggcGhpTGVuZ3RoLCAwLCBNYXRoLlBJICogMiApO1xuXG4gICAgXHQvLyB0aGVzZSBhcmUgdXNlZCB0byBjYWxjdWxhdGUgYnVmZmVyIGxlbmd0aFxuICAgIFx0dmFyIHZlcnRleENvdW50ID0gKCBzZWdtZW50cyArIDEgKSAqIHBvaW50cy5sZW5ndGg7XG4gICAgXHR2YXIgaW5kZXhDb3VudCA9IHNlZ21lbnRzICogcG9pbnRzLmxlbmd0aCAqIDIgKiAzO1xuXG4gICAgXHQvLyBidWZmZXJzXG4gICAgXHR2YXIgaW5kaWNlcyA9IG5ldyBCdWZmZXJBdHRyaWJ1dGUoIG5ldyAoIGluZGV4Q291bnQgPiA2NTUzNSA/IFVpbnQzMkFycmF5IDogVWludDE2QXJyYXkgKSggaW5kZXhDb3VudCApICwgMSApO1xuICAgIFx0dmFyIHZlcnRpY2VzID0gbmV3IEJ1ZmZlckF0dHJpYnV0ZSggbmV3IEZsb2F0MzJBcnJheSggdmVydGV4Q291bnQgKiAzICksIDMgKTtcbiAgICBcdHZhciB1dnMgPSBuZXcgQnVmZmVyQXR0cmlidXRlKCBuZXcgRmxvYXQzMkFycmF5KCB2ZXJ0ZXhDb3VudCAqIDIgKSwgMiApO1xuXG4gICAgXHQvLyBoZWxwZXIgdmFyaWFibGVzXG4gICAgXHR2YXIgaW5kZXggPSAwLCBpbmRleE9mZnNldCA9IDAsIGJhc2U7XG4gICAgXHR2YXIgaW52ZXJzZVNlZ21lbnRzID0gMS4wIC8gc2VnbWVudHM7XG4gICAgXHR2YXIgdmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcbiAgICBcdHZhciB1diA9IG5ldyBWZWN0b3IyKCk7XG4gICAgXHR2YXIgaSwgajtcblxuICAgIFx0Ly8gZ2VuZXJhdGUgdmVydGljZXMgYW5kIHV2c1xuXG4gICAgXHRmb3IgKCBpID0gMDsgaSA8PSBzZWdtZW50czsgaSArKyApIHtcblxuICAgIFx0XHR2YXIgcGhpID0gcGhpU3RhcnQgKyBpICogaW52ZXJzZVNlZ21lbnRzICogcGhpTGVuZ3RoO1xuXG4gICAgXHRcdHZhciBzaW4gPSBNYXRoLnNpbiggcGhpICk7XG4gICAgXHRcdHZhciBjb3MgPSBNYXRoLmNvcyggcGhpICk7XG5cbiAgICBcdFx0Zm9yICggaiA9IDA7IGogPD0gKCBwb2ludHMubGVuZ3RoIC0gMSApOyBqICsrICkge1xuXG4gICAgXHRcdFx0Ly8gdmVydGV4XG4gICAgXHRcdFx0dmVydGV4LnggPSBwb2ludHNbIGogXS54ICogc2luO1xuICAgIFx0XHRcdHZlcnRleC55ID0gcG9pbnRzWyBqIF0ueTtcbiAgICBcdFx0XHR2ZXJ0ZXgueiA9IHBvaW50c1sgaiBdLnggKiBjb3M7XG4gICAgXHRcdFx0dmVydGljZXMuc2V0WFlaKCBpbmRleCwgdmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueiApO1xuXG4gICAgXHRcdFx0Ly8gdXZcbiAgICBcdFx0XHR1di54ID0gaSAvIHNlZ21lbnRzO1xuICAgIFx0XHRcdHV2LnkgPSBqIC8gKCBwb2ludHMubGVuZ3RoIC0gMSApO1xuICAgIFx0XHRcdHV2cy5zZXRYWSggaW5kZXgsIHV2LngsIHV2LnkgKTtcblxuICAgIFx0XHRcdC8vIGluY3JlYXNlIGluZGV4XG4gICAgXHRcdFx0aW5kZXggKys7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9XG5cbiAgICBcdC8vIGdlbmVyYXRlIGluZGljZXNcblxuICAgIFx0Zm9yICggaSA9IDA7IGkgPCBzZWdtZW50czsgaSArKyApIHtcblxuICAgIFx0XHRmb3IgKCBqID0gMDsgaiA8ICggcG9pbnRzLmxlbmd0aCAtIDEgKTsgaiArKyApIHtcblxuICAgIFx0XHRcdGJhc2UgPSBqICsgaSAqIHBvaW50cy5sZW5ndGg7XG5cbiAgICBcdFx0XHQvLyBpbmRpY2VzXG4gICAgXHRcdFx0dmFyIGEgPSBiYXNlO1xuICAgIFx0XHRcdHZhciBiID0gYmFzZSArIHBvaW50cy5sZW5ndGg7XG4gICAgXHRcdFx0dmFyIGMgPSBiYXNlICsgcG9pbnRzLmxlbmd0aCArIDE7XG4gICAgXHRcdFx0dmFyIGQgPSBiYXNlICsgMTtcblxuICAgIFx0XHRcdC8vIGZhY2Ugb25lXG4gICAgXHRcdFx0aW5kaWNlcy5zZXRYKCBpbmRleE9mZnNldCwgYSApOyBpbmRleE9mZnNldCsrO1xuICAgIFx0XHRcdGluZGljZXMuc2V0WCggaW5kZXhPZmZzZXQsIGIgKTsgaW5kZXhPZmZzZXQrKztcbiAgICBcdFx0XHRpbmRpY2VzLnNldFgoIGluZGV4T2Zmc2V0LCBkICk7IGluZGV4T2Zmc2V0Kys7XG5cbiAgICBcdFx0XHQvLyBmYWNlIHR3b1xuICAgIFx0XHRcdGluZGljZXMuc2V0WCggaW5kZXhPZmZzZXQsIGIgKTsgaW5kZXhPZmZzZXQrKztcbiAgICBcdFx0XHRpbmRpY2VzLnNldFgoIGluZGV4T2Zmc2V0LCBjICk7IGluZGV4T2Zmc2V0Kys7XG4gICAgXHRcdFx0aW5kaWNlcy5zZXRYKCBpbmRleE9mZnNldCwgZCApOyBpbmRleE9mZnNldCsrO1xuXG4gICAgXHRcdH1cblxuICAgIFx0fVxuXG4gICAgXHQvLyBidWlsZCBnZW9tZXRyeVxuXG4gICAgXHR0aGlzLnNldEluZGV4KCBpbmRpY2VzICk7XG4gICAgXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgdmVydGljZXMgKTtcbiAgICBcdHRoaXMuYWRkQXR0cmlidXRlKCAndXYnLCB1dnMgKTtcblxuICAgIFx0Ly8gZ2VuZXJhdGUgbm9ybWFsc1xuXG4gICAgXHR0aGlzLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7XG5cbiAgICBcdC8vIGlmIHRoZSBnZW9tZXRyeSBpcyBjbG9zZWQsIHdlIG5lZWQgdG8gYXZlcmFnZSB0aGUgbm9ybWFscyBhbG9uZyB0aGUgc2VhbS5cbiAgICBcdC8vIGJlY2F1c2UgdGhlIGNvcnJlc3BvbmRpbmcgdmVydGljZXMgYXJlIGlkZW50aWNhbCAoYnV0IHN0aWxsIGhhdmUgZGlmZmVyZW50IFVWcykuXG5cbiAgICBcdGlmKCBwaGlMZW5ndGggPT09IE1hdGguUEkgKiAyICkge1xuXG4gICAgXHRcdHZhciBub3JtYWxzID0gdGhpcy5hdHRyaWJ1dGVzLm5vcm1hbC5hcnJheTtcbiAgICBcdFx0dmFyIG4xID0gbmV3IFZlY3RvcjMoKTtcbiAgICBcdFx0dmFyIG4yID0gbmV3IFZlY3RvcjMoKTtcbiAgICBcdFx0dmFyIG4gPSBuZXcgVmVjdG9yMygpO1xuXG4gICAgXHRcdC8vIHRoaXMgaXMgdGhlIGJ1ZmZlciBvZmZzZXQgZm9yIHRoZSBsYXN0IGxpbmUgb2YgdmVydGljZXNcbiAgICBcdFx0YmFzZSA9IHNlZ21lbnRzICogcG9pbnRzLmxlbmd0aCAqIDM7XG5cbiAgICBcdFx0Zm9yKCBpID0gMCwgaiA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpICsrLCBqICs9IDMgKSB7XG5cbiAgICBcdFx0XHQvLyBzZWxlY3QgdGhlIG5vcm1hbCBvZiB0aGUgdmVydGV4IGluIHRoZSBmaXJzdCBsaW5lXG4gICAgXHRcdFx0bjEueCA9IG5vcm1hbHNbIGogKyAwIF07XG4gICAgXHRcdFx0bjEueSA9IG5vcm1hbHNbIGogKyAxIF07XG4gICAgXHRcdFx0bjEueiA9IG5vcm1hbHNbIGogKyAyIF07XG5cbiAgICBcdFx0XHQvLyBzZWxlY3QgdGhlIG5vcm1hbCBvZiB0aGUgdmVydGV4IGluIHRoZSBsYXN0IGxpbmVcbiAgICBcdFx0XHRuMi54ID0gbm9ybWFsc1sgYmFzZSArIGogKyAwIF07XG4gICAgXHRcdFx0bjIueSA9IG5vcm1hbHNbIGJhc2UgKyBqICsgMSBdO1xuICAgIFx0XHRcdG4yLnogPSBub3JtYWxzWyBiYXNlICsgaiArIDIgXTtcblxuICAgIFx0XHRcdC8vIGF2ZXJhZ2Ugbm9ybWFsc1xuICAgIFx0XHRcdG4uYWRkVmVjdG9ycyggbjEsIG4yICkubm9ybWFsaXplKCk7XG5cbiAgICBcdFx0XHQvLyBhc3NpZ24gdGhlIG5ldyB2YWx1ZXMgdG8gYm90aCBub3JtYWxzXG4gICAgXHRcdFx0bm9ybWFsc1sgaiArIDAgXSA9IG5vcm1hbHNbIGJhc2UgKyBqICsgMCBdID0gbi54O1xuICAgIFx0XHRcdG5vcm1hbHNbIGogKyAxIF0gPSBub3JtYWxzWyBiYXNlICsgaiArIDEgXSA9IG4ueTtcbiAgICBcdFx0XHRub3JtYWxzWyBqICsgMiBdID0gbm9ybWFsc1sgYmFzZSArIGogKyAyIF0gPSBuLno7XG5cbiAgICBcdFx0fSAvLyBuZXh0IHJvd1xuXG4gICAgXHR9XG5cbiAgICB9XG5cbiAgICBMYXRoZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xuICAgIExhdGhlQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGF0aGVCdWZmZXJHZW9tZXRyeTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgYXN0cm9kdWQgLyBodHRwOi8vYXN0cm9kdWQuaXNncmVhdC5vcmcvXG4gICAgICogQGF1dGhvciB6ejg1IC8gaHR0cHM6Ly9naXRodWIuY29tL3p6ODVcbiAgICAgKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXG4gICAgICovXG5cbiAgICAvLyBwb2ludHMgLSB0byBjcmVhdGUgYSBjbG9zZWQgdG9ydXMsIG9uZSBtdXN0IHVzZSBhIHNldCBvZiBwb2ludHNcbiAgICAvLyAgICBsaWtlIHNvOiBbIGEsIGIsIGMsIGQsIGEgXSwgc2VlIGZpcnN0IGlzIHRoZSBzYW1lIGFzIGxhc3QuXG4gICAgLy8gc2VnbWVudHMgLSB0aGUgbnVtYmVyIG9mIGNpcmN1bWZlcmVuY2Ugc2VnbWVudHMgdG8gY3JlYXRlXG4gICAgLy8gcGhpU3RhcnQgLSB0aGUgc3RhcnRpbmcgcmFkaWFuXG4gICAgLy8gcGhpTGVuZ3RoIC0gdGhlIHJhZGlhbiAoMCB0byAyUEkpIHJhbmdlIG9mIHRoZSBsYXRoZWQgc2VjdGlvblxuICAgIC8vICAgIDJQSSBpcyBhIGNsb3NlZCBsYXRoZSwgbGVzcyB0aGFuIDJQSSBpcyBhIHBvcnRpb24uXG5cbiAgICBmdW5jdGlvbiBMYXRoZUdlb21ldHJ5KCBwb2ludHMsIHNlZ21lbnRzLCBwaGlTdGFydCwgcGhpTGVuZ3RoICkge1xuXG4gICAgXHRHZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cbiAgICBcdHRoaXMudHlwZSA9ICdMYXRoZUdlb21ldHJ5JztcblxuICAgIFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuICAgIFx0XHRwb2ludHM6IHBvaW50cyxcbiAgICBcdFx0c2VnbWVudHM6IHNlZ21lbnRzLFxuICAgIFx0XHRwaGlTdGFydDogcGhpU3RhcnQsXG4gICAgXHRcdHBoaUxlbmd0aDogcGhpTGVuZ3RoXG4gICAgXHR9O1xuXG4gICAgXHR0aGlzLmZyb21CdWZmZXJHZW9tZXRyeSggbmV3IExhdGhlQnVmZmVyR2VvbWV0cnkoIHBvaW50cywgc2VnbWVudHMsIHBoaVN0YXJ0LCBwaGlMZW5ndGggKSApO1xuICAgIFx0dGhpcy5tZXJnZVZlcnRpY2VzKCk7XG5cbiAgICB9XG5cbiAgICBMYXRoZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEdlb21ldHJ5LnByb3RvdHlwZSApO1xuICAgIExhdGhlR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGF0aGVHZW9tZXRyeTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3Igam9ub2JyMSAvIGh0dHA6Ly9qb25vYnIxLmNvbVxuICAgICAqXG4gICAgICogQ3JlYXRlcyBhIG9uZS1zaWRlZCBwb2x5Z29uYWwgZ2VvbWV0cnkgZnJvbSBhIHBhdGggc2hhcGUuIFNpbWlsYXIgdG9cbiAgICAgKiBFeHRydWRlR2VvbWV0cnkuXG4gICAgICpcbiAgICAgKiBwYXJhbWV0ZXJzID0ge1xuICAgICAqXG4gICAgICpcdGN1cnZlU2VnbWVudHM6IDxpbnQ+LCAvLyBudW1iZXIgb2YgcG9pbnRzIG9uIHRoZSBjdXJ2ZXMuIE5PVCBVU0VEIEFUIFRIRSBNT01FTlQuXG4gICAgICpcbiAgICAgKlx0bWF0ZXJpYWw6IDxpbnQ+IC8vIG1hdGVyaWFsIGluZGV4IGZvciBmcm9udCBhbmQgYmFjayBmYWNlc1xuICAgICAqXHR1dkdlbmVyYXRvcjogPE9iamVjdD4gLy8gb2JqZWN0IHRoYXQgcHJvdmlkZXMgVVYgZ2VuZXJhdG9yIGZ1bmN0aW9uc1xuICAgICAqXG4gICAgICogfVxuICAgICAqKi9cblxuICAgIGZ1bmN0aW9uIFNoYXBlR2VvbWV0cnkoIHNoYXBlcywgb3B0aW9ucyApIHtcblxuICAgIFx0R2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG4gICAgXHR0aGlzLnR5cGUgPSAnU2hhcGVHZW9tZXRyeSc7XG5cbiAgICBcdGlmICggQXJyYXkuaXNBcnJheSggc2hhcGVzICkgPT09IGZhbHNlICkgc2hhcGVzID0gWyBzaGFwZXMgXTtcblxuICAgIFx0dGhpcy5hZGRTaGFwZUxpc3QoIHNoYXBlcywgb3B0aW9ucyApO1xuXG4gICAgXHR0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xuXG4gICAgfVxuXG4gICAgU2hhcGVHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBHZW9tZXRyeS5wcm90b3R5cGUgKTtcbiAgICBTaGFwZUdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNoYXBlR2VvbWV0cnk7XG5cbiAgICAvKipcbiAgICAgKiBBZGQgYW4gYXJyYXkgb2Ygc2hhcGVzIHRvIFRIUkVFLlNoYXBlR2VvbWV0cnkuXG4gICAgICovXG4gICAgU2hhcGVHZW9tZXRyeS5wcm90b3R5cGUuYWRkU2hhcGVMaXN0ID0gZnVuY3Rpb24gKCBzaGFwZXMsIG9wdGlvbnMgKSB7XG5cbiAgICBcdGZvciAoIHZhciBpID0gMCwgbCA9IHNoYXBlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgXHRcdHRoaXMuYWRkU2hhcGUoIHNoYXBlc1sgaSBdLCBvcHRpb25zICk7XG5cbiAgICBcdH1cblxuICAgIFx0cmV0dXJuIHRoaXM7XG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIHNoYXBlIHRvIFRIUkVFLlNoYXBlR2VvbWV0cnksIGJhc2VkIG9uIFRIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5cbiAgICAgKi9cbiAgICBTaGFwZUdlb21ldHJ5LnByb3RvdHlwZS5hZGRTaGFwZSA9IGZ1bmN0aW9uICggc2hhcGUsIG9wdGlvbnMgKSB7XG5cbiAgICBcdGlmICggb3B0aW9ucyA9PT0gdW5kZWZpbmVkICkgb3B0aW9ucyA9IHt9O1xuICAgIFx0dmFyIGN1cnZlU2VnbWVudHMgPSBvcHRpb25zLmN1cnZlU2VnbWVudHMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY3VydmVTZWdtZW50cyA6IDEyO1xuXG4gICAgXHR2YXIgbWF0ZXJpYWwgPSBvcHRpb25zLm1hdGVyaWFsO1xuICAgIFx0dmFyIHV2Z2VuID0gb3B0aW9ucy5VVkdlbmVyYXRvciA9PT0gdW5kZWZpbmVkID8gRXh0cnVkZUdlb21ldHJ5LldvcmxkVVZHZW5lcmF0b3IgOiBvcHRpb25zLlVWR2VuZXJhdG9yO1xuXG4gICAgXHQvL1xuXG4gICAgXHR2YXIgaSwgbCwgaG9sZTtcblxuICAgIFx0dmFyIHNoYXBlc09mZnNldCA9IHRoaXMudmVydGljZXMubGVuZ3RoO1xuICAgIFx0dmFyIHNoYXBlUG9pbnRzID0gc2hhcGUuZXh0cmFjdFBvaW50cyggY3VydmVTZWdtZW50cyApO1xuXG4gICAgXHR2YXIgdmVydGljZXMgPSBzaGFwZVBvaW50cy5zaGFwZTtcbiAgICBcdHZhciBob2xlcyA9IHNoYXBlUG9pbnRzLmhvbGVzO1xuXG4gICAgXHR2YXIgcmV2ZXJzZSA9ICEgZXhwb3J0cy5TaGFwZVV0aWxzLmlzQ2xvY2tXaXNlKCB2ZXJ0aWNlcyApO1xuXG4gICAgXHRpZiAoIHJldmVyc2UgKSB7XG5cbiAgICBcdFx0dmVydGljZXMgPSB2ZXJ0aWNlcy5yZXZlcnNlKCk7XG5cbiAgICBcdFx0Ly8gTWF5YmUgd2Ugc2hvdWxkIGFsc28gY2hlY2sgaWYgaG9sZXMgYXJlIGluIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb24sIGp1c3QgdG8gYmUgc2FmZS4uLlxuXG4gICAgXHRcdGZvciAoIGkgPSAwLCBsID0gaG9sZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgIFx0XHRcdGhvbGUgPSBob2xlc1sgaSBdO1xuXG4gICAgXHRcdFx0aWYgKCBleHBvcnRzLlNoYXBlVXRpbHMuaXNDbG9ja1dpc2UoIGhvbGUgKSApIHtcblxuICAgIFx0XHRcdFx0aG9sZXNbIGkgXSA9IGhvbGUucmV2ZXJzZSgpO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXZlcnNlID0gZmFsc2U7XG5cbiAgICBcdH1cblxuICAgIFx0dmFyIGZhY2VzID0gZXhwb3J0cy5TaGFwZVV0aWxzLnRyaWFuZ3VsYXRlU2hhcGUoIHZlcnRpY2VzLCBob2xlcyApO1xuXG4gICAgXHQvLyBWZXJ0aWNlc1xuXG4gICAgXHRmb3IgKCBpID0gMCwgbCA9IGhvbGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICBcdFx0aG9sZSA9IGhvbGVzWyBpIF07XG4gICAgXHRcdHZlcnRpY2VzID0gdmVydGljZXMuY29uY2F0KCBob2xlICk7XG5cbiAgICBcdH1cblxuICAgIFx0Ly9cblxuICAgIFx0dmFyIHZlcnQsIHZsZW4gPSB2ZXJ0aWNlcy5sZW5ndGg7XG4gICAgXHR2YXIgZmFjZSwgZmxlbiA9IGZhY2VzLmxlbmd0aDtcblxuICAgIFx0Zm9yICggaSA9IDA7IGkgPCB2bGVuOyBpICsrICkge1xuXG4gICAgXHRcdHZlcnQgPSB2ZXJ0aWNlc1sgaSBdO1xuXG4gICAgXHRcdHRoaXMudmVydGljZXMucHVzaCggbmV3IFZlY3RvcjMoIHZlcnQueCwgdmVydC55LCAwICkgKTtcblxuICAgIFx0fVxuXG4gICAgXHRmb3IgKCBpID0gMDsgaSA8IGZsZW47IGkgKysgKSB7XG5cbiAgICBcdFx0ZmFjZSA9IGZhY2VzWyBpIF07XG5cbiAgICBcdFx0dmFyIGEgPSBmYWNlWyAwIF0gKyBzaGFwZXNPZmZzZXQ7XG4gICAgXHRcdHZhciBiID0gZmFjZVsgMSBdICsgc2hhcGVzT2Zmc2V0O1xuICAgIFx0XHR2YXIgYyA9IGZhY2VbIDIgXSArIHNoYXBlc09mZnNldDtcblxuICAgIFx0XHR0aGlzLmZhY2VzLnB1c2goIG5ldyBGYWNlMyggYSwgYiwgYywgbnVsbCwgbnVsbCwgbWF0ZXJpYWwgKSApO1xuICAgIFx0XHR0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCB1dmdlbi5nZW5lcmF0ZVRvcFVWKCB0aGlzLCBhLCBiLCBjICkgKTtcblxuICAgIFx0fVxuXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gRWRnZXNHZW9tZXRyeSggZ2VvbWV0cnksIHRocmVzaG9sZEFuZ2xlICkge1xuXG4gICAgXHRCdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cbiAgICBcdHRocmVzaG9sZEFuZ2xlID0gKCB0aHJlc2hvbGRBbmdsZSAhPT0gdW5kZWZpbmVkICkgPyB0aHJlc2hvbGRBbmdsZSA6IDE7XG5cbiAgICBcdHZhciB0aHJlc2hvbGREb3QgPSBNYXRoLmNvcyggZXhwb3J0cy5NYXRoLkRFRzJSQUQgKiB0aHJlc2hvbGRBbmdsZSApO1xuXG4gICAgXHR2YXIgZWRnZSA9IFsgMCwgMCBdLCBoYXNoID0ge307XG5cbiAgICBcdGZ1bmN0aW9uIHNvcnRGdW5jdGlvbiggYSwgYiApIHtcblxuICAgIFx0XHRyZXR1cm4gYSAtIGI7XG5cbiAgICBcdH1cblxuICAgIFx0dmFyIGtleXMgPSBbICdhJywgJ2InLCAnYycgXTtcblxuICAgIFx0dmFyIGdlb21ldHJ5MjtcblxuICAgIFx0aWYgKCAoZ2VvbWV0cnkgJiYgZ2VvbWV0cnkuaXNCdWZmZXJHZW9tZXRyeSkgKSB7XG5cbiAgICBcdFx0Z2VvbWV0cnkyID0gbmV3IEdlb21ldHJ5KCk7XG4gICAgXHRcdGdlb21ldHJ5Mi5mcm9tQnVmZmVyR2VvbWV0cnkoIGdlb21ldHJ5ICk7XG5cbiAgICBcdH0gZWxzZSB7XG5cbiAgICBcdFx0Z2VvbWV0cnkyID0gZ2VvbWV0cnkuY2xvbmUoKTtcblxuICAgIFx0fVxuXG4gICAgXHRnZW9tZXRyeTIubWVyZ2VWZXJ0aWNlcygpO1xuICAgIFx0Z2VvbWV0cnkyLmNvbXB1dGVGYWNlTm9ybWFscygpO1xuXG4gICAgXHR2YXIgdmVydGljZXMgPSBnZW9tZXRyeTIudmVydGljZXM7XG4gICAgXHR2YXIgZmFjZXMgPSBnZW9tZXRyeTIuZmFjZXM7XG5cbiAgICBcdGZvciAoIHZhciBpID0gMCwgbCA9IGZhY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICBcdFx0dmFyIGZhY2UgPSBmYWNlc1sgaSBdO1xuXG4gICAgXHRcdGZvciAoIHZhciBqID0gMDsgaiA8IDM7IGogKysgKSB7XG5cbiAgICBcdFx0XHRlZGdlWyAwIF0gPSBmYWNlWyBrZXlzWyBqIF0gXTtcbiAgICBcdFx0XHRlZGdlWyAxIF0gPSBmYWNlWyBrZXlzWyAoIGogKyAxICkgJSAzIF0gXTtcbiAgICBcdFx0XHRlZGdlLnNvcnQoIHNvcnRGdW5jdGlvbiApO1xuXG4gICAgXHRcdFx0dmFyIGtleSA9IGVkZ2UudG9TdHJpbmcoKTtcblxuICAgIFx0XHRcdGlmICggaGFzaFsga2V5IF0gPT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0aGFzaFsga2V5IF0gPSB7IHZlcnQxOiBlZGdlWyAwIF0sIHZlcnQyOiBlZGdlWyAxIF0sIGZhY2UxOiBpLCBmYWNlMjogdW5kZWZpbmVkIH07XG5cbiAgICBcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRoYXNoWyBrZXkgXS5mYWNlMiA9IGk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9XG5cbiAgICBcdHZhciBjb29yZHMgPSBbXTtcblxuICAgIFx0Zm9yICggdmFyIGtleSBpbiBoYXNoICkge1xuXG4gICAgXHRcdHZhciBoID0gaGFzaFsga2V5IF07XG5cbiAgICBcdFx0aWYgKCBoLmZhY2UyID09PSB1bmRlZmluZWQgfHwgZmFjZXNbIGguZmFjZTEgXS5ub3JtYWwuZG90KCBmYWNlc1sgaC5mYWNlMiBdLm5vcm1hbCApIDw9IHRocmVzaG9sZERvdCApIHtcblxuICAgIFx0XHRcdHZhciB2ZXJ0ZXggPSB2ZXJ0aWNlc1sgaC52ZXJ0MSBdO1xuICAgIFx0XHRcdGNvb3Jkcy5wdXNoKCB2ZXJ0ZXgueCApO1xuICAgIFx0XHRcdGNvb3Jkcy5wdXNoKCB2ZXJ0ZXgueSApO1xuICAgIFx0XHRcdGNvb3Jkcy5wdXNoKCB2ZXJ0ZXgueiApO1xuXG4gICAgXHRcdFx0dmVydGV4ID0gdmVydGljZXNbIGgudmVydDIgXTtcbiAgICBcdFx0XHRjb29yZHMucHVzaCggdmVydGV4LnggKTtcbiAgICBcdFx0XHRjb29yZHMucHVzaCggdmVydGV4LnkgKTtcbiAgICBcdFx0XHRjb29yZHMucHVzaCggdmVydGV4LnogKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdH1cblxuICAgIFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIG5ldyBGbG9hdDMyQXJyYXkoIGNvb3JkcyApLCAzICkgKTtcblxuICAgIH1cblxuICAgIEVkZ2VzR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XG4gICAgRWRnZXNHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBFZGdlc0dlb21ldHJ5O1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBNdWdlbjg3IC8gaHR0cHM6Ly9naXRodWIuY29tL011Z2VuODdcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIEN5bGluZGVyQnVmZmVyR2VvbWV0cnkoIHJhZGl1c1RvcCwgcmFkaXVzQm90dG9tLCBoZWlnaHQsIHJhZGlhbFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgb3BlbkVuZGVkLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApIHtcblxuICAgIFx0QnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG4gICAgXHR0aGlzLnR5cGUgPSAnQ3lsaW5kZXJCdWZmZXJHZW9tZXRyeSc7XG5cbiAgICBcdHRoaXMucGFyYW1ldGVycyA9IHtcbiAgICBcdFx0cmFkaXVzVG9wOiByYWRpdXNUb3AsXG4gICAgXHRcdHJhZGl1c0JvdHRvbTogcmFkaXVzQm90dG9tLFxuICAgIFx0XHRoZWlnaHQ6IGhlaWdodCxcbiAgICBcdFx0cmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxuICAgIFx0XHRoZWlnaHRTZWdtZW50czogaGVpZ2h0U2VnbWVudHMsXG4gICAgXHRcdG9wZW5FbmRlZDogb3BlbkVuZGVkLFxuICAgIFx0XHR0aGV0YVN0YXJ0OiB0aGV0YVN0YXJ0LFxuICAgIFx0XHR0aGV0YUxlbmd0aDogdGhldGFMZW5ndGhcbiAgICBcdH07XG5cbiAgICBcdHZhciBzY29wZSA9IHRoaXM7XG5cbiAgICBcdHJhZGl1c1RvcCA9IHJhZGl1c1RvcCAhPT0gdW5kZWZpbmVkID8gcmFkaXVzVG9wIDogMjA7XG4gICAgXHRyYWRpdXNCb3R0b20gPSByYWRpdXNCb3R0b20gIT09IHVuZGVmaW5lZCA/IHJhZGl1c0JvdHRvbSA6IDIwO1xuICAgIFx0aGVpZ2h0ID0gaGVpZ2h0ICE9PSB1bmRlZmluZWQgPyBoZWlnaHQgOiAxMDA7XG5cbiAgICBcdHJhZGlhbFNlZ21lbnRzID0gTWF0aC5mbG9vciggcmFkaWFsU2VnbWVudHMgKSB8fCA4O1xuICAgIFx0aGVpZ2h0U2VnbWVudHMgPSBNYXRoLmZsb29yKCBoZWlnaHRTZWdtZW50cyApIHx8IDE7XG5cbiAgICBcdG9wZW5FbmRlZCA9IG9wZW5FbmRlZCAhPT0gdW5kZWZpbmVkID8gb3BlbkVuZGVkIDogZmFsc2U7XG4gICAgXHR0aGV0YVN0YXJ0ID0gdGhldGFTdGFydCAhPT0gdW5kZWZpbmVkID8gdGhldGFTdGFydCA6IDAuMDtcbiAgICBcdHRoZXRhTGVuZ3RoID0gdGhldGFMZW5ndGggIT09IHVuZGVmaW5lZCA/IHRoZXRhTGVuZ3RoIDogMi4wICogTWF0aC5QSTtcblxuICAgIFx0Ly8gdXNlZCB0byBjYWxjdWxhdGUgYnVmZmVyIGxlbmd0aFxuXG4gICAgXHR2YXIgbmJDYXAgPSAwO1xuXG4gICAgXHRpZiAoIG9wZW5FbmRlZCA9PT0gZmFsc2UgKSB7XG5cbiAgICBcdFx0aWYgKCByYWRpdXNUb3AgPiAwICkgbmJDYXAgKys7XG4gICAgXHRcdGlmICggcmFkaXVzQm90dG9tID4gMCApIG5iQ2FwICsrO1xuXG4gICAgXHR9XG5cbiAgICBcdHZhciB2ZXJ0ZXhDb3VudCA9IGNhbGN1bGF0ZVZlcnRleENvdW50KCk7XG4gICAgXHR2YXIgaW5kZXhDb3VudCA9IGNhbGN1bGF0ZUluZGV4Q291bnQoKTtcblxuICAgIFx0Ly8gYnVmZmVyc1xuXG4gICAgXHR2YXIgaW5kaWNlcyA9IG5ldyBCdWZmZXJBdHRyaWJ1dGUoIG5ldyAoIGluZGV4Q291bnQgPiA2NTUzNSA/IFVpbnQzMkFycmF5IDogVWludDE2QXJyYXkgKSggaW5kZXhDb3VudCApLCAxICk7XG4gICAgXHR2YXIgdmVydGljZXMgPSBuZXcgQnVmZmVyQXR0cmlidXRlKCBuZXcgRmxvYXQzMkFycmF5KCB2ZXJ0ZXhDb3VudCAqIDMgKSwgMyApO1xuICAgIFx0dmFyIG5vcm1hbHMgPSBuZXcgQnVmZmVyQXR0cmlidXRlKCBuZXcgRmxvYXQzMkFycmF5KCB2ZXJ0ZXhDb3VudCAqIDMgKSwgMyApO1xuICAgIFx0dmFyIHV2cyA9IG5ldyBCdWZmZXJBdHRyaWJ1dGUoIG5ldyBGbG9hdDMyQXJyYXkoIHZlcnRleENvdW50ICogMiApLCAyICk7XG5cbiAgICBcdC8vIGhlbHBlciB2YXJpYWJsZXNcblxuICAgIFx0dmFyIGluZGV4ID0gMCxcbiAgICBcdCAgICBpbmRleE9mZnNldCA9IDAsXG4gICAgXHQgICAgaW5kZXhBcnJheSA9IFtdLFxuICAgIFx0ICAgIGhhbGZIZWlnaHQgPSBoZWlnaHQgLyAyO1xuXG4gICAgXHQvLyBncm91cCB2YXJpYWJsZXNcbiAgICBcdHZhciBncm91cFN0YXJ0ID0gMDtcblxuICAgIFx0Ly8gZ2VuZXJhdGUgZ2VvbWV0cnlcblxuICAgIFx0Z2VuZXJhdGVUb3JzbygpO1xuXG4gICAgXHRpZiAoIG9wZW5FbmRlZCA9PT0gZmFsc2UgKSB7XG5cbiAgICBcdFx0aWYgKCByYWRpdXNUb3AgPiAwICkgZ2VuZXJhdGVDYXAoIHRydWUgKTtcbiAgICBcdFx0aWYgKCByYWRpdXNCb3R0b20gPiAwICkgZ2VuZXJhdGVDYXAoIGZhbHNlICk7XG5cbiAgICBcdH1cblxuICAgIFx0Ly8gYnVpbGQgZ2VvbWV0cnlcblxuICAgIFx0dGhpcy5zZXRJbmRleCggaW5kaWNlcyApO1xuICAgIFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIHZlcnRpY2VzICk7XG4gICAgXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5vcm1hbHMgKTtcbiAgICBcdHRoaXMuYWRkQXR0cmlidXRlKCAndXYnLCB1dnMgKTtcblxuICAgIFx0Ly8gaGVscGVyIGZ1bmN0aW9uc1xuXG4gICAgXHRmdW5jdGlvbiBjYWxjdWxhdGVWZXJ0ZXhDb3VudCgpIHtcblxuICAgIFx0XHR2YXIgY291bnQgPSAoIHJhZGlhbFNlZ21lbnRzICsgMSApICogKCBoZWlnaHRTZWdtZW50cyArIDEgKTtcblxuICAgIFx0XHRpZiAoIG9wZW5FbmRlZCA9PT0gZmFsc2UgKSB7XG5cbiAgICBcdFx0XHRjb3VudCArPSAoICggcmFkaWFsU2VnbWVudHMgKyAxICkgKiBuYkNhcCApICsgKCByYWRpYWxTZWdtZW50cyAqIG5iQ2FwICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiBjb3VudDtcblxuICAgIFx0fVxuXG4gICAgXHRmdW5jdGlvbiBjYWxjdWxhdGVJbmRleENvdW50KCkge1xuXG4gICAgXHRcdHZhciBjb3VudCA9IHJhZGlhbFNlZ21lbnRzICogaGVpZ2h0U2VnbWVudHMgKiAyICogMztcblxuICAgIFx0XHRpZiAoIG9wZW5FbmRlZCA9PT0gZmFsc2UgKSB7XG5cbiAgICBcdFx0XHRjb3VudCArPSByYWRpYWxTZWdtZW50cyAqIG5iQ2FwICogMztcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIGNvdW50O1xuXG4gICAgXHR9XG5cbiAgICBcdGZ1bmN0aW9uIGdlbmVyYXRlVG9yc28oKSB7XG5cbiAgICBcdFx0dmFyIHgsIHk7XG4gICAgXHRcdHZhciBub3JtYWwgPSBuZXcgVmVjdG9yMygpO1xuICAgIFx0XHR2YXIgdmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcblxuICAgIFx0XHR2YXIgZ3JvdXBDb3VudCA9IDA7XG5cbiAgICBcdFx0Ly8gdGhpcyB3aWxsIGJlIHVzZWQgdG8gY2FsY3VsYXRlIHRoZSBub3JtYWxcbiAgICBcdFx0dmFyIHNsb3BlID0gKCByYWRpdXNCb3R0b20gLSByYWRpdXNUb3AgKSAvIGhlaWdodDtcblxuICAgIFx0XHQvLyBnZW5lcmF0ZSB2ZXJ0aWNlcywgbm9ybWFscyBhbmQgdXZzXG5cbiAgICBcdFx0Zm9yICggeSA9IDA7IHkgPD0gaGVpZ2h0U2VnbWVudHM7IHkgKysgKSB7XG5cbiAgICBcdFx0XHR2YXIgaW5kZXhSb3cgPSBbXTtcblxuICAgIFx0XHRcdHZhciB2ID0geSAvIGhlaWdodFNlZ21lbnRzO1xuXG4gICAgXHRcdFx0Ly8gY2FsY3VsYXRlIHRoZSByYWRpdXMgb2YgdGhlIGN1cnJlbnQgcm93XG4gICAgXHRcdFx0dmFyIHJhZGl1cyA9IHYgKiAoIHJhZGl1c0JvdHRvbSAtIHJhZGl1c1RvcCApICsgcmFkaXVzVG9wO1xuXG4gICAgXHRcdFx0Zm9yICggeCA9IDA7IHggPD0gcmFkaWFsU2VnbWVudHM7IHggKysgKSB7XG5cbiAgICBcdFx0XHRcdHZhciB1ID0geCAvIHJhZGlhbFNlZ21lbnRzO1xuXG4gICAgXHRcdFx0XHR2YXIgdGhldGEgPSB1ICogdGhldGFMZW5ndGggKyB0aGV0YVN0YXJ0O1xuXG4gICAgXHRcdFx0XHR2YXIgc2luVGhldGEgPSBNYXRoLnNpbiggdGhldGEgKTtcbiAgICBcdFx0XHRcdHZhciBjb3NUaGV0YSA9IE1hdGguY29zKCB0aGV0YSApO1xuXG4gICAgXHRcdFx0XHQvLyB2ZXJ0ZXhcbiAgICBcdFx0XHRcdHZlcnRleC54ID0gcmFkaXVzICogc2luVGhldGE7XG4gICAgXHRcdFx0XHR2ZXJ0ZXgueSA9IC0gdiAqIGhlaWdodCArIGhhbGZIZWlnaHQ7XG4gICAgXHRcdFx0XHR2ZXJ0ZXgueiA9IHJhZGl1cyAqIGNvc1RoZXRhO1xuICAgIFx0XHRcdFx0dmVydGljZXMuc2V0WFlaKCBpbmRleCwgdmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueiApO1xuXG4gICAgXHRcdFx0XHQvLyBub3JtYWxcbiAgICBcdFx0XHRcdG5vcm1hbC5zZXQoIHNpblRoZXRhLCBzbG9wZSwgY29zVGhldGEgKS5ub3JtYWxpemUoKTtcbiAgICBcdFx0XHRcdG5vcm1hbHMuc2V0WFlaKCBpbmRleCwgbm9ybWFsLngsIG5vcm1hbC55LCBub3JtYWwueiApO1xuXG4gICAgXHRcdFx0XHQvLyB1dlxuICAgIFx0XHRcdFx0dXZzLnNldFhZKCBpbmRleCwgdSwgMSAtIHYgKTtcblxuICAgIFx0XHRcdFx0Ly8gc2F2ZSBpbmRleCBvZiB2ZXJ0ZXggaW4gcmVzcGVjdGl2ZSByb3dcbiAgICBcdFx0XHRcdGluZGV4Um93LnB1c2goIGluZGV4ICk7XG5cbiAgICBcdFx0XHRcdC8vIGluY3JlYXNlIGluZGV4XG4gICAgXHRcdFx0XHRpbmRleCArKztcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdC8vIG5vdyBzYXZlIHZlcnRpY2VzIG9mIHRoZSByb3cgaW4gb3VyIGluZGV4IGFycmF5XG4gICAgXHRcdFx0aW5kZXhBcnJheS5wdXNoKCBpbmRleFJvdyApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHQvLyBnZW5lcmF0ZSBpbmRpY2VzXG5cbiAgICBcdFx0Zm9yICggeCA9IDA7IHggPCByYWRpYWxTZWdtZW50czsgeCArKyApIHtcblxuICAgIFx0XHRcdGZvciAoIHkgPSAwOyB5IDwgaGVpZ2h0U2VnbWVudHM7IHkgKysgKSB7XG5cbiAgICBcdFx0XHRcdC8vIHdlIHVzZSB0aGUgaW5kZXggYXJyYXkgdG8gYWNjZXNzIHRoZSBjb3JyZWN0IGluZGljZXNcbiAgICBcdFx0XHRcdHZhciBpMSA9IGluZGV4QXJyYXlbIHkgXVsgeCBdO1xuICAgIFx0XHRcdFx0dmFyIGkyID0gaW5kZXhBcnJheVsgeSArIDEgXVsgeCBdO1xuICAgIFx0XHRcdFx0dmFyIGkzID0gaW5kZXhBcnJheVsgeSArIDEgXVsgeCArIDEgXTtcbiAgICBcdFx0XHRcdHZhciBpNCA9IGluZGV4QXJyYXlbIHkgXVsgeCArIDEgXTtcblxuICAgIFx0XHRcdFx0Ly8gZmFjZSBvbmVcbiAgICBcdFx0XHRcdGluZGljZXMuc2V0WCggaW5kZXhPZmZzZXQsIGkxICk7IGluZGV4T2Zmc2V0ICsrO1xuICAgIFx0XHRcdFx0aW5kaWNlcy5zZXRYKCBpbmRleE9mZnNldCwgaTIgKTsgaW5kZXhPZmZzZXQgKys7XG4gICAgXHRcdFx0XHRpbmRpY2VzLnNldFgoIGluZGV4T2Zmc2V0LCBpNCApOyBpbmRleE9mZnNldCArKztcblxuICAgIFx0XHRcdFx0Ly8gZmFjZSB0d29cbiAgICBcdFx0XHRcdGluZGljZXMuc2V0WCggaW5kZXhPZmZzZXQsIGkyICk7IGluZGV4T2Zmc2V0ICsrO1xuICAgIFx0XHRcdFx0aW5kaWNlcy5zZXRYKCBpbmRleE9mZnNldCwgaTMgKTsgaW5kZXhPZmZzZXQgKys7XG4gICAgXHRcdFx0XHRpbmRpY2VzLnNldFgoIGluZGV4T2Zmc2V0LCBpNCApOyBpbmRleE9mZnNldCArKztcblxuICAgIFx0XHRcdFx0Ly8gdXBkYXRlIGNvdW50ZXJzXG4gICAgXHRcdFx0XHRncm91cENvdW50ICs9IDY7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdC8vIGFkZCBhIGdyb3VwIHRvIHRoZSBnZW9tZXRyeS4gdGhpcyB3aWxsIGVuc3VyZSBtdWx0aSBtYXRlcmlhbCBzdXBwb3J0XG4gICAgXHRcdHNjb3BlLmFkZEdyb3VwKCBncm91cFN0YXJ0LCBncm91cENvdW50LCAwICk7XG5cbiAgICBcdFx0Ly8gY2FsY3VsYXRlIG5ldyBzdGFydCB2YWx1ZSBmb3IgZ3JvdXBzXG4gICAgXHRcdGdyb3VwU3RhcnQgKz0gZ3JvdXBDb3VudDtcblxuICAgIFx0fVxuXG4gICAgXHRmdW5jdGlvbiBnZW5lcmF0ZUNhcCggdG9wICkge1xuXG4gICAgXHRcdHZhciB4LCBjZW50ZXJJbmRleFN0YXJ0LCBjZW50ZXJJbmRleEVuZDtcblxuICAgIFx0XHR2YXIgdXYgPSBuZXcgVmVjdG9yMigpO1xuICAgIFx0XHR2YXIgdmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcblxuICAgIFx0XHR2YXIgZ3JvdXBDb3VudCA9IDA7XG5cbiAgICBcdFx0dmFyIHJhZGl1cyA9ICggdG9wID09PSB0cnVlICkgPyByYWRpdXNUb3AgOiByYWRpdXNCb3R0b207XG4gICAgXHRcdHZhciBzaWduID0gKCB0b3AgPT09IHRydWUgKSA/IDEgOiAtIDE7XG5cbiAgICBcdFx0Ly8gc2F2ZSB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IGNlbnRlciB2ZXJ0ZXhcbiAgICBcdFx0Y2VudGVySW5kZXhTdGFydCA9IGluZGV4O1xuXG4gICAgXHRcdC8vIGZpcnN0IHdlIGdlbmVyYXRlIHRoZSBjZW50ZXIgdmVydGV4IGRhdGEgb2YgdGhlIGNhcC5cbiAgICBcdFx0Ly8gYmVjYXVzZSB0aGUgZ2VvbWV0cnkgbmVlZHMgb25lIHNldCBvZiB1dnMgcGVyIGZhY2UsXG4gICAgXHRcdC8vIHdlIG11c3QgZ2VuZXJhdGUgYSBjZW50ZXIgdmVydGV4IHBlciBmYWNlL3NlZ21lbnRcblxuICAgIFx0XHRmb3IgKCB4ID0gMTsgeCA8PSByYWRpYWxTZWdtZW50czsgeCArKyApIHtcblxuICAgIFx0XHRcdC8vIHZlcnRleFxuICAgIFx0XHRcdHZlcnRpY2VzLnNldFhZWiggaW5kZXgsIDAsIGhhbGZIZWlnaHQgKiBzaWduLCAwICk7XG5cbiAgICBcdFx0XHQvLyBub3JtYWxcbiAgICBcdFx0XHRub3JtYWxzLnNldFhZWiggaW5kZXgsIDAsIHNpZ24sIDAgKTtcblxuICAgIFx0XHRcdC8vIHV2XG4gICAgXHRcdFx0dXYueCA9IDAuNTtcbiAgICBcdFx0XHR1di55ID0gMC41O1xuXG4gICAgXHRcdFx0dXZzLnNldFhZKCBpbmRleCwgdXYueCwgdXYueSApO1xuXG4gICAgXHRcdFx0Ly8gaW5jcmVhc2UgaW5kZXhcbiAgICBcdFx0XHRpbmRleCArKztcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0Ly8gc2F2ZSB0aGUgaW5kZXggb2YgdGhlIGxhc3QgY2VudGVyIHZlcnRleFxuICAgIFx0XHRjZW50ZXJJbmRleEVuZCA9IGluZGV4O1xuXG4gICAgXHRcdC8vIG5vdyB3ZSBnZW5lcmF0ZSB0aGUgc3Vycm91bmRpbmcgdmVydGljZXMsIG5vcm1hbHMgYW5kIHV2c1xuXG4gICAgXHRcdGZvciAoIHggPSAwOyB4IDw9IHJhZGlhbFNlZ21lbnRzOyB4ICsrICkge1xuXG4gICAgXHRcdFx0dmFyIHUgPSB4IC8gcmFkaWFsU2VnbWVudHM7XG4gICAgXHRcdFx0dmFyIHRoZXRhID0gdSAqIHRoZXRhTGVuZ3RoICsgdGhldGFTdGFydDtcblxuICAgIFx0XHRcdHZhciBjb3NUaGV0YSA9IE1hdGguY29zKCB0aGV0YSApO1xuICAgIFx0XHRcdHZhciBzaW5UaGV0YSA9IE1hdGguc2luKCB0aGV0YSApO1xuXG4gICAgXHRcdFx0Ly8gdmVydGV4XG4gICAgXHRcdFx0dmVydGV4LnggPSByYWRpdXMgKiBzaW5UaGV0YTtcbiAgICBcdFx0XHR2ZXJ0ZXgueSA9IGhhbGZIZWlnaHQgKiBzaWduO1xuICAgIFx0XHRcdHZlcnRleC56ID0gcmFkaXVzICogY29zVGhldGE7XG4gICAgXHRcdFx0dmVydGljZXMuc2V0WFlaKCBpbmRleCwgdmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueiApO1xuXG4gICAgXHRcdFx0Ly8gbm9ybWFsXG4gICAgXHRcdFx0bm9ybWFscy5zZXRYWVooIGluZGV4LCAwLCBzaWduLCAwICk7XG5cbiAgICBcdFx0XHQvLyB1dlxuICAgIFx0XHRcdHV2LnggPSAoIGNvc1RoZXRhICogMC41ICkgKyAwLjU7XG4gICAgXHRcdFx0dXYueSA9ICggc2luVGhldGEgKiAwLjUgKiBzaWduICkgKyAwLjU7XG4gICAgXHRcdFx0dXZzLnNldFhZKCBpbmRleCwgdXYueCwgdXYueSApO1xuXG4gICAgXHRcdFx0Ly8gaW5jcmVhc2UgaW5kZXhcbiAgICBcdFx0XHRpbmRleCArKztcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0Ly8gZ2VuZXJhdGUgaW5kaWNlc1xuXG4gICAgXHRcdGZvciAoIHggPSAwOyB4IDwgcmFkaWFsU2VnbWVudHM7IHggKysgKSB7XG5cbiAgICBcdFx0XHR2YXIgYyA9IGNlbnRlckluZGV4U3RhcnQgKyB4O1xuICAgIFx0XHRcdHZhciBpID0gY2VudGVySW5kZXhFbmQgKyB4O1xuXG4gICAgXHRcdFx0aWYgKCB0b3AgPT09IHRydWUgKSB7XG5cbiAgICBcdFx0XHRcdC8vIGZhY2UgdG9wXG4gICAgXHRcdFx0XHRpbmRpY2VzLnNldFgoIGluZGV4T2Zmc2V0LCBpICk7IGluZGV4T2Zmc2V0ICsrO1xuICAgIFx0XHRcdFx0aW5kaWNlcy5zZXRYKCBpbmRleE9mZnNldCwgaSArIDEgKTsgaW5kZXhPZmZzZXQgKys7XG4gICAgXHRcdFx0XHRpbmRpY2VzLnNldFgoIGluZGV4T2Zmc2V0LCBjICk7IGluZGV4T2Zmc2V0ICsrO1xuXG4gICAgXHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0Ly8gZmFjZSBib3R0b21cbiAgICBcdFx0XHRcdGluZGljZXMuc2V0WCggaW5kZXhPZmZzZXQsIGkgKyAxICk7IGluZGV4T2Zmc2V0ICsrO1xuICAgIFx0XHRcdFx0aW5kaWNlcy5zZXRYKCBpbmRleE9mZnNldCwgaSApOyBpbmRleE9mZnNldCArKztcbiAgICBcdFx0XHRcdGluZGljZXMuc2V0WCggaW5kZXhPZmZzZXQsIGMgKTsgaW5kZXhPZmZzZXQgKys7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHQvLyB1cGRhdGUgY291bnRlcnNcbiAgICBcdFx0XHRncm91cENvdW50ICs9IDM7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdC8vIGFkZCBhIGdyb3VwIHRvIHRoZSBnZW9tZXRyeS4gdGhpcyB3aWxsIGVuc3VyZSBtdWx0aSBtYXRlcmlhbCBzdXBwb3J0XG4gICAgXHRcdHNjb3BlLmFkZEdyb3VwKCBncm91cFN0YXJ0LCBncm91cENvdW50LCB0b3AgPT09IHRydWUgPyAxIDogMiApO1xuXG4gICAgXHRcdC8vIGNhbGN1bGF0ZSBuZXcgc3RhcnQgdmFsdWUgZm9yIGdyb3Vwc1xuICAgIFx0XHRncm91cFN0YXJ0ICs9IGdyb3VwQ291bnQ7XG5cbiAgICBcdH1cblxuICAgIH1cblxuICAgIEN5bGluZGVyQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XG4gICAgQ3lsaW5kZXJCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDeWxpbmRlckJ1ZmZlckdlb21ldHJ5O1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIEN5bGluZGVyR2VvbWV0cnkoIHJhZGl1c1RvcCwgcmFkaXVzQm90dG9tLCBoZWlnaHQsIHJhZGlhbFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgb3BlbkVuZGVkLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApIHtcblxuICAgIFx0R2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG4gICAgXHR0aGlzLnR5cGUgPSAnQ3lsaW5kZXJHZW9tZXRyeSc7XG5cbiAgICBcdHRoaXMucGFyYW1ldGVycyA9IHtcbiAgICBcdFx0cmFkaXVzVG9wOiByYWRpdXNUb3AsXG4gICAgXHRcdHJhZGl1c0JvdHRvbTogcmFkaXVzQm90dG9tLFxuICAgIFx0XHRoZWlnaHQ6IGhlaWdodCxcbiAgICBcdFx0cmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxuICAgIFx0XHRoZWlnaHRTZWdtZW50czogaGVpZ2h0U2VnbWVudHMsXG4gICAgXHRcdG9wZW5FbmRlZDogb3BlbkVuZGVkLFxuICAgIFx0XHR0aGV0YVN0YXJ0OiB0aGV0YVN0YXJ0LFxuICAgIFx0XHR0aGV0YUxlbmd0aDogdGhldGFMZW5ndGhcbiAgICBcdH07XG5cbiAgICBcdHRoaXMuZnJvbUJ1ZmZlckdlb21ldHJ5KCBuZXcgQ3lsaW5kZXJCdWZmZXJHZW9tZXRyeSggcmFkaXVzVG9wLCByYWRpdXNCb3R0b20sIGhlaWdodCwgcmFkaWFsU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCBvcGVuRW5kZWQsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICkgKTtcbiAgICBcdHRoaXMubWVyZ2VWZXJ0aWNlcygpO1xuXG4gICAgfVxuXG4gICAgQ3lsaW5kZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBHZW9tZXRyeS5wcm90b3R5cGUgKTtcbiAgICBDeWxpbmRlckdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEN5bGluZGVyR2VvbWV0cnk7XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIGFiZWxuYXRpb24gLyBodHRwOi8vZ2l0aHViLmNvbS9hYmVsbmF0aW9uXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBDb25lR2VvbWV0cnkoXG4gICAgXHRyYWRpdXMsIGhlaWdodCxcbiAgICBcdHJhZGlhbFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cyxcbiAgICBcdG9wZW5FbmRlZCwgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKSB7XG5cbiAgICBcdEN5bGluZGVyR2VvbWV0cnkuY2FsbCggdGhpcyxcbiAgICBcdFx0MCwgcmFkaXVzLCBoZWlnaHQsXG4gICAgXHRcdHJhZGlhbFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cyxcbiAgICBcdFx0b3BlbkVuZGVkLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApO1xuXG4gICAgXHR0aGlzLnR5cGUgPSAnQ29uZUdlb21ldHJ5JztcblxuICAgIFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuICAgIFx0XHRyYWRpdXM6IHJhZGl1cyxcbiAgICBcdFx0aGVpZ2h0OiBoZWlnaHQsXG4gICAgXHRcdHJhZGlhbFNlZ21lbnRzOiByYWRpYWxTZWdtZW50cyxcbiAgICBcdFx0aGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzLFxuICAgIFx0XHRvcGVuRW5kZWQ6IG9wZW5FbmRlZCxcbiAgICBcdFx0dGhldGFTdGFydDogdGhldGFTdGFydCxcbiAgICBcdFx0dGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoXG4gICAgXHR9O1xuXG4gICAgfVxuXG4gICAgQ29uZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEN5bGluZGVyR2VvbWV0cnkucHJvdG90eXBlICk7XG4gICAgQ29uZUdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbmVHZW9tZXRyeTtcblxuICAgIC8qXG4gICAgICogQGF1dGhvcjogYWJlbG5hdGlvbiAvIGh0dHA6Ly9naXRodWIuY29tL2FiZWxuYXRpb25cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIENvbmVCdWZmZXJHZW9tZXRyeShcbiAgICBcdHJhZGl1cywgaGVpZ2h0LFxuICAgIFx0cmFkaWFsU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLFxuICAgIFx0b3BlbkVuZGVkLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApIHtcblxuICAgIFx0Q3lsaW5kZXJCdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzLFxuICAgIFx0XHQwLCByYWRpdXMsIGhlaWdodCxcbiAgICBcdFx0cmFkaWFsU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLFxuICAgIFx0XHRvcGVuRW5kZWQsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICk7XG5cbiAgICBcdHRoaXMudHlwZSA9ICdDb25lQnVmZmVyR2VvbWV0cnknO1xuXG4gICAgXHR0aGlzLnBhcmFtZXRlcnMgPSB7XG4gICAgXHRcdHJhZGl1czogcmFkaXVzLFxuICAgIFx0XHRoZWlnaHQ6IGhlaWdodCxcbiAgICBcdFx0cmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxuICAgIFx0XHRoZWlnaHRTZWdtZW50czogaGVpZ2h0U2VnbWVudHMsXG4gICAgXHRcdHRoZXRhU3RhcnQ6IHRoZXRhU3RhcnQsXG4gICAgXHRcdHRoZXRhTGVuZ3RoOiB0aGV0YUxlbmd0aFxuICAgIFx0fTtcblxuICAgIH1cblxuICAgIENvbmVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcbiAgICBDb25lQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29uZUJ1ZmZlckdlb21ldHJ5O1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBiZW5hYWRhbXMgLyBodHRwczovL3R3aXR0ZXIuY29tL2Jlbl9hX2FkYW1zXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBDaXJjbGVCdWZmZXJHZW9tZXRyeSggcmFkaXVzLCBzZWdtZW50cywgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKSB7XG5cbiAgICBcdEJ1ZmZlckdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuICAgIFx0dGhpcy50eXBlID0gJ0NpcmNsZUJ1ZmZlckdlb21ldHJ5JztcblxuICAgIFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuICAgIFx0XHRyYWRpdXM6IHJhZGl1cyxcbiAgICBcdFx0c2VnbWVudHM6IHNlZ21lbnRzLFxuICAgIFx0XHR0aGV0YVN0YXJ0OiB0aGV0YVN0YXJ0LFxuICAgIFx0XHR0aGV0YUxlbmd0aDogdGhldGFMZW5ndGhcbiAgICBcdH07XG5cbiAgICBcdHJhZGl1cyA9IHJhZGl1cyB8fCA1MDtcbiAgICBcdHNlZ21lbnRzID0gc2VnbWVudHMgIT09IHVuZGVmaW5lZCA/IE1hdGgubWF4KCAzLCBzZWdtZW50cyApIDogODtcblxuICAgIFx0dGhldGFTdGFydCA9IHRoZXRhU3RhcnQgIT09IHVuZGVmaW5lZCA/IHRoZXRhU3RhcnQgOiAwO1xuICAgIFx0dGhldGFMZW5ndGggPSB0aGV0YUxlbmd0aCAhPT0gdW5kZWZpbmVkID8gdGhldGFMZW5ndGggOiBNYXRoLlBJICogMjtcblxuICAgIFx0dmFyIHZlcnRpY2VzID0gc2VnbWVudHMgKyAyO1xuXG4gICAgXHR2YXIgcG9zaXRpb25zID0gbmV3IEZsb2F0MzJBcnJheSggdmVydGljZXMgKiAzICk7XG4gICAgXHR2YXIgbm9ybWFscyA9IG5ldyBGbG9hdDMyQXJyYXkoIHZlcnRpY2VzICogMyApO1xuICAgIFx0dmFyIHV2cyA9IG5ldyBGbG9hdDMyQXJyYXkoIHZlcnRpY2VzICogMiApO1xuXG4gICAgXHQvLyBjZW50ZXIgZGF0YSBpcyBhbHJlYWR5IHplcm8sIGJ1dCBuZWVkIHRvIHNldCBhIGZldyBleHRyYXNcbiAgICBcdG5vcm1hbHNbIDIgXSA9IDEuMDtcbiAgICBcdHV2c1sgMCBdID0gMC41O1xuICAgIFx0dXZzWyAxIF0gPSAwLjU7XG5cbiAgICBcdGZvciAoIHZhciBzID0gMCwgaSA9IDMsIGlpID0gMiA7IHMgPD0gc2VnbWVudHM7IHMgKyssIGkgKz0gMywgaWkgKz0gMiApIHtcblxuICAgIFx0XHR2YXIgc2VnbWVudCA9IHRoZXRhU3RhcnQgKyBzIC8gc2VnbWVudHMgKiB0aGV0YUxlbmd0aDtcblxuICAgIFx0XHRwb3NpdGlvbnNbIGkgXSA9IHJhZGl1cyAqIE1hdGguY29zKCBzZWdtZW50ICk7XG4gICAgXHRcdHBvc2l0aW9uc1sgaSArIDEgXSA9IHJhZGl1cyAqIE1hdGguc2luKCBzZWdtZW50ICk7XG5cbiAgICBcdFx0bm9ybWFsc1sgaSArIDIgXSA9IDE7IC8vIG5vcm1hbCB6XG5cbiAgICBcdFx0dXZzWyBpaSBdID0gKCBwb3NpdGlvbnNbIGkgXSAvIHJhZGl1cyArIDEgKSAvIDI7XG4gICAgXHRcdHV2c1sgaWkgKyAxIF0gPSAoIHBvc2l0aW9uc1sgaSArIDEgXSAvIHJhZGl1cyArIDEgKSAvIDI7XG5cbiAgICBcdH1cblxuICAgIFx0dmFyIGluZGljZXMgPSBbXTtcblxuICAgIFx0Zm9yICggdmFyIGkgPSAxOyBpIDw9IHNlZ21lbnRzOyBpICsrICkge1xuXG4gICAgXHRcdGluZGljZXMucHVzaCggaSwgaSArIDEsIDAgKTtcblxuICAgIFx0fVxuXG4gICAgXHR0aGlzLnNldEluZGV4KCBuZXcgQnVmZmVyQXR0cmlidXRlKCBuZXcgVWludDE2QXJyYXkoIGluZGljZXMgKSwgMSApICk7XG4gICAgXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25zLCAzICkgKTtcbiAgICBcdHRoaXMuYWRkQXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IEJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFscywgMyApICk7XG4gICAgXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3V2JywgbmV3IEJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcblxuICAgIFx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG5ldyBTcGhlcmUoIG5ldyBWZWN0b3IzKCksIHJhZGl1cyApO1xuXG4gICAgfVxuXG4gICAgQ2lyY2xlQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XG4gICAgQ2lyY2xlQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2lyY2xlQnVmZmVyR2VvbWV0cnk7XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIGh1Z2hlc1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gQ2lyY2xlR2VvbWV0cnkoIHJhZGl1cywgc2VnbWVudHMsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICkge1xuXG4gICAgXHRHZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cbiAgICBcdHRoaXMudHlwZSA9ICdDaXJjbGVHZW9tZXRyeSc7XG5cbiAgICBcdHRoaXMucGFyYW1ldGVycyA9IHtcbiAgICBcdFx0cmFkaXVzOiByYWRpdXMsXG4gICAgXHRcdHNlZ21lbnRzOiBzZWdtZW50cyxcbiAgICBcdFx0dGhldGFTdGFydDogdGhldGFTdGFydCxcbiAgICBcdFx0dGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoXG4gICAgXHR9O1xuXG4gICAgXHR0aGlzLmZyb21CdWZmZXJHZW9tZXRyeSggbmV3IENpcmNsZUJ1ZmZlckdlb21ldHJ5KCByYWRpdXMsIHNlZ21lbnRzLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApICk7XG5cbiAgICB9XG5cbiAgICBDaXJjbGVHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBHZW9tZXRyeS5wcm90b3R5cGUgKTtcbiAgICBDaXJjbGVHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDaXJjbGVHZW9tZXRyeTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gICAgICogYmFzZWQgb24gaHR0cDovL3BhcGVydmlzaW9uM2QuZ29vZ2xlY29kZS5jb20vc3ZuL3RydW5rL2FzMy90cnVuay9zcmMvb3JnL3BhcGVydmlzaW9uM2Qvb2JqZWN0cy9wcmltaXRpdmVzL0N1YmUuYXNcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIEJveEdlb21ldHJ5KCB3aWR0aCwgaGVpZ2h0LCBkZXB0aCwgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIGRlcHRoU2VnbWVudHMgKSB7XG5cbiAgICBcdEdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuICAgIFx0dGhpcy50eXBlID0gJ0JveEdlb21ldHJ5JztcblxuICAgIFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuICAgIFx0XHR3aWR0aDogd2lkdGgsXG4gICAgXHRcdGhlaWdodDogaGVpZ2h0LFxuICAgIFx0XHRkZXB0aDogZGVwdGgsXG4gICAgXHRcdHdpZHRoU2VnbWVudHM6IHdpZHRoU2VnbWVudHMsXG4gICAgXHRcdGhlaWdodFNlZ21lbnRzOiBoZWlnaHRTZWdtZW50cyxcbiAgICBcdFx0ZGVwdGhTZWdtZW50czogZGVwdGhTZWdtZW50c1xuICAgIFx0fTtcblxuICAgIFx0dGhpcy5mcm9tQnVmZmVyR2VvbWV0cnkoIG5ldyBCb3hCdWZmZXJHZW9tZXRyeSggd2lkdGgsIGhlaWdodCwgZGVwdGgsIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCBkZXB0aFNlZ21lbnRzICkgKTtcbiAgICBcdHRoaXMubWVyZ2VWZXJ0aWNlcygpO1xuXG4gICAgfVxuXG4gICAgQm94R2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggR2VvbWV0cnkucHJvdG90eXBlICk7XG4gICAgQm94R2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQm94R2VvbWV0cnk7XG5cblxuXG4gICAgdmFyIEdlb21ldHJpZXMgPSBPYmplY3QuZnJlZXplKHtcbiAgICBcdFdpcmVmcmFtZUdlb21ldHJ5OiBXaXJlZnJhbWVHZW9tZXRyeSxcbiAgICBcdFBhcmFtZXRyaWNHZW9tZXRyeTogUGFyYW1ldHJpY0dlb21ldHJ5LFxuICAgIFx0VGV0cmFoZWRyb25HZW9tZXRyeTogVGV0cmFoZWRyb25HZW9tZXRyeSxcbiAgICBcdE9jdGFoZWRyb25HZW9tZXRyeTogT2N0YWhlZHJvbkdlb21ldHJ5LFxuICAgIFx0SWNvc2FoZWRyb25HZW9tZXRyeTogSWNvc2FoZWRyb25HZW9tZXRyeSxcbiAgICBcdERvZGVjYWhlZHJvbkdlb21ldHJ5OiBEb2RlY2FoZWRyb25HZW9tZXRyeSxcbiAgICBcdFBvbHloZWRyb25HZW9tZXRyeTogUG9seWhlZHJvbkdlb21ldHJ5LFxuICAgIFx0VHViZUdlb21ldHJ5OiBUdWJlR2VvbWV0cnksXG4gICAgXHRUb3J1c0tub3RHZW9tZXRyeTogVG9ydXNLbm90R2VvbWV0cnksXG4gICAgXHRUb3J1c0tub3RCdWZmZXJHZW9tZXRyeTogVG9ydXNLbm90QnVmZmVyR2VvbWV0cnksXG4gICAgXHRUb3J1c0dlb21ldHJ5OiBUb3J1c0dlb21ldHJ5LFxuICAgIFx0VG9ydXNCdWZmZXJHZW9tZXRyeTogVG9ydXNCdWZmZXJHZW9tZXRyeSxcbiAgICBcdFRleHRHZW9tZXRyeTogVGV4dEdlb21ldHJ5LFxuICAgIFx0U3BoZXJlQnVmZmVyR2VvbWV0cnk6IFNwaGVyZUJ1ZmZlckdlb21ldHJ5LFxuICAgIFx0U3BoZXJlR2VvbWV0cnk6IFNwaGVyZUdlb21ldHJ5LFxuICAgIFx0UmluZ0dlb21ldHJ5OiBSaW5nR2VvbWV0cnksXG4gICAgXHRSaW5nQnVmZmVyR2VvbWV0cnk6IFJpbmdCdWZmZXJHZW9tZXRyeSxcbiAgICBcdFBsYW5lQnVmZmVyR2VvbWV0cnk6IFBsYW5lQnVmZmVyR2VvbWV0cnksXG4gICAgXHRQbGFuZUdlb21ldHJ5OiBQbGFuZUdlb21ldHJ5LFxuICAgIFx0TGF0aGVHZW9tZXRyeTogTGF0aGVHZW9tZXRyeSxcbiAgICBcdExhdGhlQnVmZmVyR2VvbWV0cnk6IExhdGhlQnVmZmVyR2VvbWV0cnksXG4gICAgXHRTaGFwZUdlb21ldHJ5OiBTaGFwZUdlb21ldHJ5LFxuICAgIFx0RXh0cnVkZUdlb21ldHJ5OiBFeHRydWRlR2VvbWV0cnksXG4gICAgXHRFZGdlc0dlb21ldHJ5OiBFZGdlc0dlb21ldHJ5LFxuICAgIFx0Q29uZUdlb21ldHJ5OiBDb25lR2VvbWV0cnksXG4gICAgXHRDb25lQnVmZmVyR2VvbWV0cnk6IENvbmVCdWZmZXJHZW9tZXRyeSxcbiAgICBcdEN5bGluZGVyR2VvbWV0cnk6IEN5bGluZGVyR2VvbWV0cnksXG4gICAgXHRDeWxpbmRlckJ1ZmZlckdlb21ldHJ5OiBDeWxpbmRlckJ1ZmZlckdlb21ldHJ5LFxuICAgIFx0Q2lyY2xlQnVmZmVyR2VvbWV0cnk6IENpcmNsZUJ1ZmZlckdlb21ldHJ5LFxuICAgIFx0Q2lyY2xlR2VvbWV0cnk6IENpcmNsZUdlb21ldHJ5LFxuICAgIFx0Qm94QnVmZmVyR2VvbWV0cnk6IEJveEJ1ZmZlckdlb21ldHJ5LFxuICAgIFx0Qm94R2VvbWV0cnk6IEJveEdlb21ldHJ5XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gU2hhZG93TWF0ZXJpYWwoKSB7XG5cbiAgICBcdFNoYWRlck1hdGVyaWFsLmNhbGwoIHRoaXMsIHtcbiAgICBcdFx0dW5pZm9ybXM6IGV4cG9ydHMuVW5pZm9ybXNVdGlscy5tZXJnZSggW1xuICAgIFx0XHRcdFVuaWZvcm1zTGliWyBcImxpZ2h0c1wiIF0sXG4gICAgXHRcdFx0e1xuICAgIFx0XHRcdFx0b3BhY2l0eTogeyB2YWx1ZTogMS4wIH1cbiAgICBcdFx0XHR9XG4gICAgXHRcdF0gKSxcbiAgICBcdFx0dmVydGV4U2hhZGVyOiBTaGFkZXJDaHVua1sgJ3NoYWRvd192ZXJ0JyBdLFxuICAgIFx0XHRmcmFnbWVudFNoYWRlcjogU2hhZGVyQ2h1bmtbICdzaGFkb3dfZnJhZycgXVxuICAgIFx0fSApO1xuXG4gICAgXHR0aGlzLmxpZ2h0cyA9IHRydWU7XG4gICAgXHR0aGlzLnRyYW5zcGFyZW50ID0gdHJ1ZTtcblxuICAgIFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIHRoaXMsIHtcbiAgICBcdFx0b3BhY2l0eToge1xuICAgIFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gICAgXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgXHRcdFx0XHRyZXR1cm4gdGhpcy51bmlmb3Jtcy5vcGFjaXR5LnZhbHVlO1xuICAgIFx0XHRcdH0sXG4gICAgXHRcdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuICAgIFx0XHRcdFx0dGhpcy51bmlmb3Jtcy5vcGFjaXR5LnZhbHVlID0gdmFsdWU7XG4gICAgXHRcdFx0fVxuICAgIFx0XHR9XG4gICAgXHR9ICk7XG5cbiAgICB9XG5cbiAgICBTaGFkb3dNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBTaGFkZXJNYXRlcmlhbC5wcm90b3R5cGUgKTtcbiAgICBTaGFkb3dNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTaGFkb3dNYXRlcmlhbDtcblxuICAgIFNoYWRvd01hdGVyaWFsLnByb3RvdHlwZS5pc1NoYWRvd01hdGVyaWFsID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBSYXdTaGFkZXJNYXRlcmlhbCggcGFyYW1ldGVycyApIHtcblxuICAgIFx0U2hhZGVyTWF0ZXJpYWwuY2FsbCggdGhpcywgcGFyYW1ldGVycyApO1xuXG4gICAgXHR0aGlzLnR5cGUgPSAnUmF3U2hhZGVyTWF0ZXJpYWwnO1xuXG4gICAgfVxuXG4gICAgUmF3U2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggU2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlICk7XG4gICAgUmF3U2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmF3U2hhZGVyTWF0ZXJpYWw7XG5cbiAgICBSYXdTaGFkZXJNYXRlcmlhbC5wcm90b3R5cGUuaXNSYXdTaGFkZXJNYXRlcmlhbCA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gTXVsdGlNYXRlcmlhbCggbWF0ZXJpYWxzICkge1xuXG4gICAgXHR0aGlzLnV1aWQgPSBleHBvcnRzLk1hdGguZ2VuZXJhdGVVVUlEKCk7XG5cbiAgICBcdHRoaXMudHlwZSA9ICdNdWx0aU1hdGVyaWFsJztcblxuICAgIFx0dGhpcy5tYXRlcmlhbHMgPSBtYXRlcmlhbHMgaW5zdGFuY2VvZiBBcnJheSA/IG1hdGVyaWFscyA6IFtdO1xuXG4gICAgXHR0aGlzLnZpc2libGUgPSB0cnVlO1xuXG4gICAgfVxuXG4gICAgTXVsdGlNYXRlcmlhbC5wcm90b3R5cGUgPSB7XG5cbiAgICBcdGNvbnN0cnVjdG9yOiBNdWx0aU1hdGVyaWFsLFxuXG4gICAgXHRpc011bHRpTWF0ZXJpYWw6IHRydWUsXG5cbiAgICBcdHRvSlNPTjogZnVuY3Rpb24gKCBtZXRhICkge1xuXG4gICAgXHRcdHZhciBvdXRwdXQgPSB7XG4gICAgXHRcdFx0bWV0YWRhdGE6IHtcbiAgICBcdFx0XHRcdHZlcnNpb246IDQuMixcbiAgICBcdFx0XHRcdHR5cGU6ICdtYXRlcmlhbCcsXG4gICAgXHRcdFx0XHRnZW5lcmF0b3I6ICdNYXRlcmlhbEV4cG9ydGVyJ1xuICAgIFx0XHRcdH0sXG4gICAgXHRcdFx0dXVpZDogdGhpcy51dWlkLFxuICAgIFx0XHRcdHR5cGU6IHRoaXMudHlwZSxcbiAgICBcdFx0XHRtYXRlcmlhbHM6IFtdXG4gICAgXHRcdH07XG5cbiAgICBcdFx0dmFyIG1hdGVyaWFscyA9IHRoaXMubWF0ZXJpYWxzO1xuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IG1hdGVyaWFscy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgXHRcdFx0dmFyIG1hdGVyaWFsID0gbWF0ZXJpYWxzWyBpIF0udG9KU09OKCBtZXRhICk7XG4gICAgXHRcdFx0ZGVsZXRlIG1hdGVyaWFsLm1ldGFkYXRhO1xuXG4gICAgXHRcdFx0b3V0cHV0Lm1hdGVyaWFscy5wdXNoKCBtYXRlcmlhbCApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRvdXRwdXQudmlzaWJsZSA9IHRoaXMudmlzaWJsZTtcblxuICAgIFx0XHRyZXR1cm4gb3V0cHV0O1xuXG4gICAgXHR9LFxuXG4gICAgXHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHZhciBtYXRlcmlhbCA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKCk7XG5cbiAgICBcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5tYXRlcmlhbHMubGVuZ3RoOyBpICsrICkge1xuXG4gICAgXHRcdFx0bWF0ZXJpYWwubWF0ZXJpYWxzLnB1c2goIHRoaXMubWF0ZXJpYWxzWyBpIF0uY2xvbmUoKSApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRtYXRlcmlhbC52aXNpYmxlID0gdGhpcy52aXNpYmxlO1xuXG4gICAgXHRcdHJldHVybiBtYXRlcmlhbDtcblxuICAgIFx0fVxuXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuICAgICAqXG4gICAgICogcGFyYW1ldGVycyA9IHtcbiAgICAgKiAgY29sb3I6IDxoZXg+LFxuICAgICAqICByb3VnaG5lc3M6IDxmbG9hdD4sXG4gICAgICogIG1ldGFsbmVzczogPGZsb2F0PixcbiAgICAgKiAgb3BhY2l0eTogPGZsb2F0PixcbiAgICAgKlxuICAgICAqICBtYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gICAgICpcbiAgICAgKiAgbGlnaHRNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gICAgICogIGxpZ2h0TWFwSW50ZW5zaXR5OiA8ZmxvYXQ+XG4gICAgICpcbiAgICAgKiAgYW9NYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gICAgICogIGFvTWFwSW50ZW5zaXR5OiA8ZmxvYXQ+XG4gICAgICpcbiAgICAgKiAgZW1pc3NpdmU6IDxoZXg+LFxuICAgICAqICBlbWlzc2l2ZUludGVuc2l0eTogPGZsb2F0PlxuICAgICAqICBlbWlzc2l2ZU1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAgICAgKlxuICAgICAqICBidW1wTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICAgICAqICBidW1wU2NhbGU6IDxmbG9hdD4sXG4gICAgICpcbiAgICAgKiAgbm9ybWFsTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICAgICAqICBub3JtYWxTY2FsZTogPFZlY3RvcjI+LFxuICAgICAqXG4gICAgICogIGRpc3BsYWNlbWVudE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAgICAgKiAgZGlzcGxhY2VtZW50U2NhbGU6IDxmbG9hdD4sXG4gICAgICogIGRpc3BsYWNlbWVudEJpYXM6IDxmbG9hdD4sXG4gICAgICpcbiAgICAgKiAgcm91Z2huZXNzTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICAgICAqXG4gICAgICogIG1ldGFsbmVzc01hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAgICAgKlxuICAgICAqICBhbHBoYU1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAgICAgKlxuICAgICAqICBlbnZNYXA6IG5ldyBUSFJFRS5DdWJlVGV4dHVyZSggW3Bvc3gsIG5lZ3gsIHBvc3ksIG5lZ3ksIHBvc3osIG5lZ3pdICksXG4gICAgICogIGVudk1hcEludGVuc2l0eTogPGZsb2F0PlxuICAgICAqXG4gICAgICogIHJlZnJhY3Rpb25SYXRpbzogPGZsb2F0PixcbiAgICAgKlxuICAgICAqICB3aXJlZnJhbWU6IDxib29sZWFuPixcbiAgICAgKiAgd2lyZWZyYW1lTGluZXdpZHRoOiA8ZmxvYXQ+LFxuICAgICAqXG4gICAgICogIHNraW5uaW5nOiA8Ym9vbD4sXG4gICAgICogIG1vcnBoVGFyZ2V0czogPGJvb2w+LFxuICAgICAqICBtb3JwaE5vcm1hbHM6IDxib29sPlxuICAgICAqIH1cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIE1lc2hTdGFuZGFyZE1hdGVyaWFsKCBwYXJhbWV0ZXJzICkge1xuXG4gICAgXHRNYXRlcmlhbC5jYWxsKCB0aGlzICk7XG5cbiAgICBcdHRoaXMuZGVmaW5lcyA9IHsgJ1NUQU5EQVJEJzogJycgfTtcblxuICAgIFx0dGhpcy50eXBlID0gJ01lc2hTdGFuZGFyZE1hdGVyaWFsJztcblxuICAgIFx0dGhpcy5jb2xvciA9IG5ldyBDb2xvciggMHhmZmZmZmYgKTsgLy8gZGlmZnVzZVxuICAgIFx0dGhpcy5yb3VnaG5lc3MgPSAwLjU7XG4gICAgXHR0aGlzLm1ldGFsbmVzcyA9IDAuNTtcblxuICAgIFx0dGhpcy5tYXAgPSBudWxsO1xuXG4gICAgXHR0aGlzLmxpZ2h0TWFwID0gbnVsbDtcbiAgICBcdHRoaXMubGlnaHRNYXBJbnRlbnNpdHkgPSAxLjA7XG5cbiAgICBcdHRoaXMuYW9NYXAgPSBudWxsO1xuICAgIFx0dGhpcy5hb01hcEludGVuc2l0eSA9IDEuMDtcblxuICAgIFx0dGhpcy5lbWlzc2l2ZSA9IG5ldyBDb2xvciggMHgwMDAwMDAgKTtcbiAgICBcdHRoaXMuZW1pc3NpdmVJbnRlbnNpdHkgPSAxLjA7XG4gICAgXHR0aGlzLmVtaXNzaXZlTWFwID0gbnVsbDtcblxuICAgIFx0dGhpcy5idW1wTWFwID0gbnVsbDtcbiAgICBcdHRoaXMuYnVtcFNjYWxlID0gMTtcblxuICAgIFx0dGhpcy5ub3JtYWxNYXAgPSBudWxsO1xuICAgIFx0dGhpcy5ub3JtYWxTY2FsZSA9IG5ldyBWZWN0b3IyKCAxLCAxICk7XG5cbiAgICBcdHRoaXMuZGlzcGxhY2VtZW50TWFwID0gbnVsbDtcbiAgICBcdHRoaXMuZGlzcGxhY2VtZW50U2NhbGUgPSAxO1xuICAgIFx0dGhpcy5kaXNwbGFjZW1lbnRCaWFzID0gMDtcblxuICAgIFx0dGhpcy5yb3VnaG5lc3NNYXAgPSBudWxsO1xuXG4gICAgXHR0aGlzLm1ldGFsbmVzc01hcCA9IG51bGw7XG5cbiAgICBcdHRoaXMuYWxwaGFNYXAgPSBudWxsO1xuXG4gICAgXHR0aGlzLmVudk1hcCA9IG51bGw7XG4gICAgXHR0aGlzLmVudk1hcEludGVuc2l0eSA9IDEuMDtcblxuICAgIFx0dGhpcy5yZWZyYWN0aW9uUmF0aW8gPSAwLjk4O1xuXG4gICAgXHR0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xuICAgIFx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSAxO1xuICAgIFx0dGhpcy53aXJlZnJhbWVMaW5lY2FwID0gJ3JvdW5kJztcbiAgICBcdHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSAncm91bmQnO1xuXG4gICAgXHR0aGlzLnNraW5uaW5nID0gZmFsc2U7XG4gICAgXHR0aGlzLm1vcnBoVGFyZ2V0cyA9IGZhbHNlO1xuICAgIFx0dGhpcy5tb3JwaE5vcm1hbHMgPSBmYWxzZTtcblxuICAgIFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcblxuICAgIH1cblxuICAgIE1lc2hTdGFuZGFyZE1hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE1hdGVyaWFsLnByb3RvdHlwZSApO1xuICAgIE1lc2hTdGFuZGFyZE1hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1lc2hTdGFuZGFyZE1hdGVyaWFsO1xuXG4gICAgTWVzaFN0YW5kYXJkTWF0ZXJpYWwucHJvdG90eXBlLmlzTWVzaFN0YW5kYXJkTWF0ZXJpYWwgPSB0cnVlO1xuXG4gICAgTWVzaFN0YW5kYXJkTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuICAgIFx0TWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cbiAgICBcdHRoaXMuZGVmaW5lcyA9IHsgJ1NUQU5EQVJEJzogJycgfTtcblxuICAgIFx0dGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcbiAgICBcdHRoaXMucm91Z2huZXNzID0gc291cmNlLnJvdWdobmVzcztcbiAgICBcdHRoaXMubWV0YWxuZXNzID0gc291cmNlLm1ldGFsbmVzcztcblxuICAgIFx0dGhpcy5tYXAgPSBzb3VyY2UubWFwO1xuXG4gICAgXHR0aGlzLmxpZ2h0TWFwID0gc291cmNlLmxpZ2h0TWFwO1xuICAgIFx0dGhpcy5saWdodE1hcEludGVuc2l0eSA9IHNvdXJjZS5saWdodE1hcEludGVuc2l0eTtcblxuICAgIFx0dGhpcy5hb01hcCA9IHNvdXJjZS5hb01hcDtcbiAgICBcdHRoaXMuYW9NYXBJbnRlbnNpdHkgPSBzb3VyY2UuYW9NYXBJbnRlbnNpdHk7XG5cbiAgICBcdHRoaXMuZW1pc3NpdmUuY29weSggc291cmNlLmVtaXNzaXZlICk7XG4gICAgXHR0aGlzLmVtaXNzaXZlTWFwID0gc291cmNlLmVtaXNzaXZlTWFwO1xuICAgIFx0dGhpcy5lbWlzc2l2ZUludGVuc2l0eSA9IHNvdXJjZS5lbWlzc2l2ZUludGVuc2l0eTtcblxuICAgIFx0dGhpcy5idW1wTWFwID0gc291cmNlLmJ1bXBNYXA7XG4gICAgXHR0aGlzLmJ1bXBTY2FsZSA9IHNvdXJjZS5idW1wU2NhbGU7XG5cbiAgICBcdHRoaXMubm9ybWFsTWFwID0gc291cmNlLm5vcm1hbE1hcDtcbiAgICBcdHRoaXMubm9ybWFsU2NhbGUuY29weSggc291cmNlLm5vcm1hbFNjYWxlICk7XG5cbiAgICBcdHRoaXMuZGlzcGxhY2VtZW50TWFwID0gc291cmNlLmRpc3BsYWNlbWVudE1hcDtcbiAgICBcdHRoaXMuZGlzcGxhY2VtZW50U2NhbGUgPSBzb3VyY2UuZGlzcGxhY2VtZW50U2NhbGU7XG4gICAgXHR0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSBzb3VyY2UuZGlzcGxhY2VtZW50QmlhcztcblxuICAgIFx0dGhpcy5yb3VnaG5lc3NNYXAgPSBzb3VyY2Uucm91Z2huZXNzTWFwO1xuXG4gICAgXHR0aGlzLm1ldGFsbmVzc01hcCA9IHNvdXJjZS5tZXRhbG5lc3NNYXA7XG5cbiAgICBcdHRoaXMuYWxwaGFNYXAgPSBzb3VyY2UuYWxwaGFNYXA7XG5cbiAgICBcdHRoaXMuZW52TWFwID0gc291cmNlLmVudk1hcDtcbiAgICBcdHRoaXMuZW52TWFwSW50ZW5zaXR5ID0gc291cmNlLmVudk1hcEludGVuc2l0eTtcblxuICAgIFx0dGhpcy5yZWZyYWN0aW9uUmF0aW8gPSBzb3VyY2UucmVmcmFjdGlvblJhdGlvO1xuXG4gICAgXHR0aGlzLndpcmVmcmFtZSA9IHNvdXJjZS53aXJlZnJhbWU7XG4gICAgXHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IHNvdXJjZS53aXJlZnJhbWVMaW5ld2lkdGg7XG4gICAgXHR0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSBzb3VyY2Uud2lyZWZyYW1lTGluZWNhcDtcbiAgICBcdHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSBzb3VyY2Uud2lyZWZyYW1lTGluZWpvaW47XG5cbiAgICBcdHRoaXMuc2tpbm5pbmcgPSBzb3VyY2Uuc2tpbm5pbmc7XG4gICAgXHR0aGlzLm1vcnBoVGFyZ2V0cyA9IHNvdXJjZS5tb3JwaFRhcmdldHM7XG4gICAgXHR0aGlzLm1vcnBoTm9ybWFscyA9IHNvdXJjZS5tb3JwaE5vcm1hbHM7XG5cbiAgICBcdHJldHVybiB0aGlzO1xuXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuICAgICAqXG4gICAgICogcGFyYW1ldGVycyA9IHtcbiAgICAgKiAgcmVmbGVjdGl2aXR5OiA8ZmxvYXQ+XG4gICAgICogfVxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gTWVzaFBoeXNpY2FsTWF0ZXJpYWwoIHBhcmFtZXRlcnMgKSB7XG5cbiAgICBcdE1lc2hTdGFuZGFyZE1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcblxuICAgIFx0dGhpcy5kZWZpbmVzID0geyAnUEhZU0lDQUwnOiAnJyB9O1xuXG4gICAgXHR0aGlzLnR5cGUgPSAnTWVzaFBoeXNpY2FsTWF0ZXJpYWwnO1xuXG4gICAgXHR0aGlzLnJlZmxlY3Rpdml0eSA9IDAuNTsgLy8gbWFwcyB0byBGMCA9IDAuMDRcblxuICAgIFx0dGhpcy5jbGVhckNvYXQgPSAwLjA7XG4gICAgXHR0aGlzLmNsZWFyQ29hdFJvdWdobmVzcyA9IDAuMDtcblxuICAgIFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcblxuICAgIH1cblxuICAgIE1lc2hQaHlzaWNhbE1hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE1lc2hTdGFuZGFyZE1hdGVyaWFsLnByb3RvdHlwZSApO1xuICAgIE1lc2hQaHlzaWNhbE1hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1lc2hQaHlzaWNhbE1hdGVyaWFsO1xuXG4gICAgTWVzaFBoeXNpY2FsTWF0ZXJpYWwucHJvdG90eXBlLmlzTWVzaFBoeXNpY2FsTWF0ZXJpYWwgPSB0cnVlO1xuXG4gICAgTWVzaFBoeXNpY2FsTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuICAgIFx0TWVzaFN0YW5kYXJkTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cbiAgICBcdHRoaXMuZGVmaW5lcyA9IHsgJ1BIWVNJQ0FMJzogJycgfTtcblxuICAgIFx0dGhpcy5yZWZsZWN0aXZpdHkgPSBzb3VyY2UucmVmbGVjdGl2aXR5O1xuXG4gICAgXHR0aGlzLmNsZWFyQ29hdCA9IHNvdXJjZS5jbGVhckNvYXQ7XG4gICAgXHR0aGlzLmNsZWFyQ29hdFJvdWdobmVzcyA9IHNvdXJjZS5jbGVhckNvYXRSb3VnaG5lc3M7XG5cbiAgICBcdHJldHVybiB0aGlzO1xuXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gICAgICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAgICAgKlxuICAgICAqIHBhcmFtZXRlcnMgPSB7XG4gICAgICogIGNvbG9yOiA8aGV4PixcbiAgICAgKiAgc3BlY3VsYXI6IDxoZXg+LFxuICAgICAqICBzaGluaW5lc3M6IDxmbG9hdD4sXG4gICAgICogIG9wYWNpdHk6IDxmbG9hdD4sXG4gICAgICpcbiAgICAgKiAgbWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICAgICAqXG4gICAgICogIGxpZ2h0TWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICAgICAqICBsaWdodE1hcEludGVuc2l0eTogPGZsb2F0PlxuICAgICAqXG4gICAgICogIGFvTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICAgICAqICBhb01hcEludGVuc2l0eTogPGZsb2F0PlxuICAgICAqXG4gICAgICogIGVtaXNzaXZlOiA8aGV4PixcbiAgICAgKiAgZW1pc3NpdmVJbnRlbnNpdHk6IDxmbG9hdD5cbiAgICAgKiAgZW1pc3NpdmVNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gICAgICpcbiAgICAgKiAgYnVtcE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAgICAgKiAgYnVtcFNjYWxlOiA8ZmxvYXQ+LFxuICAgICAqXG4gICAgICogIG5vcm1hbE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAgICAgKiAgbm9ybWFsU2NhbGU6IDxWZWN0b3IyPixcbiAgICAgKlxuICAgICAqICBkaXNwbGFjZW1lbnRNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gICAgICogIGRpc3BsYWNlbWVudFNjYWxlOiA8ZmxvYXQ+LFxuICAgICAqICBkaXNwbGFjZW1lbnRCaWFzOiA8ZmxvYXQ+LFxuICAgICAqXG4gICAgICogIHNwZWN1bGFyTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICAgICAqXG4gICAgICogIGFscGhhTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICAgICAqXG4gICAgICogIGVudk1hcDogbmV3IFRIUkVFLlRleHR1cmVDdWJlKCBbcG9zeCwgbmVneCwgcG9zeSwgbmVneSwgcG9zeiwgbmVnel0gKSxcbiAgICAgKiAgY29tYmluZTogVEhSRUUuTXVsdGlwbHksXG4gICAgICogIHJlZmxlY3Rpdml0eTogPGZsb2F0PixcbiAgICAgKiAgcmVmcmFjdGlvblJhdGlvOiA8ZmxvYXQ+LFxuICAgICAqXG4gICAgICogIHdpcmVmcmFtZTogPGJvb2xlYW4+LFxuICAgICAqICB3aXJlZnJhbWVMaW5ld2lkdGg6IDxmbG9hdD4sXG4gICAgICpcbiAgICAgKiAgc2tpbm5pbmc6IDxib29sPixcbiAgICAgKiAgbW9ycGhUYXJnZXRzOiA8Ym9vbD4sXG4gICAgICogIG1vcnBoTm9ybWFsczogPGJvb2w+XG4gICAgICogfVxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gTWVzaFBob25nTWF0ZXJpYWwoIHBhcmFtZXRlcnMgKSB7XG5cbiAgICBcdE1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcblxuICAgIFx0dGhpcy50eXBlID0gJ01lc2hQaG9uZ01hdGVyaWFsJztcblxuICAgIFx0dGhpcy5jb2xvciA9IG5ldyBDb2xvciggMHhmZmZmZmYgKTsgLy8gZGlmZnVzZVxuICAgIFx0dGhpcy5zcGVjdWxhciA9IG5ldyBDb2xvciggMHgxMTExMTEgKTtcbiAgICBcdHRoaXMuc2hpbmluZXNzID0gMzA7XG5cbiAgICBcdHRoaXMubWFwID0gbnVsbDtcblxuICAgIFx0dGhpcy5saWdodE1hcCA9IG51bGw7XG4gICAgXHR0aGlzLmxpZ2h0TWFwSW50ZW5zaXR5ID0gMS4wO1xuXG4gICAgXHR0aGlzLmFvTWFwID0gbnVsbDtcbiAgICBcdHRoaXMuYW9NYXBJbnRlbnNpdHkgPSAxLjA7XG5cbiAgICBcdHRoaXMuZW1pc3NpdmUgPSBuZXcgQ29sb3IoIDB4MDAwMDAwICk7XG4gICAgXHR0aGlzLmVtaXNzaXZlSW50ZW5zaXR5ID0gMS4wO1xuICAgIFx0dGhpcy5lbWlzc2l2ZU1hcCA9IG51bGw7XG5cbiAgICBcdHRoaXMuYnVtcE1hcCA9IG51bGw7XG4gICAgXHR0aGlzLmJ1bXBTY2FsZSA9IDE7XG5cbiAgICBcdHRoaXMubm9ybWFsTWFwID0gbnVsbDtcbiAgICBcdHRoaXMubm9ybWFsU2NhbGUgPSBuZXcgVmVjdG9yMiggMSwgMSApO1xuXG4gICAgXHR0aGlzLmRpc3BsYWNlbWVudE1hcCA9IG51bGw7XG4gICAgXHR0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gMTtcbiAgICBcdHRoaXMuZGlzcGxhY2VtZW50QmlhcyA9IDA7XG5cbiAgICBcdHRoaXMuc3BlY3VsYXJNYXAgPSBudWxsO1xuXG4gICAgXHR0aGlzLmFscGhhTWFwID0gbnVsbDtcblxuICAgIFx0dGhpcy5lbnZNYXAgPSBudWxsO1xuICAgIFx0dGhpcy5jb21iaW5lID0gTXVsdGlwbHlPcGVyYXRpb247XG4gICAgXHR0aGlzLnJlZmxlY3Rpdml0eSA9IDE7XG4gICAgXHR0aGlzLnJlZnJhY3Rpb25SYXRpbyA9IDAuOTg7XG5cbiAgICBcdHRoaXMud2lyZWZyYW1lID0gZmFsc2U7XG4gICAgXHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XG4gICAgXHR0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSAncm91bmQnO1xuICAgIFx0dGhpcy53aXJlZnJhbWVMaW5lam9pbiA9ICdyb3VuZCc7XG5cbiAgICBcdHRoaXMuc2tpbm5pbmcgPSBmYWxzZTtcbiAgICBcdHRoaXMubW9ycGhUYXJnZXRzID0gZmFsc2U7XG4gICAgXHR0aGlzLm1vcnBoTm9ybWFscyA9IGZhbHNlO1xuXG4gICAgXHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xuXG4gICAgfVxuXG4gICAgTWVzaFBob25nTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTWF0ZXJpYWwucHJvdG90eXBlICk7XG4gICAgTWVzaFBob25nTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWVzaFBob25nTWF0ZXJpYWw7XG5cbiAgICBNZXNoUGhvbmdNYXRlcmlhbC5wcm90b3R5cGUuaXNNZXNoUGhvbmdNYXRlcmlhbCA9IHRydWU7XG5cbiAgICBNZXNoUGhvbmdNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xuXG4gICAgXHRNYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuICAgIFx0dGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcbiAgICBcdHRoaXMuc3BlY3VsYXIuY29weSggc291cmNlLnNwZWN1bGFyICk7XG4gICAgXHR0aGlzLnNoaW5pbmVzcyA9IHNvdXJjZS5zaGluaW5lc3M7XG5cbiAgICBcdHRoaXMubWFwID0gc291cmNlLm1hcDtcblxuICAgIFx0dGhpcy5saWdodE1hcCA9IHNvdXJjZS5saWdodE1hcDtcbiAgICBcdHRoaXMubGlnaHRNYXBJbnRlbnNpdHkgPSBzb3VyY2UubGlnaHRNYXBJbnRlbnNpdHk7XG5cbiAgICBcdHRoaXMuYW9NYXAgPSBzb3VyY2UuYW9NYXA7XG4gICAgXHR0aGlzLmFvTWFwSW50ZW5zaXR5ID0gc291cmNlLmFvTWFwSW50ZW5zaXR5O1xuXG4gICAgXHR0aGlzLmVtaXNzaXZlLmNvcHkoIHNvdXJjZS5lbWlzc2l2ZSApO1xuICAgIFx0dGhpcy5lbWlzc2l2ZU1hcCA9IHNvdXJjZS5lbWlzc2l2ZU1hcDtcbiAgICBcdHRoaXMuZW1pc3NpdmVJbnRlbnNpdHkgPSBzb3VyY2UuZW1pc3NpdmVJbnRlbnNpdHk7XG5cbiAgICBcdHRoaXMuYnVtcE1hcCA9IHNvdXJjZS5idW1wTWFwO1xuICAgIFx0dGhpcy5idW1wU2NhbGUgPSBzb3VyY2UuYnVtcFNjYWxlO1xuXG4gICAgXHR0aGlzLm5vcm1hbE1hcCA9IHNvdXJjZS5ub3JtYWxNYXA7XG4gICAgXHR0aGlzLm5vcm1hbFNjYWxlLmNvcHkoIHNvdXJjZS5ub3JtYWxTY2FsZSApO1xuXG4gICAgXHR0aGlzLmRpc3BsYWNlbWVudE1hcCA9IHNvdXJjZS5kaXNwbGFjZW1lbnRNYXA7XG4gICAgXHR0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gc291cmNlLmRpc3BsYWNlbWVudFNjYWxlO1xuICAgIFx0dGhpcy5kaXNwbGFjZW1lbnRCaWFzID0gc291cmNlLmRpc3BsYWNlbWVudEJpYXM7XG5cbiAgICBcdHRoaXMuc3BlY3VsYXJNYXAgPSBzb3VyY2Uuc3BlY3VsYXJNYXA7XG5cbiAgICBcdHRoaXMuYWxwaGFNYXAgPSBzb3VyY2UuYWxwaGFNYXA7XG5cbiAgICBcdHRoaXMuZW52TWFwID0gc291cmNlLmVudk1hcDtcbiAgICBcdHRoaXMuY29tYmluZSA9IHNvdXJjZS5jb21iaW5lO1xuICAgIFx0dGhpcy5yZWZsZWN0aXZpdHkgPSBzb3VyY2UucmVmbGVjdGl2aXR5O1xuICAgIFx0dGhpcy5yZWZyYWN0aW9uUmF0aW8gPSBzb3VyY2UucmVmcmFjdGlvblJhdGlvO1xuXG4gICAgXHR0aGlzLndpcmVmcmFtZSA9IHNvdXJjZS53aXJlZnJhbWU7XG4gICAgXHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IHNvdXJjZS53aXJlZnJhbWVMaW5ld2lkdGg7XG4gICAgXHR0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSBzb3VyY2Uud2lyZWZyYW1lTGluZWNhcDtcbiAgICBcdHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSBzb3VyY2Uud2lyZWZyYW1lTGluZWpvaW47XG5cbiAgICBcdHRoaXMuc2tpbm5pbmcgPSBzb3VyY2Uuc2tpbm5pbmc7XG4gICAgXHR0aGlzLm1vcnBoVGFyZ2V0cyA9IHNvdXJjZS5tb3JwaFRhcmdldHM7XG4gICAgXHR0aGlzLm1vcnBoTm9ybWFscyA9IHNvdXJjZS5tb3JwaE5vcm1hbHM7XG5cbiAgICBcdHJldHVybiB0aGlzO1xuXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gICAgICpcbiAgICAgKiBwYXJhbWV0ZXJzID0ge1xuICAgICAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxuICAgICAqXG4gICAgICogIHdpcmVmcmFtZTogPGJvb2xlYW4+LFxuICAgICAqICB3aXJlZnJhbWVMaW5ld2lkdGg6IDxmbG9hdD5cbiAgICAgKiB9XG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBNZXNoTm9ybWFsTWF0ZXJpYWwoIHBhcmFtZXRlcnMgKSB7XG5cbiAgICBcdE1hdGVyaWFsLmNhbGwoIHRoaXMsIHBhcmFtZXRlcnMgKTtcblxuICAgIFx0dGhpcy50eXBlID0gJ01lc2hOb3JtYWxNYXRlcmlhbCc7XG5cbiAgICBcdHRoaXMud2lyZWZyYW1lID0gZmFsc2U7XG4gICAgXHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XG5cbiAgICBcdHRoaXMuZm9nID0gZmFsc2U7XG4gICAgXHR0aGlzLmxpZ2h0cyA9IGZhbHNlO1xuICAgIFx0dGhpcy5tb3JwaFRhcmdldHMgPSBmYWxzZTtcblxuICAgIFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcblxuICAgIH1cblxuICAgIE1lc2hOb3JtYWxNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBNYXRlcmlhbC5wcm90b3R5cGUgKTtcbiAgICBNZXNoTm9ybWFsTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWVzaE5vcm1hbE1hdGVyaWFsO1xuXG4gICAgTWVzaE5vcm1hbE1hdGVyaWFsLnByb3RvdHlwZS5pc01lc2hOb3JtYWxNYXRlcmlhbCA9IHRydWU7XG5cbiAgICBNZXNoTm9ybWFsTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuICAgIFx0TWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cbiAgICBcdHRoaXMud2lyZWZyYW1lID0gc291cmNlLndpcmVmcmFtZTtcbiAgICBcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gc291cmNlLndpcmVmcmFtZUxpbmV3aWR0aDtcblxuICAgIFx0cmV0dXJuIHRoaXM7XG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAgICAgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICAgICAqXG4gICAgICogcGFyYW1ldGVycyA9IHtcbiAgICAgKiAgY29sb3I6IDxoZXg+LFxuICAgICAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxuICAgICAqXG4gICAgICogIG1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAgICAgKlxuICAgICAqICBsaWdodE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAgICAgKiAgbGlnaHRNYXBJbnRlbnNpdHk6IDxmbG9hdD5cbiAgICAgKlxuICAgICAqICBhb01hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAgICAgKiAgYW9NYXBJbnRlbnNpdHk6IDxmbG9hdD5cbiAgICAgKlxuICAgICAqICBlbWlzc2l2ZTogPGhleD4sXG4gICAgICogIGVtaXNzaXZlSW50ZW5zaXR5OiA8ZmxvYXQ+XG4gICAgICogIGVtaXNzaXZlTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICAgICAqXG4gICAgICogIHNwZWN1bGFyTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICAgICAqXG4gICAgICogIGFscGhhTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICAgICAqXG4gICAgICogIGVudk1hcDogbmV3IFRIUkVFLlRleHR1cmVDdWJlKCBbcG9zeCwgbmVneCwgcG9zeSwgbmVneSwgcG9zeiwgbmVnel0gKSxcbiAgICAgKiAgY29tYmluZTogVEhSRUUuTXVsdGlwbHksXG4gICAgICogIHJlZmxlY3Rpdml0eTogPGZsb2F0PixcbiAgICAgKiAgcmVmcmFjdGlvblJhdGlvOiA8ZmxvYXQ+LFxuICAgICAqXG4gICAgICogIHdpcmVmcmFtZTogPGJvb2xlYW4+LFxuICAgICAqICB3aXJlZnJhbWVMaW5ld2lkdGg6IDxmbG9hdD4sXG4gICAgICpcbiAgICAgKiAgc2tpbm5pbmc6IDxib29sPixcbiAgICAgKiAgbW9ycGhUYXJnZXRzOiA8Ym9vbD4sXG4gICAgICogIG1vcnBoTm9ybWFsczogPGJvb2w+XG4gICAgICogfVxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gTWVzaExhbWJlcnRNYXRlcmlhbCggcGFyYW1ldGVycyApIHtcblxuICAgIFx0TWF0ZXJpYWwuY2FsbCggdGhpcyApO1xuXG4gICAgXHR0aGlzLnR5cGUgPSAnTWVzaExhbWJlcnRNYXRlcmlhbCc7XG5cbiAgICBcdHRoaXMuY29sb3IgPSBuZXcgQ29sb3IoIDB4ZmZmZmZmICk7IC8vIGRpZmZ1c2VcblxuICAgIFx0dGhpcy5tYXAgPSBudWxsO1xuXG4gICAgXHR0aGlzLmxpZ2h0TWFwID0gbnVsbDtcbiAgICBcdHRoaXMubGlnaHRNYXBJbnRlbnNpdHkgPSAxLjA7XG5cbiAgICBcdHRoaXMuYW9NYXAgPSBudWxsO1xuICAgIFx0dGhpcy5hb01hcEludGVuc2l0eSA9IDEuMDtcblxuICAgIFx0dGhpcy5lbWlzc2l2ZSA9IG5ldyBDb2xvciggMHgwMDAwMDAgKTtcbiAgICBcdHRoaXMuZW1pc3NpdmVJbnRlbnNpdHkgPSAxLjA7XG4gICAgXHR0aGlzLmVtaXNzaXZlTWFwID0gbnVsbDtcblxuICAgIFx0dGhpcy5zcGVjdWxhck1hcCA9IG51bGw7XG5cbiAgICBcdHRoaXMuYWxwaGFNYXAgPSBudWxsO1xuXG4gICAgXHR0aGlzLmVudk1hcCA9IG51bGw7XG4gICAgXHR0aGlzLmNvbWJpbmUgPSBNdWx0aXBseU9wZXJhdGlvbjtcbiAgICBcdHRoaXMucmVmbGVjdGl2aXR5ID0gMTtcbiAgICBcdHRoaXMucmVmcmFjdGlvblJhdGlvID0gMC45ODtcblxuICAgIFx0dGhpcy53aXJlZnJhbWUgPSBmYWxzZTtcbiAgICBcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcbiAgICBcdHRoaXMud2lyZWZyYW1lTGluZWNhcCA9ICdyb3VuZCc7XG4gICAgXHR0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gJ3JvdW5kJztcblxuICAgIFx0dGhpcy5za2lubmluZyA9IGZhbHNlO1xuICAgIFx0dGhpcy5tb3JwaFRhcmdldHMgPSBmYWxzZTtcbiAgICBcdHRoaXMubW9ycGhOb3JtYWxzID0gZmFsc2U7XG5cbiAgICBcdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XG5cbiAgICB9XG5cbiAgICBNZXNoTGFtYmVydE1hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE1hdGVyaWFsLnByb3RvdHlwZSApO1xuICAgIE1lc2hMYW1iZXJ0TWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWVzaExhbWJlcnRNYXRlcmlhbDtcblxuICAgIE1lc2hMYW1iZXJ0TWF0ZXJpYWwucHJvdG90eXBlLmlzTWVzaExhbWJlcnRNYXRlcmlhbCA9IHRydWU7XG5cbiAgICBNZXNoTGFtYmVydE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cbiAgICBcdE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG4gICAgXHR0aGlzLmNvbG9yLmNvcHkoIHNvdXJjZS5jb2xvciApO1xuXG4gICAgXHR0aGlzLm1hcCA9IHNvdXJjZS5tYXA7XG5cbiAgICBcdHRoaXMubGlnaHRNYXAgPSBzb3VyY2UubGlnaHRNYXA7XG4gICAgXHR0aGlzLmxpZ2h0TWFwSW50ZW5zaXR5ID0gc291cmNlLmxpZ2h0TWFwSW50ZW5zaXR5O1xuXG4gICAgXHR0aGlzLmFvTWFwID0gc291cmNlLmFvTWFwO1xuICAgIFx0dGhpcy5hb01hcEludGVuc2l0eSA9IHNvdXJjZS5hb01hcEludGVuc2l0eTtcblxuICAgIFx0dGhpcy5lbWlzc2l2ZS5jb3B5KCBzb3VyY2UuZW1pc3NpdmUgKTtcbiAgICBcdHRoaXMuZW1pc3NpdmVNYXAgPSBzb3VyY2UuZW1pc3NpdmVNYXA7XG4gICAgXHR0aGlzLmVtaXNzaXZlSW50ZW5zaXR5ID0gc291cmNlLmVtaXNzaXZlSW50ZW5zaXR5O1xuXG4gICAgXHR0aGlzLnNwZWN1bGFyTWFwID0gc291cmNlLnNwZWN1bGFyTWFwO1xuXG4gICAgXHR0aGlzLmFscGhhTWFwID0gc291cmNlLmFscGhhTWFwO1xuXG4gICAgXHR0aGlzLmVudk1hcCA9IHNvdXJjZS5lbnZNYXA7XG4gICAgXHR0aGlzLmNvbWJpbmUgPSBzb3VyY2UuY29tYmluZTtcbiAgICBcdHRoaXMucmVmbGVjdGl2aXR5ID0gc291cmNlLnJlZmxlY3Rpdml0eTtcbiAgICBcdHRoaXMucmVmcmFjdGlvblJhdGlvID0gc291cmNlLnJlZnJhY3Rpb25SYXRpbztcblxuICAgIFx0dGhpcy53aXJlZnJhbWUgPSBzb3VyY2Uud2lyZWZyYW1lO1xuICAgIFx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSBzb3VyY2Uud2lyZWZyYW1lTGluZXdpZHRoO1xuICAgIFx0dGhpcy53aXJlZnJhbWVMaW5lY2FwID0gc291cmNlLndpcmVmcmFtZUxpbmVjYXA7XG4gICAgXHR0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gc291cmNlLndpcmVmcmFtZUxpbmVqb2luO1xuXG4gICAgXHR0aGlzLnNraW5uaW5nID0gc291cmNlLnNraW5uaW5nO1xuICAgIFx0dGhpcy5tb3JwaFRhcmdldHMgPSBzb3VyY2UubW9ycGhUYXJnZXRzO1xuICAgIFx0dGhpcy5tb3JwaE5vcm1hbHMgPSBzb3VyY2UubW9ycGhOb3JtYWxzO1xuXG4gICAgXHRyZXR1cm4gdGhpcztcblxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICAgICAqXG4gICAgICogcGFyYW1ldGVycyA9IHtcbiAgICAgKiAgY29sb3I6IDxoZXg+LFxuICAgICAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxuICAgICAqXG4gICAgICogIGxpbmV3aWR0aDogPGZsb2F0PixcbiAgICAgKlxuICAgICAqICBzY2FsZTogPGZsb2F0PixcbiAgICAgKiAgZGFzaFNpemU6IDxmbG9hdD4sXG4gICAgICogIGdhcFNpemU6IDxmbG9hdD5cbiAgICAgKiB9XG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBMaW5lRGFzaGVkTWF0ZXJpYWwoIHBhcmFtZXRlcnMgKSB7XG5cbiAgICBcdE1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcblxuICAgIFx0dGhpcy50eXBlID0gJ0xpbmVEYXNoZWRNYXRlcmlhbCc7XG5cbiAgICBcdHRoaXMuY29sb3IgPSBuZXcgQ29sb3IoIDB4ZmZmZmZmICk7XG5cbiAgICBcdHRoaXMubGluZXdpZHRoID0gMTtcblxuICAgIFx0dGhpcy5zY2FsZSA9IDE7XG4gICAgXHR0aGlzLmRhc2hTaXplID0gMztcbiAgICBcdHRoaXMuZ2FwU2l6ZSA9IDE7XG5cbiAgICBcdHRoaXMubGlnaHRzID0gZmFsc2U7XG5cbiAgICBcdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XG5cbiAgICB9XG5cbiAgICBMaW5lRGFzaGVkTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTWF0ZXJpYWwucHJvdG90eXBlICk7XG4gICAgTGluZURhc2hlZE1hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExpbmVEYXNoZWRNYXRlcmlhbDtcblxuICAgIExpbmVEYXNoZWRNYXRlcmlhbC5wcm90b3R5cGUuaXNMaW5lRGFzaGVkTWF0ZXJpYWwgPSB0cnVlO1xuXG4gICAgTGluZURhc2hlZE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cbiAgICBcdE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG4gICAgXHR0aGlzLmNvbG9yLmNvcHkoIHNvdXJjZS5jb2xvciApO1xuXG4gICAgXHR0aGlzLmxpbmV3aWR0aCA9IHNvdXJjZS5saW5ld2lkdGg7XG5cbiAgICBcdHRoaXMuc2NhbGUgPSBzb3VyY2Uuc2NhbGU7XG4gICAgXHR0aGlzLmRhc2hTaXplID0gc291cmNlLmRhc2hTaXplO1xuICAgIFx0dGhpcy5nYXBTaXplID0gc291cmNlLmdhcFNpemU7XG5cbiAgICBcdHJldHVybiB0aGlzO1xuXG4gICAgfTtcblxuXG5cbiAgICB2YXIgTWF0ZXJpYWxzID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgXHRTaGFkb3dNYXRlcmlhbDogU2hhZG93TWF0ZXJpYWwsXG4gICAgXHRTcHJpdGVNYXRlcmlhbDogU3ByaXRlTWF0ZXJpYWwsXG4gICAgXHRSYXdTaGFkZXJNYXRlcmlhbDogUmF3U2hhZGVyTWF0ZXJpYWwsXG4gICAgXHRTaGFkZXJNYXRlcmlhbDogU2hhZGVyTWF0ZXJpYWwsXG4gICAgXHRQb2ludHNNYXRlcmlhbDogUG9pbnRzTWF0ZXJpYWwsXG4gICAgXHRNdWx0aU1hdGVyaWFsOiBNdWx0aU1hdGVyaWFsLFxuICAgIFx0TWVzaFBoeXNpY2FsTWF0ZXJpYWw6IE1lc2hQaHlzaWNhbE1hdGVyaWFsLFxuICAgIFx0TWVzaFN0YW5kYXJkTWF0ZXJpYWw6IE1lc2hTdGFuZGFyZE1hdGVyaWFsLFxuICAgIFx0TWVzaFBob25nTWF0ZXJpYWw6IE1lc2hQaG9uZ01hdGVyaWFsLFxuICAgIFx0TWVzaE5vcm1hbE1hdGVyaWFsOiBNZXNoTm9ybWFsTWF0ZXJpYWwsXG4gICAgXHRNZXNoTGFtYmVydE1hdGVyaWFsOiBNZXNoTGFtYmVydE1hdGVyaWFsLFxuICAgIFx0TWVzaERlcHRoTWF0ZXJpYWw6IE1lc2hEZXB0aE1hdGVyaWFsLFxuICAgIFx0TWVzaEJhc2ljTWF0ZXJpYWw6IE1lc2hCYXNpY01hdGVyaWFsLFxuICAgIFx0TGluZURhc2hlZE1hdGVyaWFsOiBMaW5lRGFzaGVkTWF0ZXJpYWwsXG4gICAgXHRMaW5lQmFzaWNNYXRlcmlhbDogTGluZUJhc2ljTWF0ZXJpYWwsXG4gICAgXHRNYXRlcmlhbDogTWF0ZXJpYWxcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gICAgICovXG5cbiAgICBleHBvcnRzLkNhY2hlID0ge1xuXG4gICAgXHRlbmFibGVkOiBmYWxzZSxcblxuICAgIFx0ZmlsZXM6IHt9LFxuXG4gICAgXHRhZGQ6IGZ1bmN0aW9uICgga2V5LCBmaWxlICkge1xuXG4gICAgXHRcdGlmICggdGhpcy5lbmFibGVkID09PSBmYWxzZSApIHJldHVybjtcblxuICAgIFx0XHQvLyBjb25zb2xlLmxvZyggJ1RIUkVFLkNhY2hlJywgJ0FkZGluZyBrZXk6Jywga2V5ICk7XG5cbiAgICBcdFx0dGhpcy5maWxlc1sga2V5IF0gPSBmaWxlO1xuXG4gICAgXHR9LFxuXG4gICAgXHRnZXQ6IGZ1bmN0aW9uICgga2V5ICkge1xuXG4gICAgXHRcdGlmICggdGhpcy5lbmFibGVkID09PSBmYWxzZSApIHJldHVybjtcblxuICAgIFx0XHQvLyBjb25zb2xlLmxvZyggJ1RIUkVFLkNhY2hlJywgJ0NoZWNraW5nIGtleTonLCBrZXkgKTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcy5maWxlc1sga2V5IF07XG5cbiAgICBcdH0sXG5cbiAgICBcdHJlbW92ZTogZnVuY3Rpb24gKCBrZXkgKSB7XG5cbiAgICBcdFx0ZGVsZXRlIHRoaXMuZmlsZXNbIGtleSBdO1xuXG4gICAgXHR9LFxuXG4gICAgXHRjbGVhcjogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHRoaXMuZmlsZXMgPSB7fTtcblxuICAgIFx0fVxuXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBMb2FkaW5nTWFuYWdlciggb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG4gICAgXHR2YXIgc2NvcGUgPSB0aGlzO1xuXG4gICAgXHR2YXIgaXNMb2FkaW5nID0gZmFsc2UsIGl0ZW1zTG9hZGVkID0gMCwgaXRlbXNUb3RhbCA9IDA7XG5cbiAgICBcdHRoaXMub25TdGFydCA9IHVuZGVmaW5lZDtcbiAgICBcdHRoaXMub25Mb2FkID0gb25Mb2FkO1xuICAgIFx0dGhpcy5vblByb2dyZXNzID0gb25Qcm9ncmVzcztcbiAgICBcdHRoaXMub25FcnJvciA9IG9uRXJyb3I7XG5cbiAgICBcdHRoaXMuaXRlbVN0YXJ0ID0gZnVuY3Rpb24gKCB1cmwgKSB7XG5cbiAgICBcdFx0aXRlbXNUb3RhbCArKztcblxuICAgIFx0XHRpZiAoIGlzTG9hZGluZyA9PT0gZmFsc2UgKSB7XG5cbiAgICBcdFx0XHRpZiAoIHNjb3BlLm9uU3RhcnQgIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0c2NvcGUub25TdGFydCggdXJsLCBpdGVtc0xvYWRlZCwgaXRlbXNUb3RhbCApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpc0xvYWRpbmcgPSB0cnVlO1xuXG4gICAgXHR9O1xuXG4gICAgXHR0aGlzLml0ZW1FbmQgPSBmdW5jdGlvbiAoIHVybCApIHtcblxuICAgIFx0XHRpdGVtc0xvYWRlZCArKztcblxuICAgIFx0XHRpZiAoIHNjb3BlLm9uUHJvZ3Jlc3MgIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdHNjb3BlLm9uUHJvZ3Jlc3MoIHVybCwgaXRlbXNMb2FkZWQsIGl0ZW1zVG90YWwgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKCBpdGVtc0xvYWRlZCA9PT0gaXRlbXNUb3RhbCApIHtcblxuICAgIFx0XHRcdGlzTG9hZGluZyA9IGZhbHNlO1xuXG4gICAgXHRcdFx0aWYgKCBzY29wZS5vbkxvYWQgIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0c2NvcGUub25Mb2FkKCk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9O1xuXG4gICAgXHR0aGlzLml0ZW1FcnJvciA9IGZ1bmN0aW9uICggdXJsICkge1xuXG4gICAgXHRcdGlmICggc2NvcGUub25FcnJvciAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0c2NvcGUub25FcnJvciggdXJsICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9O1xuXG4gICAgfVxuXG4gICAgZXhwb3J0cy5EZWZhdWx0TG9hZGluZ01hbmFnZXIgPSBuZXcgTG9hZGluZ01hbmFnZXIoKTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBYSFJMb2FkZXIoIG1hbmFnZXIgKSB7XG5cbiAgICBcdHRoaXMubWFuYWdlciA9ICggbWFuYWdlciAhPT0gdW5kZWZpbmVkICkgPyBtYW5hZ2VyIDogZXhwb3J0cy5EZWZhdWx0TG9hZGluZ01hbmFnZXI7XG5cbiAgICB9XG5cbiAgICBPYmplY3QuYXNzaWduKCBYSFJMb2FkZXIucHJvdG90eXBlLCB7XG5cbiAgICBcdGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cbiAgICBcdFx0aWYgKCB0aGlzLnBhdGggIT09IHVuZGVmaW5lZCApIHVybCA9IHRoaXMucGF0aCArIHVybDtcblxuICAgIFx0XHR2YXIgc2NvcGUgPSB0aGlzO1xuXG4gICAgXHRcdHZhciBjYWNoZWQgPSBleHBvcnRzLkNhY2hlLmdldCggdXJsICk7XG5cbiAgICBcdFx0aWYgKCBjYWNoZWQgIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbVN0YXJ0KCB1cmwgKTtcblxuICAgIFx0XHRcdHNldFRpbWVvdXQoIGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHRcdFx0aWYgKCBvbkxvYWQgKSBvbkxvYWQoIGNhY2hlZCApO1xuXG4gICAgXHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FbmQoIHVybCApO1xuXG4gICAgXHRcdFx0fSwgMCApO1xuXG4gICAgXHRcdFx0cmV0dXJuIGNhY2hlZDtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0dmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICBcdFx0cmVxdWVzdC5vcGVuKCAnR0VUJywgdXJsLCB0cnVlICk7XG5cbiAgICBcdFx0cmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCAnbG9hZCcsIGZ1bmN0aW9uICggZXZlbnQgKSB7XG5cbiAgICBcdFx0XHR2YXIgcmVzcG9uc2UgPSBldmVudC50YXJnZXQucmVzcG9uc2U7XG5cbiAgICBcdFx0XHRleHBvcnRzLkNhY2hlLmFkZCggdXJsLCByZXNwb25zZSApO1xuXG4gICAgXHRcdFx0aWYgKCB0aGlzLnN0YXR1cyA9PT0gMjAwICkge1xuXG4gICAgXHRcdFx0XHRpZiAoIG9uTG9hZCApIG9uTG9hZCggcmVzcG9uc2UgKTtcblxuICAgIFx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRW5kKCB1cmwgKTtcblxuICAgIFx0XHRcdH0gZWxzZSBpZiAoIHRoaXMuc3RhdHVzID09PSAwICkge1xuXG4gICAgXHRcdFx0XHQvLyBTb21lIGJyb3dzZXJzIHJldHVybiBIVFRQIFN0YXR1cyAwIHdoZW4gdXNpbmcgbm9uLWh0dHAgcHJvdG9jb2xcbiAgICBcdFx0XHRcdC8vIGUuZy4gJ2ZpbGU6Ly8nIG9yICdkYXRhOi8vJy4gSGFuZGxlIGFzIHN1Y2Nlc3MuXG5cbiAgICBcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlhIUkxvYWRlcjogSFRUUCBTdGF0dXMgMCByZWNlaXZlZC4nICk7XG5cbiAgICBcdFx0XHRcdGlmICggb25Mb2FkICkgb25Mb2FkKCByZXNwb25zZSApO1xuXG4gICAgXHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FbmQoIHVybCApO1xuXG4gICAgXHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0aWYgKCBvbkVycm9yICkgb25FcnJvciggZXZlbnQgKTtcblxuICAgIFx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRXJyb3IoIHVybCApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH0sIGZhbHNlICk7XG5cbiAgICBcdFx0aWYgKCBvblByb2dyZXNzICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRyZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoICdwcm9ncmVzcycsIGZ1bmN0aW9uICggZXZlbnQgKSB7XG5cbiAgICBcdFx0XHRcdG9uUHJvZ3Jlc3MoIGV2ZW50ICk7XG5cbiAgICBcdFx0XHR9LCBmYWxzZSApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoICdlcnJvcicsIGZ1bmN0aW9uICggZXZlbnQgKSB7XG5cbiAgICBcdFx0XHRpZiAoIG9uRXJyb3IgKSBvbkVycm9yKCBldmVudCApO1xuXG4gICAgXHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRXJyb3IoIHVybCApO1xuXG4gICAgXHRcdH0sIGZhbHNlICk7XG5cbiAgICBcdFx0aWYgKCB0aGlzLnJlc3BvbnNlVHlwZSAhPT0gdW5kZWZpbmVkICkgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSB0aGlzLnJlc3BvbnNlVHlwZTtcbiAgICBcdFx0aWYgKCB0aGlzLndpdGhDcmVkZW50aWFscyAhPT0gdW5kZWZpbmVkICkgcmVxdWVzdC53aXRoQ3JlZGVudGlhbHMgPSB0aGlzLndpdGhDcmVkZW50aWFscztcblxuICAgIFx0XHRpZiAoIHJlcXVlc3Qub3ZlcnJpZGVNaW1lVHlwZSApIHJlcXVlc3Qub3ZlcnJpZGVNaW1lVHlwZSggJ3RleHQvcGxhaW4nICk7XG5cbiAgICBcdFx0cmVxdWVzdC5zZW5kKCBudWxsICk7XG5cbiAgICBcdFx0c2NvcGUubWFuYWdlci5pdGVtU3RhcnQoIHVybCApO1xuXG4gICAgXHRcdHJldHVybiByZXF1ZXN0O1xuXG4gICAgXHR9LFxuXG4gICAgXHRzZXRQYXRoOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG4gICAgXHRcdHRoaXMucGF0aCA9IHZhbHVlO1xuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0c2V0UmVzcG9uc2VUeXBlOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG4gICAgXHRcdHRoaXMucmVzcG9uc2VUeXBlID0gdmFsdWU7XG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzZXRXaXRoQ3JlZGVudGlhbHM6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cbiAgICBcdFx0dGhpcy53aXRoQ3JlZGVudGlhbHMgPSB2YWx1ZTtcbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH1cblxuICAgIH0gKTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gICAgICpcbiAgICAgKiBBYnN0cmFjdCBCYXNlIGNsYXNzIHRvIGJsb2NrIGJhc2VkIHRleHR1cmVzIGxvYWRlciAoZGRzLCBwdnIsIC4uLilcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIENvbXByZXNzZWRUZXh0dXJlTG9hZGVyKCBtYW5hZ2VyICkge1xuXG4gICAgXHR0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IGV4cG9ydHMuRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xuXG4gICAgXHQvLyBvdmVycmlkZSBpbiBzdWIgY2xhc3Nlc1xuICAgIFx0dGhpcy5fcGFyc2VyID0gbnVsbDtcblxuICAgIH1cblxuICAgIE9iamVjdC5hc3NpZ24oIENvbXByZXNzZWRUZXh0dXJlTG9hZGVyLnByb3RvdHlwZSwge1xuXG4gICAgXHRsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG4gICAgXHRcdHZhciBzY29wZSA9IHRoaXM7XG5cbiAgICBcdFx0dmFyIGltYWdlcyA9IFtdO1xuXG4gICAgXHRcdHZhciB0ZXh0dXJlID0gbmV3IENvbXByZXNzZWRUZXh0dXJlKCk7XG4gICAgXHRcdHRleHR1cmUuaW1hZ2UgPSBpbWFnZXM7XG5cbiAgICBcdFx0dmFyIGxvYWRlciA9IG5ldyBYSFJMb2FkZXIoIHRoaXMubWFuYWdlciApO1xuICAgIFx0XHRsb2FkZXIuc2V0UGF0aCggdGhpcy5wYXRoICk7XG4gICAgXHRcdGxvYWRlci5zZXRSZXNwb25zZVR5cGUoICdhcnJheWJ1ZmZlcicgKTtcblxuICAgIFx0XHRmdW5jdGlvbiBsb2FkVGV4dHVyZSggaSApIHtcblxuICAgIFx0XHRcdGxvYWRlci5sb2FkKCB1cmxbIGkgXSwgZnVuY3Rpb24gKCBidWZmZXIgKSB7XG5cbiAgICBcdFx0XHRcdHZhciB0ZXhEYXRhcyA9IHNjb3BlLl9wYXJzZXIoIGJ1ZmZlciwgdHJ1ZSApO1xuXG4gICAgXHRcdFx0XHRpbWFnZXNbIGkgXSA9IHtcbiAgICBcdFx0XHRcdFx0d2lkdGg6IHRleERhdGFzLndpZHRoLFxuICAgIFx0XHRcdFx0XHRoZWlnaHQ6IHRleERhdGFzLmhlaWdodCxcbiAgICBcdFx0XHRcdFx0Zm9ybWF0OiB0ZXhEYXRhcy5mb3JtYXQsXG4gICAgXHRcdFx0XHRcdG1pcG1hcHM6IHRleERhdGFzLm1pcG1hcHNcbiAgICBcdFx0XHRcdH07XG5cbiAgICBcdFx0XHRcdGxvYWRlZCArPSAxO1xuXG4gICAgXHRcdFx0XHRpZiAoIGxvYWRlZCA9PT0gNiApIHtcblxuICAgIFx0XHRcdFx0XHRpZiAoIHRleERhdGFzLm1pcG1hcENvdW50ID09PSAxIClcbiAgICBcdFx0XHRcdFx0XHR0ZXh0dXJlLm1pbkZpbHRlciA9IExpbmVhckZpbHRlcjtcblxuICAgIFx0XHRcdFx0XHR0ZXh0dXJlLmZvcm1hdCA9IHRleERhdGFzLmZvcm1hdDtcbiAgICBcdFx0XHRcdFx0dGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICBcdFx0XHRcdFx0aWYgKCBvbkxvYWQgKSBvbkxvYWQoIHRleHR1cmUgKTtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHVybCApICkge1xuXG4gICAgXHRcdFx0dmFyIGxvYWRlZCA9IDA7XG5cbiAgICBcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gdXJsLmxlbmd0aDsgaSA8IGlsOyArKyBpICkge1xuXG4gICAgXHRcdFx0XHRsb2FkVGV4dHVyZSggaSApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHQvLyBjb21wcmVzc2VkIGN1YmVtYXAgdGV4dHVyZSBzdG9yZWQgaW4gYSBzaW5nbGUgRERTIGZpbGVcblxuICAgIFx0XHRcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggYnVmZmVyICkge1xuXG4gICAgXHRcdFx0XHR2YXIgdGV4RGF0YXMgPSBzY29wZS5fcGFyc2VyKCBidWZmZXIsIHRydWUgKTtcblxuICAgIFx0XHRcdFx0aWYgKCB0ZXhEYXRhcy5pc0N1YmVtYXAgKSB7XG5cbiAgICBcdFx0XHRcdFx0dmFyIGZhY2VzID0gdGV4RGF0YXMubWlwbWFwcy5sZW5ndGggLyB0ZXhEYXRhcy5taXBtYXBDb3VudDtcblxuICAgIFx0XHRcdFx0XHRmb3IgKCB2YXIgZiA9IDA7IGYgPCBmYWNlczsgZiArKyApIHtcblxuICAgIFx0XHRcdFx0XHRcdGltYWdlc1sgZiBdID0geyBtaXBtYXBzIDogW10gfTtcblxuICAgIFx0XHRcdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHRleERhdGFzLm1pcG1hcENvdW50OyBpICsrICkge1xuXG4gICAgXHRcdFx0XHRcdFx0XHRpbWFnZXNbIGYgXS5taXBtYXBzLnB1c2goIHRleERhdGFzLm1pcG1hcHNbIGYgKiB0ZXhEYXRhcy5taXBtYXBDb3VudCArIGkgXSApO1xuICAgIFx0XHRcdFx0XHRcdFx0aW1hZ2VzWyBmIF0uZm9ybWF0ID0gdGV4RGF0YXMuZm9ybWF0O1xuICAgIFx0XHRcdFx0XHRcdFx0aW1hZ2VzWyBmIF0ud2lkdGggPSB0ZXhEYXRhcy53aWR0aDtcbiAgICBcdFx0XHRcdFx0XHRcdGltYWdlc1sgZiBdLmhlaWdodCA9IHRleERhdGFzLmhlaWdodDtcblxuICAgIFx0XHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdFx0dGV4dHVyZS5pbWFnZS53aWR0aCA9IHRleERhdGFzLndpZHRoO1xuICAgIFx0XHRcdFx0XHR0ZXh0dXJlLmltYWdlLmhlaWdodCA9IHRleERhdGFzLmhlaWdodDtcbiAgICBcdFx0XHRcdFx0dGV4dHVyZS5taXBtYXBzID0gdGV4RGF0YXMubWlwbWFwcztcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRpZiAoIHRleERhdGFzLm1pcG1hcENvdW50ID09PSAxICkge1xuXG4gICAgXHRcdFx0XHRcdHRleHR1cmUubWluRmlsdGVyID0gTGluZWFyRmlsdGVyO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdHRleHR1cmUuZm9ybWF0ID0gdGV4RGF0YXMuZm9ybWF0O1xuICAgIFx0XHRcdFx0dGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICBcdFx0XHRcdGlmICggb25Mb2FkICkgb25Mb2FkKCB0ZXh0dXJlICk7XG5cbiAgICBcdFx0XHR9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiB0ZXh0dXJlO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzZXRQYXRoOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG4gICAgXHRcdHRoaXMucGF0aCA9IHZhbHVlO1xuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fVxuXG4gICAgfSApO1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBOaWtvcyBNLiAvIGh0dHBzOi8vZ2l0aHViLmNvbS9mb28xMjMvXG4gICAgICpcbiAgICAgKiBBYnN0cmFjdCBCYXNlIGNsYXNzIHRvIGxvYWQgZ2VuZXJpYyBiaW5hcnkgdGV4dHVyZXMgZm9ybWF0cyAocmdiZSwgaGRyLCAuLi4pXG4gICAgICovXG5cbiAgICB2YXIgRGF0YVRleHR1cmVMb2FkZXIgPSBCaW5hcnlUZXh0dXJlTG9hZGVyO1xuICAgIGZ1bmN0aW9uIEJpbmFyeVRleHR1cmVMb2FkZXIoIG1hbmFnZXIgKSB7XG5cbiAgICBcdHRoaXMubWFuYWdlciA9ICggbWFuYWdlciAhPT0gdW5kZWZpbmVkICkgPyBtYW5hZ2VyIDogZXhwb3J0cy5EZWZhdWx0TG9hZGluZ01hbmFnZXI7XG5cbiAgICBcdC8vIG92ZXJyaWRlIGluIHN1YiBjbGFzc2VzXG4gICAgXHR0aGlzLl9wYXJzZXIgPSBudWxsO1xuXG4gICAgfVxuXG4gICAgT2JqZWN0LmFzc2lnbiggQmluYXJ5VGV4dHVyZUxvYWRlci5wcm90b3R5cGUsIHtcblxuICAgIFx0bG9hZDogZnVuY3Rpb24gKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcblxuICAgIFx0XHR2YXIgc2NvcGUgPSB0aGlzO1xuXG4gICAgXHRcdHZhciB0ZXh0dXJlID0gbmV3IERhdGFUZXh0dXJlKCk7XG5cbiAgICBcdFx0dmFyIGxvYWRlciA9IG5ldyBYSFJMb2FkZXIoIHRoaXMubWFuYWdlciApO1xuICAgIFx0XHRsb2FkZXIuc2V0UmVzcG9uc2VUeXBlKCAnYXJyYXlidWZmZXInICk7XG5cbiAgICBcdFx0bG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCBidWZmZXIgKSB7XG5cbiAgICBcdFx0XHR2YXIgdGV4RGF0YSA9IHNjb3BlLl9wYXJzZXIoIGJ1ZmZlciApO1xuXG4gICAgXHRcdFx0aWYgKCAhIHRleERhdGEgKSByZXR1cm47XG5cbiAgICBcdFx0XHRpZiAoIHVuZGVmaW5lZCAhPT0gdGV4RGF0YS5pbWFnZSApIHtcblxuICAgIFx0XHRcdFx0dGV4dHVyZS5pbWFnZSA9IHRleERhdGEuaW1hZ2U7XG5cbiAgICBcdFx0XHR9IGVsc2UgaWYgKCB1bmRlZmluZWQgIT09IHRleERhdGEuZGF0YSApIHtcblxuICAgIFx0XHRcdFx0dGV4dHVyZS5pbWFnZS53aWR0aCA9IHRleERhdGEud2lkdGg7XG4gICAgXHRcdFx0XHR0ZXh0dXJlLmltYWdlLmhlaWdodCA9IHRleERhdGEuaGVpZ2h0O1xuICAgIFx0XHRcdFx0dGV4dHVyZS5pbWFnZS5kYXRhID0gdGV4RGF0YS5kYXRhO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0dGV4dHVyZS53cmFwUyA9IHVuZGVmaW5lZCAhPT0gdGV4RGF0YS53cmFwUyA/IHRleERhdGEud3JhcFMgOiBDbGFtcFRvRWRnZVdyYXBwaW5nO1xuICAgIFx0XHRcdHRleHR1cmUud3JhcFQgPSB1bmRlZmluZWQgIT09IHRleERhdGEud3JhcFQgPyB0ZXhEYXRhLndyYXBUIDogQ2xhbXBUb0VkZ2VXcmFwcGluZztcblxuICAgIFx0XHRcdHRleHR1cmUubWFnRmlsdGVyID0gdW5kZWZpbmVkICE9PSB0ZXhEYXRhLm1hZ0ZpbHRlciA/IHRleERhdGEubWFnRmlsdGVyIDogTGluZWFyRmlsdGVyO1xuICAgIFx0XHRcdHRleHR1cmUubWluRmlsdGVyID0gdW5kZWZpbmVkICE9PSB0ZXhEYXRhLm1pbkZpbHRlciA/IHRleERhdGEubWluRmlsdGVyIDogTGluZWFyTWlwTWFwTGluZWFyRmlsdGVyO1xuXG4gICAgXHRcdFx0dGV4dHVyZS5hbmlzb3Ryb3B5ID0gdW5kZWZpbmVkICE9PSB0ZXhEYXRhLmFuaXNvdHJvcHkgPyB0ZXhEYXRhLmFuaXNvdHJvcHkgOiAxO1xuXG4gICAgXHRcdFx0aWYgKCB1bmRlZmluZWQgIT09IHRleERhdGEuZm9ybWF0ICkge1xuXG4gICAgXHRcdFx0XHR0ZXh0dXJlLmZvcm1hdCA9IHRleERhdGEuZm9ybWF0O1xuXG4gICAgXHRcdFx0fVxuICAgIFx0XHRcdGlmICggdW5kZWZpbmVkICE9PSB0ZXhEYXRhLnR5cGUgKSB7XG5cbiAgICBcdFx0XHRcdHRleHR1cmUudHlwZSA9IHRleERhdGEudHlwZTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGlmICggdW5kZWZpbmVkICE9PSB0ZXhEYXRhLm1pcG1hcHMgKSB7XG5cbiAgICBcdFx0XHRcdHRleHR1cmUubWlwbWFwcyA9IHRleERhdGEubWlwbWFwcztcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGlmICggMSA9PT0gdGV4RGF0YS5taXBtYXBDb3VudCApIHtcblxuICAgIFx0XHRcdFx0dGV4dHVyZS5taW5GaWx0ZXIgPSBMaW5lYXJGaWx0ZXI7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgIFx0XHRcdGlmICggb25Mb2FkICkgb25Mb2FkKCB0ZXh0dXJlLCB0ZXhEYXRhICk7XG5cbiAgICBcdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xuXG5cbiAgICBcdFx0cmV0dXJuIHRleHR1cmU7XG5cbiAgICBcdH1cblxuICAgIH0gKTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBJbWFnZUxvYWRlciggbWFuYWdlciApIHtcblxuICAgIFx0dGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBleHBvcnRzLkRlZmF1bHRMb2FkaW5nTWFuYWdlcjtcblxuICAgIH1cblxuICAgIE9iamVjdC5hc3NpZ24oIEltYWdlTG9hZGVyLnByb3RvdHlwZSwge1xuXG4gICAgXHRsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG4gICAgXHRcdHZhciBzY29wZSA9IHRoaXM7XG5cbiAgICBcdFx0dmFyIGltYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCcsICdpbWcnICk7XG4gICAgXHRcdGltYWdlLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHRcdGltYWdlLm9ubG9hZCA9IG51bGw7XG5cbiAgICBcdFx0XHRVUkwucmV2b2tlT2JqZWN0VVJMKCBpbWFnZS5zcmMgKTtcblxuICAgIFx0XHRcdGlmICggb25Mb2FkICkgb25Mb2FkKCBpbWFnZSApO1xuXG4gICAgXHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRW5kKCB1cmwgKTtcblxuICAgIFx0XHR9O1xuXG4gICAgXHRcdGlmICggdXJsLmluZGV4T2YoICdkYXRhOicgKSA9PT0gMCApIHtcblxuICAgIFx0XHRcdGltYWdlLnNyYyA9IHVybDtcblxuICAgIFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0dmFyIGxvYWRlciA9IG5ldyBYSFJMb2FkZXIoKTtcbiAgICBcdFx0XHRsb2FkZXIuc2V0UGF0aCggdGhpcy5wYXRoICk7XG4gICAgXHRcdFx0bG9hZGVyLnNldFJlc3BvbnNlVHlwZSggJ2Jsb2InICk7XG4gICAgXHRcdFx0bG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyggdGhpcy53aXRoQ3JlZGVudGlhbHMgKTtcbiAgICBcdFx0XHRsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIGJsb2IgKSB7XG5cbiAgICBcdFx0XHRcdGltYWdlLnNyYyA9IFVSTC5jcmVhdGVPYmplY3RVUkwoIGJsb2IgKTtcblxuICAgIFx0XHRcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0c2NvcGUubWFuYWdlci5pdGVtU3RhcnQoIHVybCApO1xuXG4gICAgXHRcdHJldHVybiBpbWFnZTtcblxuICAgIFx0fSxcblxuICAgIFx0c2V0Q3Jvc3NPcmlnaW46IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cbiAgICBcdFx0dGhpcy5jcm9zc09yaWdpbiA9IHZhbHVlO1xuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0c2V0V2l0aENyZWRlbnRpYWxzOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG4gICAgXHRcdHRoaXMud2l0aENyZWRlbnRpYWxzID0gdmFsdWU7XG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzZXRQYXRoOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG4gICAgXHRcdHRoaXMucGF0aCA9IHZhbHVlO1xuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fVxuXG4gICAgfSApO1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIEN1YmVUZXh0dXJlTG9hZGVyKCBtYW5hZ2VyICkge1xuXG4gICAgXHR0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IGV4cG9ydHMuRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xuXG4gICAgfVxuXG4gICAgT2JqZWN0LmFzc2lnbiggQ3ViZVRleHR1cmVMb2FkZXIucHJvdG90eXBlLCB7XG5cbiAgICBcdGxvYWQ6IGZ1bmN0aW9uICggdXJscywgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG4gICAgXHRcdHZhciB0ZXh0dXJlID0gbmV3IEN1YmVUZXh0dXJlKCk7XG5cbiAgICBcdFx0dmFyIGxvYWRlciA9IG5ldyBJbWFnZUxvYWRlciggdGhpcy5tYW5hZ2VyICk7XG4gICAgXHRcdGxvYWRlci5zZXRDcm9zc09yaWdpbiggdGhpcy5jcm9zc09yaWdpbiApO1xuICAgIFx0XHRsb2FkZXIuc2V0UGF0aCggdGhpcy5wYXRoICk7XG5cbiAgICBcdFx0dmFyIGxvYWRlZCA9IDA7XG5cbiAgICBcdFx0ZnVuY3Rpb24gbG9hZFRleHR1cmUoIGkgKSB7XG5cbiAgICBcdFx0XHRsb2FkZXIubG9hZCggdXJsc1sgaSBdLCBmdW5jdGlvbiAoIGltYWdlICkge1xuXG4gICAgXHRcdFx0XHR0ZXh0dXJlLmltYWdlc1sgaSBdID0gaW1hZ2U7XG5cbiAgICBcdFx0XHRcdGxvYWRlZCArKztcblxuICAgIFx0XHRcdFx0aWYgKCBsb2FkZWQgPT09IDYgKSB7XG5cbiAgICBcdFx0XHRcdFx0dGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICBcdFx0XHRcdFx0aWYgKCBvbkxvYWQgKSBvbkxvYWQoIHRleHR1cmUgKTtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fSwgdW5kZWZpbmVkLCBvbkVycm9yICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHVybHMubGVuZ3RoOyArKyBpICkge1xuXG4gICAgXHRcdFx0bG9hZFRleHR1cmUoIGkgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIHRleHR1cmU7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldENyb3NzT3JpZ2luOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG4gICAgXHRcdHRoaXMuY3Jvc3NPcmlnaW4gPSB2YWx1ZTtcbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldFBhdGg6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cbiAgICBcdFx0dGhpcy5wYXRoID0gdmFsdWU7XG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9XG5cbiAgICB9ICk7XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gVGV4dHVyZUxvYWRlciggbWFuYWdlciApIHtcblxuICAgIFx0dGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBleHBvcnRzLkRlZmF1bHRMb2FkaW5nTWFuYWdlcjtcblxuICAgIH1cblxuICAgIE9iamVjdC5hc3NpZ24oIFRleHR1cmVMb2FkZXIucHJvdG90eXBlLCB7XG5cbiAgICBcdGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cbiAgICBcdFx0dmFyIHRleHR1cmUgPSBuZXcgVGV4dHVyZSgpO1xuXG4gICAgXHRcdHZhciBsb2FkZXIgPSBuZXcgSW1hZ2VMb2FkZXIoIHRoaXMubWFuYWdlciApO1xuICAgIFx0XHRsb2FkZXIuc2V0Q3Jvc3NPcmlnaW4oIHRoaXMuY3Jvc3NPcmlnaW4gKTtcbiAgICBcdFx0bG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyggdGhpcy53aXRoQ3JlZGVudGlhbHMgKTtcbiAgICBcdFx0bG9hZGVyLnNldFBhdGgoIHRoaXMucGF0aCApO1xuICAgIFx0XHRsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIGltYWdlICkge1xuXG4gICAgXHRcdFx0Ly8gSlBFR3MgY2FuJ3QgaGF2ZSBhbiBhbHBoYSBjaGFubmVsLCBzbyBtZW1vcnkgY2FuIGJlIHNhdmVkIGJ5IHN0b3JpbmcgdGhlbSBhcyBSR0IuXG4gICAgXHRcdFx0dmFyIGlzSlBFRyA9IHVybC5zZWFyY2goIC9cXC4oanBnfGpwZWcpJC8gKSA+IDAgfHwgdXJsLnNlYXJjaCggL15kYXRhXFw6aW1hZ2VcXC9qcGVnLyApID09PSAwO1xuXG4gICAgXHRcdFx0dGV4dHVyZS5mb3JtYXQgPSBpc0pQRUcgPyBSR0JGb3JtYXQgOiBSR0JBRm9ybWF0O1xuICAgIFx0XHRcdHRleHR1cmUuaW1hZ2UgPSBpbWFnZTtcbiAgICBcdFx0XHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgIFx0XHRcdGlmICggb25Mb2FkICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRcdG9uTG9hZCggdGV4dHVyZSApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcblxuICAgIFx0XHRyZXR1cm4gdGV4dHVyZTtcblxuICAgIFx0fSxcblxuICAgIFx0c2V0Q3Jvc3NPcmlnaW46IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cbiAgICBcdFx0dGhpcy5jcm9zc09yaWdpbiA9IHZhbHVlO1xuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0c2V0V2l0aENyZWRlbnRpYWxzOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG4gICAgXHRcdHRoaXMud2l0aENyZWRlbnRpYWxzID0gdmFsdWU7XG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzZXRQYXRoOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG4gICAgXHRcdHRoaXMucGF0aCA9IHZhbHVlO1xuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fVxuXG5cblxuICAgIH0gKTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gICAgICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIExpZ2h0KCBjb2xvciwgaW50ZW5zaXR5ICkge1xuXG4gICAgXHRPYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cbiAgICBcdHRoaXMudHlwZSA9ICdMaWdodCc7XG5cbiAgICBcdHRoaXMuY29sb3IgPSBuZXcgQ29sb3IoIGNvbG9yICk7XG4gICAgXHR0aGlzLmludGVuc2l0eSA9IGludGVuc2l0eSAhPT0gdW5kZWZpbmVkID8gaW50ZW5zaXR5IDogMTtcblxuICAgIFx0dGhpcy5yZWNlaXZlU2hhZG93ID0gdW5kZWZpbmVkO1xuXG4gICAgfVxuXG4gICAgTGlnaHQucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggT2JqZWN0M0QucHJvdG90eXBlICksIHtcblxuICAgIFx0Y29uc3RydWN0b3I6IExpZ2h0LFxuXG4gICAgXHRpc0xpZ2h0OiB0cnVlLFxuXG4gICAgXHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuICAgIFx0XHRPYmplY3QzRC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuICAgIFx0XHR0aGlzLmNvbG9yLmNvcHkoIHNvdXJjZS5jb2xvciApO1xuICAgIFx0XHR0aGlzLmludGVuc2l0eSA9IHNvdXJjZS5pbnRlbnNpdHk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdHRvSlNPTjogZnVuY3Rpb24gKCBtZXRhICkge1xuXG4gICAgXHRcdHZhciBkYXRhID0gT2JqZWN0M0QucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzLCBtZXRhICk7XG5cbiAgICBcdFx0ZGF0YS5vYmplY3QuY29sb3IgPSB0aGlzLmNvbG9yLmdldEhleCgpO1xuICAgIFx0XHRkYXRhLm9iamVjdC5pbnRlbnNpdHkgPSB0aGlzLmludGVuc2l0eTtcblxuICAgIFx0XHRpZiAoIHRoaXMuZ3JvdW5kQ29sb3IgIT09IHVuZGVmaW5lZCApIGRhdGEub2JqZWN0Lmdyb3VuZENvbG9yID0gdGhpcy5ncm91bmRDb2xvci5nZXRIZXgoKTtcblxuICAgIFx0XHRpZiAoIHRoaXMuZGlzdGFuY2UgIT09IHVuZGVmaW5lZCApIGRhdGEub2JqZWN0LmRpc3RhbmNlID0gdGhpcy5kaXN0YW5jZTtcbiAgICBcdFx0aWYgKCB0aGlzLmFuZ2xlICE9PSB1bmRlZmluZWQgKSBkYXRhLm9iamVjdC5hbmdsZSA9IHRoaXMuYW5nbGU7XG4gICAgXHRcdGlmICggdGhpcy5kZWNheSAhPT0gdW5kZWZpbmVkICkgZGF0YS5vYmplY3QuZGVjYXkgPSB0aGlzLmRlY2F5O1xuICAgIFx0XHRpZiAoIHRoaXMucGVudW1icmEgIT09IHVuZGVmaW5lZCApIGRhdGEub2JqZWN0LnBlbnVtYnJhID0gdGhpcy5wZW51bWJyYTtcblxuICAgIFx0XHRpZiAoIHRoaXMuc2hhZG93ICE9PSB1bmRlZmluZWQgKSBkYXRhLm9iamVjdC5zaGFkb3cgPSB0aGlzLnNoYWRvdy50b0pTT04oKTtcblxuICAgIFx0XHRyZXR1cm4gZGF0YTtcblxuICAgIFx0fVxuXG4gICAgfSApO1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIEhlbWlzcGhlcmVMaWdodCggc2t5Q29sb3IsIGdyb3VuZENvbG9yLCBpbnRlbnNpdHkgKSB7XG5cbiAgICBcdExpZ2h0LmNhbGwoIHRoaXMsIHNreUNvbG9yLCBpbnRlbnNpdHkgKTtcblxuICAgIFx0dGhpcy50eXBlID0gJ0hlbWlzcGhlcmVMaWdodCc7XG5cbiAgICBcdHRoaXMuY2FzdFNoYWRvdyA9IHVuZGVmaW5lZDtcblxuICAgIFx0dGhpcy5wb3NpdGlvbi5jb3B5KCBPYmplY3QzRC5EZWZhdWx0VXAgKTtcbiAgICBcdHRoaXMudXBkYXRlTWF0cml4KCk7XG5cbiAgICBcdHRoaXMuZ3JvdW5kQ29sb3IgPSBuZXcgQ29sb3IoIGdyb3VuZENvbG9yICk7XG5cbiAgICB9XG5cbiAgICBIZW1pc3BoZXJlTGlnaHQucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggTGlnaHQucHJvdG90eXBlICksIHtcblxuICAgIFx0Y29uc3RydWN0b3I6IEhlbWlzcGhlcmVMaWdodCxcblxuICAgIFx0aXNIZW1pc3BoZXJlTGlnaHQ6IHRydWUsXG5cbiAgICBcdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xuXG4gICAgXHRcdExpZ2h0LnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG4gICAgXHRcdHRoaXMuZ3JvdW5kQ29sb3IuY29weSggc291cmNlLmdyb3VuZENvbG9yICk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH1cblxuICAgIH0gKTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBMaWdodFNoYWRvdyggY2FtZXJhICkge1xuXG4gICAgXHR0aGlzLmNhbWVyYSA9IGNhbWVyYTtcblxuICAgIFx0dGhpcy5iaWFzID0gMDtcbiAgICBcdHRoaXMucmFkaXVzID0gMTtcblxuICAgIFx0dGhpcy5tYXBTaXplID0gbmV3IFZlY3RvcjIoIDUxMiwgNTEyICk7XG5cbiAgICBcdHRoaXMubWFwID0gbnVsbDtcbiAgICBcdHRoaXMubWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcblxuICAgIH1cblxuICAgIE9iamVjdC5hc3NpZ24oIExpZ2h0U2hhZG93LnByb3RvdHlwZSwge1xuXG4gICAgXHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuICAgIFx0XHR0aGlzLmNhbWVyYSA9IHNvdXJjZS5jYW1lcmEuY2xvbmUoKTtcblxuICAgIFx0XHR0aGlzLmJpYXMgPSBzb3VyY2UuYmlhcztcbiAgICBcdFx0dGhpcy5yYWRpdXMgPSBzb3VyY2UucmFkaXVzO1xuXG4gICAgXHRcdHRoaXMubWFwU2l6ZS5jb3B5KCBzb3VyY2UubWFwU2l6ZSApO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuICAgIFx0fSxcblxuICAgIFx0dG9KU09OOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dmFyIG9iamVjdCA9IHt9O1xuXG4gICAgXHRcdGlmICggdGhpcy5iaWFzICE9PSAwICkgb2JqZWN0LmJpYXMgPSB0aGlzLmJpYXM7XG4gICAgXHRcdGlmICggdGhpcy5yYWRpdXMgIT09IDEgKSBvYmplY3QucmFkaXVzID0gdGhpcy5yYWRpdXM7XG4gICAgXHRcdGlmICggdGhpcy5tYXBTaXplLnggIT09IDUxMiB8fCB0aGlzLm1hcFNpemUueSAhPT0gNTEyICkgb2JqZWN0Lm1hcFNpemUgPSB0aGlzLm1hcFNpemUudG9BcnJheSgpO1xuXG4gICAgXHRcdG9iamVjdC5jYW1lcmEgPSB0aGlzLmNhbWVyYS50b0pTT04oIGZhbHNlICkub2JqZWN0O1xuICAgIFx0XHRkZWxldGUgb2JqZWN0LmNhbWVyYS5tYXRyaXg7XG5cbiAgICBcdFx0cmV0dXJuIG9iamVjdDtcblxuICAgIFx0fVxuXG4gICAgfSApO1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIFNwb3RMaWdodFNoYWRvdygpIHtcblxuICAgIFx0TGlnaHRTaGFkb3cuY2FsbCggdGhpcywgbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKCA1MCwgMSwgMC41LCA1MDAgKSApO1xuXG4gICAgfVxuXG4gICAgU3BvdExpZ2h0U2hhZG93LnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIExpZ2h0U2hhZG93LnByb3RvdHlwZSApLCB7XG5cbiAgICBcdGNvbnN0cnVjdG9yOiBTcG90TGlnaHRTaGFkb3csXG5cbiAgICBcdGlzU3BvdExpZ2h0U2hhZG93OiB0cnVlLFxuXG4gICAgXHR1cGRhdGU6IGZ1bmN0aW9uICggbGlnaHQgKSB7XG5cbiAgICBcdFx0dmFyIGZvdiA9IGV4cG9ydHMuTWF0aC5SQUQyREVHICogMiAqIGxpZ2h0LmFuZ2xlO1xuICAgIFx0XHR2YXIgYXNwZWN0ID0gdGhpcy5tYXBTaXplLndpZHRoIC8gdGhpcy5tYXBTaXplLmhlaWdodDtcbiAgICBcdFx0dmFyIGZhciA9IGxpZ2h0LmRpc3RhbmNlIHx8IDUwMDtcblxuICAgIFx0XHR2YXIgY2FtZXJhID0gdGhpcy5jYW1lcmE7XG5cbiAgICBcdFx0aWYgKCBmb3YgIT09IGNhbWVyYS5mb3YgfHwgYXNwZWN0ICE9PSBjYW1lcmEuYXNwZWN0IHx8IGZhciAhPT0gY2FtZXJhLmZhciApIHtcblxuICAgIFx0XHRcdGNhbWVyYS5mb3YgPSBmb3Y7XG4gICAgXHRcdFx0Y2FtZXJhLmFzcGVjdCA9IGFzcGVjdDtcbiAgICBcdFx0XHRjYW1lcmEuZmFyID0gZmFyO1xuICAgIFx0XHRcdGNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9XG5cbiAgICB9ICk7XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gU3BvdExpZ2h0KCBjb2xvciwgaW50ZW5zaXR5LCBkaXN0YW5jZSwgYW5nbGUsIHBlbnVtYnJhLCBkZWNheSApIHtcblxuICAgIFx0TGlnaHQuY2FsbCggdGhpcywgY29sb3IsIGludGVuc2l0eSApO1xuXG4gICAgXHR0aGlzLnR5cGUgPSAnU3BvdExpZ2h0JztcblxuICAgIFx0dGhpcy5wb3NpdGlvbi5jb3B5KCBPYmplY3QzRC5EZWZhdWx0VXAgKTtcbiAgICBcdHRoaXMudXBkYXRlTWF0cml4KCk7XG5cbiAgICBcdHRoaXMudGFyZ2V0ID0gbmV3IE9iamVjdDNEKCk7XG5cbiAgICBcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgJ3Bvd2VyJywge1xuICAgIFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBcdFx0XHQvLyBpbnRlbnNpdHkgPSBwb3dlciBwZXIgc29saWQgYW5nbGUuXG4gICAgXHRcdFx0Ly8gcmVmOiBlcXVhdGlvbiAoMTcpIGZyb20gaHR0cDovL3d3dy5mcm9zdGJpdGUuY29tL3dwLWNvbnRlbnQvdXBsb2Fkcy8yMDE0LzExL2NvdXJzZV9ub3Rlc19tb3ZpbmdfZnJvc3RiaXRlX3RvX3Bici5wZGZcbiAgICBcdFx0XHRyZXR1cm4gdGhpcy5pbnRlbnNpdHkgKiBNYXRoLlBJO1xuICAgIFx0XHR9LFxuICAgIFx0XHRzZXQ6IGZ1bmN0aW9uICggcG93ZXIgKSB7XG4gICAgXHRcdFx0Ly8gaW50ZW5zaXR5ID0gcG93ZXIgcGVyIHNvbGlkIGFuZ2xlLlxuICAgIFx0XHRcdC8vIHJlZjogZXF1YXRpb24gKDE3KSBmcm9tIGh0dHA6Ly93d3cuZnJvc3RiaXRlLmNvbS93cC1jb250ZW50L3VwbG9hZHMvMjAxNC8xMS9jb3Vyc2Vfbm90ZXNfbW92aW5nX2Zyb3N0Yml0ZV90b19wYnIucGRmXG4gICAgXHRcdFx0dGhpcy5pbnRlbnNpdHkgPSBwb3dlciAvIE1hdGguUEk7XG4gICAgXHRcdH1cbiAgICBcdH0gKTtcblxuICAgIFx0dGhpcy5kaXN0YW5jZSA9ICggZGlzdGFuY2UgIT09IHVuZGVmaW5lZCApID8gZGlzdGFuY2UgOiAwO1xuICAgIFx0dGhpcy5hbmdsZSA9ICggYW5nbGUgIT09IHVuZGVmaW5lZCApID8gYW5nbGUgOiBNYXRoLlBJIC8gMztcbiAgICBcdHRoaXMucGVudW1icmEgPSAoIHBlbnVtYnJhICE9PSB1bmRlZmluZWQgKSA/IHBlbnVtYnJhIDogMDtcbiAgICBcdHRoaXMuZGVjYXkgPSAoIGRlY2F5ICE9PSB1bmRlZmluZWQgKSA/IGRlY2F5IDogMTtcdC8vIGZvciBwaHlzaWNhbGx5IGNvcnJlY3QgbGlnaHRzLCBzaG91bGQgYmUgMi5cblxuICAgIFx0dGhpcy5zaGFkb3cgPSBuZXcgU3BvdExpZ2h0U2hhZG93KCk7XG5cbiAgICB9XG5cbiAgICBTcG90TGlnaHQucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggTGlnaHQucHJvdG90eXBlICksIHtcblxuICAgIFx0Y29uc3RydWN0b3I6IFNwb3RMaWdodCxcblxuICAgIFx0aXNTcG90TGlnaHQ6IHRydWUsXG5cbiAgICBcdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xuXG4gICAgXHRcdExpZ2h0LnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG4gICAgXHRcdHRoaXMuZGlzdGFuY2UgPSBzb3VyY2UuZGlzdGFuY2U7XG4gICAgXHRcdHRoaXMuYW5nbGUgPSBzb3VyY2UuYW5nbGU7XG4gICAgXHRcdHRoaXMucGVudW1icmEgPSBzb3VyY2UucGVudW1icmE7XG4gICAgXHRcdHRoaXMuZGVjYXkgPSBzb3VyY2UuZGVjYXk7XG5cbiAgICBcdFx0dGhpcy50YXJnZXQgPSBzb3VyY2UudGFyZ2V0LmNsb25lKCk7XG5cbiAgICBcdFx0dGhpcy5zaGFkb3cgPSBzb3VyY2Uuc2hhZG93LmNsb25lKCk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH1cblxuICAgIH0gKTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gICAgICovXG5cblxuICAgIGZ1bmN0aW9uIFBvaW50TGlnaHQoIGNvbG9yLCBpbnRlbnNpdHksIGRpc3RhbmNlLCBkZWNheSApIHtcblxuICAgIFx0TGlnaHQuY2FsbCggdGhpcywgY29sb3IsIGludGVuc2l0eSApO1xuXG4gICAgXHR0aGlzLnR5cGUgPSAnUG9pbnRMaWdodCc7XG5cbiAgICBcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgJ3Bvd2VyJywge1xuICAgIFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBcdFx0XHQvLyBpbnRlbnNpdHkgPSBwb3dlciBwZXIgc29saWQgYW5nbGUuXG4gICAgXHRcdFx0Ly8gcmVmOiBlcXVhdGlvbiAoMTUpIGZyb20gaHR0cDovL3d3dy5mcm9zdGJpdGUuY29tL3dwLWNvbnRlbnQvdXBsb2Fkcy8yMDE0LzExL2NvdXJzZV9ub3Rlc19tb3ZpbmdfZnJvc3RiaXRlX3RvX3Bici5wZGZcbiAgICBcdFx0XHRyZXR1cm4gdGhpcy5pbnRlbnNpdHkgKiA0ICogTWF0aC5QSTtcblxuICAgIFx0XHR9LFxuICAgIFx0XHRzZXQ6IGZ1bmN0aW9uICggcG93ZXIgKSB7XG4gICAgXHRcdFx0Ly8gaW50ZW5zaXR5ID0gcG93ZXIgcGVyIHNvbGlkIGFuZ2xlLlxuICAgIFx0XHRcdC8vIHJlZjogZXF1YXRpb24gKDE1KSBmcm9tIGh0dHA6Ly93d3cuZnJvc3RiaXRlLmNvbS93cC1jb250ZW50L3VwbG9hZHMvMjAxNC8xMS9jb3Vyc2Vfbm90ZXNfbW92aW5nX2Zyb3N0Yml0ZV90b19wYnIucGRmXG4gICAgXHRcdFx0dGhpcy5pbnRlbnNpdHkgPSBwb3dlciAvICggNCAqIE1hdGguUEkgKTtcbiAgICBcdFx0fVxuICAgIFx0fSApO1xuXG4gICAgXHR0aGlzLmRpc3RhbmNlID0gKCBkaXN0YW5jZSAhPT0gdW5kZWZpbmVkICkgPyBkaXN0YW5jZSA6IDA7XG4gICAgXHR0aGlzLmRlY2F5ID0gKCBkZWNheSAhPT0gdW5kZWZpbmVkICkgPyBkZWNheSA6IDE7XHQvLyBmb3IgcGh5c2ljYWxseSBjb3JyZWN0IGxpZ2h0cywgc2hvdWxkIGJlIDIuXG5cbiAgICBcdHRoaXMuc2hhZG93ID0gbmV3IExpZ2h0U2hhZG93KCBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoIDkwLCAxLCAwLjUsIDUwMCApICk7XG5cbiAgICB9XG5cbiAgICBQb2ludExpZ2h0LnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIExpZ2h0LnByb3RvdHlwZSApLCB7XG5cbiAgICBcdGNvbnN0cnVjdG9yOiBQb2ludExpZ2h0LFxuXG4gICAgXHRpc1BvaW50TGlnaHQ6IHRydWUsXG5cbiAgICBcdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xuXG4gICAgXHRcdExpZ2h0LnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG4gICAgXHRcdHRoaXMuZGlzdGFuY2UgPSBzb3VyY2UuZGlzdGFuY2U7XG4gICAgXHRcdHRoaXMuZGVjYXkgPSBzb3VyY2UuZGVjYXk7XG5cbiAgICBcdFx0dGhpcy5zaGFkb3cgPSBzb3VyY2Uuc2hhZG93LmNsb25lKCk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH1cblxuICAgIH0gKTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBEaXJlY3Rpb25hbExpZ2h0U2hhZG93KCBsaWdodCApIHtcblxuICAgIFx0TGlnaHRTaGFkb3cuY2FsbCggdGhpcywgbmV3IE9ydGhvZ3JhcGhpY0NhbWVyYSggLSA1LCA1LCA1LCAtIDUsIDAuNSwgNTAwICkgKTtcblxuICAgIH1cblxuICAgIERpcmVjdGlvbmFsTGlnaHRTaGFkb3cucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggTGlnaHRTaGFkb3cucHJvdG90eXBlICksIHtcblxuICAgIFx0Y29uc3RydWN0b3I6IERpcmVjdGlvbmFsTGlnaHRTaGFkb3dcblxuICAgIH0gKTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gICAgICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIERpcmVjdGlvbmFsTGlnaHQoIGNvbG9yLCBpbnRlbnNpdHkgKSB7XG5cbiAgICBcdExpZ2h0LmNhbGwoIHRoaXMsIGNvbG9yLCBpbnRlbnNpdHkgKTtcblxuICAgIFx0dGhpcy50eXBlID0gJ0RpcmVjdGlvbmFsTGlnaHQnO1xuXG4gICAgXHR0aGlzLnBvc2l0aW9uLmNvcHkoIE9iamVjdDNELkRlZmF1bHRVcCApO1xuICAgIFx0dGhpcy51cGRhdGVNYXRyaXgoKTtcblxuICAgIFx0dGhpcy50YXJnZXQgPSBuZXcgT2JqZWN0M0QoKTtcblxuICAgIFx0dGhpcy5zaGFkb3cgPSBuZXcgRGlyZWN0aW9uYWxMaWdodFNoYWRvdygpO1xuXG4gICAgfVxuXG4gICAgRGlyZWN0aW9uYWxMaWdodC5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBMaWdodC5wcm90b3R5cGUgKSwge1xuXG4gICAgXHRjb25zdHJ1Y3RvcjogRGlyZWN0aW9uYWxMaWdodCxcblxuICAgIFx0aXNEaXJlY3Rpb25hbExpZ2h0OiB0cnVlLFxuXG4gICAgXHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuICAgIFx0XHRMaWdodC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuICAgIFx0XHR0aGlzLnRhcmdldCA9IHNvdXJjZS50YXJnZXQuY2xvbmUoKTtcblxuICAgIFx0XHR0aGlzLnNoYWRvdyA9IHNvdXJjZS5zaGFkb3cuY2xvbmUoKTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fVxuXG4gICAgfSApO1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIEFtYmllbnRMaWdodCggY29sb3IsIGludGVuc2l0eSApIHtcblxuICAgIFx0TGlnaHQuY2FsbCggdGhpcywgY29sb3IsIGludGVuc2l0eSApO1xuXG4gICAgXHR0aGlzLnR5cGUgPSAnQW1iaWVudExpZ2h0JztcblxuICAgIFx0dGhpcy5jYXN0U2hhZG93ID0gdW5kZWZpbmVkO1xuXG4gICAgfVxuXG4gICAgQW1iaWVudExpZ2h0LnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIExpZ2h0LnByb3RvdHlwZSApLCB7XG5cbiAgICBcdGNvbnN0cnVjdG9yOiBBbWJpZW50TGlnaHQsXG5cbiAgICBcdGlzQW1iaWVudExpZ2h0OiB0cnVlLFxuXG4gICAgfSApO1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciB0c2Nod1xuICAgICAqIEBhdXRob3IgQmVuIEhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW8vXG4gICAgICogQGF1dGhvciBEYXZpZCBTYXJubyAvIGh0dHA6Ly9saWdodGhhdXMudXMvXG4gICAgICovXG5cbiAgICBleHBvcnRzLkFuaW1hdGlvblV0aWxzID0ge1xuXG4gICAgXHQvLyBzYW1lIGFzIEFycmF5LnByb3RvdHlwZS5zbGljZSwgYnV0IGFsc28gd29ya3Mgb24gdHlwZWQgYXJyYXlzXG4gICAgXHRhcnJheVNsaWNlOiBmdW5jdGlvbiggYXJyYXksIGZyb20sIHRvICkge1xuXG4gICAgXHRcdGlmICggZXhwb3J0cy5BbmltYXRpb25VdGlscy5pc1R5cGVkQXJyYXkoIGFycmF5ICkgKSB7XG5cbiAgICBcdFx0XHRyZXR1cm4gbmV3IGFycmF5LmNvbnN0cnVjdG9yKCBhcnJheS5zdWJhcnJheSggZnJvbSwgdG8gKSApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gYXJyYXkuc2xpY2UoIGZyb20sIHRvICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdC8vIGNvbnZlcnRzIGFuIGFycmF5IHRvIGEgc3BlY2lmaWMgdHlwZVxuICAgIFx0Y29udmVydEFycmF5OiBmdW5jdGlvbiggYXJyYXksIHR5cGUsIGZvcmNlQ2xvbmUgKSB7XG5cbiAgICBcdFx0aWYgKCAhIGFycmF5IHx8IC8vIGxldCAndW5kZWZpbmVkJyBhbmQgJ251bGwnIHBhc3NcbiAgICBcdFx0XHRcdCEgZm9yY2VDbG9uZSAmJiBhcnJheS5jb25zdHJ1Y3RvciA9PT0gdHlwZSApIHJldHVybiBhcnJheTtcblxuICAgIFx0XHRpZiAoIHR5cGVvZiB0eXBlLkJZVEVTX1BFUl9FTEVNRU5UID09PSAnbnVtYmVyJyApIHtcblxuICAgIFx0XHRcdHJldHVybiBuZXcgdHlwZSggYXJyYXkgKTsgLy8gY3JlYXRlIHR5cGVkIGFycmF5XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggYXJyYXkgKTsgLy8gY3JlYXRlIEFycmF5XG5cbiAgICBcdH0sXG5cbiAgICBcdGlzVHlwZWRBcnJheTogZnVuY3Rpb24oIG9iamVjdCApIHtcblxuICAgIFx0XHRyZXR1cm4gQXJyYXlCdWZmZXIuaXNWaWV3KCBvYmplY3QgKSAmJlxuICAgIFx0XHRcdFx0ISAoIG9iamVjdCBpbnN0YW5jZW9mIERhdGFWaWV3ICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdC8vIHJldHVybnMgYW4gYXJyYXkgYnkgd2hpY2ggdGltZXMgYW5kIHZhbHVlcyBjYW4gYmUgc29ydGVkXG4gICAgXHRnZXRLZXlmcmFtZU9yZGVyOiBmdW5jdGlvbiggdGltZXMgKSB7XG5cbiAgICBcdFx0ZnVuY3Rpb24gY29tcGFyZVRpbWUoIGksIGogKSB7XG5cbiAgICBcdFx0XHRyZXR1cm4gdGltZXNbIGkgXSAtIHRpbWVzWyBqIF07XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHZhciBuID0gdGltZXMubGVuZ3RoO1xuICAgIFx0XHR2YXIgcmVzdWx0ID0gbmV3IEFycmF5KCBuICk7XG4gICAgXHRcdGZvciAoIHZhciBpID0gMDsgaSAhPT0gbjsgKysgaSApIHJlc3VsdFsgaSBdID0gaTtcblxuICAgIFx0XHRyZXN1bHQuc29ydCggY29tcGFyZVRpbWUgKTtcblxuICAgIFx0XHRyZXR1cm4gcmVzdWx0O1xuXG4gICAgXHR9LFxuXG4gICAgXHQvLyB1c2VzIHRoZSBhcnJheSBwcmV2aW91c2x5IHJldHVybmVkIGJ5ICdnZXRLZXlmcmFtZU9yZGVyJyB0byBzb3J0IGRhdGFcbiAgICBcdHNvcnRlZEFycmF5OiBmdW5jdGlvbiggdmFsdWVzLCBzdHJpZGUsIG9yZGVyICkge1xuXG4gICAgXHRcdHZhciBuVmFsdWVzID0gdmFsdWVzLmxlbmd0aDtcbiAgICBcdFx0dmFyIHJlc3VsdCA9IG5ldyB2YWx1ZXMuY29uc3RydWN0b3IoIG5WYWx1ZXMgKTtcblxuICAgIFx0XHRmb3IgKCB2YXIgaSA9IDAsIGRzdE9mZnNldCA9IDA7IGRzdE9mZnNldCAhPT0gblZhbHVlczsgKysgaSApIHtcblxuICAgIFx0XHRcdHZhciBzcmNPZmZzZXQgPSBvcmRlclsgaSBdICogc3RyaWRlO1xuXG4gICAgXHRcdFx0Zm9yICggdmFyIGogPSAwOyBqICE9PSBzdHJpZGU7ICsrIGogKSB7XG5cbiAgICBcdFx0XHRcdHJlc3VsdFsgZHN0T2Zmc2V0ICsrIF0gPSB2YWx1ZXNbIHNyY09mZnNldCArIGogXTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIHJlc3VsdDtcblxuICAgIFx0fSxcblxuICAgIFx0Ly8gZnVuY3Rpb24gZm9yIHBhcnNpbmcgQU9TIGtleWZyYW1lIGZvcm1hdHNcbiAgICBcdGZsYXR0ZW5KU09OOiBmdW5jdGlvbigganNvbktleXMsIHRpbWVzLCB2YWx1ZXMsIHZhbHVlUHJvcGVydHlOYW1lICkge1xuXG4gICAgXHRcdHZhciBpID0gMSwga2V5ID0ganNvbktleXNbIDAgXTtcblxuICAgIFx0XHR3aGlsZSAoIGtleSAhPT0gdW5kZWZpbmVkICYmIGtleVsgdmFsdWVQcm9wZXJ0eU5hbWUgXSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0a2V5ID0ganNvbktleXNbIGkgKysgXTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCApIHJldHVybjsgLy8gbm8gZGF0YVxuXG4gICAgXHRcdHZhciB2YWx1ZSA9IGtleVsgdmFsdWVQcm9wZXJ0eU5hbWUgXTtcbiAgICBcdFx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICkgcmV0dXJuOyAvLyBubyBkYXRhXG5cbiAgICBcdFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWx1ZSApICkge1xuXG4gICAgXHRcdFx0ZG8ge1xuXG4gICAgXHRcdFx0XHR2YWx1ZSA9IGtleVsgdmFsdWVQcm9wZXJ0eU5hbWUgXTtcblxuICAgIFx0XHRcdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0XHRcdHRpbWVzLnB1c2goIGtleS50aW1lICk7XG4gICAgXHRcdFx0XHRcdHZhbHVlcy5wdXNoLmFwcGx5KCB2YWx1ZXMsIHZhbHVlICk7IC8vIHB1c2ggYWxsIGVsZW1lbnRzXG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0a2V5ID0ganNvbktleXNbIGkgKysgXTtcblxuICAgIFx0XHRcdH0gd2hpbGUgKCBrZXkgIT09IHVuZGVmaW5lZCApO1xuXG4gICAgXHRcdH0gZWxzZSBpZiAoIHZhbHVlLnRvQXJyYXkgIT09IHVuZGVmaW5lZCApIHtcbiAgICBcdFx0XHQvLyAuLi5hc3N1bWUgVEhSRUUuTWF0aC1pc2hcblxuICAgIFx0XHRcdGRvIHtcblxuICAgIFx0XHRcdFx0dmFsdWUgPSBrZXlbIHZhbHVlUHJvcGVydHlOYW1lIF07XG5cbiAgICBcdFx0XHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0XHR0aW1lcy5wdXNoKCBrZXkudGltZSApO1xuICAgIFx0XHRcdFx0XHR2YWx1ZS50b0FycmF5KCB2YWx1ZXMsIHZhbHVlcy5sZW5ndGggKTtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRrZXkgPSBqc29uS2V5c1sgaSArKyBdO1xuXG4gICAgXHRcdFx0fSB3aGlsZSAoIGtleSAhPT0gdW5kZWZpbmVkICk7XG5cbiAgICBcdFx0fSBlbHNlIHtcbiAgICBcdFx0XHQvLyBvdGhlcndpc2UgcHVzaCBhcy1pc1xuXG4gICAgXHRcdFx0ZG8ge1xuXG4gICAgXHRcdFx0XHR2YWx1ZSA9IGtleVsgdmFsdWVQcm9wZXJ0eU5hbWUgXTtcblxuICAgIFx0XHRcdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0XHRcdHRpbWVzLnB1c2goIGtleS50aW1lICk7XG4gICAgXHRcdFx0XHRcdHZhbHVlcy5wdXNoKCB2YWx1ZSApO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdGtleSA9IGpzb25LZXlzWyBpICsrIF07XG5cbiAgICBcdFx0XHR9IHdoaWxlICgga2V5ICE9PSB1bmRlZmluZWQgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdH1cblxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBYnN0cmFjdCBiYXNlIGNsYXNzIG9mIGludGVycG9sYW50cyBvdmVyIHBhcmFtZXRyaWMgc2FtcGxlcy5cbiAgICAgKlxuICAgICAqIFRoZSBwYXJhbWV0ZXIgZG9tYWluIGlzIG9uZSBkaW1lbnNpb25hbCwgdHlwaWNhbGx5IHRoZSB0aW1lIG9yIGEgcGF0aFxuICAgICAqIGFsb25nIGEgY3VydmUgZGVmaW5lZCBieSB0aGUgZGF0YS5cbiAgICAgKlxuICAgICAqIFRoZSBzYW1wbGUgdmFsdWVzIGNhbiBoYXZlIGFueSBkaW1lbnNpb25hbGl0eSBhbmQgZGVyaXZlZCBjbGFzc2VzIG1heVxuICAgICAqIGFwcGx5IHNwZWNpYWwgaW50ZXJwcmV0YXRpb25zIHRvIHRoZSBkYXRhLlxuICAgICAqXG4gICAgICogVGhpcyBjbGFzcyBwcm92aWRlcyB0aGUgaW50ZXJ2YWwgc2VlayBpbiBhIFRlbXBsYXRlIE1ldGhvZCwgZGVmZXJyaW5nXG4gICAgICogdGhlIGFjdHVhbCBpbnRlcnBvbGF0aW9uIHRvIGRlcml2ZWQgY2xhc3Nlcy5cbiAgICAgKlxuICAgICAqIFRpbWUgY29tcGxleGl0eSBpcyBPKDEpIGZvciBsaW5lYXIgYWNjZXNzIGNyb3NzaW5nIGF0IG1vc3QgdHdvIHBvaW50c1xuICAgICAqIGFuZCBPKGxvZyBOKSBmb3IgcmFuZG9tIGFjY2Vzcywgd2hlcmUgTiBpcyB0aGUgbnVtYmVyIG9mIHBvc2l0aW9ucy5cbiAgICAgKlxuICAgICAqIFJlZmVyZW5jZXM6XG4gICAgICpcbiAgICAgKiBcdFx0aHR0cDovL3d3dy5vb2Rlc2lnbi5jb20vdGVtcGxhdGUtbWV0aG9kLXBhdHRlcm4uaHRtbFxuICAgICAqXG4gICAgICogQGF1dGhvciB0c2Nod1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gSW50ZXJwb2xhbnQoXG4gICAgXHRcdHBhcmFtZXRlclBvc2l0aW9ucywgc2FtcGxlVmFsdWVzLCBzYW1wbGVTaXplLCByZXN1bHRCdWZmZXIgKSB7XG5cbiAgICBcdHRoaXMucGFyYW1ldGVyUG9zaXRpb25zID0gcGFyYW1ldGVyUG9zaXRpb25zO1xuICAgIFx0dGhpcy5fY2FjaGVkSW5kZXggPSAwO1xuXG4gICAgXHR0aGlzLnJlc3VsdEJ1ZmZlciA9IHJlc3VsdEJ1ZmZlciAhPT0gdW5kZWZpbmVkID9cbiAgICBcdFx0XHRyZXN1bHRCdWZmZXIgOiBuZXcgc2FtcGxlVmFsdWVzLmNvbnN0cnVjdG9yKCBzYW1wbGVTaXplICk7XG4gICAgXHR0aGlzLnNhbXBsZVZhbHVlcyA9IHNhbXBsZVZhbHVlcztcbiAgICBcdHRoaXMudmFsdWVTaXplID0gc2FtcGxlU2l6ZTtcblxuICAgIH1cblxuICAgIEludGVycG9sYW50LnByb3RvdHlwZSA9IHtcblxuICAgIFx0Y29uc3RydWN0b3I6IEludGVycG9sYW50LFxuXG4gICAgXHRldmFsdWF0ZTogZnVuY3Rpb24oIHQgKSB7XG5cbiAgICBcdFx0dmFyIHBwID0gdGhpcy5wYXJhbWV0ZXJQb3NpdGlvbnMsXG4gICAgXHRcdFx0aTEgPSB0aGlzLl9jYWNoZWRJbmRleCxcblxuICAgIFx0XHRcdHQxID0gcHBbICAgaTEgICBdLFxuICAgIFx0XHRcdHQwID0gcHBbIGkxIC0gMSBdO1xuXG4gICAgXHRcdHZhbGlkYXRlX2ludGVydmFsOiB7XG5cbiAgICBcdFx0XHRzZWVrOiB7XG5cbiAgICBcdFx0XHRcdHZhciByaWdodDtcblxuICAgIFx0XHRcdFx0bGluZWFyX3NjYW46IHtcbiAgICAvLy0gU2VlIGh0dHA6Ly9qc3BlcmYuY29tL2NvbXBhcmlzb24tdG8tdW5kZWZpbmVkLzNcbiAgICAvLy0gc2xvd2VyIGNvZGU6XG4gICAgLy8tXG4gICAgLy8tIFx0XHRcdFx0aWYgKCB0ID49IHQxIHx8IHQxID09PSB1bmRlZmluZWQgKSB7XG4gICAgXHRcdFx0XHRcdGZvcndhcmRfc2NhbjogaWYgKCAhICggdCA8IHQxICkgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHRmb3IgKCB2YXIgZ2l2ZVVwQXQgPSBpMSArIDI7IDspIHtcblxuICAgIFx0XHRcdFx0XHRcdFx0aWYgKCB0MSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0XHRcdFx0XHRcdGlmICggdCA8IHQwICkgYnJlYWsgZm9yd2FyZF9zY2FuO1xuXG4gICAgXHRcdFx0XHRcdFx0XHRcdC8vIGFmdGVyIGVuZFxuXG4gICAgXHRcdFx0XHRcdFx0XHRcdGkxID0gcHAubGVuZ3RoO1xuICAgIFx0XHRcdFx0XHRcdFx0XHR0aGlzLl9jYWNoZWRJbmRleCA9IGkxO1xuICAgIFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5hZnRlckVuZF8oIGkxIC0gMSwgdCwgdDAgKTtcblxuICAgIFx0XHRcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRcdFx0XHRpZiAoIGkxID09PSBnaXZlVXBBdCApIGJyZWFrOyAvLyB0aGlzIGxvb3BcblxuICAgIFx0XHRcdFx0XHRcdFx0dDAgPSB0MTtcbiAgICBcdFx0XHRcdFx0XHRcdHQxID0gcHBbICsrIGkxIF07XG5cbiAgICBcdFx0XHRcdFx0XHRcdGlmICggdCA8IHQxICkge1xuXG4gICAgXHRcdFx0XHRcdFx0XHRcdC8vIHdlIGhhdmUgYXJyaXZlZCBhdCB0aGUgc291Z2h0IGludGVydmFsXG4gICAgXHRcdFx0XHRcdFx0XHRcdGJyZWFrIHNlZWs7XG5cbiAgICBcdFx0XHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0XHRcdC8vIHByZXBhcmUgYmluYXJ5IHNlYXJjaCBvbiB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgaW5kZXhcbiAgICBcdFx0XHRcdFx0XHRyaWdodCA9IHBwLmxlbmd0aDtcbiAgICBcdFx0XHRcdFx0XHRicmVhayBsaW5lYXJfc2NhbjtcblxuICAgIFx0XHRcdFx0XHR9XG5cbiAgICAvLy0gc2xvd2VyIGNvZGU6XG4gICAgLy8tXHRcdFx0XHRcdGlmICggdCA8IHQwIHx8IHQwID09PSB1bmRlZmluZWQgKSB7XG4gICAgXHRcdFx0XHRcdGlmICggISAoIHQgPj0gdDAgKSApIHtcblxuICAgIFx0XHRcdFx0XHRcdC8vIGxvb3Bpbmc/XG5cbiAgICBcdFx0XHRcdFx0XHR2YXIgdDFnbG9iYWwgPSBwcFsgMSBdO1xuXG4gICAgXHRcdFx0XHRcdFx0aWYgKCB0IDwgdDFnbG9iYWwgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHRcdGkxID0gMjsgLy8gKyAxLCB1c2luZyB0aGUgc2NhbiBmb3IgdGhlIGRldGFpbHNcbiAgICBcdFx0XHRcdFx0XHRcdHQwID0gdDFnbG9iYWw7XG5cbiAgICBcdFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdFx0XHQvLyBsaW5lYXIgcmV2ZXJzZSBzY2FuXG5cbiAgICBcdFx0XHRcdFx0XHRmb3IgKCB2YXIgZ2l2ZVVwQXQgPSBpMSAtIDI7IDspIHtcblxuICAgIFx0XHRcdFx0XHRcdFx0aWYgKCB0MCA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0XHRcdFx0XHRcdC8vIGJlZm9yZSBzdGFydFxuXG4gICAgXHRcdFx0XHRcdFx0XHRcdHRoaXMuX2NhY2hlZEluZGV4ID0gMDtcbiAgICBcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuYmVmb3JlU3RhcnRfKCAwLCB0LCB0MSApO1xuXG4gICAgXHRcdFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdFx0XHRcdGlmICggaTEgPT09IGdpdmVVcEF0ICkgYnJlYWs7IC8vIHRoaXMgbG9vcFxuXG4gICAgXHRcdFx0XHRcdFx0XHR0MSA9IHQwO1xuICAgIFx0XHRcdFx0XHRcdFx0dDAgPSBwcFsgLS0gaTEgLSAxIF07XG5cbiAgICBcdFx0XHRcdFx0XHRcdGlmICggdCA+PSB0MCApIHtcblxuICAgIFx0XHRcdFx0XHRcdFx0XHQvLyB3ZSBoYXZlIGFycml2ZWQgYXQgdGhlIHNvdWdodCBpbnRlcnZhbFxuICAgIFx0XHRcdFx0XHRcdFx0XHRicmVhayBzZWVrO1xuXG4gICAgXHRcdFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdFx0XHQvLyBwcmVwYXJlIGJpbmFyeSBzZWFyY2ggb24gdGhlIGxlZnQgc2lkZSBvZiB0aGUgaW5kZXhcbiAgICBcdFx0XHRcdFx0XHRyaWdodCA9IGkxO1xuICAgIFx0XHRcdFx0XHRcdGkxID0gMDtcbiAgICBcdFx0XHRcdFx0XHRicmVhayBsaW5lYXJfc2NhbjtcblxuICAgIFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdFx0Ly8gdGhlIGludGVydmFsIGlzIHZhbGlkXG5cbiAgICBcdFx0XHRcdFx0YnJlYWsgdmFsaWRhdGVfaW50ZXJ2YWw7XG5cbiAgICBcdFx0XHRcdH0gLy8gbGluZWFyIHNjYW5cblxuICAgIFx0XHRcdFx0Ly8gYmluYXJ5IHNlYXJjaFxuXG4gICAgXHRcdFx0XHR3aGlsZSAoIGkxIDwgcmlnaHQgKSB7XG5cbiAgICBcdFx0XHRcdFx0dmFyIG1pZCA9ICggaTEgKyByaWdodCApID4+PiAxO1xuXG4gICAgXHRcdFx0XHRcdGlmICggdCA8IHBwWyBtaWQgXSApIHtcblxuICAgIFx0XHRcdFx0XHRcdHJpZ2h0ID0gbWlkO1xuXG4gICAgXHRcdFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdFx0XHRpMSA9IG1pZCArIDE7XG5cbiAgICBcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdHQxID0gcHBbICAgaTEgICBdO1xuICAgIFx0XHRcdFx0dDAgPSBwcFsgaTEgLSAxIF07XG5cbiAgICBcdFx0XHRcdC8vIGNoZWNrIGJvdW5kYXJ5IGNhc2VzLCBhZ2FpblxuXG4gICAgXHRcdFx0XHRpZiAoIHQwID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRcdFx0dGhpcy5fY2FjaGVkSW5kZXggPSAwO1xuICAgIFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5iZWZvcmVTdGFydF8oIDAsIHQsIHQxICk7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0aWYgKCB0MSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0XHRcdGkxID0gcHAubGVuZ3RoO1xuICAgIFx0XHRcdFx0XHR0aGlzLl9jYWNoZWRJbmRleCA9IGkxO1xuICAgIFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5hZnRlckVuZF8oIGkxIC0gMSwgdDAsIHQgKTtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fSAvLyBzZWVrXG5cbiAgICBcdFx0XHR0aGlzLl9jYWNoZWRJbmRleCA9IGkxO1xuXG4gICAgXHRcdFx0dGhpcy5pbnRlcnZhbENoYW5nZWRfKCBpMSwgdDAsIHQxICk7XG5cbiAgICBcdFx0fSAvLyB2YWxpZGF0ZV9pbnRlcnZhbFxuXG4gICAgXHRcdHJldHVybiB0aGlzLmludGVycG9sYXRlXyggaTEsIHQwLCB0LCB0MSApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzZXR0aW5nczogbnVsbCwgLy8gb3B0aW9uYWwsIHN1YmNsYXNzLXNwZWNpZmljIHNldHRpbmdzIHN0cnVjdHVyZVxuICAgIFx0Ly8gTm90ZTogVGhlIGluZGlyZWN0aW9uIGFsbG93cyBjZW50cmFsIGNvbnRyb2wgb2YgbWFueSBpbnRlcnBvbGFudHMuXG5cbiAgICBcdC8vIC0tLSBQcm90ZWN0ZWQgaW50ZXJmYWNlXG5cbiAgICBcdERlZmF1bHRTZXR0aW5nc186IHt9LFxuXG4gICAgXHRnZXRTZXR0aW5nc186IGZ1bmN0aW9uKCkge1xuXG4gICAgXHRcdHJldHVybiB0aGlzLnNldHRpbmdzIHx8IHRoaXMuRGVmYXVsdFNldHRpbmdzXztcblxuICAgIFx0fSxcblxuICAgIFx0Y29weVNhbXBsZVZhbHVlXzogZnVuY3Rpb24oIGluZGV4ICkge1xuXG4gICAgXHRcdC8vIGNvcGllcyBhIHNhbXBsZSB2YWx1ZSB0byB0aGUgcmVzdWx0IGJ1ZmZlclxuXG4gICAgXHRcdHZhciByZXN1bHQgPSB0aGlzLnJlc3VsdEJ1ZmZlcixcbiAgICBcdFx0XHR2YWx1ZXMgPSB0aGlzLnNhbXBsZVZhbHVlcyxcbiAgICBcdFx0XHRzdHJpZGUgPSB0aGlzLnZhbHVlU2l6ZSxcbiAgICBcdFx0XHRvZmZzZXQgPSBpbmRleCAqIHN0cmlkZTtcblxuICAgIFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgIT09IHN0cmlkZTsgKysgaSApIHtcblxuICAgIFx0XHRcdHJlc3VsdFsgaSBdID0gdmFsdWVzWyBvZmZzZXQgKyBpIF07XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiByZXN1bHQ7XG5cbiAgICBcdH0sXG5cbiAgICBcdC8vIFRlbXBsYXRlIG1ldGhvZHMgZm9yIGRlcml2ZWQgY2xhc3NlczpcblxuICAgIFx0aW50ZXJwb2xhdGVfOiBmdW5jdGlvbiggaTEsIHQwLCB0LCB0MSApIHtcblxuICAgIFx0XHR0aHJvdyBuZXcgRXJyb3IoIFwiY2FsbCB0byBhYnN0cmFjdCBtZXRob2RcIiApO1xuICAgIFx0XHQvLyBpbXBsZW1lbnRhdGlvbnMgc2hhbGwgcmV0dXJuIHRoaXMucmVzdWx0QnVmZmVyXG5cbiAgICBcdH0sXG5cbiAgICBcdGludGVydmFsQ2hhbmdlZF86IGZ1bmN0aW9uKCBpMSwgdDAsIHQxICkge1xuXG4gICAgXHRcdC8vIGVtcHR5XG5cbiAgICBcdH1cblxuICAgIH07XG5cbiAgICBPYmplY3QuYXNzaWduKCBJbnRlcnBvbGFudC5wcm90b3R5cGUsIHtcblxuICAgIFx0YmVmb3JlU3RhcnRfOiAvLyggMCwgdCwgdDAgKSwgcmV0dXJucyB0aGlzLnJlc3VsdEJ1ZmZlclxuICAgIFx0XHRJbnRlcnBvbGFudC5wcm90b3R5cGUuY29weVNhbXBsZVZhbHVlXyxcblxuICAgIFx0YWZ0ZXJFbmRfOiAvLyggTi0xLCB0Ti0xLCB0ICksIHJldHVybnMgdGhpcy5yZXN1bHRCdWZmZXJcbiAgICBcdFx0SW50ZXJwb2xhbnQucHJvdG90eXBlLmNvcHlTYW1wbGVWYWx1ZV9cblxuICAgIH0gKTtcblxuICAgIC8qKlxuICAgICAqIEZhc3QgYW5kIHNpbXBsZSBjdWJpYyBzcGxpbmUgaW50ZXJwb2xhbnQuXG4gICAgICpcbiAgICAgKiBJdCB3YXMgZGVyaXZlZCBmcm9tIGEgSGVybWl0aWFuIGNvbnN0cnVjdGlvbiBzZXR0aW5nIHRoZSBmaXJzdCBkZXJpdmF0aXZlXG4gICAgICogYXQgZWFjaCBzYW1wbGUgcG9zaXRpb24gdG8gdGhlIGxpbmVhciBzbG9wZSBiZXR3ZWVuIG5laWdoYm9yaW5nIHBvc2l0aW9uc1xuICAgICAqIG92ZXIgdGhlaXIgcGFyYW1ldGVyIGludGVydmFsLlxuICAgICAqXG4gICAgICogQGF1dGhvciB0c2Nod1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gQ3ViaWNJbnRlcnBvbGFudChcbiAgICBcdFx0cGFyYW1ldGVyUG9zaXRpb25zLCBzYW1wbGVWYWx1ZXMsIHNhbXBsZVNpemUsIHJlc3VsdEJ1ZmZlciApIHtcblxuICAgIFx0SW50ZXJwb2xhbnQuY2FsbChcbiAgICBcdFx0XHR0aGlzLCBwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyICk7XG5cbiAgICBcdHRoaXMuX3dlaWdodFByZXYgPSAtMDtcbiAgICBcdHRoaXMuX29mZnNldFByZXYgPSAtMDtcbiAgICBcdHRoaXMuX3dlaWdodE5leHQgPSAtMDtcbiAgICBcdHRoaXMuX29mZnNldE5leHQgPSAtMDtcblxuICAgIH1cblxuICAgIEN1YmljSW50ZXJwb2xhbnQucHJvdG90eXBlID1cbiAgICBcdFx0T2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggSW50ZXJwb2xhbnQucHJvdG90eXBlICksIHtcblxuICAgIFx0Y29uc3RydWN0b3I6IEN1YmljSW50ZXJwb2xhbnQsXG5cbiAgICBcdERlZmF1bHRTZXR0aW5nc186IHtcblxuICAgIFx0XHRlbmRpbmdTdGFydDogXHRaZXJvQ3VydmF0dXJlRW5kaW5nLFxuICAgIFx0XHRlbmRpbmdFbmQ6XHRcdFplcm9DdXJ2YXR1cmVFbmRpbmdcblxuICAgIFx0fSxcblxuICAgIFx0aW50ZXJ2YWxDaGFuZ2VkXzogZnVuY3Rpb24oIGkxLCB0MCwgdDEgKSB7XG5cbiAgICBcdFx0dmFyIHBwID0gdGhpcy5wYXJhbWV0ZXJQb3NpdGlvbnMsXG4gICAgXHRcdFx0aVByZXYgPSBpMSAtIDIsXG4gICAgXHRcdFx0aU5leHQgPSBpMSArIDEsXG5cbiAgICBcdFx0XHR0UHJldiA9IHBwWyBpUHJldiBdLFxuICAgIFx0XHRcdHROZXh0ID0gcHBbIGlOZXh0IF07XG5cbiAgICBcdFx0aWYgKCB0UHJldiA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0c3dpdGNoICggdGhpcy5nZXRTZXR0aW5nc18oKS5lbmRpbmdTdGFydCApIHtcblxuICAgIFx0XHRcdFx0Y2FzZSBaZXJvU2xvcGVFbmRpbmc6XG5cbiAgICBcdFx0XHRcdFx0Ly8gZicodDApID0gMFxuICAgIFx0XHRcdFx0XHRpUHJldiA9IGkxO1xuICAgIFx0XHRcdFx0XHR0UHJldiA9IDIgKiB0MCAtIHQxO1xuXG4gICAgXHRcdFx0XHRcdGJyZWFrO1xuXG4gICAgXHRcdFx0XHRjYXNlIFdyYXBBcm91bmRFbmRpbmc6XG5cbiAgICBcdFx0XHRcdFx0Ly8gdXNlIHRoZSBvdGhlciBlbmQgb2YgdGhlIGN1cnZlXG4gICAgXHRcdFx0XHRcdGlQcmV2ID0gcHAubGVuZ3RoIC0gMjtcbiAgICBcdFx0XHRcdFx0dFByZXYgPSB0MCArIHBwWyBpUHJldiBdIC0gcHBbIGlQcmV2ICsgMSBdO1xuXG4gICAgXHRcdFx0XHRcdGJyZWFrO1xuXG4gICAgXHRcdFx0XHRkZWZhdWx0OiAvLyBaZXJvQ3VydmF0dXJlRW5kaW5nXG5cbiAgICBcdFx0XHRcdFx0Ly8gZicnKHQwKSA9IDAgYS5rLmEuIE5hdHVyYWwgU3BsaW5lXG4gICAgXHRcdFx0XHRcdGlQcmV2ID0gaTE7XG4gICAgXHRcdFx0XHRcdHRQcmV2ID0gdDE7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGlmICggdE5leHQgPT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdHN3aXRjaCAoIHRoaXMuZ2V0U2V0dGluZ3NfKCkuZW5kaW5nRW5kICkge1xuXG4gICAgXHRcdFx0XHRjYXNlIFplcm9TbG9wZUVuZGluZzpcblxuICAgIFx0XHRcdFx0XHQvLyBmJyh0TikgPSAwXG4gICAgXHRcdFx0XHRcdGlOZXh0ID0gaTE7XG4gICAgXHRcdFx0XHRcdHROZXh0ID0gMiAqIHQxIC0gdDA7XG5cbiAgICBcdFx0XHRcdFx0YnJlYWs7XG5cbiAgICBcdFx0XHRcdGNhc2UgV3JhcEFyb3VuZEVuZGluZzpcblxuICAgIFx0XHRcdFx0XHQvLyB1c2UgdGhlIG90aGVyIGVuZCBvZiB0aGUgY3VydmVcbiAgICBcdFx0XHRcdFx0aU5leHQgPSAxO1xuICAgIFx0XHRcdFx0XHR0TmV4dCA9IHQxICsgcHBbIDEgXSAtIHBwWyAwIF07XG5cbiAgICBcdFx0XHRcdFx0YnJlYWs7XG5cbiAgICBcdFx0XHRcdGRlZmF1bHQ6IC8vIFplcm9DdXJ2YXR1cmVFbmRpbmdcblxuICAgIFx0XHRcdFx0XHQvLyBmJycodE4pID0gMCwgYS5rLmEuIE5hdHVyYWwgU3BsaW5lXG4gICAgXHRcdFx0XHRcdGlOZXh0ID0gaTEgLSAxO1xuICAgIFx0XHRcdFx0XHR0TmV4dCA9IHQwO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHR2YXIgaGFsZkR0ID0gKCB0MSAtIHQwICkgKiAwLjUsXG4gICAgXHRcdFx0c3RyaWRlID0gdGhpcy52YWx1ZVNpemU7XG5cbiAgICBcdFx0dGhpcy5fd2VpZ2h0UHJldiA9IGhhbGZEdCAvICggdDAgLSB0UHJldiApO1xuICAgIFx0XHR0aGlzLl93ZWlnaHROZXh0ID0gaGFsZkR0IC8gKCB0TmV4dCAtIHQxICk7XG4gICAgXHRcdHRoaXMuX29mZnNldFByZXYgPSBpUHJldiAqIHN0cmlkZTtcbiAgICBcdFx0dGhpcy5fb2Zmc2V0TmV4dCA9IGlOZXh0ICogc3RyaWRlO1xuXG4gICAgXHR9LFxuXG4gICAgXHRpbnRlcnBvbGF0ZV86IGZ1bmN0aW9uKCBpMSwgdDAsIHQsIHQxICkge1xuXG4gICAgXHRcdHZhciByZXN1bHQgPSB0aGlzLnJlc3VsdEJ1ZmZlcixcbiAgICBcdFx0XHR2YWx1ZXMgPSB0aGlzLnNhbXBsZVZhbHVlcyxcbiAgICBcdFx0XHRzdHJpZGUgPSB0aGlzLnZhbHVlU2l6ZSxcblxuICAgIFx0XHRcdG8xID0gaTEgKiBzdHJpZGUsXHRcdG8wID0gbzEgLSBzdHJpZGUsXG4gICAgXHRcdFx0b1AgPSB0aGlzLl9vZmZzZXRQcmV2LCBcdG9OID0gdGhpcy5fb2Zmc2V0TmV4dCxcbiAgICBcdFx0XHR3UCA9IHRoaXMuX3dlaWdodFByZXYsXHR3TiA9IHRoaXMuX3dlaWdodE5leHQsXG5cbiAgICBcdFx0XHRwID0gKCB0IC0gdDAgKSAvICggdDEgLSB0MCApLFxuICAgIFx0XHRcdHBwID0gcCAqIHAsXG4gICAgXHRcdFx0cHBwID0gcHAgKiBwO1xuXG4gICAgXHRcdC8vIGV2YWx1YXRlIHBvbHlub21pYWxzXG5cbiAgICBcdFx0dmFyIHNQID0gICAgIC0gd1AgICAqIHBwcCAgICsgICAgICAgICAyICogd1AgICAgKiBwcCAgICAtICAgICAgICAgIHdQICAgKiBwO1xuICAgIFx0XHR2YXIgczAgPSAoIDEgKyB3UCApICogcHBwICAgKyAoLTEuNSAtIDIgKiB3UCApICAqIHBwICAgICsgKCAtMC41ICsgd1AgKSAqIHAgICAgICsgMTtcbiAgICBcdFx0dmFyIHMxID0gKC0xIC0gd04gKSAqIHBwcCAgICsgKCAxLjUgKyAgIHdOICAgKSAgKiBwcCAgICArICAgIDAuNSAgICAgICAgKiBwO1xuICAgIFx0XHR2YXIgc04gPSAgICAgICB3TiAgICogcHBwICAgLSAgICAgICAgICAgd04gICAgICAqIHBwO1xuXG4gICAgXHRcdC8vIGNvbWJpbmUgZGF0YSBsaW5lYXJseVxuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMDsgaSAhPT0gc3RyaWRlOyArKyBpICkge1xuXG4gICAgXHRcdFx0cmVzdWx0WyBpIF0gPVxuICAgIFx0XHRcdFx0XHRzUCAqIHZhbHVlc1sgb1AgKyBpIF0gK1xuICAgIFx0XHRcdFx0XHRzMCAqIHZhbHVlc1sgbzAgKyBpIF0gK1xuICAgIFx0XHRcdFx0XHRzMSAqIHZhbHVlc1sgbzEgKyBpIF0gK1xuICAgIFx0XHRcdFx0XHRzTiAqIHZhbHVlc1sgb04gKyBpIF07XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiByZXN1bHQ7XG5cbiAgICBcdH1cblxuICAgIH0gKTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgdHNjaHdcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIExpbmVhckludGVycG9sYW50KFxuICAgIFx0XHRwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyICkge1xuXG4gICAgXHRJbnRlcnBvbGFudC5jYWxsKFxuICAgIFx0XHRcdHRoaXMsIHBhcmFtZXRlclBvc2l0aW9ucywgc2FtcGxlVmFsdWVzLCBzYW1wbGVTaXplLCByZXN1bHRCdWZmZXIgKTtcblxuICAgIH1cblxuICAgIExpbmVhckludGVycG9sYW50LnByb3RvdHlwZSA9XG4gICAgXHRcdE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIEludGVycG9sYW50LnByb3RvdHlwZSApLCB7XG5cbiAgICBcdGNvbnN0cnVjdG9yOiBMaW5lYXJJbnRlcnBvbGFudCxcblxuICAgIFx0aW50ZXJwb2xhdGVfOiBmdW5jdGlvbiggaTEsIHQwLCB0LCB0MSApIHtcblxuICAgIFx0XHR2YXIgcmVzdWx0ID0gdGhpcy5yZXN1bHRCdWZmZXIsXG4gICAgXHRcdFx0dmFsdWVzID0gdGhpcy5zYW1wbGVWYWx1ZXMsXG4gICAgXHRcdFx0c3RyaWRlID0gdGhpcy52YWx1ZVNpemUsXG5cbiAgICBcdFx0XHRvZmZzZXQxID0gaTEgKiBzdHJpZGUsXG4gICAgXHRcdFx0b2Zmc2V0MCA9IG9mZnNldDEgLSBzdHJpZGUsXG5cbiAgICBcdFx0XHR3ZWlnaHQxID0gKCB0IC0gdDAgKSAvICggdDEgLSB0MCApLFxuICAgIFx0XHRcdHdlaWdodDAgPSAxIC0gd2VpZ2h0MTtcblxuICAgIFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgIT09IHN0cmlkZTsgKysgaSApIHtcblxuICAgIFx0XHRcdHJlc3VsdFsgaSBdID1cbiAgICBcdFx0XHRcdFx0dmFsdWVzWyBvZmZzZXQwICsgaSBdICogd2VpZ2h0MCArXG4gICAgXHRcdFx0XHRcdHZhbHVlc1sgb2Zmc2V0MSArIGkgXSAqIHdlaWdodDE7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiByZXN1bHQ7XG5cbiAgICBcdH1cblxuICAgIH0gKTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogSW50ZXJwb2xhbnQgdGhhdCBldmFsdWF0ZXMgdG8gdGhlIHNhbXBsZSB2YWx1ZSBhdCB0aGUgcG9zaXRpb24gcHJlY2VlZGluZ1xuICAgICAqIHRoZSBwYXJhbWV0ZXIuXG4gICAgICpcbiAgICAgKiBAYXV0aG9yIHRzY2h3XG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBEaXNjcmV0ZUludGVycG9sYW50KFxuICAgIFx0XHRwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyICkge1xuXG4gICAgXHRJbnRlcnBvbGFudC5jYWxsKFxuICAgIFx0XHRcdHRoaXMsIHBhcmFtZXRlclBvc2l0aW9ucywgc2FtcGxlVmFsdWVzLCBzYW1wbGVTaXplLCByZXN1bHRCdWZmZXIgKTtcblxuICAgIH1cblxuICAgIERpc2NyZXRlSW50ZXJwb2xhbnQucHJvdG90eXBlID1cbiAgICBcdFx0T2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggSW50ZXJwb2xhbnQucHJvdG90eXBlICksIHtcblxuICAgIFx0Y29uc3RydWN0b3I6IERpc2NyZXRlSW50ZXJwb2xhbnQsXG5cbiAgICBcdGludGVycG9sYXRlXzogZnVuY3Rpb24oIGkxLCB0MCwgdCwgdDEgKSB7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMuY29weVNhbXBsZVZhbHVlXyggaTEgLSAxICk7XG5cbiAgICBcdH1cblxuICAgIH0gKTtcblxuICAgIHZhciBLZXlmcmFtZVRyYWNrUHJvdG90eXBlO1xuXG4gICAgS2V5ZnJhbWVUcmFja1Byb3RvdHlwZSA9IHtcblxuICAgIFx0VGltZUJ1ZmZlclR5cGU6IEZsb2F0MzJBcnJheSxcbiAgICBcdFZhbHVlQnVmZmVyVHlwZTogRmxvYXQzMkFycmF5LFxuXG4gICAgXHREZWZhdWx0SW50ZXJwb2xhdGlvbjogSW50ZXJwb2xhdGVMaW5lYXIsXG5cbiAgICBcdEludGVycG9sYW50RmFjdG9yeU1ldGhvZERpc2NyZXRlOiBmdW5jdGlvbiggcmVzdWx0ICkge1xuXG4gICAgXHRcdHJldHVybiBuZXcgRGlzY3JldGVJbnRlcnBvbGFudChcbiAgICBcdFx0XHRcdHRoaXMudGltZXMsIHRoaXMudmFsdWVzLCB0aGlzLmdldFZhbHVlU2l6ZSgpLCByZXN1bHQgKTtcblxuICAgIFx0fSxcblxuICAgIFx0SW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kTGluZWFyOiBmdW5jdGlvbiggcmVzdWx0ICkge1xuXG4gICAgXHRcdHJldHVybiBuZXcgTGluZWFySW50ZXJwb2xhbnQoXG4gICAgXHRcdFx0XHR0aGlzLnRpbWVzLCB0aGlzLnZhbHVlcywgdGhpcy5nZXRWYWx1ZVNpemUoKSwgcmVzdWx0ICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdEludGVycG9sYW50RmFjdG9yeU1ldGhvZFNtb290aDogZnVuY3Rpb24oIHJlc3VsdCApIHtcblxuICAgIFx0XHRyZXR1cm4gbmV3IEN1YmljSW50ZXJwb2xhbnQoXG4gICAgXHRcdFx0XHR0aGlzLnRpbWVzLCB0aGlzLnZhbHVlcywgdGhpcy5nZXRWYWx1ZVNpemUoKSwgcmVzdWx0ICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldEludGVycG9sYXRpb246IGZ1bmN0aW9uKCBpbnRlcnBvbGF0aW9uICkge1xuXG4gICAgXHRcdHZhciBmYWN0b3J5TWV0aG9kO1xuXG4gICAgXHRcdHN3aXRjaCAoIGludGVycG9sYXRpb24gKSB7XG5cbiAgICBcdFx0XHRjYXNlIEludGVycG9sYXRlRGlzY3JldGU6XG5cbiAgICBcdFx0XHRcdGZhY3RvcnlNZXRob2QgPSB0aGlzLkludGVycG9sYW50RmFjdG9yeU1ldGhvZERpc2NyZXRlO1xuXG4gICAgXHRcdFx0XHRicmVhaztcblxuICAgIFx0XHRcdGNhc2UgSW50ZXJwb2xhdGVMaW5lYXI6XG5cbiAgICBcdFx0XHRcdGZhY3RvcnlNZXRob2QgPSB0aGlzLkludGVycG9sYW50RmFjdG9yeU1ldGhvZExpbmVhcjtcblxuICAgIFx0XHRcdFx0YnJlYWs7XG5cbiAgICBcdFx0XHRjYXNlIEludGVycG9sYXRlU21vb3RoOlxuXG4gICAgXHRcdFx0XHRmYWN0b3J5TWV0aG9kID0gdGhpcy5JbnRlcnBvbGFudEZhY3RvcnlNZXRob2RTbW9vdGg7XG5cbiAgICBcdFx0XHRcdGJyZWFrO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoIGZhY3RvcnlNZXRob2QgPT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdHZhciBtZXNzYWdlID0gXCJ1bnN1cHBvcnRlZCBpbnRlcnBvbGF0aW9uIGZvciBcIiArXG4gICAgXHRcdFx0XHRcdHRoaXMuVmFsdWVUeXBlTmFtZSArIFwiIGtleWZyYW1lIHRyYWNrIG5hbWVkIFwiICsgdGhpcy5uYW1lO1xuXG4gICAgXHRcdFx0aWYgKCB0aGlzLmNyZWF0ZUludGVycG9sYW50ID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRcdC8vIGZhbGwgYmFjayB0byBkZWZhdWx0LCB1bmxlc3MgdGhlIGRlZmF1bHQgaXRzZWxmIGlzIG1lc3NlZCB1cFxuICAgIFx0XHRcdFx0aWYgKCBpbnRlcnBvbGF0aW9uICE9PSB0aGlzLkRlZmF1bHRJbnRlcnBvbGF0aW9uICkge1xuXG4gICAgXHRcdFx0XHRcdHRoaXMuc2V0SW50ZXJwb2xhdGlvbiggdGhpcy5EZWZhdWx0SW50ZXJwb2xhdGlvbiApO1xuXG4gICAgXHRcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggbWVzc2FnZSApOyAvLyBmYXRhbCwgaW4gdGhpcyBjYXNlXG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGNvbnNvbGUud2FybiggbWVzc2FnZSApO1xuICAgIFx0XHRcdHJldHVybjtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0dGhpcy5jcmVhdGVJbnRlcnBvbGFudCA9IGZhY3RvcnlNZXRob2Q7XG5cbiAgICBcdH0sXG5cbiAgICBcdGdldEludGVycG9sYXRpb246IGZ1bmN0aW9uKCkge1xuXG4gICAgXHRcdHN3aXRjaCAoIHRoaXMuY3JlYXRlSW50ZXJwb2xhbnQgKSB7XG5cbiAgICBcdFx0XHRjYXNlIHRoaXMuSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kRGlzY3JldGU6XG5cbiAgICBcdFx0XHRcdHJldHVybiBJbnRlcnBvbGF0ZURpc2NyZXRlO1xuXG4gICAgXHRcdFx0Y2FzZSB0aGlzLkludGVycG9sYW50RmFjdG9yeU1ldGhvZExpbmVhcjpcblxuICAgIFx0XHRcdFx0cmV0dXJuIEludGVycG9sYXRlTGluZWFyO1xuXG4gICAgXHRcdFx0Y2FzZSB0aGlzLkludGVycG9sYW50RmFjdG9yeU1ldGhvZFNtb290aDpcblxuICAgIFx0XHRcdFx0cmV0dXJuIEludGVycG9sYXRlU21vb3RoO1xuXG4gICAgXHRcdH1cblxuICAgIFx0fSxcblxuICAgIFx0Z2V0VmFsdWVTaXplOiBmdW5jdGlvbigpIHtcblxuICAgIFx0XHRyZXR1cm4gdGhpcy52YWx1ZXMubGVuZ3RoIC8gdGhpcy50aW1lcy5sZW5ndGg7XG5cbiAgICBcdH0sXG5cbiAgICBcdC8vIG1vdmUgYWxsIGtleWZyYW1lcyBlaXRoZXIgZm9yd2FyZHMgb3IgYmFja3dhcmRzIGluIHRpbWVcbiAgICBcdHNoaWZ0OiBmdW5jdGlvbiggdGltZU9mZnNldCApIHtcblxuICAgIFx0XHRpZiggdGltZU9mZnNldCAhPT0gMC4wICkge1xuXG4gICAgXHRcdFx0dmFyIHRpbWVzID0gdGhpcy50aW1lcztcblxuICAgIFx0XHRcdGZvciggdmFyIGkgPSAwLCBuID0gdGltZXMubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xuXG4gICAgXHRcdFx0XHR0aW1lc1sgaSBdICs9IHRpbWVPZmZzZXQ7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHQvLyBzY2FsZSBhbGwga2V5ZnJhbWUgdGltZXMgYnkgYSBmYWN0b3IgKHVzZWZ1bCBmb3IgZnJhbWUgPC0+IHNlY29uZHMgY29udmVyc2lvbnMpXG4gICAgXHRzY2FsZTogZnVuY3Rpb24oIHRpbWVTY2FsZSApIHtcblxuICAgIFx0XHRpZiggdGltZVNjYWxlICE9PSAxLjAgKSB7XG5cbiAgICBcdFx0XHR2YXIgdGltZXMgPSB0aGlzLnRpbWVzO1xuXG4gICAgXHRcdFx0Zm9yKCB2YXIgaSA9IDAsIG4gPSB0aW1lcy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cbiAgICBcdFx0XHRcdHRpbWVzWyBpIF0gKj0gdGltZVNjYWxlO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0Ly8gcmVtb3ZlcyBrZXlmcmFtZXMgYmVmb3JlIGFuZCBhZnRlciBhbmltYXRpb24gd2l0aG91dCBjaGFuZ2luZyBhbnkgdmFsdWVzIHdpdGhpbiB0aGUgcmFuZ2UgW3N0YXJ0VGltZSwgZW5kVGltZV0uXG4gICAgXHQvLyBJTVBPUlRBTlQ6IFdlIGRvIG5vdCBzaGlmdCBhcm91bmQga2V5cyB0byB0aGUgc3RhcnQgb2YgdGhlIHRyYWNrIHRpbWUsIGJlY2F1c2UgZm9yIGludGVycG9sYXRlZCBrZXlzIHRoaXMgd2lsbCBjaGFuZ2UgdGhlaXIgdmFsdWVzXG4gICAgXHR0cmltOiBmdW5jdGlvbiggc3RhcnRUaW1lLCBlbmRUaW1lICkge1xuXG4gICAgXHRcdHZhciB0aW1lcyA9IHRoaXMudGltZXMsXG4gICAgXHRcdFx0bktleXMgPSB0aW1lcy5sZW5ndGgsXG4gICAgXHRcdFx0ZnJvbSA9IDAsXG4gICAgXHRcdFx0dG8gPSBuS2V5cyAtIDE7XG5cbiAgICBcdFx0d2hpbGUgKCBmcm9tICE9PSBuS2V5cyAmJiB0aW1lc1sgZnJvbSBdIDwgc3RhcnRUaW1lICkgKysgZnJvbTtcbiAgICBcdFx0d2hpbGUgKCB0byAhPT0gLTEgJiYgdGltZXNbIHRvIF0gPiBlbmRUaW1lICkgLS0gdG87XG5cbiAgICBcdFx0KysgdG87IC8vIGluY2x1c2l2ZSAtPiBleGNsdXNpdmUgYm91bmRcblxuICAgIFx0XHRpZiggZnJvbSAhPT0gMCB8fCB0byAhPT0gbktleXMgKSB7XG5cbiAgICBcdFx0XHQvLyBlbXB0eSB0cmFja3MgYXJlIGZvcmJpZGRlbiwgc28ga2VlcCBhdCBsZWFzdCBvbmUga2V5ZnJhbWVcbiAgICBcdFx0XHRpZiAoIGZyb20gPj0gdG8gKSB0byA9IE1hdGgubWF4KCB0byAsIDEgKSwgZnJvbSA9IHRvIC0gMTtcblxuICAgIFx0XHRcdHZhciBzdHJpZGUgPSB0aGlzLmdldFZhbHVlU2l6ZSgpO1xuICAgIFx0XHRcdHRoaXMudGltZXMgPSBleHBvcnRzLkFuaW1hdGlvblV0aWxzLmFycmF5U2xpY2UoIHRpbWVzLCBmcm9tLCB0byApO1xuICAgIFx0XHRcdHRoaXMudmFsdWVzID0gZXhwb3J0cy5BbmltYXRpb25VdGlscy5cbiAgICBcdFx0XHRcdFx0YXJyYXlTbGljZSggdGhpcy52YWx1ZXMsIGZyb20gKiBzdHJpZGUsIHRvICogc3RyaWRlICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHQvLyBlbnN1cmUgd2UgZG8gbm90IGdldCBhIEdhcmJhZ2VJbkdhcmJhZ2VPdXQgc2l0dWF0aW9uLCBtYWtlIHN1cmUgdHJhY2tzIGFyZSBhdCBsZWFzdCBtaW5pbWFsbHkgdmlhYmxlXG4gICAgXHR2YWxpZGF0ZTogZnVuY3Rpb24oKSB7XG5cbiAgICBcdFx0dmFyIHZhbGlkID0gdHJ1ZTtcblxuICAgIFx0XHR2YXIgdmFsdWVTaXplID0gdGhpcy5nZXRWYWx1ZVNpemUoKTtcbiAgICBcdFx0aWYgKCB2YWx1ZVNpemUgLSBNYXRoLmZsb29yKCB2YWx1ZVNpemUgKSAhPT0gMCApIHtcblxuICAgIFx0XHRcdGNvbnNvbGUuZXJyb3IoIFwiaW52YWxpZCB2YWx1ZSBzaXplIGluIHRyYWNrXCIsIHRoaXMgKTtcbiAgICBcdFx0XHR2YWxpZCA9IGZhbHNlO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHR2YXIgdGltZXMgPSB0aGlzLnRpbWVzLFxuICAgIFx0XHRcdHZhbHVlcyA9IHRoaXMudmFsdWVzLFxuXG4gICAgXHRcdFx0bktleXMgPSB0aW1lcy5sZW5ndGg7XG5cbiAgICBcdFx0aWYoIG5LZXlzID09PSAwICkge1xuXG4gICAgXHRcdFx0Y29uc29sZS5lcnJvciggXCJ0cmFjayBpcyBlbXB0eVwiLCB0aGlzICk7XG4gICAgXHRcdFx0dmFsaWQgPSBmYWxzZTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0dmFyIHByZXZUaW1lID0gbnVsbDtcblxuICAgIFx0XHRmb3IoIHZhciBpID0gMDsgaSAhPT0gbktleXM7IGkgKysgKSB7XG5cbiAgICBcdFx0XHR2YXIgY3VyclRpbWUgPSB0aW1lc1sgaSBdO1xuXG4gICAgXHRcdFx0aWYgKCB0eXBlb2YgY3VyclRpbWUgPT09ICdudW1iZXInICYmIGlzTmFOKCBjdXJyVGltZSApICkge1xuXG4gICAgXHRcdFx0XHRjb25zb2xlLmVycm9yKCBcInRpbWUgaXMgbm90IGEgdmFsaWQgbnVtYmVyXCIsIHRoaXMsIGksIGN1cnJUaW1lICk7XG4gICAgXHRcdFx0XHR2YWxpZCA9IGZhbHNlO1xuICAgIFx0XHRcdFx0YnJlYWs7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRpZiggcHJldlRpbWUgIT09IG51bGwgJiYgcHJldlRpbWUgPiBjdXJyVGltZSApIHtcblxuICAgIFx0XHRcdFx0Y29uc29sZS5lcnJvciggXCJvdXQgb2Ygb3JkZXIga2V5c1wiLCB0aGlzLCBpLCBjdXJyVGltZSwgcHJldlRpbWUgKTtcbiAgICBcdFx0XHRcdHZhbGlkID0gZmFsc2U7XG4gICAgXHRcdFx0XHRicmVhaztcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdHByZXZUaW1lID0gY3VyclRpbWU7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGlmICggdmFsdWVzICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRpZiAoIGV4cG9ydHMuQW5pbWF0aW9uVXRpbHMuaXNUeXBlZEFycmF5KCB2YWx1ZXMgKSApIHtcblxuICAgIFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBuID0gdmFsdWVzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcblxuICAgIFx0XHRcdFx0XHR2YXIgdmFsdWUgPSB2YWx1ZXNbIGkgXTtcblxuICAgIFx0XHRcdFx0XHRpZiAoIGlzTmFOKCB2YWx1ZSApICkge1xuXG4gICAgXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvciggXCJ2YWx1ZSBpcyBub3QgYSB2YWxpZCBudW1iZXJcIiwgdGhpcywgaSwgdmFsdWUgKTtcbiAgICBcdFx0XHRcdFx0XHR2YWxpZCA9IGZhbHNlO1xuICAgIFx0XHRcdFx0XHRcdGJyZWFrO1xuXG4gICAgXHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gdmFsaWQ7XG5cbiAgICBcdH0sXG5cbiAgICBcdC8vIHJlbW92ZXMgZXF1aXZhbGVudCBzZXF1ZW50aWFsIGtleXMgYXMgY29tbW9uIGluIG1vcnBoIHRhcmdldCBzZXF1ZW5jZXNcbiAgICBcdC8vICgwLDAsMCwwLDEsMSwxLDAsMCwwLDAsMCwwLDApIC0tPiAoMCwwLDEsMSwwLDApXG4gICAgXHRvcHRpbWl6ZTogZnVuY3Rpb24oKSB7XG5cbiAgICBcdFx0dmFyIHRpbWVzID0gdGhpcy50aW1lcyxcbiAgICBcdFx0XHR2YWx1ZXMgPSB0aGlzLnZhbHVlcyxcbiAgICBcdFx0XHRzdHJpZGUgPSB0aGlzLmdldFZhbHVlU2l6ZSgpLFxuXG4gICAgXHRcdFx0c21vb3RoSW50ZXJwb2xhdGlvbiA9IHRoaXMuZ2V0SW50ZXJwb2xhdGlvbigpID09PSBJbnRlcnBvbGF0ZVNtb290aCxcblxuICAgIFx0XHRcdHdyaXRlSW5kZXggPSAxLFxuICAgIFx0XHRcdGxhc3RJbmRleCA9IHRpbWVzLmxlbmd0aCAtIDE7XG5cbiAgICBcdFx0Zm9yKCB2YXIgaSA9IDE7IGkgPCBsYXN0SW5kZXg7ICsrIGkgKSB7XG5cbiAgICBcdFx0XHR2YXIga2VlcCA9IGZhbHNlO1xuXG4gICAgXHRcdFx0dmFyIHRpbWUgPSB0aW1lc1sgaSBdO1xuICAgIFx0XHRcdHZhciB0aW1lTmV4dCA9IHRpbWVzWyBpICsgMSBdO1xuXG4gICAgXHRcdFx0Ly8gcmVtb3ZlIGFkamFjZW50IGtleWZyYW1lcyBzY2hlZHVsZWQgYXQgdGhlIHNhbWUgdGltZVxuXG4gICAgXHRcdFx0aWYgKCB0aW1lICE9PSB0aW1lTmV4dCAmJiAoIGkgIT09IDEgfHwgdGltZSAhPT0gdGltZVsgMCBdICkgKSB7XG5cbiAgICBcdFx0XHRcdGlmICggISBzbW9vdGhJbnRlcnBvbGF0aW9uICkge1xuXG4gICAgXHRcdFx0XHRcdC8vIHJlbW92ZSB1bm5lY2Vzc2FyeSBrZXlmcmFtZXMgc2FtZSBhcyB0aGVpciBuZWlnaGJvcnNcblxuICAgIFx0XHRcdFx0XHR2YXIgb2Zmc2V0ID0gaSAqIHN0cmlkZSxcbiAgICBcdFx0XHRcdFx0XHRvZmZzZXRQID0gb2Zmc2V0IC0gc3RyaWRlLFxuICAgIFx0XHRcdFx0XHRcdG9mZnNldE4gPSBvZmZzZXQgKyBzdHJpZGU7XG5cbiAgICBcdFx0XHRcdFx0Zm9yICggdmFyIGogPSAwOyBqICE9PSBzdHJpZGU7ICsrIGogKSB7XG5cbiAgICBcdFx0XHRcdFx0XHR2YXIgdmFsdWUgPSB2YWx1ZXNbIG9mZnNldCArIGogXTtcblxuICAgIFx0XHRcdFx0XHRcdGlmICggdmFsdWUgIT09IHZhbHVlc1sgb2Zmc2V0UCArIGogXSB8fFxuICAgIFx0XHRcdFx0XHRcdFx0XHR2YWx1ZSAhPT0gdmFsdWVzWyBvZmZzZXROICsgaiBdICkge1xuXG4gICAgXHRcdFx0XHRcdFx0XHRrZWVwID0gdHJ1ZTtcbiAgICBcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG4gICAgXHRcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0fSBlbHNlIGtlZXAgPSB0cnVlO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0Ly8gaW4tcGxhY2UgY29tcGFjdGlvblxuXG4gICAgXHRcdFx0aWYgKCBrZWVwICkge1xuXG4gICAgXHRcdFx0XHRpZiAoIGkgIT09IHdyaXRlSW5kZXggKSB7XG5cbiAgICBcdFx0XHRcdFx0dGltZXNbIHdyaXRlSW5kZXggXSA9IHRpbWVzWyBpIF07XG5cbiAgICBcdFx0XHRcdFx0dmFyIHJlYWRPZmZzZXQgPSBpICogc3RyaWRlLFxuICAgIFx0XHRcdFx0XHRcdHdyaXRlT2Zmc2V0ID0gd3JpdGVJbmRleCAqIHN0cmlkZTtcblxuICAgIFx0XHRcdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogIT09IHN0cmlkZTsgKysgaiApXG5cbiAgICBcdFx0XHRcdFx0XHR2YWx1ZXNbIHdyaXRlT2Zmc2V0ICsgaiBdID0gdmFsdWVzWyByZWFkT2Zmc2V0ICsgaiBdO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdCsrIHdyaXRlSW5kZXg7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdC8vIGZsdXNoIGxhc3Qga2V5ZnJhbWUgKGNvbXBhY3Rpb24gbG9va3MgYWhlYWQpXG5cbiAgICBcdFx0aWYgKCBsYXN0SW5kZXggPiAwICkge1xuXG4gICAgXHRcdFx0dGltZXNbIHdyaXRlSW5kZXggXSA9IHRpbWVzWyBsYXN0SW5kZXggXTtcblxuICAgIFx0XHRcdGZvciAoIHZhciByZWFkT2Zmc2V0ID0gbGFzdEluZGV4ICogc3RyaWRlLCB3cml0ZU9mZnNldCA9IHdyaXRlSW5kZXggKiBzdHJpZGUsIGogPSAwOyBqICE9PSBzdHJpZGU7ICsrIGogKVxuXG4gICAgXHRcdFx0XHR2YWx1ZXNbIHdyaXRlT2Zmc2V0ICsgaiBdID0gdmFsdWVzWyByZWFkT2Zmc2V0ICsgaiBdO1xuXG4gICAgXHRcdFx0Kysgd3JpdGVJbmRleDtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKCB3cml0ZUluZGV4ICE9PSB0aW1lcy5sZW5ndGggKSB7XG5cbiAgICBcdFx0XHR0aGlzLnRpbWVzID0gZXhwb3J0cy5BbmltYXRpb25VdGlscy5hcnJheVNsaWNlKCB0aW1lcywgMCwgd3JpdGVJbmRleCApO1xuICAgIFx0XHRcdHRoaXMudmFsdWVzID0gZXhwb3J0cy5BbmltYXRpb25VdGlscy5hcnJheVNsaWNlKCB2YWx1ZXMsIDAsIHdyaXRlSW5kZXggKiBzdHJpZGUgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH1cblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIEtleWZyYW1lVHJhY2tDb25zdHJ1Y3RvciggbmFtZSwgdGltZXMsIHZhbHVlcywgaW50ZXJwb2xhdGlvbiApIHtcblxuICAgIFx0aWYoIG5hbWUgPT09IHVuZGVmaW5lZCApIHRocm93IG5ldyBFcnJvciggXCJ0cmFjayBuYW1lIGlzIHVuZGVmaW5lZFwiICk7XG5cbiAgICBcdGlmKCB0aW1lcyA9PT0gdW5kZWZpbmVkIHx8IHRpbWVzLmxlbmd0aCA9PT0gMCApIHtcblxuICAgIFx0XHR0aHJvdyBuZXcgRXJyb3IoIFwibm8ga2V5ZnJhbWVzIGluIHRyYWNrIG5hbWVkIFwiICsgbmFtZSApO1xuXG4gICAgXHR9XG5cbiAgICBcdHRoaXMubmFtZSA9IG5hbWU7XG5cbiAgICBcdHRoaXMudGltZXMgPSBleHBvcnRzLkFuaW1hdGlvblV0aWxzLmNvbnZlcnRBcnJheSggdGltZXMsIHRoaXMuVGltZUJ1ZmZlclR5cGUgKTtcbiAgICBcdHRoaXMudmFsdWVzID0gZXhwb3J0cy5BbmltYXRpb25VdGlscy5jb252ZXJ0QXJyYXkoIHZhbHVlcywgdGhpcy5WYWx1ZUJ1ZmZlclR5cGUgKTtcblxuICAgIFx0dGhpcy5zZXRJbnRlcnBvbGF0aW9uKCBpbnRlcnBvbGF0aW9uIHx8IHRoaXMuRGVmYXVsdEludGVycG9sYXRpb24gKTtcblxuICAgIFx0dGhpcy52YWxpZGF0ZSgpO1xuICAgIFx0dGhpcy5vcHRpbWl6ZSgpO1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBBIFRyYWNrIG9mIHZlY3RvcmVkIGtleWZyYW1lIHZhbHVlcy5cbiAgICAgKlxuICAgICAqXG4gICAgICogQGF1dGhvciBCZW4gSG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pby9cbiAgICAgKiBAYXV0aG9yIERhdmlkIFNhcm5vIC8gaHR0cDovL2xpZ2h0aGF1cy51cy9cbiAgICAgKiBAYXV0aG9yIHRzY2h3XG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBWZWN0b3JLZXlmcmFtZVRyYWNrKCBuYW1lLCB0aW1lcywgdmFsdWVzLCBpbnRlcnBvbGF0aW9uICkge1xuXG4gICAgXHRLZXlmcmFtZVRyYWNrQ29uc3RydWN0b3IuY2FsbCggdGhpcywgbmFtZSwgdGltZXMsIHZhbHVlcywgaW50ZXJwb2xhdGlvbiApO1xuXG4gICAgfVxuXG4gICAgVmVjdG9yS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUgPVxuICAgIFx0XHRPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBLZXlmcmFtZVRyYWNrUHJvdG90eXBlICksIHtcblxuICAgIFx0Y29uc3RydWN0b3I6IFZlY3RvcktleWZyYW1lVHJhY2ssXG5cbiAgICBcdFZhbHVlVHlwZU5hbWU6ICd2ZWN0b3InXG5cbiAgICBcdC8vIFZhbHVlQnVmZmVyVHlwZSBpcyBpbmhlcml0ZWRcblxuICAgIFx0Ly8gRGVmYXVsdEludGVycG9sYXRpb24gaXMgaW5oZXJpdGVkXG5cbiAgICB9ICk7XG5cbiAgICAvKipcbiAgICAgKiBTcGhlcmljYWwgbGluZWFyIHVuaXQgcXVhdGVybmlvbiBpbnRlcnBvbGFudC5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgdHNjaHdcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIFF1YXRlcm5pb25MaW5lYXJJbnRlcnBvbGFudChcbiAgICBcdFx0cGFyYW1ldGVyUG9zaXRpb25zLCBzYW1wbGVWYWx1ZXMsIHNhbXBsZVNpemUsIHJlc3VsdEJ1ZmZlciApIHtcblxuICAgIFx0SW50ZXJwb2xhbnQuY2FsbChcbiAgICBcdFx0XHR0aGlzLCBwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyICk7XG5cbiAgICB9XG5cbiAgICBRdWF0ZXJuaW9uTGluZWFySW50ZXJwb2xhbnQucHJvdG90eXBlID1cbiAgICBcdFx0T2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggSW50ZXJwb2xhbnQucHJvdG90eXBlICksIHtcblxuICAgIFx0Y29uc3RydWN0b3I6IFF1YXRlcm5pb25MaW5lYXJJbnRlcnBvbGFudCxcblxuICAgIFx0aW50ZXJwb2xhdGVfOiBmdW5jdGlvbiggaTEsIHQwLCB0LCB0MSApIHtcblxuICAgIFx0XHR2YXIgcmVzdWx0ID0gdGhpcy5yZXN1bHRCdWZmZXIsXG4gICAgXHRcdFx0dmFsdWVzID0gdGhpcy5zYW1wbGVWYWx1ZXMsXG4gICAgXHRcdFx0c3RyaWRlID0gdGhpcy52YWx1ZVNpemUsXG5cbiAgICBcdFx0XHRvZmZzZXQgPSBpMSAqIHN0cmlkZSxcblxuICAgIFx0XHRcdGFscGhhID0gKCB0IC0gdDAgKSAvICggdDEgLSB0MCApO1xuXG4gICAgXHRcdGZvciAoIHZhciBlbmQgPSBvZmZzZXQgKyBzdHJpZGU7IG9mZnNldCAhPT0gZW5kOyBvZmZzZXQgKz0gNCApIHtcblxuICAgIFx0XHRcdFF1YXRlcm5pb24uc2xlcnBGbGF0KCByZXN1bHQsIDAsXG4gICAgXHRcdFx0XHRcdHZhbHVlcywgb2Zmc2V0IC0gc3RyaWRlLCB2YWx1ZXMsIG9mZnNldCwgYWxwaGEgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIHJlc3VsdDtcblxuICAgIFx0fVxuXG4gICAgfSApO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBBIFRyYWNrIG9mIHF1YXRlcm5pb24ga2V5ZnJhbWUgdmFsdWVzLlxuICAgICAqXG4gICAgICogQGF1dGhvciBCZW4gSG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pby9cbiAgICAgKiBAYXV0aG9yIERhdmlkIFNhcm5vIC8gaHR0cDovL2xpZ2h0aGF1cy51cy9cbiAgICAgKiBAYXV0aG9yIHRzY2h3XG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBRdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjayggbmFtZSwgdGltZXMsIHZhbHVlcywgaW50ZXJwb2xhdGlvbiApIHtcblxuICAgIFx0S2V5ZnJhbWVUcmFja0NvbnN0cnVjdG9yLmNhbGwoIHRoaXMsIG5hbWUsIHRpbWVzLCB2YWx1ZXMsIGludGVycG9sYXRpb24gKTtcblxuICAgIH1cblxuICAgIFF1YXRlcm5pb25LZXlmcmFtZVRyYWNrLnByb3RvdHlwZSA9XG4gICAgXHRcdE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIEtleWZyYW1lVHJhY2tQcm90b3R5cGUgKSwge1xuXG4gICAgXHRjb25zdHJ1Y3RvcjogUXVhdGVybmlvbktleWZyYW1lVHJhY2ssXG5cbiAgICBcdFZhbHVlVHlwZU5hbWU6ICdxdWF0ZXJuaW9uJyxcblxuICAgIFx0Ly8gVmFsdWVCdWZmZXJUeXBlIGlzIGluaGVyaXRlZFxuXG4gICAgXHREZWZhdWx0SW50ZXJwb2xhdGlvbjogSW50ZXJwb2xhdGVMaW5lYXIsXG5cbiAgICBcdEludGVycG9sYW50RmFjdG9yeU1ldGhvZExpbmVhcjogZnVuY3Rpb24oIHJlc3VsdCApIHtcblxuICAgIFx0XHRyZXR1cm4gbmV3IFF1YXRlcm5pb25MaW5lYXJJbnRlcnBvbGFudChcbiAgICBcdFx0XHRcdHRoaXMudGltZXMsIHRoaXMudmFsdWVzLCB0aGlzLmdldFZhbHVlU2l6ZSgpLCByZXN1bHQgKTtcblxuICAgIFx0fSxcblxuICAgIFx0SW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kU21vb3RoOiB1bmRlZmluZWQgLy8gbm90IHlldCBpbXBsZW1lbnRlZFxuXG4gICAgfSApO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBBIFRyYWNrIG9mIG51bWVyaWMga2V5ZnJhbWUgdmFsdWVzLlxuICAgICAqXG4gICAgICogQGF1dGhvciBCZW4gSG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pby9cbiAgICAgKiBAYXV0aG9yIERhdmlkIFNhcm5vIC8gaHR0cDovL2xpZ2h0aGF1cy51cy9cbiAgICAgKiBAYXV0aG9yIHRzY2h3XG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBOdW1iZXJLZXlmcmFtZVRyYWNrKCBuYW1lLCB0aW1lcywgdmFsdWVzLCBpbnRlcnBvbGF0aW9uICkge1xuXG4gICAgXHRLZXlmcmFtZVRyYWNrQ29uc3RydWN0b3IuY2FsbCggdGhpcywgbmFtZSwgdGltZXMsIHZhbHVlcywgaW50ZXJwb2xhdGlvbiApO1xuXG4gICAgfVxuXG4gICAgTnVtYmVyS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUgPVxuICAgIFx0XHRPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBLZXlmcmFtZVRyYWNrUHJvdG90eXBlICksIHtcblxuICAgIFx0Y29uc3RydWN0b3I6IE51bWJlcktleWZyYW1lVHJhY2ssXG5cbiAgICBcdFZhbHVlVHlwZU5hbWU6ICdudW1iZXInLFxuXG4gICAgXHQvLyBWYWx1ZUJ1ZmZlclR5cGUgaXMgaW5oZXJpdGVkXG5cbiAgICBcdC8vIERlZmF1bHRJbnRlcnBvbGF0aW9uIGlzIGluaGVyaXRlZFxuXG4gICAgfSApO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBBIFRyYWNrIHRoYXQgaW50ZXJwb2xhdGVzIFN0cmluZ3NcbiAgICAgKlxuICAgICAqXG4gICAgICogQGF1dGhvciBCZW4gSG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pby9cbiAgICAgKiBAYXV0aG9yIERhdmlkIFNhcm5vIC8gaHR0cDovL2xpZ2h0aGF1cy51cy9cbiAgICAgKiBAYXV0aG9yIHRzY2h3XG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBTdHJpbmdLZXlmcmFtZVRyYWNrKCBuYW1lLCB0aW1lcywgdmFsdWVzLCBpbnRlcnBvbGF0aW9uICkge1xuXG4gICAgXHRLZXlmcmFtZVRyYWNrQ29uc3RydWN0b3IuY2FsbCggdGhpcywgbmFtZSwgdGltZXMsIHZhbHVlcywgaW50ZXJwb2xhdGlvbiApO1xuXG4gICAgfVxuXG4gICAgU3RyaW5nS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUgPVxuICAgIFx0XHRPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBLZXlmcmFtZVRyYWNrUHJvdG90eXBlICksIHtcblxuICAgIFx0Y29uc3RydWN0b3I6IFN0cmluZ0tleWZyYW1lVHJhY2ssXG5cbiAgICBcdFZhbHVlVHlwZU5hbWU6ICdzdHJpbmcnLFxuICAgIFx0VmFsdWVCdWZmZXJUeXBlOiBBcnJheSxcblxuICAgIFx0RGVmYXVsdEludGVycG9sYXRpb246IEludGVycG9sYXRlRGlzY3JldGUsXG5cbiAgICBcdEludGVycG9sYW50RmFjdG9yeU1ldGhvZExpbmVhcjogdW5kZWZpbmVkLFxuXG4gICAgXHRJbnRlcnBvbGFudEZhY3RvcnlNZXRob2RTbW9vdGg6IHVuZGVmaW5lZFxuXG4gICAgfSApO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBBIFRyYWNrIG9mIEJvb2xlYW4ga2V5ZnJhbWUgdmFsdWVzLlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAYXV0aG9yIEJlbiBIb3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvL1xuICAgICAqIEBhdXRob3IgRGF2aWQgU2Fybm8gLyBodHRwOi8vbGlnaHRoYXVzLnVzL1xuICAgICAqIEBhdXRob3IgdHNjaHdcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIEJvb2xlYW5LZXlmcmFtZVRyYWNrKCBuYW1lLCB0aW1lcywgdmFsdWVzICkge1xuXG4gICAgXHRLZXlmcmFtZVRyYWNrQ29uc3RydWN0b3IuY2FsbCggdGhpcywgbmFtZSwgdGltZXMsIHZhbHVlcyApO1xuXG4gICAgfVxuXG4gICAgQm9vbGVhbktleWZyYW1lVHJhY2sucHJvdG90eXBlID1cbiAgICBcdFx0T2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggS2V5ZnJhbWVUcmFja1Byb3RvdHlwZSApLCB7XG5cbiAgICBcdGNvbnN0cnVjdG9yOiBCb29sZWFuS2V5ZnJhbWVUcmFjayxcblxuICAgIFx0VmFsdWVUeXBlTmFtZTogJ2Jvb2wnLFxuICAgIFx0VmFsdWVCdWZmZXJUeXBlOiBBcnJheSxcblxuICAgIFx0RGVmYXVsdEludGVycG9sYXRpb246IEludGVycG9sYXRlRGlzY3JldGUsXG5cbiAgICBcdEludGVycG9sYW50RmFjdG9yeU1ldGhvZExpbmVhcjogdW5kZWZpbmVkLFxuICAgIFx0SW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kU21vb3RoOiB1bmRlZmluZWRcblxuICAgIFx0Ly8gTm90ZTogQWN0dWFsbHkgdGhpcyB0cmFjayBjb3VsZCBoYXZlIGEgb3B0aW1pemVkIC8gY29tcHJlc3NlZFxuICAgIFx0Ly8gcmVwcmVzZW50YXRpb24gb2YgYSBzaW5nbGUgdmFsdWUgYW5kIGEgY3VzdG9tIGludGVycG9sYW50IHRoYXRcbiAgICBcdC8vIGNvbXB1dGVzIFwiZmlyc3RWYWx1ZSBeIGlzT2RkKCBpbmRleCApXCIuXG5cbiAgICB9ICk7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEEgVHJhY2sgb2Yga2V5ZnJhbWUgdmFsdWVzIHRoYXQgcmVwcmVzZW50IGNvbG9yLlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAYXV0aG9yIEJlbiBIb3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvL1xuICAgICAqIEBhdXRob3IgRGF2aWQgU2Fybm8gLyBodHRwOi8vbGlnaHRoYXVzLnVzL1xuICAgICAqIEBhdXRob3IgdHNjaHdcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIENvbG9yS2V5ZnJhbWVUcmFjayggbmFtZSwgdGltZXMsIHZhbHVlcywgaW50ZXJwb2xhdGlvbiApIHtcblxuICAgIFx0S2V5ZnJhbWVUcmFja0NvbnN0cnVjdG9yLmNhbGwoIHRoaXMsIG5hbWUsIHRpbWVzLCB2YWx1ZXMsIGludGVycG9sYXRpb24gKTtcblxuICAgIH1cblxuICAgIENvbG9yS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUgPVxuICAgIFx0XHRPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBLZXlmcmFtZVRyYWNrUHJvdG90eXBlICksIHtcblxuICAgIFx0Y29uc3RydWN0b3I6IENvbG9yS2V5ZnJhbWVUcmFjayxcblxuICAgIFx0VmFsdWVUeXBlTmFtZTogJ2NvbG9yJ1xuXG4gICAgXHQvLyBWYWx1ZUJ1ZmZlclR5cGUgaXMgaW5oZXJpdGVkXG5cbiAgICBcdC8vIERlZmF1bHRJbnRlcnBvbGF0aW9uIGlzIGluaGVyaXRlZFxuXG5cbiAgICBcdC8vIE5vdGU6IFZlcnkgYmFzaWMgaW1wbGVtZW50YXRpb24gYW5kIG5vdGhpbmcgc3BlY2lhbCB5ZXQuXG4gICAgXHQvLyBIb3dldmVyLCB0aGlzIGlzIHRoZSBwbGFjZSBmb3IgY29sb3Igc3BhY2UgcGFyYW1ldGVyaXphdGlvbi5cblxuICAgIH0gKTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQSB0aW1lZCBzZXF1ZW5jZSBvZiBrZXlmcmFtZXMgZm9yIGEgc3BlY2lmaWMgcHJvcGVydHkuXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBhdXRob3IgQmVuIEhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW8vXG4gICAgICogQGF1dGhvciBEYXZpZCBTYXJubyAvIGh0dHA6Ly9saWdodGhhdXMudXMvXG4gICAgICogQGF1dGhvciB0c2Nod1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gS2V5ZnJhbWVUcmFjayggbmFtZSwgdGltZXMsIHZhbHVlcywgaW50ZXJwb2xhdGlvbiApIHtcblxuICAgIFx0S2V5ZnJhbWVUcmFja0NvbnN0cnVjdG9yLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblxuICAgIH1cblxuICAgIEtleWZyYW1lVHJhY2sucHJvdG90eXBlID0gS2V5ZnJhbWVUcmFja1Byb3RvdHlwZTtcbiAgICBLZXlmcmFtZVRyYWNrUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gS2V5ZnJhbWVUcmFjaztcblxuICAgIC8vIFN0YXRpYyBtZXRob2RzOlxuXG4gICAgT2JqZWN0LmFzc2lnbiggS2V5ZnJhbWVUcmFjaywge1xuXG4gICAgXHQvLyBTZXJpYWxpemF0aW9uIChpbiBzdGF0aWMgY29udGV4dCwgYmVjYXVzZSBvZiBjb25zdHJ1Y3RvciBpbnZvY2F0aW9uXG4gICAgXHQvLyBhbmQgYXV0b21hdGljIGludm9jYXRpb24gb2YgLnRvSlNPTik6XG5cbiAgICBcdHBhcnNlOiBmdW5jdGlvbigganNvbiApIHtcblxuICAgIFx0XHRpZigganNvbi50eXBlID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHR0aHJvdyBuZXcgRXJyb3IoIFwidHJhY2sgdHlwZSB1bmRlZmluZWQsIGNhbiBub3QgcGFyc2VcIiApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHR2YXIgdHJhY2tUeXBlID0gS2V5ZnJhbWVUcmFjay5fZ2V0VHJhY2tUeXBlRm9yVmFsdWVUeXBlTmFtZSgganNvbi50eXBlICk7XG5cbiAgICBcdFx0aWYgKCBqc29uLnRpbWVzID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHR2YXIgdGltZXMgPSBbXSwgdmFsdWVzID0gW107XG5cbiAgICBcdFx0XHRleHBvcnRzLkFuaW1hdGlvblV0aWxzLmZsYXR0ZW5KU09OKCBqc29uLmtleXMsIHRpbWVzLCB2YWx1ZXMsICd2YWx1ZScgKTtcblxuICAgIFx0XHRcdGpzb24udGltZXMgPSB0aW1lcztcbiAgICBcdFx0XHRqc29uLnZhbHVlcyA9IHZhbHVlcztcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0Ly8gZGVyaXZlZCBjbGFzc2VzIGNhbiBkZWZpbmUgYSBzdGF0aWMgcGFyc2UgbWV0aG9kXG4gICAgXHRcdGlmICggdHJhY2tUeXBlLnBhcnNlICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRyZXR1cm4gdHJhY2tUeXBlLnBhcnNlKCBqc29uICk7XG5cbiAgICBcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdC8vIGJ5IGRlZmF1bHQsIHdlIGFzc3N1bWUgYSBjb25zdHJ1Y3RvciBjb21wYXRpYmxlIHdpdGggdGhlIGJhc2VcbiAgICBcdFx0XHRyZXR1cm4gbmV3IHRyYWNrVHlwZShcbiAgICBcdFx0XHRcdFx0anNvbi5uYW1lLCBqc29uLnRpbWVzLCBqc29uLnZhbHVlcywganNvbi5pbnRlcnBvbGF0aW9uICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9LFxuXG4gICAgXHR0b0pTT046IGZ1bmN0aW9uKCB0cmFjayApIHtcblxuICAgIFx0XHR2YXIgdHJhY2tUeXBlID0gdHJhY2suY29uc3RydWN0b3I7XG5cbiAgICBcdFx0dmFyIGpzb247XG5cbiAgICBcdFx0Ly8gZGVyaXZlZCBjbGFzc2VzIGNhbiBkZWZpbmUgYSBzdGF0aWMgdG9KU09OIG1ldGhvZFxuICAgIFx0XHRpZiAoIHRyYWNrVHlwZS50b0pTT04gIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdGpzb24gPSB0cmFja1R5cGUudG9KU09OKCB0cmFjayApO1xuXG4gICAgXHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHQvLyBieSBkZWZhdWx0LCB3ZSBhc3N1bWUgdGhlIGRhdGEgY2FuIGJlIHNlcmlhbGl6ZWQgYXMtaXNcbiAgICBcdFx0XHRqc29uID0ge1xuXG4gICAgXHRcdFx0XHQnbmFtZSc6IHRyYWNrLm5hbWUsXG4gICAgXHRcdFx0XHQndGltZXMnOiBleHBvcnRzLkFuaW1hdGlvblV0aWxzLmNvbnZlcnRBcnJheSggdHJhY2sudGltZXMsIEFycmF5ICksXG4gICAgXHRcdFx0XHQndmFsdWVzJzogZXhwb3J0cy5BbmltYXRpb25VdGlscy5jb252ZXJ0QXJyYXkoIHRyYWNrLnZhbHVlcywgQXJyYXkgKVxuXG4gICAgXHRcdFx0fTtcblxuICAgIFx0XHRcdHZhciBpbnRlcnBvbGF0aW9uID0gdHJhY2suZ2V0SW50ZXJwb2xhdGlvbigpO1xuXG4gICAgXHRcdFx0aWYgKCBpbnRlcnBvbGF0aW9uICE9PSB0cmFjay5EZWZhdWx0SW50ZXJwb2xhdGlvbiApIHtcblxuICAgIFx0XHRcdFx0anNvbi5pbnRlcnBvbGF0aW9uID0gaW50ZXJwb2xhdGlvbjtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdFx0anNvbi50eXBlID0gdHJhY2suVmFsdWVUeXBlTmFtZTsgLy8gbWFuZGF0b3J5XG5cbiAgICBcdFx0cmV0dXJuIGpzb247XG5cbiAgICBcdH0sXG5cbiAgICBcdF9nZXRUcmFja1R5cGVGb3JWYWx1ZVR5cGVOYW1lOiBmdW5jdGlvbiggdHlwZU5hbWUgKSB7XG5cbiAgICBcdFx0c3dpdGNoKCB0eXBlTmFtZS50b0xvd2VyQ2FzZSgpICkge1xuXG4gICAgXHRcdFx0Y2FzZSBcInNjYWxhclwiOlxuICAgIFx0XHRcdGNhc2UgXCJkb3VibGVcIjpcbiAgICBcdFx0XHRjYXNlIFwiZmxvYXRcIjpcbiAgICBcdFx0XHRjYXNlIFwibnVtYmVyXCI6XG4gICAgXHRcdFx0Y2FzZSBcImludGVnZXJcIjpcblxuICAgIFx0XHRcdFx0cmV0dXJuIE51bWJlcktleWZyYW1lVHJhY2s7XG5cbiAgICBcdFx0XHRjYXNlIFwidmVjdG9yXCI6XG4gICAgXHRcdFx0Y2FzZSBcInZlY3RvcjJcIjpcbiAgICBcdFx0XHRjYXNlIFwidmVjdG9yM1wiOlxuICAgIFx0XHRcdGNhc2UgXCJ2ZWN0b3I0XCI6XG5cbiAgICBcdFx0XHRcdHJldHVybiBWZWN0b3JLZXlmcmFtZVRyYWNrO1xuXG4gICAgXHRcdFx0Y2FzZSBcImNvbG9yXCI6XG5cbiAgICBcdFx0XHRcdHJldHVybiBDb2xvcktleWZyYW1lVHJhY2s7XG5cbiAgICBcdFx0XHRjYXNlIFwicXVhdGVybmlvblwiOlxuXG4gICAgXHRcdFx0XHRyZXR1cm4gUXVhdGVybmlvbktleWZyYW1lVHJhY2s7XG5cbiAgICBcdFx0XHRjYXNlIFwiYm9vbFwiOlxuICAgIFx0XHRcdGNhc2UgXCJib29sZWFuXCI6XG5cbiAgICBcdFx0XHRcdHJldHVybiBCb29sZWFuS2V5ZnJhbWVUcmFjaztcblxuICAgIFx0XHRcdGNhc2UgXCJzdHJpbmdcIjpcblxuICAgIFx0XHRcdFx0cmV0dXJuIFN0cmluZ0tleWZyYW1lVHJhY2s7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHRocm93IG5ldyBFcnJvciggXCJVbnN1cHBvcnRlZCB0eXBlTmFtZTogXCIgKyB0eXBlTmFtZSApO1xuXG4gICAgXHR9XG5cbiAgICB9ICk7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFJldXNhYmxlIHNldCBvZiBUcmFja3MgdGhhdCByZXByZXNlbnQgYW4gYW5pbWF0aW9uLlxuICAgICAqXG4gICAgICogQGF1dGhvciBCZW4gSG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pby9cbiAgICAgKiBAYXV0aG9yIERhdmlkIFNhcm5vIC8gaHR0cDovL2xpZ2h0aGF1cy51cy9cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIEFuaW1hdGlvbkNsaXAoIG5hbWUsIGR1cmF0aW9uLCB0cmFja3MgKSB7XG5cbiAgICBcdHRoaXMubmFtZSA9IG5hbWU7XG4gICAgXHR0aGlzLnRyYWNrcyA9IHRyYWNrcztcbiAgICBcdHRoaXMuZHVyYXRpb24gPSAoIGR1cmF0aW9uICE9PSB1bmRlZmluZWQgKSA/IGR1cmF0aW9uIDogLTE7XG5cbiAgICBcdHRoaXMudXVpZCA9IGV4cG9ydHMuTWF0aC5nZW5lcmF0ZVVVSUQoKTtcblxuICAgIFx0Ly8gdGhpcyBtZWFucyBpdCBzaG91bGQgZmlndXJlIG91dCBpdHMgZHVyYXRpb24gYnkgc2Nhbm5pbmcgdGhlIHRyYWNrc1xuICAgIFx0aWYgKCB0aGlzLmR1cmF0aW9uIDwgMCApIHtcblxuICAgIFx0XHR0aGlzLnJlc2V0RHVyYXRpb24oKTtcblxuICAgIFx0fVxuXG4gICAgXHR0aGlzLm9wdGltaXplKCk7XG5cbiAgICB9XG5cbiAgICBBbmltYXRpb25DbGlwLnByb3RvdHlwZSA9IHtcblxuICAgIFx0Y29uc3RydWN0b3I6IEFuaW1hdGlvbkNsaXAsXG5cbiAgICBcdHJlc2V0RHVyYXRpb246IGZ1bmN0aW9uKCkge1xuXG4gICAgXHRcdHZhciB0cmFja3MgPSB0aGlzLnRyYWNrcyxcbiAgICBcdFx0XHRkdXJhdGlvbiA9IDA7XG5cbiAgICBcdFx0Zm9yICggdmFyIGkgPSAwLCBuID0gdHJhY2tzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcblxuICAgIFx0XHRcdHZhciB0cmFjayA9IHRoaXMudHJhY2tzWyBpIF07XG5cbiAgICBcdFx0XHRkdXJhdGlvbiA9IE1hdGgubWF4KFxuICAgIFx0XHRcdFx0XHRkdXJhdGlvbiwgdHJhY2sudGltZXNbIHRyYWNrLnRpbWVzLmxlbmd0aCAtIDEgXSApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHR0aGlzLmR1cmF0aW9uID0gZHVyYXRpb247XG5cbiAgICBcdH0sXG5cbiAgICBcdHRyaW06IGZ1bmN0aW9uKCkge1xuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMudHJhY2tzLmxlbmd0aDsgaSArKyApIHtcblxuICAgIFx0XHRcdHRoaXMudHJhY2tzWyBpIF0udHJpbSggMCwgdGhpcy5kdXJhdGlvbiApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0b3B0aW1pemU6IGZ1bmN0aW9uKCkge1xuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMudHJhY2tzLmxlbmd0aDsgaSArKyApIHtcblxuICAgIFx0XHRcdHRoaXMudHJhY2tzWyBpIF0ub3B0aW1pemUoKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH1cblxuICAgIH07XG5cbiAgICAvLyBTdGF0aWMgbWV0aG9kczpcblxuICAgIE9iamVjdC5hc3NpZ24oIEFuaW1hdGlvbkNsaXAsIHtcblxuICAgIFx0cGFyc2U6IGZ1bmN0aW9uKCBqc29uICkge1xuXG4gICAgXHRcdHZhciB0cmFja3MgPSBbXSxcbiAgICBcdFx0XHRqc29uVHJhY2tzID0ganNvbi50cmFja3MsXG4gICAgXHRcdFx0ZnJhbWVUaW1lID0gMS4wIC8gKCBqc29uLmZwcyB8fCAxLjAgKTtcblxuICAgIFx0XHRmb3IgKCB2YXIgaSA9IDAsIG4gPSBqc29uVHJhY2tzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcblxuICAgIFx0XHRcdHRyYWNrcy5wdXNoKCBLZXlmcmFtZVRyYWNrLnBhcnNlKCBqc29uVHJhY2tzWyBpIF0gKS5zY2FsZSggZnJhbWVUaW1lICkgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIG5ldyBBbmltYXRpb25DbGlwKCBqc29uLm5hbWUsIGpzb24uZHVyYXRpb24sIHRyYWNrcyApO1xuXG4gICAgXHR9LFxuXG5cbiAgICBcdHRvSlNPTjogZnVuY3Rpb24oIGNsaXAgKSB7XG5cbiAgICBcdFx0dmFyIHRyYWNrcyA9IFtdLFxuICAgIFx0XHRcdGNsaXBUcmFja3MgPSBjbGlwLnRyYWNrcztcblxuICAgIFx0XHR2YXIganNvbiA9IHtcblxuICAgIFx0XHRcdCduYW1lJzogY2xpcC5uYW1lLFxuICAgIFx0XHRcdCdkdXJhdGlvbic6IGNsaXAuZHVyYXRpb24sXG4gICAgXHRcdFx0J3RyYWNrcyc6IHRyYWNrc1xuXG4gICAgXHRcdH07XG5cbiAgICBcdFx0Zm9yICggdmFyIGkgPSAwLCBuID0gY2xpcFRyYWNrcy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cbiAgICBcdFx0XHR0cmFja3MucHVzaCggS2V5ZnJhbWVUcmFjay50b0pTT04oIGNsaXBUcmFja3NbIGkgXSApICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiBqc29uO1xuXG4gICAgXHR9LFxuXG5cbiAgICBcdENyZWF0ZUZyb21Nb3JwaFRhcmdldFNlcXVlbmNlOiBmdW5jdGlvbiggbmFtZSwgbW9ycGhUYXJnZXRTZXF1ZW5jZSwgZnBzLCBub0xvb3AgKSB7XG5cbiAgICBcdFx0dmFyIG51bU1vcnBoVGFyZ2V0cyA9IG1vcnBoVGFyZ2V0U2VxdWVuY2UubGVuZ3RoO1xuICAgIFx0XHR2YXIgdHJhY2tzID0gW107XG5cbiAgICBcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbnVtTW9ycGhUYXJnZXRzOyBpICsrICkge1xuXG4gICAgXHRcdFx0dmFyIHRpbWVzID0gW107XG4gICAgXHRcdFx0dmFyIHZhbHVlcyA9IFtdO1xuXG4gICAgXHRcdFx0dGltZXMucHVzaChcbiAgICBcdFx0XHRcdFx0KCBpICsgbnVtTW9ycGhUYXJnZXRzIC0gMSApICUgbnVtTW9ycGhUYXJnZXRzLFxuICAgIFx0XHRcdFx0XHRpLFxuICAgIFx0XHRcdFx0XHQoIGkgKyAxICkgJSBudW1Nb3JwaFRhcmdldHMgKTtcblxuICAgIFx0XHRcdHZhbHVlcy5wdXNoKCAwLCAxLCAwICk7XG5cbiAgICBcdFx0XHR2YXIgb3JkZXIgPSBleHBvcnRzLkFuaW1hdGlvblV0aWxzLmdldEtleWZyYW1lT3JkZXIoIHRpbWVzICk7XG4gICAgXHRcdFx0dGltZXMgPSBleHBvcnRzLkFuaW1hdGlvblV0aWxzLnNvcnRlZEFycmF5KCB0aW1lcywgMSwgb3JkZXIgKTtcbiAgICBcdFx0XHR2YWx1ZXMgPSBleHBvcnRzLkFuaW1hdGlvblV0aWxzLnNvcnRlZEFycmF5KCB2YWx1ZXMsIDEsIG9yZGVyICk7XG5cbiAgICBcdFx0XHQvLyBpZiB0aGVyZSBpcyBhIGtleSBhdCB0aGUgZmlyc3QgZnJhbWUsIGR1cGxpY2F0ZSBpdCBhcyB0aGVcbiAgICBcdFx0XHQvLyBsYXN0IGZyYW1lIGFzIHdlbGwgZm9yIHBlcmZlY3QgbG9vcC5cbiAgICBcdFx0XHRpZiAoICEgbm9Mb29wICYmIHRpbWVzWyAwIF0gPT09IDAgKSB7XG5cbiAgICBcdFx0XHRcdHRpbWVzLnB1c2goIG51bU1vcnBoVGFyZ2V0cyApO1xuICAgIFx0XHRcdFx0dmFsdWVzLnB1c2goIHZhbHVlc1sgMCBdICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHR0cmFja3MucHVzaChcbiAgICBcdFx0XHRcdFx0bmV3IE51bWJlcktleWZyYW1lVHJhY2soXG4gICAgXHRcdFx0XHRcdFx0Jy5tb3JwaFRhcmdldEluZmx1ZW5jZXNbJyArIG1vcnBoVGFyZ2V0U2VxdWVuY2VbIGkgXS5uYW1lICsgJ10nLFxuICAgIFx0XHRcdFx0XHRcdHRpbWVzLCB2YWx1ZXNcbiAgICBcdFx0XHRcdFx0KS5zY2FsZSggMS4wIC8gZnBzICkgKTtcbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiBuZXcgQW5pbWF0aW9uQ2xpcCggbmFtZSwgLTEsIHRyYWNrcyApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRmaW5kQnlOYW1lOiBmdW5jdGlvbiggb2JqZWN0T3JDbGlwQXJyYXksIG5hbWUgKSB7XG5cbiAgICBcdFx0dmFyIGNsaXBBcnJheSA9IG9iamVjdE9yQ2xpcEFycmF5O1xuXG4gICAgXHRcdGlmICggISBBcnJheS5pc0FycmF5KCBvYmplY3RPckNsaXBBcnJheSApICkge1xuXG4gICAgXHRcdFx0dmFyIG8gPSBvYmplY3RPckNsaXBBcnJheTtcbiAgICBcdFx0XHRjbGlwQXJyYXkgPSBvLmdlb21ldHJ5ICYmIG8uZ2VvbWV0cnkuYW5pbWF0aW9ucyB8fCBvLmFuaW1hdGlvbnM7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGNsaXBBcnJheS5sZW5ndGg7IGkgKysgKSB7XG5cbiAgICBcdFx0XHRpZiAoIGNsaXBBcnJheVsgaSBdLm5hbWUgPT09IG5hbWUgKSB7XG5cbiAgICBcdFx0XHRcdHJldHVybiBjbGlwQXJyYXlbIGkgXTtcblxuICAgIFx0XHRcdH1cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiBudWxsO1xuXG4gICAgXHR9LFxuXG4gICAgXHRDcmVhdGVDbGlwc0Zyb21Nb3JwaFRhcmdldFNlcXVlbmNlczogZnVuY3Rpb24oIG1vcnBoVGFyZ2V0cywgZnBzLCBub0xvb3AgKSB7XG5cbiAgICBcdFx0dmFyIGFuaW1hdGlvblRvTW9ycGhUYXJnZXRzID0ge307XG5cbiAgICBcdFx0Ly8gdGVzdGVkIHdpdGggaHR0cHM6Ly9yZWdleDEwMS5jb20vIG9uIHRyaWNrIHNlcXVlbmNlc1xuICAgIFx0XHQvLyBzdWNoIGZsYW1pbmdvX2ZseUFfMDAzLCBmbGFtaW5nb19ydW4xXzAwMywgY3JkZWF0aDAwNTlcbiAgICBcdFx0dmFyIHBhdHRlcm4gPSAvXihbXFx3LV0qPykoW1xcZF0rKSQvO1xuXG4gICAgXHRcdC8vIHNvcnQgbW9ycGggdGFyZ2V0IG5hbWVzIGludG8gYW5pbWF0aW9uIGdyb3VwcyBiYXNlZFxuICAgIFx0XHQvLyBwYXR0ZXJucyBsaWtlIFdhbGtfMDAxLCBXYWxrXzAwMiwgUnVuXzAwMSwgUnVuXzAwMlxuICAgIFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gbW9ycGhUYXJnZXRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgXHRcdFx0dmFyIG1vcnBoVGFyZ2V0ID0gbW9ycGhUYXJnZXRzWyBpIF07XG4gICAgXHRcdFx0dmFyIHBhcnRzID0gbW9ycGhUYXJnZXQubmFtZS5tYXRjaCggcGF0dGVybiApO1xuXG4gICAgXHRcdFx0aWYgKCBwYXJ0cyAmJiBwYXJ0cy5sZW5ndGggPiAxICkge1xuXG4gICAgXHRcdFx0XHR2YXIgbmFtZSA9IHBhcnRzWyAxIF07XG5cbiAgICBcdFx0XHRcdHZhciBhbmltYXRpb25Nb3JwaFRhcmdldHMgPSBhbmltYXRpb25Ub01vcnBoVGFyZ2V0c1sgbmFtZSBdO1xuICAgIFx0XHRcdFx0aWYgKCAhIGFuaW1hdGlvbk1vcnBoVGFyZ2V0cyApIHtcblxuICAgIFx0XHRcdFx0XHRhbmltYXRpb25Ub01vcnBoVGFyZ2V0c1sgbmFtZSBdID0gYW5pbWF0aW9uTW9ycGhUYXJnZXRzID0gW107XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0YW5pbWF0aW9uTW9ycGhUYXJnZXRzLnB1c2goIG1vcnBoVGFyZ2V0ICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHZhciBjbGlwcyA9IFtdO1xuXG4gICAgXHRcdGZvciAoIHZhciBuYW1lIGluIGFuaW1hdGlvblRvTW9ycGhUYXJnZXRzICkge1xuXG4gICAgXHRcdFx0Y2xpcHMucHVzaCggQW5pbWF0aW9uQ2xpcC5DcmVhdGVGcm9tTW9ycGhUYXJnZXRTZXF1ZW5jZSggbmFtZSwgYW5pbWF0aW9uVG9Nb3JwaFRhcmdldHNbIG5hbWUgXSwgZnBzLCBub0xvb3AgKSApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gY2xpcHM7XG5cbiAgICBcdH0sXG5cbiAgICBcdC8vIHBhcnNlIHRoZSBhbmltYXRpb24uaGllcmFyY2h5IGZvcm1hdFxuICAgIFx0cGFyc2VBbmltYXRpb246IGZ1bmN0aW9uKCBhbmltYXRpb24sIGJvbmVzICkge1xuXG4gICAgXHRcdGlmICggISBhbmltYXRpb24gKSB7XG5cbiAgICBcdFx0XHRjb25zb2xlLmVycm9yKCBcIiAgbm8gYW5pbWF0aW9uIGluIEpTT05Mb2FkZXIgZGF0YVwiICk7XG4gICAgXHRcdFx0cmV0dXJuIG51bGw7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHZhciBhZGROb25lbXB0eVRyYWNrID0gZnVuY3Rpb24oXG4gICAgXHRcdFx0XHR0cmFja1R5cGUsIHRyYWNrTmFtZSwgYW5pbWF0aW9uS2V5cywgcHJvcGVydHlOYW1lLCBkZXN0VHJhY2tzICkge1xuXG4gICAgXHRcdFx0Ly8gb25seSByZXR1cm4gdHJhY2sgaWYgdGhlcmUgYXJlIGFjdHVhbGx5IGtleXMuXG4gICAgXHRcdFx0aWYgKCBhbmltYXRpb25LZXlzLmxlbmd0aCAhPT0gMCApIHtcblxuICAgIFx0XHRcdFx0dmFyIHRpbWVzID0gW107XG4gICAgXHRcdFx0XHR2YXIgdmFsdWVzID0gW107XG5cbiAgICBcdFx0XHRcdGV4cG9ydHMuQW5pbWF0aW9uVXRpbHMuZmxhdHRlbkpTT04oXG4gICAgXHRcdFx0XHRcdFx0YW5pbWF0aW9uS2V5cywgdGltZXMsIHZhbHVlcywgcHJvcGVydHlOYW1lICk7XG5cbiAgICBcdFx0XHRcdC8vIGVtcHR5IGtleXMgYXJlIGZpbHRlcmVkIG91dCwgc28gY2hlY2sgYWdhaW5cbiAgICBcdFx0XHRcdGlmICggdGltZXMubGVuZ3RoICE9PSAwICkge1xuXG4gICAgXHRcdFx0XHRcdGRlc3RUcmFja3MucHVzaCggbmV3IHRyYWNrVHlwZSggdHJhY2tOYW1lLCB0aW1lcywgdmFsdWVzICkgKTtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH07XG5cbiAgICBcdFx0dmFyIHRyYWNrcyA9IFtdO1xuXG4gICAgXHRcdHZhciBjbGlwTmFtZSA9IGFuaW1hdGlvbi5uYW1lIHx8ICdkZWZhdWx0JztcbiAgICBcdFx0Ly8gYXV0b21hdGljIGxlbmd0aCBkZXRlcm1pbmF0aW9uIGluIEFuaW1hdGlvbkNsaXAuXG4gICAgXHRcdHZhciBkdXJhdGlvbiA9IGFuaW1hdGlvbi5sZW5ndGggfHwgLTE7XG4gICAgXHRcdHZhciBmcHMgPSBhbmltYXRpb24uZnBzIHx8IDMwO1xuXG4gICAgXHRcdHZhciBoaWVyYXJjaHlUcmFja3MgPSBhbmltYXRpb24uaGllcmFyY2h5IHx8IFtdO1xuXG4gICAgXHRcdGZvciAoIHZhciBoID0gMDsgaCA8IGhpZXJhcmNoeVRyYWNrcy5sZW5ndGg7IGggKysgKSB7XG5cbiAgICBcdFx0XHR2YXIgYW5pbWF0aW9uS2V5cyA9IGhpZXJhcmNoeVRyYWNrc1sgaCBdLmtleXM7XG5cbiAgICBcdFx0XHQvLyBza2lwIGVtcHR5IHRyYWNrc1xuICAgIFx0XHRcdGlmICggISBhbmltYXRpb25LZXlzIHx8IGFuaW1hdGlvbktleXMubGVuZ3RoID09PSAwICkgY29udGludWU7XG5cbiAgICBcdFx0XHQvLyBwcm9jZXNzIG1vcnBoIHRhcmdldHMgaW4gYSB3YXkgZXhhY3RseSBjb21wYXRpYmxlXG4gICAgXHRcdFx0Ly8gd2l0aCBBbmltYXRpb25IYW5kbGVyLmluaXQoIGFuaW1hdGlvbiApXG4gICAgXHRcdFx0aWYgKCBhbmltYXRpb25LZXlzWzBdLm1vcnBoVGFyZ2V0cyApIHtcblxuICAgIFx0XHRcdFx0Ly8gZmlndXJlIG91dCBhbGwgbW9ycGggdGFyZ2V0cyB1c2VkIGluIHRoaXMgdHJhY2tcbiAgICBcdFx0XHRcdHZhciBtb3JwaFRhcmdldE5hbWVzID0ge307XG4gICAgXHRcdFx0XHRmb3IgKCB2YXIgayA9IDA7IGsgPCBhbmltYXRpb25LZXlzLmxlbmd0aDsgayArKyApIHtcblxuICAgIFx0XHRcdFx0XHRpZiAoIGFuaW1hdGlvbktleXNba10ubW9ycGhUYXJnZXRzICkge1xuXG4gICAgXHRcdFx0XHRcdFx0Zm9yICggdmFyIG0gPSAwOyBtIDwgYW5pbWF0aW9uS2V5c1trXS5tb3JwaFRhcmdldHMubGVuZ3RoOyBtICsrICkge1xuXG4gICAgXHRcdFx0XHRcdFx0XHRtb3JwaFRhcmdldE5hbWVzWyBhbmltYXRpb25LZXlzW2tdLm1vcnBoVGFyZ2V0c1ttXSBdID0gLTE7XG4gICAgXHRcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHQvLyBjcmVhdGUgYSB0cmFjayBmb3IgZWFjaCBtb3JwaCB0YXJnZXQgd2l0aCBhbGwgemVyb1xuICAgIFx0XHRcdFx0Ly8gbW9ycGhUYXJnZXRJbmZsdWVuY2VzIGV4Y2VwdCBmb3IgdGhlIGtleXMgaW4gd2hpY2hcbiAgICBcdFx0XHRcdC8vIHRoZSBtb3JwaFRhcmdldCBpcyBuYW1lZC5cbiAgICBcdFx0XHRcdGZvciAoIHZhciBtb3JwaFRhcmdldE5hbWUgaW4gbW9ycGhUYXJnZXROYW1lcyApIHtcblxuICAgIFx0XHRcdFx0XHR2YXIgdGltZXMgPSBbXTtcbiAgICBcdFx0XHRcdFx0dmFyIHZhbHVlcyA9IFtdO1xuXG4gICAgXHRcdFx0XHRcdGZvciAoIHZhciBtID0gMDtcbiAgICBcdFx0XHRcdFx0XHRcdG0gIT09IGFuaW1hdGlvbktleXNba10ubW9ycGhUYXJnZXRzLmxlbmd0aDsgKysgbSApIHtcblxuICAgIFx0XHRcdFx0XHRcdHZhciBhbmltYXRpb25LZXkgPSBhbmltYXRpb25LZXlzW2tdO1xuXG4gICAgXHRcdFx0XHRcdFx0dGltZXMucHVzaCggYW5pbWF0aW9uS2V5LnRpbWUgKTtcbiAgICBcdFx0XHRcdFx0XHR2YWx1ZXMucHVzaCggKCBhbmltYXRpb25LZXkubW9ycGhUYXJnZXQgPT09IG1vcnBoVGFyZ2V0TmFtZSApID8gMSA6IDAgKTtcblxuICAgIFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdFx0dHJhY2tzLnB1c2goIG5ldyBOdW1iZXJLZXlmcmFtZVRyYWNrKFxuICAgIFx0XHRcdFx0XHRcdFx0Jy5tb3JwaFRhcmdldEluZmx1ZW5jZVsnICsgbW9ycGhUYXJnZXROYW1lICsgJ10nLCB0aW1lcywgdmFsdWVzICkgKTtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRkdXJhdGlvbiA9IG1vcnBoVGFyZ2V0TmFtZXMubGVuZ3RoICogKCBmcHMgfHwgMS4wICk7XG5cbiAgICBcdFx0XHR9IGVsc2Uge1xuICAgIFx0XHRcdFx0Ly8gLi4uYXNzdW1lIHNrZWxldGFsIGFuaW1hdGlvblxuXG4gICAgXHRcdFx0XHR2YXIgYm9uZU5hbWUgPSAnLmJvbmVzWycgKyBib25lc1sgaCBdLm5hbWUgKyAnXSc7XG5cbiAgICBcdFx0XHRcdGFkZE5vbmVtcHR5VHJhY2soXG4gICAgXHRcdFx0XHRcdFx0VmVjdG9yS2V5ZnJhbWVUcmFjaywgYm9uZU5hbWUgKyAnLnBvc2l0aW9uJyxcbiAgICBcdFx0XHRcdFx0XHRhbmltYXRpb25LZXlzLCAncG9zJywgdHJhY2tzICk7XG5cbiAgICBcdFx0XHRcdGFkZE5vbmVtcHR5VHJhY2soXG4gICAgXHRcdFx0XHRcdFx0UXVhdGVybmlvbktleWZyYW1lVHJhY2ssIGJvbmVOYW1lICsgJy5xdWF0ZXJuaW9uJyxcbiAgICBcdFx0XHRcdFx0XHRhbmltYXRpb25LZXlzLCAncm90JywgdHJhY2tzICk7XG5cbiAgICBcdFx0XHRcdGFkZE5vbmVtcHR5VHJhY2soXG4gICAgXHRcdFx0XHRcdFx0VmVjdG9yS2V5ZnJhbWVUcmFjaywgYm9uZU5hbWUgKyAnLnNjYWxlJyxcbiAgICBcdFx0XHRcdFx0XHRhbmltYXRpb25LZXlzLCAnc2NsJywgdHJhY2tzICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGlmICggdHJhY2tzLmxlbmd0aCA9PT0gMCApIHtcblxuICAgIFx0XHRcdHJldHVybiBudWxsO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHR2YXIgY2xpcCA9IG5ldyBBbmltYXRpb25DbGlwKCBjbGlwTmFtZSwgZHVyYXRpb24sIHRyYWNrcyApO1xuXG4gICAgXHRcdHJldHVybiBjbGlwO1xuXG4gICAgXHR9XG5cbiAgICB9ICk7XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gTWF0ZXJpYWxMb2FkZXIoIG1hbmFnZXIgKSB7XG5cbiAgICBcdHRoaXMubWFuYWdlciA9ICggbWFuYWdlciAhPT0gdW5kZWZpbmVkICkgPyBtYW5hZ2VyIDogZXhwb3J0cy5EZWZhdWx0TG9hZGluZ01hbmFnZXI7XG4gICAgXHR0aGlzLnRleHR1cmVzID0ge307XG5cbiAgICB9XG5cbiAgICBPYmplY3QuYXNzaWduKCBNYXRlcmlhbExvYWRlci5wcm90b3R5cGUsIHtcblxuICAgIFx0bG9hZDogZnVuY3Rpb24gKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcblxuICAgIFx0XHR2YXIgc2NvcGUgPSB0aGlzO1xuXG4gICAgXHRcdHZhciBsb2FkZXIgPSBuZXcgWEhSTG9hZGVyKCBzY29wZS5tYW5hZ2VyICk7XG4gICAgXHRcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggdGV4dCApIHtcblxuICAgIFx0XHRcdG9uTG9hZCggc2NvcGUucGFyc2UoIEpTT04ucGFyc2UoIHRleHQgKSApICk7XG5cbiAgICBcdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzZXRUZXh0dXJlczogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuICAgIFx0XHR0aGlzLnRleHR1cmVzID0gdmFsdWU7XG5cbiAgICBcdH0sXG5cbiAgICBcdHBhcnNlOiBmdW5jdGlvbiAoIGpzb24gKSB7XG5cbiAgICBcdFx0dmFyIHRleHR1cmVzID0gdGhpcy50ZXh0dXJlcztcblxuICAgIFx0XHRmdW5jdGlvbiBnZXRUZXh0dXJlKCBuYW1lICkge1xuXG4gICAgXHRcdFx0aWYgKCB0ZXh0dXJlc1sgbmFtZSBdID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdGVyaWFsTG9hZGVyOiBVbmRlZmluZWQgdGV4dHVyZScsIG5hbWUgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdHJldHVybiB0ZXh0dXJlc1sgbmFtZSBdO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHR2YXIgbWF0ZXJpYWwgPSBuZXcgTWF0ZXJpYWxzWyBqc29uLnR5cGUgXSgpO1xuXG4gICAgXHRcdGlmICgganNvbi51dWlkICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC51dWlkID0ganNvbi51dWlkO1xuICAgIFx0XHRpZiAoIGpzb24ubmFtZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwubmFtZSA9IGpzb24ubmFtZTtcbiAgICBcdFx0aWYgKCBqc29uLmNvbG9yICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5jb2xvci5zZXRIZXgoIGpzb24uY29sb3IgKTtcbiAgICBcdFx0aWYgKCBqc29uLnJvdWdobmVzcyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwucm91Z2huZXNzID0ganNvbi5yb3VnaG5lc3M7XG4gICAgXHRcdGlmICgganNvbi5tZXRhbG5lc3MgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLm1ldGFsbmVzcyA9IGpzb24ubWV0YWxuZXNzO1xuICAgIFx0XHRpZiAoIGpzb24uZW1pc3NpdmUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmVtaXNzaXZlLnNldEhleCgganNvbi5lbWlzc2l2ZSApO1xuICAgIFx0XHRpZiAoIGpzb24uc3BlY3VsYXIgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnNwZWN1bGFyLnNldEhleCgganNvbi5zcGVjdWxhciApO1xuICAgIFx0XHRpZiAoIGpzb24uc2hpbmluZXNzICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zaGluaW5lc3MgPSBqc29uLnNoaW5pbmVzcztcbiAgICBcdFx0aWYgKCBqc29uLnVuaWZvcm1zICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC51bmlmb3JtcyA9IGpzb24udW5pZm9ybXM7XG4gICAgXHRcdGlmICgganNvbi52ZXJ0ZXhTaGFkZXIgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnZlcnRleFNoYWRlciA9IGpzb24udmVydGV4U2hhZGVyO1xuICAgIFx0XHRpZiAoIGpzb24uZnJhZ21lbnRTaGFkZXIgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmZyYWdtZW50U2hhZGVyID0ganNvbi5mcmFnbWVudFNoYWRlcjtcbiAgICBcdFx0aWYgKCBqc29uLnZlcnRleENvbG9ycyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwudmVydGV4Q29sb3JzID0ganNvbi52ZXJ0ZXhDb2xvcnM7XG4gICAgXHRcdGlmICgganNvbi5mb2cgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmZvZyA9IGpzb24uZm9nO1xuICAgIFx0XHRpZiAoIGpzb24uc2hhZGluZyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc2hhZGluZyA9IGpzb24uc2hhZGluZztcbiAgICBcdFx0aWYgKCBqc29uLmJsZW5kaW5nICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5ibGVuZGluZyA9IGpzb24uYmxlbmRpbmc7XG4gICAgXHRcdGlmICgganNvbi5zaWRlICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zaWRlID0ganNvbi5zaWRlO1xuICAgIFx0XHRpZiAoIGpzb24ub3BhY2l0eSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwub3BhY2l0eSA9IGpzb24ub3BhY2l0eTtcbiAgICBcdFx0aWYgKCBqc29uLnRyYW5zcGFyZW50ICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC50cmFuc3BhcmVudCA9IGpzb24udHJhbnNwYXJlbnQ7XG4gICAgXHRcdGlmICgganNvbi5hbHBoYVRlc3QgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmFscGhhVGVzdCA9IGpzb24uYWxwaGFUZXN0O1xuICAgIFx0XHRpZiAoIGpzb24uZGVwdGhUZXN0ICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5kZXB0aFRlc3QgPSBqc29uLmRlcHRoVGVzdDtcbiAgICBcdFx0aWYgKCBqc29uLmRlcHRoV3JpdGUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmRlcHRoV3JpdGUgPSBqc29uLmRlcHRoV3JpdGU7XG4gICAgXHRcdGlmICgganNvbi5jb2xvcldyaXRlICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5jb2xvcldyaXRlID0ganNvbi5jb2xvcldyaXRlO1xuICAgIFx0XHRpZiAoIGpzb24ud2lyZWZyYW1lICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC53aXJlZnJhbWUgPSBqc29uLndpcmVmcmFtZTtcbiAgICBcdFx0aWYgKCBqc29uLndpcmVmcmFtZUxpbmV3aWR0aCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwud2lyZWZyYW1lTGluZXdpZHRoID0ganNvbi53aXJlZnJhbWVMaW5ld2lkdGg7XG4gICAgXHRcdGlmICgganNvbi53aXJlZnJhbWVMaW5lY2FwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC53aXJlZnJhbWVMaW5lY2FwID0ganNvbi53aXJlZnJhbWVMaW5lY2FwO1xuICAgIFx0XHRpZiAoIGpzb24ud2lyZWZyYW1lTGluZWpvaW4gIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLndpcmVmcmFtZUxpbmVqb2luID0ganNvbi53aXJlZnJhbWVMaW5lam9pbjtcbiAgICBcdFx0aWYgKCBqc29uLnNraW5uaW5nICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5za2lubmluZyA9IGpzb24uc2tpbm5pbmc7XG4gICAgXHRcdGlmICgganNvbi5tb3JwaFRhcmdldHMgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLm1vcnBoVGFyZ2V0cyA9IGpzb24ubW9ycGhUYXJnZXRzO1xuXG4gICAgXHRcdC8vIGZvciBQb2ludHNNYXRlcmlhbFxuXG4gICAgXHRcdGlmICgganNvbi5zaXplICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zaXplID0ganNvbi5zaXplO1xuICAgIFx0XHRpZiAoIGpzb24uc2l6ZUF0dGVudWF0aW9uICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zaXplQXR0ZW51YXRpb24gPSBqc29uLnNpemVBdHRlbnVhdGlvbjtcblxuICAgIFx0XHQvLyBtYXBzXG5cbiAgICBcdFx0aWYgKCBqc29uLm1hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwubWFwID0gZ2V0VGV4dHVyZSgganNvbi5tYXAgKTtcblxuICAgIFx0XHRpZiAoIGpzb24uYWxwaGFNYXAgIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdG1hdGVyaWFsLmFscGhhTWFwID0gZ2V0VGV4dHVyZSgganNvbi5hbHBoYU1hcCApO1xuICAgIFx0XHRcdG1hdGVyaWFsLnRyYW5zcGFyZW50ID0gdHJ1ZTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKCBqc29uLmJ1bXBNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmJ1bXBNYXAgPSBnZXRUZXh0dXJlKCBqc29uLmJ1bXBNYXAgKTtcbiAgICBcdFx0aWYgKCBqc29uLmJ1bXBTY2FsZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuYnVtcFNjYWxlID0ganNvbi5idW1wU2NhbGU7XG5cbiAgICBcdFx0aWYgKCBqc29uLm5vcm1hbE1hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwubm9ybWFsTWFwID0gZ2V0VGV4dHVyZSgganNvbi5ub3JtYWxNYXAgKTtcbiAgICBcdFx0aWYgKCBqc29uLm5vcm1hbFNjYWxlICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHR2YXIgbm9ybWFsU2NhbGUgPSBqc29uLm5vcm1hbFNjYWxlO1xuXG4gICAgXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBub3JtYWxTY2FsZSApID09PSBmYWxzZSApIHtcblxuICAgIFx0XHRcdFx0Ly8gQmxlbmRlciBleHBvcnRlciB1c2VkIHRvIGV4cG9ydCBhIHNjYWxhci4gU2VlICM3NDU5XG5cbiAgICBcdFx0XHRcdG5vcm1hbFNjYWxlID0gWyBub3JtYWxTY2FsZSwgbm9ybWFsU2NhbGUgXTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdG1hdGVyaWFsLm5vcm1hbFNjYWxlID0gbmV3IFZlY3RvcjIoKS5mcm9tQXJyYXkoIG5vcm1hbFNjYWxlICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGlmICgganNvbi5kaXNwbGFjZW1lbnRNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcCA9IGdldFRleHR1cmUoIGpzb24uZGlzcGxhY2VtZW50TWFwICk7XG4gICAgXHRcdGlmICgganNvbi5kaXNwbGFjZW1lbnRTY2FsZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZGlzcGxhY2VtZW50U2NhbGUgPSBqc29uLmRpc3BsYWNlbWVudFNjYWxlO1xuICAgIFx0XHRpZiAoIGpzb24uZGlzcGxhY2VtZW50QmlhcyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZGlzcGxhY2VtZW50QmlhcyA9IGpzb24uZGlzcGxhY2VtZW50QmlhcztcblxuICAgIFx0XHRpZiAoIGpzb24ucm91Z2huZXNzTWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5yb3VnaG5lc3NNYXAgPSBnZXRUZXh0dXJlKCBqc29uLnJvdWdobmVzc01hcCApO1xuICAgIFx0XHRpZiAoIGpzb24ubWV0YWxuZXNzTWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5tZXRhbG5lc3NNYXAgPSBnZXRUZXh0dXJlKCBqc29uLm1ldGFsbmVzc01hcCApO1xuXG4gICAgXHRcdGlmICgganNvbi5lbWlzc2l2ZU1hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZW1pc3NpdmVNYXAgPSBnZXRUZXh0dXJlKCBqc29uLmVtaXNzaXZlTWFwICk7XG4gICAgXHRcdGlmICgganNvbi5lbWlzc2l2ZUludGVuc2l0eSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZW1pc3NpdmVJbnRlbnNpdHkgPSBqc29uLmVtaXNzaXZlSW50ZW5zaXR5O1xuXG4gICAgXHRcdGlmICgganNvbi5zcGVjdWxhck1hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc3BlY3VsYXJNYXAgPSBnZXRUZXh0dXJlKCBqc29uLnNwZWN1bGFyTWFwICk7XG5cbiAgICBcdFx0aWYgKCBqc29uLmVudk1hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZW52TWFwID0gZ2V0VGV4dHVyZSgganNvbi5lbnZNYXAgKTtcblxuICAgIFx0XHRpZiAoIGpzb24ucmVmbGVjdGl2aXR5ICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5yZWZsZWN0aXZpdHkgPSBqc29uLnJlZmxlY3Rpdml0eTtcblxuICAgIFx0XHRpZiAoIGpzb24ubGlnaHRNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmxpZ2h0TWFwID0gZ2V0VGV4dHVyZSgganNvbi5saWdodE1hcCApO1xuICAgIFx0XHRpZiAoIGpzb24ubGlnaHRNYXBJbnRlbnNpdHkgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmxpZ2h0TWFwSW50ZW5zaXR5ID0ganNvbi5saWdodE1hcEludGVuc2l0eTtcblxuICAgIFx0XHRpZiAoIGpzb24uYW9NYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmFvTWFwID0gZ2V0VGV4dHVyZSgganNvbi5hb01hcCApO1xuICAgIFx0XHRpZiAoIGpzb24uYW9NYXBJbnRlbnNpdHkgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmFvTWFwSW50ZW5zaXR5ID0ganNvbi5hb01hcEludGVuc2l0eTtcblxuICAgIFx0XHQvLyBNdWx0aU1hdGVyaWFsXG5cbiAgICBcdFx0aWYgKCBqc29uLm1hdGVyaWFscyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0ganNvbi5tYXRlcmlhbHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgIFx0XHRcdFx0bWF0ZXJpYWwubWF0ZXJpYWxzLnB1c2goIHRoaXMucGFyc2UoIGpzb24ubWF0ZXJpYWxzWyBpIF0gKSApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gbWF0ZXJpYWw7XG5cbiAgICBcdH1cblxuICAgIH0gKTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBCdWZmZXJHZW9tZXRyeUxvYWRlciggbWFuYWdlciApIHtcblxuICAgIFx0dGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBleHBvcnRzLkRlZmF1bHRMb2FkaW5nTWFuYWdlcjtcblxuICAgIH1cblxuICAgIE9iamVjdC5hc3NpZ24oIEJ1ZmZlckdlb21ldHJ5TG9hZGVyLnByb3RvdHlwZSwge1xuXG4gICAgXHRsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG4gICAgXHRcdHZhciBzY29wZSA9IHRoaXM7XG5cbiAgICBcdFx0dmFyIGxvYWRlciA9IG5ldyBYSFJMb2FkZXIoIHNjb3BlLm1hbmFnZXIgKTtcbiAgICBcdFx0bG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCB0ZXh0ICkge1xuXG4gICAgXHRcdFx0b25Mb2FkKCBzY29wZS5wYXJzZSggSlNPTi5wYXJzZSggdGV4dCApICkgKTtcblxuICAgIFx0XHR9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdHBhcnNlOiBmdW5jdGlvbiAoIGpzb24gKSB7XG5cbiAgICBcdFx0dmFyIGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cbiAgICBcdFx0dmFyIGluZGV4ID0ganNvbi5kYXRhLmluZGV4O1xuXG4gICAgXHRcdHZhciBUWVBFRF9BUlJBWVMgPSB7XG4gICAgXHRcdFx0J0ludDhBcnJheSc6IEludDhBcnJheSxcbiAgICBcdFx0XHQnVWludDhBcnJheSc6IFVpbnQ4QXJyYXksXG4gICAgXHRcdFx0J1VpbnQ4Q2xhbXBlZEFycmF5JzogVWludDhDbGFtcGVkQXJyYXksXG4gICAgXHRcdFx0J0ludDE2QXJyYXknOiBJbnQxNkFycmF5LFxuICAgIFx0XHRcdCdVaW50MTZBcnJheSc6IFVpbnQxNkFycmF5LFxuICAgIFx0XHRcdCdJbnQzMkFycmF5JzogSW50MzJBcnJheSxcbiAgICBcdFx0XHQnVWludDMyQXJyYXknOiBVaW50MzJBcnJheSxcbiAgICBcdFx0XHQnRmxvYXQzMkFycmF5JzogRmxvYXQzMkFycmF5LFxuICAgIFx0XHRcdCdGbG9hdDY0QXJyYXknOiBGbG9hdDY0QXJyYXlcbiAgICBcdFx0fTtcblxuICAgIFx0XHRpZiAoIGluZGV4ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHR2YXIgdHlwZWRBcnJheSA9IG5ldyBUWVBFRF9BUlJBWVNbIGluZGV4LnR5cGUgXSggaW5kZXguYXJyYXkgKTtcbiAgICBcdFx0XHRnZW9tZXRyeS5zZXRJbmRleCggbmV3IEJ1ZmZlckF0dHJpYnV0ZSggdHlwZWRBcnJheSwgMSApICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHZhciBhdHRyaWJ1dGVzID0ganNvbi5kYXRhLmF0dHJpYnV0ZXM7XG5cbiAgICBcdFx0Zm9yICggdmFyIGtleSBpbiBhdHRyaWJ1dGVzICkge1xuXG4gICAgXHRcdFx0dmFyIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbIGtleSBdO1xuICAgIFx0XHRcdHZhciB0eXBlZEFycmF5ID0gbmV3IFRZUEVEX0FSUkFZU1sgYXR0cmlidXRlLnR5cGUgXSggYXR0cmlidXRlLmFycmF5ICk7XG5cbiAgICBcdFx0XHRnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoIGtleSwgbmV3IEJ1ZmZlckF0dHJpYnV0ZSggdHlwZWRBcnJheSwgYXR0cmlidXRlLml0ZW1TaXplLCBhdHRyaWJ1dGUubm9ybWFsaXplZCApICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHZhciBncm91cHMgPSBqc29uLmRhdGEuZ3JvdXBzIHx8IGpzb24uZGF0YS5kcmF3Y2FsbHMgfHwganNvbi5kYXRhLm9mZnNldHM7XG5cbiAgICBcdFx0aWYgKCBncm91cHMgIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdGZvciAoIHZhciBpID0gMCwgbiA9IGdyb3Vwcy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cbiAgICBcdFx0XHRcdHZhciBncm91cCA9IGdyb3Vwc1sgaSBdO1xuXG4gICAgXHRcdFx0XHRnZW9tZXRyeS5hZGRHcm91cCggZ3JvdXAuc3RhcnQsIGdyb3VwLmNvdW50LCBncm91cC5tYXRlcmlhbEluZGV4ICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHZhciBib3VuZGluZ1NwaGVyZSA9IGpzb24uZGF0YS5ib3VuZGluZ1NwaGVyZTtcblxuICAgIFx0XHRpZiAoIGJvdW5kaW5nU3BoZXJlICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHR2YXIgY2VudGVyID0gbmV3IFZlY3RvcjMoKTtcblxuICAgIFx0XHRcdGlmICggYm91bmRpbmdTcGhlcmUuY2VudGVyICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRcdGNlbnRlci5mcm9tQXJyYXkoIGJvdW5kaW5nU3BoZXJlLmNlbnRlciApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0Z2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgPSBuZXcgU3BoZXJlKCBjZW50ZXIsIGJvdW5kaW5nU3BoZXJlLnJhZGl1cyApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gZ2VvbWV0cnk7XG5cbiAgICBcdH1cblxuICAgIH0gKTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBMb2FkZXIoKSB7XG5cbiAgICBcdHRoaXMub25Mb2FkU3RhcnQgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICBcdHRoaXMub25Mb2FkUHJvZ3Jlc3MgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICBcdHRoaXMub25Mb2FkQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIH1cblxuICAgIExvYWRlci5wcm90b3R5cGUgPSB7XG5cbiAgICBcdGNvbnN0cnVjdG9yOiBMb2FkZXIsXG5cbiAgICBcdGNyb3NzT3JpZ2luOiB1bmRlZmluZWQsXG5cbiAgICBcdGV4dHJhY3RVcmxCYXNlOiBmdW5jdGlvbiAoIHVybCApIHtcblxuICAgIFx0XHR2YXIgcGFydHMgPSB1cmwuc3BsaXQoICcvJyApO1xuXG4gICAgXHRcdGlmICggcGFydHMubGVuZ3RoID09PSAxICkgcmV0dXJuICcuLyc7XG5cbiAgICBcdFx0cGFydHMucG9wKCk7XG5cbiAgICBcdFx0cmV0dXJuIHBhcnRzLmpvaW4oICcvJyApICsgJy8nO1xuXG4gICAgXHR9LFxuXG4gICAgXHRpbml0TWF0ZXJpYWxzOiBmdW5jdGlvbiAoIG1hdGVyaWFscywgdGV4dHVyZVBhdGgsIGNyb3NzT3JpZ2luICkge1xuXG4gICAgXHRcdHZhciBhcnJheSA9IFtdO1xuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IG1hdGVyaWFscy5sZW5ndGg7ICsrIGkgKSB7XG5cbiAgICBcdFx0XHRhcnJheVsgaSBdID0gdGhpcy5jcmVhdGVNYXRlcmlhbCggbWF0ZXJpYWxzWyBpIF0sIHRleHR1cmVQYXRoLCBjcm9zc09yaWdpbiApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gYXJyYXk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGNyZWF0ZU1hdGVyaWFsOiAoIGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR2YXIgY29sb3IsIHRleHR1cmVMb2FkZXIsIG1hdGVyaWFsTG9hZGVyO1xuXG4gICAgXHRcdHJldHVybiBmdW5jdGlvbiBjcmVhdGVNYXRlcmlhbCggbSwgdGV4dHVyZVBhdGgsIGNyb3NzT3JpZ2luICkge1xuXG4gICAgXHRcdFx0aWYgKCBjb2xvciA9PT0gdW5kZWZpbmVkICkgY29sb3IgPSBuZXcgQ29sb3IoKTtcbiAgICBcdFx0XHRpZiAoIHRleHR1cmVMb2FkZXIgPT09IHVuZGVmaW5lZCApIHRleHR1cmVMb2FkZXIgPSBuZXcgVGV4dHVyZUxvYWRlcigpO1xuICAgIFx0XHRcdGlmICggbWF0ZXJpYWxMb2FkZXIgPT09IHVuZGVmaW5lZCApIG1hdGVyaWFsTG9hZGVyID0gbmV3IE1hdGVyaWFsTG9hZGVyKCk7XG5cbiAgICBcdFx0XHQvLyBjb252ZXJ0IGZyb20gb2xkIG1hdGVyaWFsIGZvcm1hdFxuXG4gICAgXHRcdFx0dmFyIHRleHR1cmVzID0ge307XG5cbiAgICBcdFx0XHRmdW5jdGlvbiBsb2FkVGV4dHVyZSggcGF0aCwgcmVwZWF0LCBvZmZzZXQsIHdyYXAsIGFuaXNvdHJvcHkgKSB7XG5cbiAgICBcdFx0XHRcdHZhciBmdWxsUGF0aCA9IHRleHR1cmVQYXRoICsgcGF0aDtcbiAgICBcdFx0XHRcdHZhciBsb2FkZXIgPSBMb2FkZXIuSGFuZGxlcnMuZ2V0KCBmdWxsUGF0aCApO1xuXG4gICAgXHRcdFx0XHR2YXIgdGV4dHVyZTtcblxuICAgIFx0XHRcdFx0aWYgKCBsb2FkZXIgIT09IG51bGwgKSB7XG5cbiAgICBcdFx0XHRcdFx0dGV4dHVyZSA9IGxvYWRlci5sb2FkKCBmdWxsUGF0aCApO1xuXG4gICAgXHRcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRcdHRleHR1cmVMb2FkZXIuc2V0Q3Jvc3NPcmlnaW4oIGNyb3NzT3JpZ2luICk7XG4gICAgXHRcdFx0XHRcdHRleHR1cmUgPSB0ZXh0dXJlTG9hZGVyLmxvYWQoIGZ1bGxQYXRoICk7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0aWYgKCByZXBlYXQgIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0XHR0ZXh0dXJlLnJlcGVhdC5mcm9tQXJyYXkoIHJlcGVhdCApO1xuXG4gICAgXHRcdFx0XHRcdGlmICggcmVwZWF0WyAwIF0gIT09IDEgKSB0ZXh0dXJlLndyYXBTID0gUmVwZWF0V3JhcHBpbmc7XG4gICAgXHRcdFx0XHRcdGlmICggcmVwZWF0WyAxIF0gIT09IDEgKSB0ZXh0dXJlLndyYXBUID0gUmVwZWF0V3JhcHBpbmc7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0aWYgKCBvZmZzZXQgIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0XHR0ZXh0dXJlLm9mZnNldC5mcm9tQXJyYXkoIG9mZnNldCApO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdGlmICggd3JhcCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0XHRcdGlmICggd3JhcFsgMCBdID09PSAncmVwZWF0JyApIHRleHR1cmUud3JhcFMgPSBSZXBlYXRXcmFwcGluZztcbiAgICBcdFx0XHRcdFx0aWYgKCB3cmFwWyAwIF0gPT09ICdtaXJyb3InICkgdGV4dHVyZS53cmFwUyA9IE1pcnJvcmVkUmVwZWF0V3JhcHBpbmc7XG5cbiAgICBcdFx0XHRcdFx0aWYgKCB3cmFwWyAxIF0gPT09ICdyZXBlYXQnICkgdGV4dHVyZS53cmFwVCA9IFJlcGVhdFdyYXBwaW5nO1xuICAgIFx0XHRcdFx0XHRpZiAoIHdyYXBbIDEgXSA9PT0gJ21pcnJvcicgKSB0ZXh0dXJlLndyYXBUID0gTWlycm9yZWRSZXBlYXRXcmFwcGluZztcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRpZiAoIGFuaXNvdHJvcHkgIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0XHR0ZXh0dXJlLmFuaXNvdHJvcHkgPSBhbmlzb3Ryb3B5O1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdHZhciB1dWlkID0gZXhwb3J0cy5NYXRoLmdlbmVyYXRlVVVJRCgpO1xuXG4gICAgXHRcdFx0XHR0ZXh0dXJlc1sgdXVpZCBdID0gdGV4dHVyZTtcblxuICAgIFx0XHRcdFx0cmV0dXJuIHV1aWQ7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHQvL1xuXG4gICAgXHRcdFx0dmFyIGpzb24gPSB7XG4gICAgXHRcdFx0XHR1dWlkOiBleHBvcnRzLk1hdGguZ2VuZXJhdGVVVUlEKCksXG4gICAgXHRcdFx0XHR0eXBlOiAnTWVzaExhbWJlcnRNYXRlcmlhbCdcbiAgICBcdFx0XHR9O1xuXG4gICAgXHRcdFx0Zm9yICggdmFyIG5hbWUgaW4gbSApIHtcblxuICAgIFx0XHRcdFx0dmFyIHZhbHVlID0gbVsgbmFtZSBdO1xuXG4gICAgXHRcdFx0XHRzd2l0Y2ggKCBuYW1lICkge1xuICAgIFx0XHRcdFx0XHRjYXNlICdEYmdDb2xvcic6XG4gICAgXHRcdFx0XHRcdGNhc2UgJ0RiZ0luZGV4JzpcbiAgICBcdFx0XHRcdFx0Y2FzZSAnb3B0aWNhbERlbnNpdHknOlxuICAgIFx0XHRcdFx0XHRjYXNlICdpbGx1bWluYXRpb24nOlxuICAgIFx0XHRcdFx0XHRcdGJyZWFrO1xuICAgIFx0XHRcdFx0XHRjYXNlICdEYmdOYW1lJzpcbiAgICBcdFx0XHRcdFx0XHRqc29uLm5hbWUgPSB2YWx1ZTtcbiAgICBcdFx0XHRcdFx0XHRicmVhaztcbiAgICBcdFx0XHRcdFx0Y2FzZSAnYmxlbmRpbmcnOlxuICAgIFx0XHRcdFx0XHRcdGpzb24uYmxlbmRpbmcgPSBCbGVuZGluZ01vZGVbIHZhbHVlIF07XG4gICAgXHRcdFx0XHRcdFx0YnJlYWs7XG4gICAgXHRcdFx0XHRcdGNhc2UgJ2NvbG9yQW1iaWVudCc6XG4gICAgXHRcdFx0XHRcdGNhc2UgJ21hcEFtYmllbnQnOlxuICAgIFx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkxvYWRlci5jcmVhdGVNYXRlcmlhbDonLCBuYW1lLCAnaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZC4nICk7XG4gICAgXHRcdFx0XHRcdFx0YnJlYWs7XG4gICAgXHRcdFx0XHRcdGNhc2UgJ2NvbG9yRGlmZnVzZSc6XG4gICAgXHRcdFx0XHRcdFx0anNvbi5jb2xvciA9IGNvbG9yLmZyb21BcnJheSggdmFsdWUgKS5nZXRIZXgoKTtcbiAgICBcdFx0XHRcdFx0XHRicmVhaztcbiAgICBcdFx0XHRcdFx0Y2FzZSAnY29sb3JTcGVjdWxhcic6XG4gICAgXHRcdFx0XHRcdFx0anNvbi5zcGVjdWxhciA9IGNvbG9yLmZyb21BcnJheSggdmFsdWUgKS5nZXRIZXgoKTtcbiAgICBcdFx0XHRcdFx0XHRicmVhaztcbiAgICBcdFx0XHRcdFx0Y2FzZSAnY29sb3JFbWlzc2l2ZSc6XG4gICAgXHRcdFx0XHRcdFx0anNvbi5lbWlzc2l2ZSA9IGNvbG9yLmZyb21BcnJheSggdmFsdWUgKS5nZXRIZXgoKTtcbiAgICBcdFx0XHRcdFx0XHRicmVhaztcbiAgICBcdFx0XHRcdFx0Y2FzZSAnc3BlY3VsYXJDb2VmJzpcbiAgICBcdFx0XHRcdFx0XHRqc29uLnNoaW5pbmVzcyA9IHZhbHVlO1xuICAgIFx0XHRcdFx0XHRcdGJyZWFrO1xuICAgIFx0XHRcdFx0XHRjYXNlICdzaGFkaW5nJzpcbiAgICBcdFx0XHRcdFx0XHRpZiAoIHZhbHVlLnRvTG93ZXJDYXNlKCkgPT09ICdiYXNpYycgKSBqc29uLnR5cGUgPSAnTWVzaEJhc2ljTWF0ZXJpYWwnO1xuICAgIFx0XHRcdFx0XHRcdGlmICggdmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gJ3Bob25nJyApIGpzb24udHlwZSA9ICdNZXNoUGhvbmdNYXRlcmlhbCc7XG4gICAgXHRcdFx0XHRcdFx0aWYgKCB2YWx1ZS50b0xvd2VyQ2FzZSgpID09PSAnc3RhbmRhcmQnICkganNvbi50eXBlID0gJ01lc2hTdGFuZGFyZE1hdGVyaWFsJztcbiAgICBcdFx0XHRcdFx0XHRicmVhaztcbiAgICBcdFx0XHRcdFx0Y2FzZSAnbWFwRGlmZnVzZSc6XG4gICAgXHRcdFx0XHRcdFx0anNvbi5tYXAgPSBsb2FkVGV4dHVyZSggdmFsdWUsIG0ubWFwRGlmZnVzZVJlcGVhdCwgbS5tYXBEaWZmdXNlT2Zmc2V0LCBtLm1hcERpZmZ1c2VXcmFwLCBtLm1hcERpZmZ1c2VBbmlzb3Ryb3B5ICk7XG4gICAgXHRcdFx0XHRcdFx0YnJlYWs7XG4gICAgXHRcdFx0XHRcdGNhc2UgJ21hcERpZmZ1c2VSZXBlYXQnOlxuICAgIFx0XHRcdFx0XHRjYXNlICdtYXBEaWZmdXNlT2Zmc2V0JzpcbiAgICBcdFx0XHRcdFx0Y2FzZSAnbWFwRGlmZnVzZVdyYXAnOlxuICAgIFx0XHRcdFx0XHRjYXNlICdtYXBEaWZmdXNlQW5pc290cm9weSc6XG4gICAgXHRcdFx0XHRcdFx0YnJlYWs7XG4gICAgXHRcdFx0XHRcdGNhc2UgJ21hcEVtaXNzaXZlJzpcbiAgICBcdFx0XHRcdFx0XHRqc29uLmVtaXNzaXZlTWFwID0gbG9hZFRleHR1cmUoIHZhbHVlLCBtLm1hcEVtaXNzaXZlUmVwZWF0LCBtLm1hcEVtaXNzaXZlT2Zmc2V0LCBtLm1hcEVtaXNzaXZlV3JhcCwgbS5tYXBFbWlzc2l2ZUFuaXNvdHJvcHkgKTtcbiAgICBcdFx0XHRcdFx0XHRicmVhaztcbiAgICBcdFx0XHRcdFx0Y2FzZSAnbWFwRW1pc3NpdmVSZXBlYXQnOlxuICAgIFx0XHRcdFx0XHRjYXNlICdtYXBFbWlzc2l2ZU9mZnNldCc6XG4gICAgXHRcdFx0XHRcdGNhc2UgJ21hcEVtaXNzaXZlV3JhcCc6XG4gICAgXHRcdFx0XHRcdGNhc2UgJ21hcEVtaXNzaXZlQW5pc290cm9weSc6XG4gICAgXHRcdFx0XHRcdFx0YnJlYWs7XG4gICAgXHRcdFx0XHRcdGNhc2UgJ21hcExpZ2h0JzpcbiAgICBcdFx0XHRcdFx0XHRqc29uLmxpZ2h0TWFwID0gbG9hZFRleHR1cmUoIHZhbHVlLCBtLm1hcExpZ2h0UmVwZWF0LCBtLm1hcExpZ2h0T2Zmc2V0LCBtLm1hcExpZ2h0V3JhcCwgbS5tYXBMaWdodEFuaXNvdHJvcHkgKTtcbiAgICBcdFx0XHRcdFx0XHRicmVhaztcbiAgICBcdFx0XHRcdFx0Y2FzZSAnbWFwTGlnaHRSZXBlYXQnOlxuICAgIFx0XHRcdFx0XHRjYXNlICdtYXBMaWdodE9mZnNldCc6XG4gICAgXHRcdFx0XHRcdGNhc2UgJ21hcExpZ2h0V3JhcCc6XG4gICAgXHRcdFx0XHRcdGNhc2UgJ21hcExpZ2h0QW5pc290cm9weSc6XG4gICAgXHRcdFx0XHRcdFx0YnJlYWs7XG4gICAgXHRcdFx0XHRcdGNhc2UgJ21hcEFPJzpcbiAgICBcdFx0XHRcdFx0XHRqc29uLmFvTWFwID0gbG9hZFRleHR1cmUoIHZhbHVlLCBtLm1hcEFPUmVwZWF0LCBtLm1hcEFPT2Zmc2V0LCBtLm1hcEFPV3JhcCwgbS5tYXBBT0FuaXNvdHJvcHkgKTtcbiAgICBcdFx0XHRcdFx0XHRicmVhaztcbiAgICBcdFx0XHRcdFx0Y2FzZSAnbWFwQU9SZXBlYXQnOlxuICAgIFx0XHRcdFx0XHRjYXNlICdtYXBBT09mZnNldCc6XG4gICAgXHRcdFx0XHRcdGNhc2UgJ21hcEFPV3JhcCc6XG4gICAgXHRcdFx0XHRcdGNhc2UgJ21hcEFPQW5pc290cm9weSc6XG4gICAgXHRcdFx0XHRcdFx0YnJlYWs7XG4gICAgXHRcdFx0XHRcdGNhc2UgJ21hcEJ1bXAnOlxuICAgIFx0XHRcdFx0XHRcdGpzb24uYnVtcE1hcCA9IGxvYWRUZXh0dXJlKCB2YWx1ZSwgbS5tYXBCdW1wUmVwZWF0LCBtLm1hcEJ1bXBPZmZzZXQsIG0ubWFwQnVtcFdyYXAsIG0ubWFwQnVtcEFuaXNvdHJvcHkgKTtcbiAgICBcdFx0XHRcdFx0XHRicmVhaztcbiAgICBcdFx0XHRcdFx0Y2FzZSAnbWFwQnVtcFNjYWxlJzpcbiAgICBcdFx0XHRcdFx0XHRqc29uLmJ1bXBTY2FsZSA9IHZhbHVlO1xuICAgIFx0XHRcdFx0XHRcdGJyZWFrO1xuICAgIFx0XHRcdFx0XHRjYXNlICdtYXBCdW1wUmVwZWF0JzpcbiAgICBcdFx0XHRcdFx0Y2FzZSAnbWFwQnVtcE9mZnNldCc6XG4gICAgXHRcdFx0XHRcdGNhc2UgJ21hcEJ1bXBXcmFwJzpcbiAgICBcdFx0XHRcdFx0Y2FzZSAnbWFwQnVtcEFuaXNvdHJvcHknOlxuICAgIFx0XHRcdFx0XHRcdGJyZWFrO1xuICAgIFx0XHRcdFx0XHRjYXNlICdtYXBOb3JtYWwnOlxuICAgIFx0XHRcdFx0XHRcdGpzb24ubm9ybWFsTWFwID0gbG9hZFRleHR1cmUoIHZhbHVlLCBtLm1hcE5vcm1hbFJlcGVhdCwgbS5tYXBOb3JtYWxPZmZzZXQsIG0ubWFwTm9ybWFsV3JhcCwgbS5tYXBOb3JtYWxBbmlzb3Ryb3B5ICk7XG4gICAgXHRcdFx0XHRcdFx0YnJlYWs7XG4gICAgXHRcdFx0XHRcdGNhc2UgJ21hcE5vcm1hbEZhY3Rvcic6XG4gICAgXHRcdFx0XHRcdFx0anNvbi5ub3JtYWxTY2FsZSA9IFsgdmFsdWUsIHZhbHVlIF07XG4gICAgXHRcdFx0XHRcdFx0YnJlYWs7XG4gICAgXHRcdFx0XHRcdGNhc2UgJ21hcE5vcm1hbFJlcGVhdCc6XG4gICAgXHRcdFx0XHRcdGNhc2UgJ21hcE5vcm1hbE9mZnNldCc6XG4gICAgXHRcdFx0XHRcdGNhc2UgJ21hcE5vcm1hbFdyYXAnOlxuICAgIFx0XHRcdFx0XHRjYXNlICdtYXBOb3JtYWxBbmlzb3Ryb3B5JzpcbiAgICBcdFx0XHRcdFx0XHRicmVhaztcbiAgICBcdFx0XHRcdFx0Y2FzZSAnbWFwU3BlY3VsYXInOlxuICAgIFx0XHRcdFx0XHRcdGpzb24uc3BlY3VsYXJNYXAgPSBsb2FkVGV4dHVyZSggdmFsdWUsIG0ubWFwU3BlY3VsYXJSZXBlYXQsIG0ubWFwU3BlY3VsYXJPZmZzZXQsIG0ubWFwU3BlY3VsYXJXcmFwLCBtLm1hcFNwZWN1bGFyQW5pc290cm9weSApO1xuICAgIFx0XHRcdFx0XHRcdGJyZWFrO1xuICAgIFx0XHRcdFx0XHRjYXNlICdtYXBTcGVjdWxhclJlcGVhdCc6XG4gICAgXHRcdFx0XHRcdGNhc2UgJ21hcFNwZWN1bGFyT2Zmc2V0JzpcbiAgICBcdFx0XHRcdFx0Y2FzZSAnbWFwU3BlY3VsYXJXcmFwJzpcbiAgICBcdFx0XHRcdFx0Y2FzZSAnbWFwU3BlY3VsYXJBbmlzb3Ryb3B5JzpcbiAgICBcdFx0XHRcdFx0XHRicmVhaztcbiAgICBcdFx0XHRcdFx0Y2FzZSAnbWFwTWV0YWxuZXNzJzpcbiAgICBcdFx0XHRcdFx0XHRqc29uLm1ldGFsbmVzc01hcCA9IGxvYWRUZXh0dXJlKCB2YWx1ZSwgbS5tYXBNZXRhbG5lc3NSZXBlYXQsIG0ubWFwTWV0YWxuZXNzT2Zmc2V0LCBtLm1hcE1ldGFsbmVzc1dyYXAsIG0ubWFwTWV0YWxuZXNzQW5pc290cm9weSApO1xuICAgIFx0XHRcdFx0XHRcdGJyZWFrO1xuICAgIFx0XHRcdFx0XHRjYXNlICdtYXBNZXRhbG5lc3NSZXBlYXQnOlxuICAgIFx0XHRcdFx0XHRjYXNlICdtYXBNZXRhbG5lc3NPZmZzZXQnOlxuICAgIFx0XHRcdFx0XHRjYXNlICdtYXBNZXRhbG5lc3NXcmFwJzpcbiAgICBcdFx0XHRcdFx0Y2FzZSAnbWFwTWV0YWxuZXNzQW5pc290cm9weSc6XG4gICAgXHRcdFx0XHRcdFx0YnJlYWs7XG4gICAgXHRcdFx0XHRcdGNhc2UgJ21hcFJvdWdobmVzcyc6XG4gICAgXHRcdFx0XHRcdFx0anNvbi5yb3VnaG5lc3NNYXAgPSBsb2FkVGV4dHVyZSggdmFsdWUsIG0ubWFwUm91Z2huZXNzUmVwZWF0LCBtLm1hcFJvdWdobmVzc09mZnNldCwgbS5tYXBSb3VnaG5lc3NXcmFwLCBtLm1hcFJvdWdobmVzc0FuaXNvdHJvcHkgKTtcbiAgICBcdFx0XHRcdFx0XHRicmVhaztcbiAgICBcdFx0XHRcdFx0Y2FzZSAnbWFwUm91Z2huZXNzUmVwZWF0JzpcbiAgICBcdFx0XHRcdFx0Y2FzZSAnbWFwUm91Z2huZXNzT2Zmc2V0JzpcbiAgICBcdFx0XHRcdFx0Y2FzZSAnbWFwUm91Z2huZXNzV3JhcCc6XG4gICAgXHRcdFx0XHRcdGNhc2UgJ21hcFJvdWdobmVzc0FuaXNvdHJvcHknOlxuICAgIFx0XHRcdFx0XHRcdGJyZWFrO1xuICAgIFx0XHRcdFx0XHRjYXNlICdtYXBBbHBoYSc6XG4gICAgXHRcdFx0XHRcdFx0anNvbi5hbHBoYU1hcCA9IGxvYWRUZXh0dXJlKCB2YWx1ZSwgbS5tYXBBbHBoYVJlcGVhdCwgbS5tYXBBbHBoYU9mZnNldCwgbS5tYXBBbHBoYVdyYXAsIG0ubWFwQWxwaGFBbmlzb3Ryb3B5ICk7XG4gICAgXHRcdFx0XHRcdFx0YnJlYWs7XG4gICAgXHRcdFx0XHRcdGNhc2UgJ21hcEFscGhhUmVwZWF0JzpcbiAgICBcdFx0XHRcdFx0Y2FzZSAnbWFwQWxwaGFPZmZzZXQnOlxuICAgIFx0XHRcdFx0XHRjYXNlICdtYXBBbHBoYVdyYXAnOlxuICAgIFx0XHRcdFx0XHRjYXNlICdtYXBBbHBoYUFuaXNvdHJvcHknOlxuICAgIFx0XHRcdFx0XHRcdGJyZWFrO1xuICAgIFx0XHRcdFx0XHRjYXNlICdmbGlwU2lkZWQnOlxuICAgIFx0XHRcdFx0XHRcdGpzb24uc2lkZSA9IEJhY2tTaWRlO1xuICAgIFx0XHRcdFx0XHRcdGJyZWFrO1xuICAgIFx0XHRcdFx0XHRjYXNlICdkb3VibGVTaWRlZCc6XG4gICAgXHRcdFx0XHRcdFx0anNvbi5zaWRlID0gRG91YmxlU2lkZTtcbiAgICBcdFx0XHRcdFx0XHRicmVhaztcbiAgICBcdFx0XHRcdFx0Y2FzZSAndHJhbnNwYXJlbmN5JzpcbiAgICBcdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Mb2FkZXIuY3JlYXRlTWF0ZXJpYWw6IHRyYW5zcGFyZW5jeSBoYXMgYmVlbiByZW5hbWVkIHRvIG9wYWNpdHknICk7XG4gICAgXHRcdFx0XHRcdFx0anNvbi5vcGFjaXR5ID0gdmFsdWU7XG4gICAgXHRcdFx0XHRcdFx0YnJlYWs7XG4gICAgXHRcdFx0XHRcdGNhc2UgJ2RlcHRoVGVzdCc6XG4gICAgXHRcdFx0XHRcdGNhc2UgJ2RlcHRoV3JpdGUnOlxuICAgIFx0XHRcdFx0XHRjYXNlICdjb2xvcldyaXRlJzpcbiAgICBcdFx0XHRcdFx0Y2FzZSAnb3BhY2l0eSc6XG4gICAgXHRcdFx0XHRcdGNhc2UgJ3JlZmxlY3Rpdml0eSc6XG4gICAgXHRcdFx0XHRcdGNhc2UgJ3RyYW5zcGFyZW50JzpcbiAgICBcdFx0XHRcdFx0Y2FzZSAndmlzaWJsZSc6XG4gICAgXHRcdFx0XHRcdGNhc2UgJ3dpcmVmcmFtZSc6XG4gICAgXHRcdFx0XHRcdFx0anNvblsgbmFtZSBdID0gdmFsdWU7XG4gICAgXHRcdFx0XHRcdFx0YnJlYWs7XG4gICAgXHRcdFx0XHRcdGNhc2UgJ3ZlcnRleENvbG9ycyc6XG4gICAgXHRcdFx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gdHJ1ZSApIGpzb24udmVydGV4Q29sb3JzID0gVmVydGV4Q29sb3JzO1xuICAgIFx0XHRcdFx0XHRcdGlmICggdmFsdWUgPT09ICdmYWNlJyApIGpzb24udmVydGV4Q29sb3JzID0gRmFjZUNvbG9ycztcbiAgICBcdFx0XHRcdFx0XHRicmVhaztcbiAgICBcdFx0XHRcdFx0ZGVmYXVsdDpcbiAgICBcdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuTG9hZGVyLmNyZWF0ZU1hdGVyaWFsOiBVbnN1cHBvcnRlZCcsIG5hbWUsIHZhbHVlICk7XG4gICAgXHRcdFx0XHRcdFx0YnJlYWs7XG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRpZiAoIGpzb24udHlwZSA9PT0gJ01lc2hCYXNpY01hdGVyaWFsJyApIGRlbGV0ZSBqc29uLmVtaXNzaXZlO1xuICAgIFx0XHRcdGlmICgganNvbi50eXBlICE9PSAnTWVzaFBob25nTWF0ZXJpYWwnICkgZGVsZXRlIGpzb24uc3BlY3VsYXI7XG5cbiAgICBcdFx0XHRpZiAoIGpzb24ub3BhY2l0eSA8IDEgKSBqc29uLnRyYW5zcGFyZW50ID0gdHJ1ZTtcblxuICAgIFx0XHRcdG1hdGVyaWFsTG9hZGVyLnNldFRleHR1cmVzKCB0ZXh0dXJlcyApO1xuXG4gICAgXHRcdFx0cmV0dXJuIG1hdGVyaWFsTG9hZGVyLnBhcnNlKCBqc29uICk7XG5cbiAgICBcdFx0fTtcblxuICAgIFx0fSApKClcblxuICAgIH07XG5cbiAgICBMb2FkZXIuSGFuZGxlcnMgPSB7XG5cbiAgICBcdGhhbmRsZXJzOiBbXSxcblxuICAgIFx0YWRkOiBmdW5jdGlvbiAoIHJlZ2V4LCBsb2FkZXIgKSB7XG5cbiAgICBcdFx0dGhpcy5oYW5kbGVycy5wdXNoKCByZWdleCwgbG9hZGVyICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGdldDogZnVuY3Rpb24gKCBmaWxlICkge1xuXG4gICAgXHRcdHZhciBoYW5kbGVycyA9IHRoaXMuaGFuZGxlcnM7XG5cbiAgICBcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gaGFuZGxlcnMubGVuZ3RoOyBpIDwgbDsgaSArPSAyICkge1xuXG4gICAgXHRcdFx0dmFyIHJlZ2V4ID0gaGFuZGxlcnNbIGkgXTtcbiAgICBcdFx0XHR2YXIgbG9hZGVyICA9IGhhbmRsZXJzWyBpICsgMSBdO1xuXG4gICAgXHRcdFx0aWYgKCByZWdleC50ZXN0KCBmaWxlICkgKSB7XG5cbiAgICBcdFx0XHRcdHJldHVybiBsb2FkZXI7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiBudWxsO1xuXG4gICAgXHR9XG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAgICAgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gSlNPTkxvYWRlciggbWFuYWdlciApIHtcblxuICAgIFx0aWYgKCB0eXBlb2YgbWFuYWdlciA9PT0gJ2Jvb2xlYW4nICkge1xuXG4gICAgXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkpTT05Mb2FkZXI6IHNob3dTdGF0dXMgcGFyYW1ldGVyIGhhcyBiZWVuIHJlbW92ZWQgZnJvbSBjb25zdHJ1Y3Rvci4nICk7XG4gICAgXHRcdG1hbmFnZXIgPSB1bmRlZmluZWQ7XG5cbiAgICBcdH1cblxuICAgIFx0dGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBleHBvcnRzLkRlZmF1bHRMb2FkaW5nTWFuYWdlcjtcblxuICAgIFx0dGhpcy53aXRoQ3JlZGVudGlhbHMgPSBmYWxzZTtcblxuICAgIH1cblxuICAgIE9iamVjdC5hc3NpZ24oIEpTT05Mb2FkZXIucHJvdG90eXBlLCB7XG5cbiAgICBcdGxvYWQ6IGZ1bmN0aW9uKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcblxuICAgIFx0XHR2YXIgc2NvcGUgPSB0aGlzO1xuXG4gICAgXHRcdHZhciB0ZXh0dXJlUGF0aCA9IHRoaXMudGV4dHVyZVBhdGggJiYgKCB0eXBlb2YgdGhpcy50ZXh0dXJlUGF0aCA9PT0gXCJzdHJpbmdcIiApID8gdGhpcy50ZXh0dXJlUGF0aCA6IExvYWRlci5wcm90b3R5cGUuZXh0cmFjdFVybEJhc2UoIHVybCApO1xuXG4gICAgXHRcdHZhciBsb2FkZXIgPSBuZXcgWEhSTG9hZGVyKCB0aGlzLm1hbmFnZXIgKTtcbiAgICBcdFx0bG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyggdGhpcy53aXRoQ3JlZGVudGlhbHMgKTtcbiAgICBcdFx0bG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCB0ZXh0ICkge1xuXG4gICAgXHRcdFx0dmFyIGpzb24gPSBKU09OLnBhcnNlKCB0ZXh0ICk7XG4gICAgXHRcdFx0dmFyIG1ldGFkYXRhID0ganNvbi5tZXRhZGF0YTtcblxuICAgIFx0XHRcdGlmICggbWV0YWRhdGEgIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0dmFyIHR5cGUgPSBtZXRhZGF0YS50eXBlO1xuXG4gICAgXHRcdFx0XHRpZiAoIHR5cGUgIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0XHRpZiAoIHR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ29iamVjdCcgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuSlNPTkxvYWRlcjogJyArIHVybCArICcgc2hvdWxkIGJlIGxvYWRlZCB3aXRoIFRIUkVFLk9iamVjdExvYWRlciBpbnN0ZWFkLicgKTtcbiAgICBcdFx0XHRcdFx0XHRyZXR1cm47XG5cbiAgICBcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRcdGlmICggdHlwZS50b0xvd2VyQ2FzZSgpID09PSAnc2NlbmUnICkge1xuXG4gICAgXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkpTT05Mb2FkZXI6ICcgKyB1cmwgKyAnIHNob3VsZCBiZSBsb2FkZWQgd2l0aCBUSFJFRS5TY2VuZUxvYWRlciBpbnN0ZWFkLicgKTtcbiAgICBcdFx0XHRcdFx0XHRyZXR1cm47XG5cbiAgICBcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHR2YXIgb2JqZWN0ID0gc2NvcGUucGFyc2UoIGpzb24sIHRleHR1cmVQYXRoICk7XG4gICAgXHRcdFx0b25Mb2FkKCBvYmplY3QuZ2VvbWV0cnksIG9iamVjdC5tYXRlcmlhbHMgKTtcblxuICAgIFx0XHR9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldFRleHR1cmVQYXRoOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG4gICAgXHRcdHRoaXMudGV4dHVyZVBhdGggPSB2YWx1ZTtcblxuICAgIFx0fSxcblxuICAgIFx0cGFyc2U6IGZ1bmN0aW9uICgganNvbiwgdGV4dHVyZVBhdGggKSB7XG5cbiAgICBcdFx0dmFyIGdlb21ldHJ5ID0gbmV3IEdlb21ldHJ5KCksXG4gICAgXHRcdHNjYWxlID0gKCBqc29uLnNjYWxlICE9PSB1bmRlZmluZWQgKSA/IDEuMCAvIGpzb24uc2NhbGUgOiAxLjA7XG5cbiAgICBcdFx0cGFyc2VNb2RlbCggc2NhbGUgKTtcblxuICAgIFx0XHRwYXJzZVNraW4oKTtcbiAgICBcdFx0cGFyc2VNb3JwaGluZyggc2NhbGUgKTtcbiAgICBcdFx0cGFyc2VBbmltYXRpb25zKCk7XG5cbiAgICBcdFx0Z2VvbWV0cnkuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XG4gICAgXHRcdGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuXG4gICAgXHRcdGZ1bmN0aW9uIHBhcnNlTW9kZWwoIHNjYWxlICkge1xuXG4gICAgXHRcdFx0ZnVuY3Rpb24gaXNCaXRTZXQoIHZhbHVlLCBwb3NpdGlvbiApIHtcblxuICAgIFx0XHRcdFx0cmV0dXJuIHZhbHVlICYgKCAxIDw8IHBvc2l0aW9uICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHR2YXIgaSwgaiwgZmksXG5cbiAgICBcdFx0XHRvZmZzZXQsIHpMZW5ndGgsXG5cbiAgICBcdFx0Y29sb3JJbmRleCwgbm9ybWFsSW5kZXgsIHV2SW5kZXgsIG1hdGVyaWFsSW5kZXgsXG5cbiAgICBcdFx0XHR0eXBlLFxuICAgIFx0XHRcdGlzUXVhZCxcbiAgICBcdFx0XHRoYXNNYXRlcmlhbCxcbiAgICBcdFx0XHRoYXNGYWNlVmVydGV4VXYsXG4gICAgXHRcdFx0aGFzRmFjZU5vcm1hbCwgaGFzRmFjZVZlcnRleE5vcm1hbCxcbiAgICBcdFx0XHRoYXNGYWNlQ29sb3IsIGhhc0ZhY2VWZXJ0ZXhDb2xvcixcblxuICAgIFx0XHR2ZXJ0ZXgsIGZhY2UsIGZhY2VBLCBmYWNlQiwgaGV4LCBub3JtYWwsXG5cbiAgICBcdFx0XHR1dkxheWVyLCB1diwgdSwgdixcblxuICAgIFx0XHRcdGZhY2VzID0ganNvbi5mYWNlcyxcbiAgICBcdFx0XHR2ZXJ0aWNlcyA9IGpzb24udmVydGljZXMsXG4gICAgXHRcdFx0bm9ybWFscyA9IGpzb24ubm9ybWFscyxcbiAgICBcdFx0XHRjb2xvcnMgPSBqc29uLmNvbG9ycyxcblxuICAgIFx0XHRcdG5VdkxheWVycyA9IDA7XG5cbiAgICBcdFx0XHRpZiAoIGpzb24udXZzICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRcdC8vIGRpc3JlZ2FyZCBlbXB0eSBhcnJheXNcblxuICAgIFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBqc29uLnV2cy5sZW5ndGg7IGkgKysgKSB7XG5cbiAgICBcdFx0XHRcdFx0aWYgKCBqc29uLnV2c1sgaSBdLmxlbmd0aCApIG5VdkxheWVycyArKztcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IG5VdkxheWVyczsgaSArKyApIHtcblxuICAgIFx0XHRcdFx0XHRnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyBpIF0gPSBbXTtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0b2Zmc2V0ID0gMDtcbiAgICBcdFx0XHR6TGVuZ3RoID0gdmVydGljZXMubGVuZ3RoO1xuXG4gICAgXHRcdFx0d2hpbGUgKCBvZmZzZXQgPCB6TGVuZ3RoICkge1xuXG4gICAgXHRcdFx0XHR2ZXJ0ZXggPSBuZXcgVmVjdG9yMygpO1xuXG4gICAgXHRcdFx0XHR2ZXJ0ZXgueCA9IHZlcnRpY2VzWyBvZmZzZXQgKysgXSAqIHNjYWxlO1xuICAgIFx0XHRcdFx0dmVydGV4LnkgPSB2ZXJ0aWNlc1sgb2Zmc2V0ICsrIF0gKiBzY2FsZTtcbiAgICBcdFx0XHRcdHZlcnRleC56ID0gdmVydGljZXNbIG9mZnNldCArKyBdICogc2NhbGU7XG5cbiAgICBcdFx0XHRcdGdlb21ldHJ5LnZlcnRpY2VzLnB1c2goIHZlcnRleCApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0b2Zmc2V0ID0gMDtcbiAgICBcdFx0XHR6TGVuZ3RoID0gZmFjZXMubGVuZ3RoO1xuXG4gICAgXHRcdFx0d2hpbGUgKCBvZmZzZXQgPCB6TGVuZ3RoICkge1xuXG4gICAgXHRcdFx0XHR0eXBlID0gZmFjZXNbIG9mZnNldCArKyBdO1xuXG5cbiAgICBcdFx0XHRcdGlzUXVhZCAgICAgICAgICAgICAgPSBpc0JpdFNldCggdHlwZSwgMCApO1xuICAgIFx0XHRcdFx0aGFzTWF0ZXJpYWwgICAgICAgICA9IGlzQml0U2V0KCB0eXBlLCAxICk7XG4gICAgXHRcdFx0XHRoYXNGYWNlVmVydGV4VXYgICAgID0gaXNCaXRTZXQoIHR5cGUsIDMgKTtcbiAgICBcdFx0XHRcdGhhc0ZhY2VOb3JtYWwgICAgICAgPSBpc0JpdFNldCggdHlwZSwgNCApO1xuICAgIFx0XHRcdFx0aGFzRmFjZVZlcnRleE5vcm1hbCA9IGlzQml0U2V0KCB0eXBlLCA1ICk7XG4gICAgXHRcdFx0XHRoYXNGYWNlQ29sb3JcdCAgICAgPSBpc0JpdFNldCggdHlwZSwgNiApO1xuICAgIFx0XHRcdFx0aGFzRmFjZVZlcnRleENvbG9yICA9IGlzQml0U2V0KCB0eXBlLCA3ICk7XG5cbiAgICBcdFx0XHRcdC8vIGNvbnNvbGUubG9nKFwidHlwZVwiLCB0eXBlLCBcImJpdHNcIiwgaXNRdWFkLCBoYXNNYXRlcmlhbCwgaGFzRmFjZVZlcnRleFV2LCBoYXNGYWNlTm9ybWFsLCBoYXNGYWNlVmVydGV4Tm9ybWFsLCBoYXNGYWNlQ29sb3IsIGhhc0ZhY2VWZXJ0ZXhDb2xvcik7XG5cbiAgICBcdFx0XHRcdGlmICggaXNRdWFkICkge1xuXG4gICAgXHRcdFx0XHRcdGZhY2VBID0gbmV3IEZhY2UzKCk7XG4gICAgXHRcdFx0XHRcdGZhY2VBLmEgPSBmYWNlc1sgb2Zmc2V0IF07XG4gICAgXHRcdFx0XHRcdGZhY2VBLmIgPSBmYWNlc1sgb2Zmc2V0ICsgMSBdO1xuICAgIFx0XHRcdFx0XHRmYWNlQS5jID0gZmFjZXNbIG9mZnNldCArIDMgXTtcblxuICAgIFx0XHRcdFx0XHRmYWNlQiA9IG5ldyBGYWNlMygpO1xuICAgIFx0XHRcdFx0XHRmYWNlQi5hID0gZmFjZXNbIG9mZnNldCArIDEgXTtcbiAgICBcdFx0XHRcdFx0ZmFjZUIuYiA9IGZhY2VzWyBvZmZzZXQgKyAyIF07XG4gICAgXHRcdFx0XHRcdGZhY2VCLmMgPSBmYWNlc1sgb2Zmc2V0ICsgMyBdO1xuXG4gICAgXHRcdFx0XHRcdG9mZnNldCArPSA0O1xuXG4gICAgXHRcdFx0XHRcdGlmICggaGFzTWF0ZXJpYWwgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHRtYXRlcmlhbEluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdO1xuICAgIFx0XHRcdFx0XHRcdGZhY2VBLm1hdGVyaWFsSW5kZXggPSBtYXRlcmlhbEluZGV4O1xuICAgIFx0XHRcdFx0XHRcdGZhY2VCLm1hdGVyaWFsSW5kZXggPSBtYXRlcmlhbEluZGV4O1xuXG4gICAgXHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0XHQvLyB0byBnZXQgZmFjZSA8PT4gdXYgaW5kZXggY29ycmVzcG9uZGVuY2VcblxuICAgIFx0XHRcdFx0XHRmaSA9IGdlb21ldHJ5LmZhY2VzLmxlbmd0aDtcblxuICAgIFx0XHRcdFx0XHRpZiAoIGhhc0ZhY2VWZXJ0ZXhVdiApIHtcblxuICAgIFx0XHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgblV2TGF5ZXJzOyBpICsrICkge1xuXG4gICAgXHRcdFx0XHRcdFx0XHR1dkxheWVyID0ganNvbi51dnNbIGkgXTtcblxuICAgIFx0XHRcdFx0XHRcdFx0Z2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgaSBdWyBmaSBdID0gW107XG4gICAgXHRcdFx0XHRcdFx0XHRnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyBpIF1bIGZpICsgMSBdID0gW107XG5cbiAgICBcdFx0XHRcdFx0XHRcdGZvciAoIGogPSAwOyBqIDwgNDsgaiArKyApIHtcblxuICAgIFx0XHRcdFx0XHRcdFx0XHR1dkluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdO1xuXG4gICAgXHRcdFx0XHRcdFx0XHRcdHUgPSB1dkxheWVyWyB1dkluZGV4ICogMiBdO1xuICAgIFx0XHRcdFx0XHRcdFx0XHR2ID0gdXZMYXllclsgdXZJbmRleCAqIDIgKyAxIF07XG5cbiAgICBcdFx0XHRcdFx0XHRcdFx0dXYgPSBuZXcgVmVjdG9yMiggdSwgdiApO1xuXG4gICAgXHRcdFx0XHRcdFx0XHRcdGlmICggaiAhPT0gMiApIGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIGkgXVsgZmkgXS5wdXNoKCB1diApO1xuICAgIFx0XHRcdFx0XHRcdFx0XHRpZiAoIGogIT09IDAgKSBnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyBpIF1bIGZpICsgMSBdLnB1c2goIHV2ICk7XG5cbiAgICBcdFx0XHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdFx0aWYgKCBoYXNGYWNlTm9ybWFsICkge1xuXG4gICAgXHRcdFx0XHRcdFx0bm9ybWFsSW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF0gKiAzO1xuXG4gICAgXHRcdFx0XHRcdFx0ZmFjZUEubm9ybWFsLnNldChcbiAgICBcdFx0XHRcdFx0XHRcdG5vcm1hbHNbIG5vcm1hbEluZGV4ICsrIF0sXG4gICAgXHRcdFx0XHRcdFx0XHRub3JtYWxzWyBub3JtYWxJbmRleCArKyBdLFxuICAgIFx0XHRcdFx0XHRcdFx0bm9ybWFsc1sgbm9ybWFsSW5kZXggXVxuICAgIFx0XHRcdFx0XHRcdCk7XG5cbiAgICBcdFx0XHRcdFx0XHRmYWNlQi5ub3JtYWwuY29weSggZmFjZUEubm9ybWFsICk7XG5cbiAgICBcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRcdGlmICggaGFzRmFjZVZlcnRleE5vcm1hbCApIHtcblxuICAgIFx0XHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgNDsgaSArKyApIHtcblxuICAgIFx0XHRcdFx0XHRcdFx0bm9ybWFsSW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF0gKiAzO1xuXG4gICAgXHRcdFx0XHRcdFx0XHRub3JtYWwgPSBuZXcgVmVjdG9yMyhcbiAgICBcdFx0XHRcdFx0XHRcdFx0bm9ybWFsc1sgbm9ybWFsSW5kZXggKysgXSxcbiAgICBcdFx0XHRcdFx0XHRcdFx0bm9ybWFsc1sgbm9ybWFsSW5kZXggKysgXSxcbiAgICBcdFx0XHRcdFx0XHRcdFx0bm9ybWFsc1sgbm9ybWFsSW5kZXggXVxuICAgIFx0XHRcdFx0XHRcdFx0KTtcblxuXG4gICAgXHRcdFx0XHRcdFx0XHRpZiAoIGkgIT09IDIgKSBmYWNlQS52ZXJ0ZXhOb3JtYWxzLnB1c2goIG5vcm1hbCApO1xuICAgIFx0XHRcdFx0XHRcdFx0aWYgKCBpICE9PSAwICkgZmFjZUIudmVydGV4Tm9ybWFscy5wdXNoKCBub3JtYWwgKTtcblxuICAgIFx0XHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0XHR9XG5cblxuICAgIFx0XHRcdFx0XHRpZiAoIGhhc0ZhY2VDb2xvciApIHtcblxuICAgIFx0XHRcdFx0XHRcdGNvbG9ySW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF07XG4gICAgXHRcdFx0XHRcdFx0aGV4ID0gY29sb3JzWyBjb2xvckluZGV4IF07XG5cbiAgICBcdFx0XHRcdFx0XHRmYWNlQS5jb2xvci5zZXRIZXgoIGhleCApO1xuICAgIFx0XHRcdFx0XHRcdGZhY2VCLmNvbG9yLnNldEhleCggaGV4ICk7XG5cbiAgICBcdFx0XHRcdFx0fVxuXG5cbiAgICBcdFx0XHRcdFx0aWYgKCBoYXNGYWNlVmVydGV4Q29sb3IgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IDQ7IGkgKysgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHRcdGNvbG9ySW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF07XG4gICAgXHRcdFx0XHRcdFx0XHRoZXggPSBjb2xvcnNbIGNvbG9ySW5kZXggXTtcblxuICAgIFx0XHRcdFx0XHRcdFx0aWYgKCBpICE9PSAyICkgZmFjZUEudmVydGV4Q29sb3JzLnB1c2goIG5ldyBDb2xvciggaGV4ICkgKTtcbiAgICBcdFx0XHRcdFx0XHRcdGlmICggaSAhPT0gMCApIGZhY2VCLnZlcnRleENvbG9ycy5wdXNoKCBuZXcgQ29sb3IoIGhleCApICk7XG5cbiAgICBcdFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRcdGdlb21ldHJ5LmZhY2VzLnB1c2goIGZhY2VBICk7XG4gICAgXHRcdFx0XHRcdGdlb21ldHJ5LmZhY2VzLnB1c2goIGZhY2VCICk7XG5cbiAgICBcdFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdFx0ZmFjZSA9IG5ldyBGYWNlMygpO1xuICAgIFx0XHRcdFx0XHRmYWNlLmEgPSBmYWNlc1sgb2Zmc2V0ICsrIF07XG4gICAgXHRcdFx0XHRcdGZhY2UuYiA9IGZhY2VzWyBvZmZzZXQgKysgXTtcbiAgICBcdFx0XHRcdFx0ZmFjZS5jID0gZmFjZXNbIG9mZnNldCArKyBdO1xuXG4gICAgXHRcdFx0XHRcdGlmICggaGFzTWF0ZXJpYWwgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHRtYXRlcmlhbEluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdO1xuICAgIFx0XHRcdFx0XHRcdGZhY2UubWF0ZXJpYWxJbmRleCA9IG1hdGVyaWFsSW5kZXg7XG5cbiAgICBcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRcdC8vIHRvIGdldCBmYWNlIDw9PiB1diBpbmRleCBjb3JyZXNwb25kZW5jZVxuXG4gICAgXHRcdFx0XHRcdGZpID0gZ2VvbWV0cnkuZmFjZXMubGVuZ3RoO1xuXG4gICAgXHRcdFx0XHRcdGlmICggaGFzRmFjZVZlcnRleFV2ICkge1xuXG4gICAgXHRcdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBuVXZMYXllcnM7IGkgKysgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHRcdHV2TGF5ZXIgPSBqc29uLnV2c1sgaSBdO1xuXG4gICAgXHRcdFx0XHRcdFx0XHRnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyBpIF1bIGZpIF0gPSBbXTtcblxuICAgIFx0XHRcdFx0XHRcdFx0Zm9yICggaiA9IDA7IGogPCAzOyBqICsrICkge1xuXG4gICAgXHRcdFx0XHRcdFx0XHRcdHV2SW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF07XG5cbiAgICBcdFx0XHRcdFx0XHRcdFx0dSA9IHV2TGF5ZXJbIHV2SW5kZXggKiAyIF07XG4gICAgXHRcdFx0XHRcdFx0XHRcdHYgPSB1dkxheWVyWyB1dkluZGV4ICogMiArIDEgXTtcblxuICAgIFx0XHRcdFx0XHRcdFx0XHR1diA9IG5ldyBWZWN0b3IyKCB1LCB2ICk7XG5cbiAgICBcdFx0XHRcdFx0XHRcdFx0Z2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgaSBdWyBmaSBdLnB1c2goIHV2ICk7XG5cbiAgICBcdFx0XHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdFx0aWYgKCBoYXNGYWNlTm9ybWFsICkge1xuXG4gICAgXHRcdFx0XHRcdFx0bm9ybWFsSW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF0gKiAzO1xuXG4gICAgXHRcdFx0XHRcdFx0ZmFjZS5ub3JtYWwuc2V0KFxuICAgIFx0XHRcdFx0XHRcdFx0bm9ybWFsc1sgbm9ybWFsSW5kZXggKysgXSxcbiAgICBcdFx0XHRcdFx0XHRcdG5vcm1hbHNbIG5vcm1hbEluZGV4ICsrIF0sXG4gICAgXHRcdFx0XHRcdFx0XHRub3JtYWxzWyBub3JtYWxJbmRleCBdXG4gICAgXHRcdFx0XHRcdFx0KTtcblxuICAgIFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdFx0aWYgKCBoYXNGYWNlVmVydGV4Tm9ybWFsICkge1xuXG4gICAgXHRcdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCAzOyBpICsrICkge1xuXG4gICAgXHRcdFx0XHRcdFx0XHRub3JtYWxJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXSAqIDM7XG5cbiAgICBcdFx0XHRcdFx0XHRcdG5vcm1hbCA9IG5ldyBWZWN0b3IzKFxuICAgIFx0XHRcdFx0XHRcdFx0XHRub3JtYWxzWyBub3JtYWxJbmRleCArKyBdLFxuICAgIFx0XHRcdFx0XHRcdFx0XHRub3JtYWxzWyBub3JtYWxJbmRleCArKyBdLFxuICAgIFx0XHRcdFx0XHRcdFx0XHRub3JtYWxzWyBub3JtYWxJbmRleCBdXG4gICAgXHRcdFx0XHRcdFx0XHQpO1xuXG4gICAgXHRcdFx0XHRcdFx0XHRmYWNlLnZlcnRleE5vcm1hbHMucHVzaCggbm9ybWFsICk7XG5cbiAgICBcdFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdFx0fVxuXG5cbiAgICBcdFx0XHRcdFx0aWYgKCBoYXNGYWNlQ29sb3IgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHRjb2xvckluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdO1xuICAgIFx0XHRcdFx0XHRcdGZhY2UuY29sb3Iuc2V0SGV4KCBjb2xvcnNbIGNvbG9ySW5kZXggXSApO1xuXG4gICAgXHRcdFx0XHRcdH1cblxuXG4gICAgXHRcdFx0XHRcdGlmICggaGFzRmFjZVZlcnRleENvbG9yICkge1xuXG4gICAgXHRcdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCAzOyBpICsrICkge1xuXG4gICAgXHRcdFx0XHRcdFx0XHRjb2xvckluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdO1xuICAgIFx0XHRcdFx0XHRcdFx0ZmFjZS52ZXJ0ZXhDb2xvcnMucHVzaCggbmV3IENvbG9yKCBjb2xvcnNbIGNvbG9ySW5kZXggXSApICk7XG5cbiAgICBcdFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRcdGdlb21ldHJ5LmZhY2VzLnB1c2goIGZhY2UgKTtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHRmdW5jdGlvbiBwYXJzZVNraW4oKSB7XG5cbiAgICBcdFx0XHR2YXIgaW5mbHVlbmNlc1BlclZlcnRleCA9ICgganNvbi5pbmZsdWVuY2VzUGVyVmVydGV4ICE9PSB1bmRlZmluZWQgKSA/IGpzb24uaW5mbHVlbmNlc1BlclZlcnRleCA6IDI7XG5cbiAgICBcdFx0XHRpZiAoIGpzb24uc2tpbldlaWdodHMgKSB7XG5cbiAgICBcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGpzb24uc2tpbldlaWdodHMubGVuZ3RoOyBpIDwgbDsgaSArPSBpbmZsdWVuY2VzUGVyVmVydGV4ICkge1xuXG4gICAgXHRcdFx0XHRcdHZhciB4ID0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbi5za2luV2VpZ2h0c1sgaSBdO1xuICAgIFx0XHRcdFx0XHR2YXIgeSA9ICggaW5mbHVlbmNlc1BlclZlcnRleCA+IDEgKSA/IGpzb24uc2tpbldlaWdodHNbIGkgKyAxIF0gOiAwO1xuICAgIFx0XHRcdFx0XHR2YXIgeiA9ICggaW5mbHVlbmNlc1BlclZlcnRleCA+IDIgKSA/IGpzb24uc2tpbldlaWdodHNbIGkgKyAyIF0gOiAwO1xuICAgIFx0XHRcdFx0XHR2YXIgdyA9ICggaW5mbHVlbmNlc1BlclZlcnRleCA+IDMgKSA/IGpzb24uc2tpbldlaWdodHNbIGkgKyAzIF0gOiAwO1xuXG4gICAgXHRcdFx0XHRcdGdlb21ldHJ5LnNraW5XZWlnaHRzLnB1c2goIG5ldyBWZWN0b3I0KCB4LCB5LCB6LCB3ICkgKTtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0aWYgKCBqc29uLnNraW5JbmRpY2VzICkge1xuXG4gICAgXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLnNraW5JbmRpY2VzLmxlbmd0aDsgaSA8IGw7IGkgKz0gaW5mbHVlbmNlc1BlclZlcnRleCApIHtcblxuICAgIFx0XHRcdFx0XHR2YXIgYSA9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb24uc2tpbkluZGljZXNbIGkgXTtcbiAgICBcdFx0XHRcdFx0dmFyIGIgPSAoIGluZmx1ZW5jZXNQZXJWZXJ0ZXggPiAxICkgPyBqc29uLnNraW5JbmRpY2VzWyBpICsgMSBdIDogMDtcbiAgICBcdFx0XHRcdFx0dmFyIGMgPSAoIGluZmx1ZW5jZXNQZXJWZXJ0ZXggPiAyICkgPyBqc29uLnNraW5JbmRpY2VzWyBpICsgMiBdIDogMDtcbiAgICBcdFx0XHRcdFx0dmFyIGQgPSAoIGluZmx1ZW5jZXNQZXJWZXJ0ZXggPiAzICkgPyBqc29uLnNraW5JbmRpY2VzWyBpICsgMyBdIDogMDtcblxuICAgIFx0XHRcdFx0XHRnZW9tZXRyeS5za2luSW5kaWNlcy5wdXNoKCBuZXcgVmVjdG9yNCggYSwgYiwgYywgZCApICk7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGdlb21ldHJ5LmJvbmVzID0ganNvbi5ib25lcztcblxuICAgIFx0XHRcdGlmICggZ2VvbWV0cnkuYm9uZXMgJiYgZ2VvbWV0cnkuYm9uZXMubGVuZ3RoID4gMCAmJiAoIGdlb21ldHJ5LnNraW5XZWlnaHRzLmxlbmd0aCAhPT0gZ2VvbWV0cnkuc2tpbkluZGljZXMubGVuZ3RoIHx8IGdlb21ldHJ5LnNraW5JbmRpY2VzLmxlbmd0aCAhPT0gZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoICkgKSB7XG5cbiAgICBcdFx0XHRcdGNvbnNvbGUud2FybiggJ1doZW4gc2tpbm5pbmcsIG51bWJlciBvZiB2ZXJ0aWNlcyAoJyArIGdlb21ldHJ5LnZlcnRpY2VzLmxlbmd0aCArICcpLCBza2luSW5kaWNlcyAoJyArXG4gICAgXHRcdFx0XHRcdGdlb21ldHJ5LnNraW5JbmRpY2VzLmxlbmd0aCArICcpLCBhbmQgc2tpbldlaWdodHMgKCcgKyBnZW9tZXRyeS5za2luV2VpZ2h0cy5sZW5ndGggKyAnKSBzaG91bGQgbWF0Y2guJyApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHRmdW5jdGlvbiBwYXJzZU1vcnBoaW5nKCBzY2FsZSApIHtcblxuICAgIFx0XHRcdGlmICgganNvbi5tb3JwaFRhcmdldHMgIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0ganNvbi5tb3JwaFRhcmdldHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgIFx0XHRcdFx0XHRnZW9tZXRyeS5tb3JwaFRhcmdldHNbIGkgXSA9IHt9O1xuICAgIFx0XHRcdFx0XHRnZW9tZXRyeS5tb3JwaFRhcmdldHNbIGkgXS5uYW1lID0ganNvbi5tb3JwaFRhcmdldHNbIGkgXS5uYW1lO1xuICAgIFx0XHRcdFx0XHRnZW9tZXRyeS5tb3JwaFRhcmdldHNbIGkgXS52ZXJ0aWNlcyA9IFtdO1xuXG4gICAgXHRcdFx0XHRcdHZhciBkc3RWZXJ0aWNlcyA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1sgaSBdLnZlcnRpY2VzO1xuICAgIFx0XHRcdFx0XHR2YXIgc3JjVmVydGljZXMgPSBqc29uLm1vcnBoVGFyZ2V0c1sgaSBdLnZlcnRpY2VzO1xuXG4gICAgXHRcdFx0XHRcdGZvciAoIHZhciB2ID0gMCwgdmwgPSBzcmNWZXJ0aWNlcy5sZW5ndGg7IHYgPCB2bDsgdiArPSAzICkge1xuXG4gICAgXHRcdFx0XHRcdFx0dmFyIHZlcnRleCA9IG5ldyBWZWN0b3IzKCk7XG4gICAgXHRcdFx0XHRcdFx0dmVydGV4LnggPSBzcmNWZXJ0aWNlc1sgdiBdICogc2NhbGU7XG4gICAgXHRcdFx0XHRcdFx0dmVydGV4LnkgPSBzcmNWZXJ0aWNlc1sgdiArIDEgXSAqIHNjYWxlO1xuICAgIFx0XHRcdFx0XHRcdHZlcnRleC56ID0gc3JjVmVydGljZXNbIHYgKyAyIF0gKiBzY2FsZTtcblxuICAgIFx0XHRcdFx0XHRcdGRzdFZlcnRpY2VzLnB1c2goIHZlcnRleCApO1xuXG4gICAgXHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0aWYgKCBqc29uLm1vcnBoQ29sb3JzICE9PSB1bmRlZmluZWQgJiYganNvbi5tb3JwaENvbG9ycy5sZW5ndGggPiAwICkge1xuXG4gICAgXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5KU09OTG9hZGVyOiBcIm1vcnBoQ29sb3JzXCIgbm8gbG9uZ2VyIHN1cHBvcnRlZC4gVXNpbmcgdGhlbSBhcyBmYWNlIGNvbG9ycy4nICk7XG5cbiAgICBcdFx0XHRcdHZhciBmYWNlcyA9IGdlb21ldHJ5LmZhY2VzO1xuICAgIFx0XHRcdFx0dmFyIG1vcnBoQ29sb3JzID0ganNvbi5tb3JwaENvbG9yc1sgMCBdLmNvbG9ycztcblxuICAgIFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gZmFjZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgIFx0XHRcdFx0XHRmYWNlc1sgaSBdLmNvbG9yLmZyb21BcnJheSggbW9ycGhDb2xvcnMsIGkgKiAzICk7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdFx0ZnVuY3Rpb24gcGFyc2VBbmltYXRpb25zKCkge1xuXG4gICAgXHRcdFx0dmFyIG91dHB1dEFuaW1hdGlvbnMgPSBbXTtcblxuICAgIFx0XHRcdC8vIHBhcnNlIG9sZCBzdHlsZSBCb25lL0hpZXJhcmNoeSBhbmltYXRpb25zXG4gICAgXHRcdFx0dmFyIGFuaW1hdGlvbnMgPSBbXTtcblxuICAgIFx0XHRcdGlmICgganNvbi5hbmltYXRpb24gIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0YW5pbWF0aW9ucy5wdXNoKCBqc29uLmFuaW1hdGlvbiApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0aWYgKCBqc29uLmFuaW1hdGlvbnMgIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0aWYgKCBqc29uLmFuaW1hdGlvbnMubGVuZ3RoICkge1xuXG4gICAgXHRcdFx0XHRcdGFuaW1hdGlvbnMgPSBhbmltYXRpb25zLmNvbmNhdCgganNvbi5hbmltYXRpb25zICk7XG5cbiAgICBcdFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdFx0YW5pbWF0aW9ucy5wdXNoKCBqc29uLmFuaW1hdGlvbnMgKTtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgYW5pbWF0aW9ucy5sZW5ndGg7IGkgKysgKSB7XG5cbiAgICBcdFx0XHRcdHZhciBjbGlwID0gQW5pbWF0aW9uQ2xpcC5wYXJzZUFuaW1hdGlvbiggYW5pbWF0aW9uc1sgaSBdLCBnZW9tZXRyeS5ib25lcyApO1xuICAgIFx0XHRcdFx0aWYgKCBjbGlwICkgb3V0cHV0QW5pbWF0aW9ucy5wdXNoKCBjbGlwICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHQvLyBwYXJzZSBpbXBsaWNpdCBtb3JwaCBhbmltYXRpb25zXG4gICAgXHRcdFx0aWYgKCBnZW9tZXRyeS5tb3JwaFRhcmdldHMgKSB7XG5cbiAgICBcdFx0XHRcdC8vIFRPRE86IEZpZ3VyZSBvdXQgd2hhdCBhbiBhcHByb3ByYWl0ZSBGUFMgaXMgZm9yIG1vcnBoIHRhcmdldCBhbmltYXRpb25zIC0tIGRlZmF1bHRpbmcgdG8gMTAsIGJ1dCByZWFsbHkgaXQgaXMgY29tcGxldGVseSBhcmJpdHJhcnkuXG4gICAgXHRcdFx0XHR2YXIgbW9ycGhBbmltYXRpb25DbGlwcyA9IEFuaW1hdGlvbkNsaXAuQ3JlYXRlQ2xpcHNGcm9tTW9ycGhUYXJnZXRTZXF1ZW5jZXMoIGdlb21ldHJ5Lm1vcnBoVGFyZ2V0cywgMTAgKTtcbiAgICBcdFx0XHRcdG91dHB1dEFuaW1hdGlvbnMgPSBvdXRwdXRBbmltYXRpb25zLmNvbmNhdCggbW9ycGhBbmltYXRpb25DbGlwcyApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0aWYgKCBvdXRwdXRBbmltYXRpb25zLmxlbmd0aCA+IDAgKSBnZW9tZXRyeS5hbmltYXRpb25zID0gb3V0cHV0QW5pbWF0aW9ucztcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKCBqc29uLm1hdGVyaWFscyA9PT0gdW5kZWZpbmVkIHx8IGpzb24ubWF0ZXJpYWxzLmxlbmd0aCA9PT0gMCApIHtcblxuICAgIFx0XHRcdHJldHVybiB7IGdlb21ldHJ5OiBnZW9tZXRyeSB9O1xuXG4gICAgXHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHR2YXIgbWF0ZXJpYWxzID0gTG9hZGVyLnByb3RvdHlwZS5pbml0TWF0ZXJpYWxzKCBqc29uLm1hdGVyaWFscywgdGV4dHVyZVBhdGgsIHRoaXMuY3Jvc3NPcmlnaW4gKTtcblxuICAgIFx0XHRcdHJldHVybiB7IGdlb21ldHJ5OiBnZW9tZXRyeSwgbWF0ZXJpYWxzOiBtYXRlcmlhbHMgfTtcblxuICAgIFx0XHR9XG5cbiAgICBcdH1cblxuICAgIH0gKTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBPYmplY3RMb2FkZXIgKCBtYW5hZ2VyICkge1xuXG4gICAgXHR0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IGV4cG9ydHMuRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xuICAgIFx0dGhpcy50ZXh0dXJlUGF0aCA9ICcnO1xuXG4gICAgfVxuXG4gICAgT2JqZWN0LmFzc2lnbiggT2JqZWN0TG9hZGVyLnByb3RvdHlwZSwge1xuXG4gICAgXHRsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG4gICAgXHRcdGlmICggdGhpcy50ZXh0dXJlUGF0aCA9PT0gJycgKSB7XG5cbiAgICBcdFx0XHR0aGlzLnRleHR1cmVQYXRoID0gdXJsLnN1YnN0cmluZyggMCwgdXJsLmxhc3RJbmRleE9mKCAnLycgKSArIDEgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0dmFyIHNjb3BlID0gdGhpcztcblxuICAgIFx0XHR2YXIgbG9hZGVyID0gbmV3IFhIUkxvYWRlciggc2NvcGUubWFuYWdlciApO1xuICAgIFx0XHRsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIHRleHQgKSB7XG5cbiAgICBcdFx0XHRzY29wZS5wYXJzZSggSlNPTi5wYXJzZSggdGV4dCApLCBvbkxvYWQgKTtcblxuICAgIFx0XHR9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldFRleHR1cmVQYXRoOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG4gICAgXHRcdHRoaXMudGV4dHVyZVBhdGggPSB2YWx1ZTtcblxuICAgIFx0fSxcblxuICAgIFx0c2V0Q3Jvc3NPcmlnaW46IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cbiAgICBcdFx0dGhpcy5jcm9zc09yaWdpbiA9IHZhbHVlO1xuXG4gICAgXHR9LFxuXG4gICAgXHRwYXJzZTogZnVuY3Rpb24gKCBqc29uLCBvbkxvYWQgKSB7XG5cbiAgICBcdFx0dmFyIGdlb21ldHJpZXMgPSB0aGlzLnBhcnNlR2VvbWV0cmllcygganNvbi5nZW9tZXRyaWVzICk7XG5cbiAgICBcdFx0dmFyIGltYWdlcyA9IHRoaXMucGFyc2VJbWFnZXMoIGpzb24uaW1hZ2VzLCBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0XHRpZiAoIG9uTG9hZCAhPT0gdW5kZWZpbmVkICkgb25Mb2FkKCBvYmplY3QgKTtcblxuICAgIFx0XHR9ICk7XG5cbiAgICBcdFx0dmFyIHRleHR1cmVzICA9IHRoaXMucGFyc2VUZXh0dXJlcygganNvbi50ZXh0dXJlcywgaW1hZ2VzICk7XG4gICAgXHRcdHZhciBtYXRlcmlhbHMgPSB0aGlzLnBhcnNlTWF0ZXJpYWxzKCBqc29uLm1hdGVyaWFscywgdGV4dHVyZXMgKTtcblxuICAgIFx0XHR2YXIgb2JqZWN0ID0gdGhpcy5wYXJzZU9iamVjdCgganNvbi5vYmplY3QsIGdlb21ldHJpZXMsIG1hdGVyaWFscyApO1xuXG4gICAgXHRcdGlmICgganNvbi5hbmltYXRpb25zICkge1xuXG4gICAgXHRcdFx0b2JqZWN0LmFuaW1hdGlvbnMgPSB0aGlzLnBhcnNlQW5pbWF0aW9ucygganNvbi5hbmltYXRpb25zICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGlmICgganNvbi5pbWFnZXMgPT09IHVuZGVmaW5lZCB8fCBqc29uLmltYWdlcy5sZW5ndGggPT09IDAgKSB7XG5cbiAgICBcdFx0XHRpZiAoIG9uTG9hZCAhPT0gdW5kZWZpbmVkICkgb25Mb2FkKCBvYmplY3QgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIG9iamVjdDtcblxuICAgIFx0fSxcblxuICAgIFx0cGFyc2VHZW9tZXRyaWVzOiBmdW5jdGlvbiAoIGpzb24gKSB7XG5cbiAgICBcdFx0dmFyIGdlb21ldHJpZXMgPSB7fTtcblxuICAgIFx0XHRpZiAoIGpzb24gIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdHZhciBnZW9tZXRyeUxvYWRlciA9IG5ldyBKU09OTG9hZGVyKCk7XG4gICAgXHRcdFx0dmFyIGJ1ZmZlckdlb21ldHJ5TG9hZGVyID0gbmV3IEJ1ZmZlckdlb21ldHJ5TG9hZGVyKCk7XG5cbiAgICBcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICBcdFx0XHRcdHZhciBnZW9tZXRyeTtcbiAgICBcdFx0XHRcdHZhciBkYXRhID0ganNvblsgaSBdO1xuXG4gICAgXHRcdFx0XHRzd2l0Y2ggKCBkYXRhLnR5cGUgKSB7XG5cbiAgICBcdFx0XHRcdFx0Y2FzZSAnUGxhbmVHZW9tZXRyeSc6XG4gICAgXHRcdFx0XHRcdGNhc2UgJ1BsYW5lQnVmZmVyR2VvbWV0cnknOlxuXG4gICAgXHRcdFx0XHRcdFx0Z2VvbWV0cnkgPSBuZXcgR2VvbWV0cmllc1sgZGF0YS50eXBlIF0oXG4gICAgXHRcdFx0XHRcdFx0XHRkYXRhLndpZHRoLFxuICAgIFx0XHRcdFx0XHRcdFx0ZGF0YS5oZWlnaHQsXG4gICAgXHRcdFx0XHRcdFx0XHRkYXRhLndpZHRoU2VnbWVudHMsXG4gICAgXHRcdFx0XHRcdFx0XHRkYXRhLmhlaWdodFNlZ21lbnRzXG4gICAgXHRcdFx0XHRcdFx0KTtcblxuICAgIFx0XHRcdFx0XHRcdGJyZWFrO1xuXG4gICAgXHRcdFx0XHRcdGNhc2UgJ0JveEdlb21ldHJ5JzpcbiAgICBcdFx0XHRcdFx0Y2FzZSAnQm94QnVmZmVyR2VvbWV0cnknOlxuICAgIFx0XHRcdFx0XHRjYXNlICdDdWJlR2VvbWV0cnknOiAvLyBiYWNrd2FyZHMgY29tcGF0aWJsZVxuXG4gICAgXHRcdFx0XHRcdFx0Z2VvbWV0cnkgPSBuZXcgR2VvbWV0cmllc1sgZGF0YS50eXBlIF0oXG4gICAgXHRcdFx0XHRcdFx0XHRkYXRhLndpZHRoLFxuICAgIFx0XHRcdFx0XHRcdFx0ZGF0YS5oZWlnaHQsXG4gICAgXHRcdFx0XHRcdFx0XHRkYXRhLmRlcHRoLFxuICAgIFx0XHRcdFx0XHRcdFx0ZGF0YS53aWR0aFNlZ21lbnRzLFxuICAgIFx0XHRcdFx0XHRcdFx0ZGF0YS5oZWlnaHRTZWdtZW50cyxcbiAgICBcdFx0XHRcdFx0XHRcdGRhdGEuZGVwdGhTZWdtZW50c1xuICAgIFx0XHRcdFx0XHRcdCk7XG5cbiAgICBcdFx0XHRcdFx0XHRicmVhaztcblxuICAgIFx0XHRcdFx0XHRjYXNlICdDaXJjbGVHZW9tZXRyeSc6XG4gICAgXHRcdFx0XHRcdGNhc2UgJ0NpcmNsZUJ1ZmZlckdlb21ldHJ5JzpcblxuICAgIFx0XHRcdFx0XHRcdGdlb21ldHJ5ID0gbmV3IEdlb21ldHJpZXNbIGRhdGEudHlwZSBdKFxuICAgIFx0XHRcdFx0XHRcdFx0ZGF0YS5yYWRpdXMsXG4gICAgXHRcdFx0XHRcdFx0XHRkYXRhLnNlZ21lbnRzLFxuICAgIFx0XHRcdFx0XHRcdFx0ZGF0YS50aGV0YVN0YXJ0LFxuICAgIFx0XHRcdFx0XHRcdFx0ZGF0YS50aGV0YUxlbmd0aFxuICAgIFx0XHRcdFx0XHRcdCk7XG5cbiAgICBcdFx0XHRcdFx0XHRicmVhaztcblxuICAgIFx0XHRcdFx0XHRjYXNlICdDeWxpbmRlckdlb21ldHJ5JzpcbiAgICBcdFx0XHRcdFx0Y2FzZSAnQ3lsaW5kZXJCdWZmZXJHZW9tZXRyeSc6XG5cbiAgICBcdFx0XHRcdFx0XHRnZW9tZXRyeSA9IG5ldyBHZW9tZXRyaWVzWyBkYXRhLnR5cGUgXShcbiAgICBcdFx0XHRcdFx0XHRcdGRhdGEucmFkaXVzVG9wLFxuICAgIFx0XHRcdFx0XHRcdFx0ZGF0YS5yYWRpdXNCb3R0b20sXG4gICAgXHRcdFx0XHRcdFx0XHRkYXRhLmhlaWdodCxcbiAgICBcdFx0XHRcdFx0XHRcdGRhdGEucmFkaWFsU2VnbWVudHMsXG4gICAgXHRcdFx0XHRcdFx0XHRkYXRhLmhlaWdodFNlZ21lbnRzLFxuICAgIFx0XHRcdFx0XHRcdFx0ZGF0YS5vcGVuRW5kZWQsXG4gICAgXHRcdFx0XHRcdFx0XHRkYXRhLnRoZXRhU3RhcnQsXG4gICAgXHRcdFx0XHRcdFx0XHRkYXRhLnRoZXRhTGVuZ3RoXG4gICAgXHRcdFx0XHRcdFx0KTtcblxuICAgIFx0XHRcdFx0XHRcdGJyZWFrO1xuXG4gICAgXHRcdFx0XHRcdGNhc2UgJ0NvbmVHZW9tZXRyeSc6XG4gICAgXHRcdFx0XHRcdGNhc2UgJ0NvbmVCdWZmZXJHZW9tZXRyeSc6XG5cbiAgICBcdFx0XHRcdFx0XHRnZW9tZXRyeSA9IG5ldyBHZW9tZXRyaWVzWyBkYXRhLnR5cGUgXShcbiAgICBcdFx0XHRcdFx0XHRcdGRhdGEucmFkaXVzLFxuICAgIFx0XHRcdFx0XHRcdFx0ZGF0YS5oZWlnaHQsXG4gICAgXHRcdFx0XHRcdFx0XHRkYXRhLnJhZGlhbFNlZ21lbnRzLFxuICAgIFx0XHRcdFx0XHRcdFx0ZGF0YS5oZWlnaHRTZWdtZW50cyxcbiAgICBcdFx0XHRcdFx0XHRcdGRhdGEub3BlbkVuZGVkLFxuICAgIFx0XHRcdFx0XHRcdFx0ZGF0YS50aGV0YVN0YXJ0LFxuICAgIFx0XHRcdFx0XHRcdFx0ZGF0YS50aGV0YUxlbmd0aFxuICAgIFx0XHRcdFx0XHRcdCk7XG5cbiAgICBcdFx0XHRcdFx0XHRicmVhaztcblxuICAgIFx0XHRcdFx0XHRjYXNlICdTcGhlcmVHZW9tZXRyeSc6XG4gICAgXHRcdFx0XHRcdGNhc2UgJ1NwaGVyZUJ1ZmZlckdlb21ldHJ5JzpcblxuICAgIFx0XHRcdFx0XHRcdGdlb21ldHJ5ID0gbmV3IEdlb21ldHJpZXNbIGRhdGEudHlwZSBdKFxuICAgIFx0XHRcdFx0XHRcdFx0ZGF0YS5yYWRpdXMsXG4gICAgXHRcdFx0XHRcdFx0XHRkYXRhLndpZHRoU2VnbWVudHMsXG4gICAgXHRcdFx0XHRcdFx0XHRkYXRhLmhlaWdodFNlZ21lbnRzLFxuICAgIFx0XHRcdFx0XHRcdFx0ZGF0YS5waGlTdGFydCxcbiAgICBcdFx0XHRcdFx0XHRcdGRhdGEucGhpTGVuZ3RoLFxuICAgIFx0XHRcdFx0XHRcdFx0ZGF0YS50aGV0YVN0YXJ0LFxuICAgIFx0XHRcdFx0XHRcdFx0ZGF0YS50aGV0YUxlbmd0aFxuICAgIFx0XHRcdFx0XHRcdCk7XG5cbiAgICBcdFx0XHRcdFx0XHRicmVhaztcblxuICAgIFx0XHRcdFx0XHRjYXNlICdEb2RlY2FoZWRyb25HZW9tZXRyeSc6XG4gICAgXHRcdFx0XHRcdGNhc2UgJ0ljb3NhaGVkcm9uR2VvbWV0cnknOlxuICAgIFx0XHRcdFx0XHRjYXNlICdPY3RhaGVkcm9uR2VvbWV0cnknOlxuICAgIFx0XHRcdFx0XHRjYXNlICdUZXRyYWhlZHJvbkdlb21ldHJ5JzpcblxuICAgIFx0XHRcdFx0XHRcdGdlb21ldHJ5ID0gbmV3IEdlb21ldHJpZXNbIGRhdGEudHlwZSBdKFxuICAgIFx0XHRcdFx0XHRcdFx0ZGF0YS5yYWRpdXMsXG4gICAgXHRcdFx0XHRcdFx0XHRkYXRhLmRldGFpbFxuICAgIFx0XHRcdFx0XHRcdCk7XG5cbiAgICBcdFx0XHRcdFx0XHRicmVhaztcblxuICAgIFx0XHRcdFx0XHRjYXNlICdSaW5nR2VvbWV0cnknOlxuICAgIFx0XHRcdFx0XHRjYXNlICdSaW5nQnVmZmVyR2VvbWV0cnknOlxuXG4gICAgXHRcdFx0XHRcdFx0Z2VvbWV0cnkgPSBuZXcgR2VvbWV0cmllc1sgZGF0YS50eXBlIF0oXG4gICAgXHRcdFx0XHRcdFx0XHRkYXRhLmlubmVyUmFkaXVzLFxuICAgIFx0XHRcdFx0XHRcdFx0ZGF0YS5vdXRlclJhZGl1cyxcbiAgICBcdFx0XHRcdFx0XHRcdGRhdGEudGhldGFTZWdtZW50cyxcbiAgICBcdFx0XHRcdFx0XHRcdGRhdGEucGhpU2VnbWVudHMsXG4gICAgXHRcdFx0XHRcdFx0XHRkYXRhLnRoZXRhU3RhcnQsXG4gICAgXHRcdFx0XHRcdFx0XHRkYXRhLnRoZXRhTGVuZ3RoXG4gICAgXHRcdFx0XHRcdFx0KTtcblxuICAgIFx0XHRcdFx0XHRcdGJyZWFrO1xuXG4gICAgXHRcdFx0XHRcdGNhc2UgJ1RvcnVzR2VvbWV0cnknOlxuICAgIFx0XHRcdFx0XHRjYXNlICdUb3J1c0J1ZmZlckdlb21ldHJ5JzpcblxuICAgIFx0XHRcdFx0XHRcdGdlb21ldHJ5ID0gbmV3IEdlb21ldHJpZXNbIGRhdGEudHlwZSBdKFxuICAgIFx0XHRcdFx0XHRcdFx0ZGF0YS5yYWRpdXMsXG4gICAgXHRcdFx0XHRcdFx0XHRkYXRhLnR1YmUsXG4gICAgXHRcdFx0XHRcdFx0XHRkYXRhLnJhZGlhbFNlZ21lbnRzLFxuICAgIFx0XHRcdFx0XHRcdFx0ZGF0YS50dWJ1bGFyU2VnbWVudHMsXG4gICAgXHRcdFx0XHRcdFx0XHRkYXRhLmFyY1xuICAgIFx0XHRcdFx0XHRcdCk7XG5cbiAgICBcdFx0XHRcdFx0XHRicmVhaztcblxuICAgIFx0XHRcdFx0XHRjYXNlICdUb3J1c0tub3RHZW9tZXRyeSc6XG4gICAgXHRcdFx0XHRcdGNhc2UgJ1RvcnVzS25vdEJ1ZmZlckdlb21ldHJ5JzpcblxuICAgIFx0XHRcdFx0XHRcdGdlb21ldHJ5ID0gbmV3IEdlb21ldHJpZXNbIGRhdGEudHlwZSBdKFxuICAgIFx0XHRcdFx0XHRcdFx0ZGF0YS5yYWRpdXMsXG4gICAgXHRcdFx0XHRcdFx0XHRkYXRhLnR1YmUsXG4gICAgXHRcdFx0XHRcdFx0XHRkYXRhLnR1YnVsYXJTZWdtZW50cyxcbiAgICBcdFx0XHRcdFx0XHRcdGRhdGEucmFkaWFsU2VnbWVudHMsXG4gICAgXHRcdFx0XHRcdFx0XHRkYXRhLnAsXG4gICAgXHRcdFx0XHRcdFx0XHRkYXRhLnFcbiAgICBcdFx0XHRcdFx0XHQpO1xuXG4gICAgXHRcdFx0XHRcdFx0YnJlYWs7XG5cbiAgICBcdFx0XHRcdFx0Y2FzZSAnTGF0aGVHZW9tZXRyeSc6XG4gICAgXHRcdFx0XHRcdGNhc2UgJ0xhdGhlQnVmZmVyR2VvbWV0cnknOlxuXG4gICAgXHRcdFx0XHRcdFx0Z2VvbWV0cnkgPSBuZXcgR2VvbWV0cmllc1sgZGF0YS50eXBlIF0oXG4gICAgXHRcdFx0XHRcdFx0XHRkYXRhLnBvaW50cyxcbiAgICBcdFx0XHRcdFx0XHRcdGRhdGEuc2VnbWVudHMsXG4gICAgXHRcdFx0XHRcdFx0XHRkYXRhLnBoaVN0YXJ0LFxuICAgIFx0XHRcdFx0XHRcdFx0ZGF0YS5waGlMZW5ndGhcbiAgICBcdFx0XHRcdFx0XHQpO1xuXG4gICAgXHRcdFx0XHRcdFx0YnJlYWs7XG5cbiAgICBcdFx0XHRcdFx0Y2FzZSAnQnVmZmVyR2VvbWV0cnknOlxuXG4gICAgXHRcdFx0XHRcdFx0Z2VvbWV0cnkgPSBidWZmZXJHZW9tZXRyeUxvYWRlci5wYXJzZSggZGF0YSApO1xuXG4gICAgXHRcdFx0XHRcdFx0YnJlYWs7XG5cbiAgICBcdFx0XHRcdFx0Y2FzZSAnR2VvbWV0cnknOlxuXG4gICAgXHRcdFx0XHRcdFx0Z2VvbWV0cnkgPSBnZW9tZXRyeUxvYWRlci5wYXJzZSggZGF0YS5kYXRhLCB0aGlzLnRleHR1cmVQYXRoICkuZ2VvbWV0cnk7XG5cbiAgICBcdFx0XHRcdFx0XHRicmVhaztcblxuICAgIFx0XHRcdFx0XHRkZWZhdWx0OlxuXG4gICAgXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0TG9hZGVyOiBVbnN1cHBvcnRlZCBnZW9tZXRyeSB0eXBlIFwiJyArIGRhdGEudHlwZSArICdcIicgKTtcblxuICAgIFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdGdlb21ldHJ5LnV1aWQgPSBkYXRhLnV1aWQ7XG5cbiAgICBcdFx0XHRcdGlmICggZGF0YS5uYW1lICE9PSB1bmRlZmluZWQgKSBnZW9tZXRyeS5uYW1lID0gZGF0YS5uYW1lO1xuXG4gICAgXHRcdFx0XHRnZW9tZXRyaWVzWyBkYXRhLnV1aWQgXSA9IGdlb21ldHJ5O1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gZ2VvbWV0cmllcztcblxuICAgIFx0fSxcblxuICAgIFx0cGFyc2VNYXRlcmlhbHM6IGZ1bmN0aW9uICgganNvbiwgdGV4dHVyZXMgKSB7XG5cbiAgICBcdFx0dmFyIG1hdGVyaWFscyA9IHt9O1xuXG4gICAgXHRcdGlmICgganNvbiAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0dmFyIGxvYWRlciA9IG5ldyBNYXRlcmlhbExvYWRlcigpO1xuICAgIFx0XHRcdGxvYWRlci5zZXRUZXh0dXJlcyggdGV4dHVyZXMgKTtcblxuICAgIFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGpzb24ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgIFx0XHRcdFx0dmFyIG1hdGVyaWFsID0gbG9hZGVyLnBhcnNlKCBqc29uWyBpIF0gKTtcbiAgICBcdFx0XHRcdG1hdGVyaWFsc1sgbWF0ZXJpYWwudXVpZCBdID0gbWF0ZXJpYWw7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiBtYXRlcmlhbHM7XG5cbiAgICBcdH0sXG5cbiAgICBcdHBhcnNlQW5pbWF0aW9uczogZnVuY3Rpb24gKCBqc29uICkge1xuXG4gICAgXHRcdHZhciBhbmltYXRpb25zID0gW107XG5cbiAgICBcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwganNvbi5sZW5ndGg7IGkgKysgKSB7XG5cbiAgICBcdFx0XHR2YXIgY2xpcCA9IEFuaW1hdGlvbkNsaXAucGFyc2UoIGpzb25bIGkgXSApO1xuXG4gICAgXHRcdFx0YW5pbWF0aW9ucy5wdXNoKCBjbGlwICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiBhbmltYXRpb25zO1xuXG4gICAgXHR9LFxuXG4gICAgXHRwYXJzZUltYWdlczogZnVuY3Rpb24gKCBqc29uLCBvbkxvYWQgKSB7XG5cbiAgICBcdFx0dmFyIHNjb3BlID0gdGhpcztcbiAgICBcdFx0dmFyIGltYWdlcyA9IHt9O1xuXG4gICAgXHRcdGZ1bmN0aW9uIGxvYWRJbWFnZSggdXJsICkge1xuXG4gICAgXHRcdFx0c2NvcGUubWFuYWdlci5pdGVtU3RhcnQoIHVybCApO1xuXG4gICAgXHRcdFx0cmV0dXJuIGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRW5kKCB1cmwgKTtcblxuICAgIFx0XHRcdH0sIHVuZGVmaW5lZCwgZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FcnJvciggdXJsICk7XG5cbiAgICBcdFx0XHR9ICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGlmICgganNvbiAhPT0gdW5kZWZpbmVkICYmIGpzb24ubGVuZ3RoID4gMCApIHtcblxuICAgIFx0XHRcdHZhciBtYW5hZ2VyID0gbmV3IExvYWRpbmdNYW5hZ2VyKCBvbkxvYWQgKTtcblxuICAgIFx0XHRcdHZhciBsb2FkZXIgPSBuZXcgSW1hZ2VMb2FkZXIoIG1hbmFnZXIgKTtcbiAgICBcdFx0XHRsb2FkZXIuc2V0Q3Jvc3NPcmlnaW4oIHRoaXMuY3Jvc3NPcmlnaW4gKTtcblxuICAgIFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGpzb24ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgIFx0XHRcdFx0dmFyIGltYWdlID0ganNvblsgaSBdO1xuICAgIFx0XHRcdFx0dmFyIHBhdGggPSAvXihcXC9cXC8pfChbYS16XSs6KFxcL1xcLyk/KS9pLnRlc3QoIGltYWdlLnVybCApID8gaW1hZ2UudXJsIDogc2NvcGUudGV4dHVyZVBhdGggKyBpbWFnZS51cmw7XG5cbiAgICBcdFx0XHRcdGltYWdlc1sgaW1hZ2UudXVpZCBdID0gbG9hZEltYWdlKCBwYXRoICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiBpbWFnZXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdHBhcnNlVGV4dHVyZXM6IGZ1bmN0aW9uICgganNvbiwgaW1hZ2VzICkge1xuXG4gICAgXHRcdGZ1bmN0aW9uIHBhcnNlQ29uc3RhbnQoIHZhbHVlLCB0eXBlICkge1xuXG4gICAgXHRcdFx0aWYgKCB0eXBlb2YoIHZhbHVlICkgPT09ICdudW1iZXInICkgcmV0dXJuIHZhbHVlO1xuXG4gICAgXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0TG9hZGVyLnBhcnNlVGV4dHVyZTogQ29uc3RhbnQgc2hvdWxkIGJlIGluIG51bWVyaWMgZm9ybS4nLCB2YWx1ZSApO1xuXG4gICAgXHRcdFx0cmV0dXJuIHR5cGVbIHZhbHVlIF07XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHZhciB0ZXh0dXJlcyA9IHt9O1xuXG4gICAgXHRcdGlmICgganNvbiAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0ganNvbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgXHRcdFx0XHR2YXIgZGF0YSA9IGpzb25bIGkgXTtcblxuICAgIFx0XHRcdFx0aWYgKCBkYXRhLmltYWdlID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0TG9hZGVyOiBObyBcImltYWdlXCIgc3BlY2lmaWVkIGZvcicsIGRhdGEudXVpZCApO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdGlmICggaW1hZ2VzWyBkYXRhLmltYWdlIF0gPT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3RMb2FkZXI6IFVuZGVmaW5lZCBpbWFnZScsIGRhdGEuaW1hZ2UgKTtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHR2YXIgdGV4dHVyZSA9IG5ldyBUZXh0dXJlKCBpbWFnZXNbIGRhdGEuaW1hZ2UgXSApO1xuICAgIFx0XHRcdFx0dGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICBcdFx0XHRcdHRleHR1cmUudXVpZCA9IGRhdGEudXVpZDtcblxuICAgIFx0XHRcdFx0aWYgKCBkYXRhLm5hbWUgIT09IHVuZGVmaW5lZCApIHRleHR1cmUubmFtZSA9IGRhdGEubmFtZTtcblxuICAgIFx0XHRcdFx0aWYgKCBkYXRhLm1hcHBpbmcgIT09IHVuZGVmaW5lZCApIHRleHR1cmUubWFwcGluZyA9IHBhcnNlQ29uc3RhbnQoIGRhdGEubWFwcGluZywgVGV4dHVyZU1hcHBpbmcgKTtcblxuICAgIFx0XHRcdFx0aWYgKCBkYXRhLm9mZnNldCAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5vZmZzZXQuZnJvbUFycmF5KCBkYXRhLm9mZnNldCApO1xuICAgIFx0XHRcdFx0aWYgKCBkYXRhLnJlcGVhdCAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5yZXBlYXQuZnJvbUFycmF5KCBkYXRhLnJlcGVhdCApO1xuICAgIFx0XHRcdFx0aWYgKCBkYXRhLndyYXAgIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0XHR0ZXh0dXJlLndyYXBTID0gcGFyc2VDb25zdGFudCggZGF0YS53cmFwWyAwIF0sIFRleHR1cmVXcmFwcGluZyApO1xuICAgIFx0XHRcdFx0XHR0ZXh0dXJlLndyYXBUID0gcGFyc2VDb25zdGFudCggZGF0YS53cmFwWyAxIF0sIFRleHR1cmVXcmFwcGluZyApO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdGlmICggZGF0YS5taW5GaWx0ZXIgIT09IHVuZGVmaW5lZCApIHRleHR1cmUubWluRmlsdGVyID0gcGFyc2VDb25zdGFudCggZGF0YS5taW5GaWx0ZXIsIFRleHR1cmVGaWx0ZXIgKTtcbiAgICBcdFx0XHRcdGlmICggZGF0YS5tYWdGaWx0ZXIgIT09IHVuZGVmaW5lZCApIHRleHR1cmUubWFnRmlsdGVyID0gcGFyc2VDb25zdGFudCggZGF0YS5tYWdGaWx0ZXIsIFRleHR1cmVGaWx0ZXIgKTtcbiAgICBcdFx0XHRcdGlmICggZGF0YS5hbmlzb3Ryb3B5ICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLmFuaXNvdHJvcHkgPSBkYXRhLmFuaXNvdHJvcHk7XG5cbiAgICBcdFx0XHRcdGlmICggZGF0YS5mbGlwWSAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5mbGlwWSA9IGRhdGEuZmxpcFk7XG5cbiAgICBcdFx0XHRcdHRleHR1cmVzWyBkYXRhLnV1aWQgXSA9IHRleHR1cmU7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiB0ZXh0dXJlcztcblxuICAgIFx0fSxcblxuICAgIFx0cGFyc2VPYmplY3Q6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR2YXIgbWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcblxuICAgIFx0XHRyZXR1cm4gZnVuY3Rpb24gcGFyc2VPYmplY3QoIGRhdGEsIGdlb21ldHJpZXMsIG1hdGVyaWFscyApIHtcblxuICAgIFx0XHRcdHZhciBvYmplY3Q7XG5cbiAgICBcdFx0XHRmdW5jdGlvbiBnZXRHZW9tZXRyeSggbmFtZSApIHtcblxuICAgIFx0XHRcdFx0aWYgKCBnZW9tZXRyaWVzWyBuYW1lIF0gPT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3RMb2FkZXI6IFVuZGVmaW5lZCBnZW9tZXRyeScsIG5hbWUgKTtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRyZXR1cm4gZ2VvbWV0cmllc1sgbmFtZSBdO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0ZnVuY3Rpb24gZ2V0TWF0ZXJpYWwoIG5hbWUgKSB7XG5cbiAgICBcdFx0XHRcdGlmICggbmFtZSA9PT0gdW5kZWZpbmVkICkgcmV0dXJuIHVuZGVmaW5lZDtcblxuICAgIFx0XHRcdFx0aWYgKCBtYXRlcmlhbHNbIG5hbWUgXSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdExvYWRlcjogVW5kZWZpbmVkIG1hdGVyaWFsJywgbmFtZSApO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdHJldHVybiBtYXRlcmlhbHNbIG5hbWUgXTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdHN3aXRjaCAoIGRhdGEudHlwZSApIHtcblxuICAgIFx0XHRcdFx0Y2FzZSAnU2NlbmUnOlxuXG4gICAgXHRcdFx0XHRcdG9iamVjdCA9IG5ldyBTY2VuZSgpO1xuXG4gICAgXHRcdFx0XHRcdGlmICggZGF0YS5iYWNrZ3JvdW5kICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHRpZiAoIE51bWJlci5pc0ludGVnZXIoIGRhdGEuYmFja2dyb3VuZCApICkge1xuXG4gICAgXHRcdFx0XHRcdFx0XHRvYmplY3QuYmFja2dyb3VuZCA9IG5ldyBDb2xvciggZGF0YS5iYWNrZ3JvdW5kICk7XG5cbiAgICBcdFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRcdGlmICggZGF0YS5mb2cgIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0XHRcdGlmICggZGF0YS5mb2cudHlwZSA9PT0gJ0ZvZycgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHRcdG9iamVjdC5mb2cgPSBuZXcgRm9nKCBkYXRhLmZvZy5jb2xvciwgZGF0YS5mb2cubmVhciwgZGF0YS5mb2cuZmFyICk7XG5cbiAgICBcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBkYXRhLmZvZy50eXBlID09PSAnRm9nRXhwMicgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHRcdG9iamVjdC5mb2cgPSBuZXcgRm9nRXhwMiggZGF0YS5mb2cuY29sb3IsIGRhdGEuZm9nLmRlbnNpdHkgKTtcblxuICAgIFx0XHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdFx0YnJlYWs7XG5cbiAgICBcdFx0XHRcdGNhc2UgJ1BlcnNwZWN0aXZlQ2FtZXJhJzpcblxuICAgIFx0XHRcdFx0XHRvYmplY3QgPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoIGRhdGEuZm92LCBkYXRhLmFzcGVjdCwgZGF0YS5uZWFyLCBkYXRhLmZhciApO1xuXG4gICAgXHRcdFx0XHRcdGlmICggZGF0YS5mb2N1cyAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LmZvY3VzID0gZGF0YS5mb2N1cztcbiAgICBcdFx0XHRcdFx0aWYgKCBkYXRhLnpvb20gIT09IHVuZGVmaW5lZCApIG9iamVjdC56b29tID0gZGF0YS56b29tO1xuICAgIFx0XHRcdFx0XHRpZiAoIGRhdGEuZmlsbUdhdWdlICE9PSB1bmRlZmluZWQgKSBvYmplY3QuZmlsbUdhdWdlID0gZGF0YS5maWxtR2F1Z2U7XG4gICAgXHRcdFx0XHRcdGlmICggZGF0YS5maWxtT2Zmc2V0ICE9PSB1bmRlZmluZWQgKSBvYmplY3QuZmlsbU9mZnNldCA9IGRhdGEuZmlsbU9mZnNldDtcbiAgICBcdFx0XHRcdFx0aWYgKCBkYXRhLnZpZXcgIT09IHVuZGVmaW5lZCApIG9iamVjdC52aWV3ID0gT2JqZWN0LmFzc2lnbigge30sIGRhdGEudmlldyApO1xuXG4gICAgXHRcdFx0XHRcdGJyZWFrO1xuXG4gICAgXHRcdFx0XHRjYXNlICdPcnRob2dyYXBoaWNDYW1lcmEnOlxuXG4gICAgXHRcdFx0XHRcdG9iamVjdCA9IG5ldyBPcnRob2dyYXBoaWNDYW1lcmEoIGRhdGEubGVmdCwgZGF0YS5yaWdodCwgZGF0YS50b3AsIGRhdGEuYm90dG9tLCBkYXRhLm5lYXIsIGRhdGEuZmFyICk7XG5cbiAgICBcdFx0XHRcdFx0YnJlYWs7XG5cbiAgICBcdFx0XHRcdGNhc2UgJ0FtYmllbnRMaWdodCc6XG5cbiAgICBcdFx0XHRcdFx0b2JqZWN0ID0gbmV3IEFtYmllbnRMaWdodCggZGF0YS5jb2xvciwgZGF0YS5pbnRlbnNpdHkgKTtcblxuICAgIFx0XHRcdFx0XHRicmVhaztcblxuICAgIFx0XHRcdFx0Y2FzZSAnRGlyZWN0aW9uYWxMaWdodCc6XG5cbiAgICBcdFx0XHRcdFx0b2JqZWN0ID0gbmV3IERpcmVjdGlvbmFsTGlnaHQoIGRhdGEuY29sb3IsIGRhdGEuaW50ZW5zaXR5ICk7XG5cbiAgICBcdFx0XHRcdFx0YnJlYWs7XG5cbiAgICBcdFx0XHRcdGNhc2UgJ1BvaW50TGlnaHQnOlxuXG4gICAgXHRcdFx0XHRcdG9iamVjdCA9IG5ldyBQb2ludExpZ2h0KCBkYXRhLmNvbG9yLCBkYXRhLmludGVuc2l0eSwgZGF0YS5kaXN0YW5jZSwgZGF0YS5kZWNheSApO1xuXG4gICAgXHRcdFx0XHRcdGJyZWFrO1xuXG4gICAgXHRcdFx0XHRjYXNlICdTcG90TGlnaHQnOlxuXG4gICAgXHRcdFx0XHRcdG9iamVjdCA9IG5ldyBTcG90TGlnaHQoIGRhdGEuY29sb3IsIGRhdGEuaW50ZW5zaXR5LCBkYXRhLmRpc3RhbmNlLCBkYXRhLmFuZ2xlLCBkYXRhLnBlbnVtYnJhLCBkYXRhLmRlY2F5ICk7XG5cbiAgICBcdFx0XHRcdFx0YnJlYWs7XG5cbiAgICBcdFx0XHRcdGNhc2UgJ0hlbWlzcGhlcmVMaWdodCc6XG5cbiAgICBcdFx0XHRcdFx0b2JqZWN0ID0gbmV3IEhlbWlzcGhlcmVMaWdodCggZGF0YS5jb2xvciwgZGF0YS5ncm91bmRDb2xvciwgZGF0YS5pbnRlbnNpdHkgKTtcblxuICAgIFx0XHRcdFx0XHRicmVhaztcblxuICAgIFx0XHRcdFx0Y2FzZSAnTWVzaCc6XG5cbiAgICBcdFx0XHRcdFx0dmFyIGdlb21ldHJ5ID0gZ2V0R2VvbWV0cnkoIGRhdGEuZ2VvbWV0cnkgKTtcbiAgICBcdFx0XHRcdFx0dmFyIG1hdGVyaWFsID0gZ2V0TWF0ZXJpYWwoIGRhdGEubWF0ZXJpYWwgKTtcblxuICAgIFx0XHRcdFx0XHRpZiAoIGdlb21ldHJ5LmJvbmVzICYmIGdlb21ldHJ5LmJvbmVzLmxlbmd0aCA+IDAgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHRvYmplY3QgPSBuZXcgU2tpbm5lZE1lc2goIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG4gICAgXHRcdFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdFx0XHRvYmplY3QgPSBuZXcgTWVzaCggZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cbiAgICBcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRcdGJyZWFrO1xuXG4gICAgXHRcdFx0XHRjYXNlICdMT0QnOlxuXG4gICAgXHRcdFx0XHRcdG9iamVjdCA9IG5ldyBMT0QoKTtcblxuICAgIFx0XHRcdFx0XHRicmVhaztcblxuICAgIFx0XHRcdFx0Y2FzZSAnTGluZSc6XG5cbiAgICBcdFx0XHRcdFx0b2JqZWN0ID0gbmV3IExpbmUoIGdldEdlb21ldHJ5KCBkYXRhLmdlb21ldHJ5ICksIGdldE1hdGVyaWFsKCBkYXRhLm1hdGVyaWFsICksIGRhdGEubW9kZSApO1xuXG4gICAgXHRcdFx0XHRcdGJyZWFrO1xuXG4gICAgXHRcdFx0XHRjYXNlICdMaW5lU2VnbWVudHMnOlxuXG4gICAgXHRcdFx0XHRcdG9iamVjdCA9IG5ldyBMaW5lU2VnbWVudHMoIGdldEdlb21ldHJ5KCBkYXRhLmdlb21ldHJ5ICksIGdldE1hdGVyaWFsKCBkYXRhLm1hdGVyaWFsICkgKTtcblxuICAgIFx0XHRcdFx0XHRicmVhaztcblxuICAgIFx0XHRcdFx0Y2FzZSAnUG9pbnRDbG91ZCc6XG4gICAgXHRcdFx0XHRjYXNlICdQb2ludHMnOlxuXG4gICAgXHRcdFx0XHRcdG9iamVjdCA9IG5ldyBQb2ludHMoIGdldEdlb21ldHJ5KCBkYXRhLmdlb21ldHJ5ICksIGdldE1hdGVyaWFsKCBkYXRhLm1hdGVyaWFsICkgKTtcblxuICAgIFx0XHRcdFx0XHRicmVhaztcblxuICAgIFx0XHRcdFx0Y2FzZSAnU3ByaXRlJzpcblxuICAgIFx0XHRcdFx0XHRvYmplY3QgPSBuZXcgU3ByaXRlKCBnZXRNYXRlcmlhbCggZGF0YS5tYXRlcmlhbCApICk7XG5cbiAgICBcdFx0XHRcdFx0YnJlYWs7XG5cbiAgICBcdFx0XHRcdGNhc2UgJ0dyb3VwJzpcblxuICAgIFx0XHRcdFx0XHRvYmplY3QgPSBuZXcgR3JvdXAoKTtcblxuICAgIFx0XHRcdFx0XHRicmVhaztcblxuICAgIFx0XHRcdFx0ZGVmYXVsdDpcblxuICAgIFx0XHRcdFx0XHRvYmplY3QgPSBuZXcgT2JqZWN0M0QoKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdG9iamVjdC51dWlkID0gZGF0YS51dWlkO1xuXG4gICAgXHRcdFx0aWYgKCBkYXRhLm5hbWUgIT09IHVuZGVmaW5lZCApIG9iamVjdC5uYW1lID0gZGF0YS5uYW1lO1xuICAgIFx0XHRcdGlmICggZGF0YS5tYXRyaXggIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0bWF0cml4LmZyb21BcnJheSggZGF0YS5tYXRyaXggKTtcbiAgICBcdFx0XHRcdG1hdHJpeC5kZWNvbXBvc2UoIG9iamVjdC5wb3NpdGlvbiwgb2JqZWN0LnF1YXRlcm5pb24sIG9iamVjdC5zY2FsZSApO1xuXG4gICAgXHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0aWYgKCBkYXRhLnBvc2l0aW9uICE9PSB1bmRlZmluZWQgKSBvYmplY3QucG9zaXRpb24uZnJvbUFycmF5KCBkYXRhLnBvc2l0aW9uICk7XG4gICAgXHRcdFx0XHRpZiAoIGRhdGEucm90YXRpb24gIT09IHVuZGVmaW5lZCApIG9iamVjdC5yb3RhdGlvbi5mcm9tQXJyYXkoIGRhdGEucm90YXRpb24gKTtcbiAgICBcdFx0XHRcdGlmICggZGF0YS5xdWF0ZXJuaW9uICE9PSB1bmRlZmluZWQgKSBvYmplY3QucXVhdGVybmlvbi5mcm9tQXJyYXkoIGRhdGEucXVhdGVybmlvbiApO1xuICAgIFx0XHRcdFx0aWYgKCBkYXRhLnNjYWxlICE9PSB1bmRlZmluZWQgKSBvYmplY3Quc2NhbGUuZnJvbUFycmF5KCBkYXRhLnNjYWxlICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRpZiAoIGRhdGEuY2FzdFNoYWRvdyAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LmNhc3RTaGFkb3cgPSBkYXRhLmNhc3RTaGFkb3c7XG4gICAgXHRcdFx0aWYgKCBkYXRhLnJlY2VpdmVTaGFkb3cgIT09IHVuZGVmaW5lZCApIG9iamVjdC5yZWNlaXZlU2hhZG93ID0gZGF0YS5yZWNlaXZlU2hhZG93O1xuXG4gICAgXHRcdFx0aWYgKCBkYXRhLnNoYWRvdyApIHtcblxuICAgIFx0XHRcdFx0aWYgKCBkYXRhLnNoYWRvdy5iaWFzICE9PSB1bmRlZmluZWQgKSBvYmplY3Quc2hhZG93LmJpYXMgPSBkYXRhLnNoYWRvdy5iaWFzO1xuICAgIFx0XHRcdFx0aWYgKCBkYXRhLnNoYWRvdy5yYWRpdXMgIT09IHVuZGVmaW5lZCApIG9iamVjdC5zaGFkb3cucmFkaXVzID0gZGF0YS5zaGFkb3cucmFkaXVzO1xuICAgIFx0XHRcdFx0aWYgKCBkYXRhLnNoYWRvdy5tYXBTaXplICE9PSB1bmRlZmluZWQgKSBvYmplY3Quc2hhZG93Lm1hcFNpemUuZnJvbUFycmF5KCBkYXRhLnNoYWRvdy5tYXBTaXplICk7XG4gICAgXHRcdFx0XHRpZiAoIGRhdGEuc2hhZG93LmNhbWVyYSAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnNoYWRvdy5jYW1lcmEgPSB0aGlzLnBhcnNlT2JqZWN0KCBkYXRhLnNoYWRvdy5jYW1lcmEgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGlmICggZGF0YS52aXNpYmxlICE9PSB1bmRlZmluZWQgKSBvYmplY3QudmlzaWJsZSA9IGRhdGEudmlzaWJsZTtcbiAgICBcdFx0XHRpZiAoIGRhdGEudXNlckRhdGEgIT09IHVuZGVmaW5lZCApIG9iamVjdC51c2VyRGF0YSA9IGRhdGEudXNlckRhdGE7XG5cbiAgICBcdFx0XHRpZiAoIGRhdGEuY2hpbGRyZW4gIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0Zm9yICggdmFyIGNoaWxkIGluIGRhdGEuY2hpbGRyZW4gKSB7XG5cbiAgICBcdFx0XHRcdFx0b2JqZWN0LmFkZCggdGhpcy5wYXJzZU9iamVjdCggZGF0YS5jaGlsZHJlblsgY2hpbGQgXSwgZ2VvbWV0cmllcywgbWF0ZXJpYWxzICkgKTtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0aWYgKCBkYXRhLnR5cGUgPT09ICdMT0QnICkge1xuXG4gICAgXHRcdFx0XHR2YXIgbGV2ZWxzID0gZGF0YS5sZXZlbHM7XG5cbiAgICBcdFx0XHRcdGZvciAoIHZhciBsID0gMDsgbCA8IGxldmVscy5sZW5ndGg7IGwgKysgKSB7XG5cbiAgICBcdFx0XHRcdFx0dmFyIGxldmVsID0gbGV2ZWxzWyBsIF07XG4gICAgXHRcdFx0XHRcdHZhciBjaGlsZCA9IG9iamVjdC5nZXRPYmplY3RCeVByb3BlcnR5KCAndXVpZCcsIGxldmVsLm9iamVjdCApO1xuXG4gICAgXHRcdFx0XHRcdGlmICggY2hpbGQgIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0XHRcdG9iamVjdC5hZGRMZXZlbCggY2hpbGQsIGxldmVsLmRpc3RhbmNlICk7XG5cbiAgICBcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRyZXR1cm4gb2JqZWN0O1xuXG4gICAgXHRcdH07XG5cbiAgICBcdH0oKVxuXG4gICAgfSApO1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xuICAgICAqIEV4dGVuc2libGUgY3VydmUgb2JqZWN0XG4gICAgICpcbiAgICAgKiBTb21lIGNvbW1vbiBvZiBDdXJ2ZSBtZXRob2RzXG4gICAgICogLmdldFBvaW50KHQpLCBnZXRUYW5nZW50KHQpXG4gICAgICogLmdldFBvaW50QXQodSksIGdldFRhbmdlbnRBdCh1KVxuICAgICAqIC5nZXRQb2ludHMoKSwgLmdldFNwYWNlZFBvaW50cygpXG4gICAgICogLmdldExlbmd0aCgpXG4gICAgICogLnVwZGF0ZUFyY0xlbmd0aHMoKVxuICAgICAqXG4gICAgICogVGhpcyBmb2xsb3dpbmcgY2xhc3NlcyBzdWJjbGFzc2VzIFRIUkVFLkN1cnZlOlxuICAgICAqXG4gICAgICogLS0gMmQgY2xhc3NlcyAtLVxuICAgICAqIFRIUkVFLkxpbmVDdXJ2ZVxuICAgICAqIFRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlXG4gICAgICogVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZVxuICAgICAqIFRIUkVFLlNwbGluZUN1cnZlXG4gICAgICogVEhSRUUuQXJjQ3VydmVcbiAgICAgKiBUSFJFRS5FbGxpcHNlQ3VydmVcbiAgICAgKlxuICAgICAqIC0tIDNkIGNsYXNzZXMgLS1cbiAgICAgKiBUSFJFRS5MaW5lQ3VydmUzXG4gICAgICogVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmUzXG4gICAgICogVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZTNcbiAgICAgKiBUSFJFRS5TcGxpbmVDdXJ2ZTNcbiAgICAgKlxuICAgICAqIEEgc2VyaWVzIG9mIGN1cnZlcyBjYW4gYmUgcmVwcmVzZW50ZWQgYXMgYSBUSFJFRS5DdXJ2ZVBhdGhcbiAgICAgKlxuICAgICAqKi9cblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAqXHRBYnN0cmFjdCBDdXJ2ZSBiYXNlIGNsYXNzXG4gICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgZnVuY3Rpb24gQ3VydmUoKSB7fVxuXG4gICAgQ3VydmUucHJvdG90eXBlID0ge1xuXG4gICAgXHRjb25zdHJ1Y3RvcjogQ3VydmUsXG5cbiAgICBcdC8vIFZpcnR1YWwgYmFzZSBjbGFzcyBtZXRob2QgdG8gb3ZlcndyaXRlIGFuZCBpbXBsZW1lbnQgaW4gc3ViY2xhc3Nlc1xuICAgIFx0Ly9cdC0gdCBbMCAuLiAxXVxuXG4gICAgXHRnZXRQb2ludDogZnVuY3Rpb24gKCB0ICkge1xuXG4gICAgXHRcdGNvbnNvbGUud2FybiggXCJUSFJFRS5DdXJ2ZTogV2FybmluZywgZ2V0UG9pbnQoKSBub3QgaW1wbGVtZW50ZWQhXCIgKTtcbiAgICBcdFx0cmV0dXJuIG51bGw7XG5cbiAgICBcdH0sXG5cbiAgICBcdC8vIEdldCBwb2ludCBhdCByZWxhdGl2ZSBwb3NpdGlvbiBpbiBjdXJ2ZSBhY2NvcmRpbmcgdG8gYXJjIGxlbmd0aFxuICAgIFx0Ly8gLSB1IFswIC4uIDFdXG5cbiAgICBcdGdldFBvaW50QXQ6IGZ1bmN0aW9uICggdSApIHtcblxuICAgIFx0XHR2YXIgdCA9IHRoaXMuZ2V0VXRvVG1hcHBpbmcoIHUgKTtcbiAgICBcdFx0cmV0dXJuIHRoaXMuZ2V0UG9pbnQoIHQgKTtcblxuICAgIFx0fSxcblxuICAgIFx0Ly8gR2V0IHNlcXVlbmNlIG9mIHBvaW50cyB1c2luZyBnZXRQb2ludCggdCApXG5cbiAgICBcdGdldFBvaW50czogZnVuY3Rpb24gKCBkaXZpc2lvbnMgKSB7XG5cbiAgICBcdFx0aWYgKCAhIGRpdmlzaW9ucyApIGRpdmlzaW9ucyA9IDU7XG5cbiAgICBcdFx0dmFyIHBvaW50cyA9IFtdO1xuXG4gICAgXHRcdGZvciAoIHZhciBkID0gMDsgZCA8PSBkaXZpc2lvbnM7IGQgKysgKSB7XG5cbiAgICBcdFx0XHRwb2ludHMucHVzaCggdGhpcy5nZXRQb2ludCggZCAvIGRpdmlzaW9ucyApICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiBwb2ludHM7XG5cbiAgICBcdH0sXG5cbiAgICBcdC8vIEdldCBzZXF1ZW5jZSBvZiBwb2ludHMgdXNpbmcgZ2V0UG9pbnRBdCggdSApXG5cbiAgICBcdGdldFNwYWNlZFBvaW50czogZnVuY3Rpb24gKCBkaXZpc2lvbnMgKSB7XG5cbiAgICBcdFx0aWYgKCAhIGRpdmlzaW9ucyApIGRpdmlzaW9ucyA9IDU7XG5cbiAgICBcdFx0dmFyIHBvaW50cyA9IFtdO1xuXG4gICAgXHRcdGZvciAoIHZhciBkID0gMDsgZCA8PSBkaXZpc2lvbnM7IGQgKysgKSB7XG5cbiAgICBcdFx0XHRwb2ludHMucHVzaCggdGhpcy5nZXRQb2ludEF0KCBkIC8gZGl2aXNpb25zICkgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIHBvaW50cztcblxuICAgIFx0fSxcblxuICAgIFx0Ly8gR2V0IHRvdGFsIGN1cnZlIGFyYyBsZW5ndGhcblxuICAgIFx0Z2V0TGVuZ3RoOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dmFyIGxlbmd0aHMgPSB0aGlzLmdldExlbmd0aHMoKTtcbiAgICBcdFx0cmV0dXJuIGxlbmd0aHNbIGxlbmd0aHMubGVuZ3RoIC0gMSBdO1xuXG4gICAgXHR9LFxuXG4gICAgXHQvLyBHZXQgbGlzdCBvZiBjdW11bGF0aXZlIHNlZ21lbnQgbGVuZ3Roc1xuXG4gICAgXHRnZXRMZW5ndGhzOiBmdW5jdGlvbiAoIGRpdmlzaW9ucyApIHtcblxuICAgIFx0XHRpZiAoICEgZGl2aXNpb25zICkgZGl2aXNpb25zID0gKCB0aGlzLl9fYXJjTGVuZ3RoRGl2aXNpb25zICkgPyAoIHRoaXMuX19hcmNMZW5ndGhEaXZpc2lvbnMgKSA6IDIwMDtcblxuICAgIFx0XHRpZiAoIHRoaXMuY2FjaGVBcmNMZW5ndGhzXG4gICAgXHRcdFx0JiYgKCB0aGlzLmNhY2hlQXJjTGVuZ3Rocy5sZW5ndGggPT09IGRpdmlzaW9ucyArIDEgKVxuICAgIFx0XHRcdCYmICEgdGhpcy5uZWVkc1VwZGF0ZSApIHtcblxuICAgIFx0XHRcdC8vY29uc29sZS5sb2coIFwiY2FjaGVkXCIsIHRoaXMuY2FjaGVBcmNMZW5ndGhzICk7XG4gICAgXHRcdFx0cmV0dXJuIHRoaXMuY2FjaGVBcmNMZW5ndGhzO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHR0aGlzLm5lZWRzVXBkYXRlID0gZmFsc2U7XG5cbiAgICBcdFx0dmFyIGNhY2hlID0gW107XG4gICAgXHRcdHZhciBjdXJyZW50LCBsYXN0ID0gdGhpcy5nZXRQb2ludCggMCApO1xuICAgIFx0XHR2YXIgcCwgc3VtID0gMDtcblxuICAgIFx0XHRjYWNoZS5wdXNoKCAwICk7XG5cbiAgICBcdFx0Zm9yICggcCA9IDE7IHAgPD0gZGl2aXNpb25zOyBwICsrICkge1xuXG4gICAgXHRcdFx0Y3VycmVudCA9IHRoaXMuZ2V0UG9pbnQgKCBwIC8gZGl2aXNpb25zICk7XG4gICAgXHRcdFx0c3VtICs9IGN1cnJlbnQuZGlzdGFuY2VUbyggbGFzdCApO1xuICAgIFx0XHRcdGNhY2hlLnB1c2goIHN1bSApO1xuICAgIFx0XHRcdGxhc3QgPSBjdXJyZW50O1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHR0aGlzLmNhY2hlQXJjTGVuZ3RocyA9IGNhY2hlO1xuXG4gICAgXHRcdHJldHVybiBjYWNoZTsgLy8geyBzdW1zOiBjYWNoZSwgc3VtOnN1bSB9OyBTdW0gaXMgaW4gdGhlIGxhc3QgZWxlbWVudC5cblxuICAgIFx0fSxcblxuICAgIFx0dXBkYXRlQXJjTGVuZ3RoczogZnVuY3Rpb24oKSB7XG5cbiAgICBcdFx0dGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgXHRcdHRoaXMuZ2V0TGVuZ3RocygpO1xuXG4gICAgXHR9LFxuXG4gICAgXHQvLyBHaXZlbiB1ICggMCAuLiAxICksIGdldCBhIHQgdG8gZmluZCBwLiBUaGlzIGdpdmVzIHlvdSBwb2ludHMgd2hpY2ggYXJlIGVxdWlkaXN0YW50XG5cbiAgICBcdGdldFV0b1RtYXBwaW5nOiBmdW5jdGlvbiAoIHUsIGRpc3RhbmNlICkge1xuXG4gICAgXHRcdHZhciBhcmNMZW5ndGhzID0gdGhpcy5nZXRMZW5ndGhzKCk7XG5cbiAgICBcdFx0dmFyIGkgPSAwLCBpbCA9IGFyY0xlbmd0aHMubGVuZ3RoO1xuXG4gICAgXHRcdHZhciB0YXJnZXRBcmNMZW5ndGg7IC8vIFRoZSB0YXJnZXRlZCB1IGRpc3RhbmNlIHZhbHVlIHRvIGdldFxuXG4gICAgXHRcdGlmICggZGlzdGFuY2UgKSB7XG5cbiAgICBcdFx0XHR0YXJnZXRBcmNMZW5ndGggPSBkaXN0YW5jZTtcblxuICAgIFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0dGFyZ2V0QXJjTGVuZ3RoID0gdSAqIGFyY0xlbmd0aHNbIGlsIC0gMSBdO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHQvL3ZhciB0aW1lID0gRGF0ZS5ub3coKTtcblxuICAgIFx0XHQvLyBiaW5hcnkgc2VhcmNoIGZvciB0aGUgaW5kZXggd2l0aCBsYXJnZXN0IHZhbHVlIHNtYWxsZXIgdGhhbiB0YXJnZXQgdSBkaXN0YW5jZVxuXG4gICAgXHRcdHZhciBsb3cgPSAwLCBoaWdoID0gaWwgLSAxLCBjb21wYXJpc29uO1xuXG4gICAgXHRcdHdoaWxlICggbG93IDw9IGhpZ2ggKSB7XG5cbiAgICBcdFx0XHRpID0gTWF0aC5mbG9vciggbG93ICsgKCBoaWdoIC0gbG93ICkgLyAyICk7IC8vIGxlc3MgbGlrZWx5IHRvIG92ZXJmbG93LCB0aG91Z2ggcHJvYmFibHkgbm90IGlzc3VlIGhlcmUsIEpTIGRvZXNuJ3QgcmVhbGx5IGhhdmUgaW50ZWdlcnMsIGFsbCBudW1iZXJzIGFyZSBmbG9hdHNcblxuICAgIFx0XHRcdGNvbXBhcmlzb24gPSBhcmNMZW5ndGhzWyBpIF0gLSB0YXJnZXRBcmNMZW5ndGg7XG5cbiAgICBcdFx0XHRpZiAoIGNvbXBhcmlzb24gPCAwICkge1xuXG4gICAgXHRcdFx0XHRsb3cgPSBpICsgMTtcblxuICAgIFx0XHRcdH0gZWxzZSBpZiAoIGNvbXBhcmlzb24gPiAwICkge1xuXG4gICAgXHRcdFx0XHRoaWdoID0gaSAtIDE7XG5cbiAgICBcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRoaWdoID0gaTtcbiAgICBcdFx0XHRcdGJyZWFrO1xuXG4gICAgXHRcdFx0XHQvLyBET05FXG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGkgPSBoaWdoO1xuXG4gICAgXHRcdC8vY29uc29sZS5sb2coJ2InICwgaSwgbG93LCBoaWdoLCBEYXRlLm5vdygpLSB0aW1lKTtcblxuICAgIFx0XHRpZiAoIGFyY0xlbmd0aHNbIGkgXSA9PT0gdGFyZ2V0QXJjTGVuZ3RoICkge1xuXG4gICAgXHRcdFx0dmFyIHQgPSBpIC8gKCBpbCAtIDEgKTtcbiAgICBcdFx0XHRyZXR1cm4gdDtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0Ly8gd2UgY291bGQgZ2V0IGZpbmVyIGdyYWluIGF0IGxlbmd0aHMsIG9yIHVzZSBzaW1wbGUgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byBwb2ludHNcblxuICAgIFx0XHR2YXIgbGVuZ3RoQmVmb3JlID0gYXJjTGVuZ3Roc1sgaSBdO1xuICAgIFx0XHR2YXIgbGVuZ3RoQWZ0ZXIgPSBhcmNMZW5ndGhzWyBpICsgMSBdO1xuXG4gICAgXHRcdHZhciBzZWdtZW50TGVuZ3RoID0gbGVuZ3RoQWZ0ZXIgLSBsZW5ndGhCZWZvcmU7XG5cbiAgICBcdFx0Ly8gZGV0ZXJtaW5lIHdoZXJlIHdlIGFyZSBiZXR3ZWVuIHRoZSAnYmVmb3JlJyBhbmQgJ2FmdGVyJyBwb2ludHNcblxuICAgIFx0XHR2YXIgc2VnbWVudEZyYWN0aW9uID0gKCB0YXJnZXRBcmNMZW5ndGggLSBsZW5ndGhCZWZvcmUgKSAvIHNlZ21lbnRMZW5ndGg7XG5cbiAgICBcdFx0Ly8gYWRkIHRoYXQgZnJhY3Rpb25hbCBhbW91bnQgdG8gdFxuXG4gICAgXHRcdHZhciB0ID0gKCBpICsgc2VnbWVudEZyYWN0aW9uICkgLyAoIGlsIC0gMSApO1xuXG4gICAgXHRcdHJldHVybiB0O1xuXG4gICAgXHR9LFxuXG4gICAgXHQvLyBSZXR1cm5zIGEgdW5pdCB2ZWN0b3IgdGFuZ2VudCBhdCB0XG4gICAgXHQvLyBJbiBjYXNlIGFueSBzdWIgY3VydmUgZG9lcyBub3QgaW1wbGVtZW50IGl0cyB0YW5nZW50IGRlcml2YXRpb24sXG4gICAgXHQvLyAyIHBvaW50cyBhIHNtYWxsIGRlbHRhIGFwYXJ0IHdpbGwgYmUgdXNlZCB0byBmaW5kIGl0cyBncmFkaWVudFxuICAgIFx0Ly8gd2hpY2ggc2VlbXMgdG8gZ2l2ZSBhIHJlYXNvbmFibGUgYXBwcm94aW1hdGlvblxuXG4gICAgXHRnZXRUYW5nZW50OiBmdW5jdGlvbiggdCApIHtcblxuICAgIFx0XHR2YXIgZGVsdGEgPSAwLjAwMDE7XG4gICAgXHRcdHZhciB0MSA9IHQgLSBkZWx0YTtcbiAgICBcdFx0dmFyIHQyID0gdCArIGRlbHRhO1xuXG4gICAgXHRcdC8vIENhcHBpbmcgaW4gY2FzZSBvZiBkYW5nZXJcblxuICAgIFx0XHRpZiAoIHQxIDwgMCApIHQxID0gMDtcbiAgICBcdFx0aWYgKCB0MiA+IDEgKSB0MiA9IDE7XG5cbiAgICBcdFx0dmFyIHB0MSA9IHRoaXMuZ2V0UG9pbnQoIHQxICk7XG4gICAgXHRcdHZhciBwdDIgPSB0aGlzLmdldFBvaW50KCB0MiApO1xuXG4gICAgXHRcdHZhciB2ZWMgPSBwdDIuY2xvbmUoKS5zdWIoIHB0MSApO1xuICAgIFx0XHRyZXR1cm4gdmVjLm5vcm1hbGl6ZSgpO1xuXG4gICAgXHR9LFxuXG4gICAgXHRnZXRUYW5nZW50QXQ6IGZ1bmN0aW9uICggdSApIHtcblxuICAgIFx0XHR2YXIgdCA9IHRoaXMuZ2V0VXRvVG1hcHBpbmcoIHUgKTtcbiAgICBcdFx0cmV0dXJuIHRoaXMuZ2V0VGFuZ2VudCggdCApO1xuXG4gICAgXHR9XG5cbiAgICB9O1xuXG4gICAgLy8gVE9ETzogVHJhbnNmb3JtYXRpb24gZm9yIEN1cnZlcz9cblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAqXHQzRCBDdXJ2ZXNcbiAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAvLyBBIEZhY3RvcnkgbWV0aG9kIGZvciBjcmVhdGluZyBuZXcgY3VydmUgc3ViY2xhc3Nlc1xuXG4gICAgQ3VydmUuY3JlYXRlID0gZnVuY3Rpb24gKCBjb25zdHJ1Y3RvciwgZ2V0UG9pbnRGdW5jICkge1xuXG4gICAgXHRjb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBDdXJ2ZS5wcm90b3R5cGUgKTtcbiAgICBcdGNvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGNvbnN0cnVjdG9yO1xuICAgIFx0Y29uc3RydWN0b3IucHJvdG90eXBlLmdldFBvaW50ID0gZ2V0UG9pbnRGdW5jO1xuXG4gICAgXHRyZXR1cm4gY29uc3RydWN0b3I7XG5cbiAgICB9O1xuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICpcdExpbmVcbiAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICBmdW5jdGlvbiBMaW5lQ3VydmUoIHYxLCB2MiApIHtcblxuICAgIFx0dGhpcy52MSA9IHYxO1xuICAgIFx0dGhpcy52MiA9IHYyO1xuXG4gICAgfVxuXG4gICAgTGluZUN1cnZlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEN1cnZlLnByb3RvdHlwZSApO1xuICAgIExpbmVDdXJ2ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMaW5lQ3VydmU7XG5cbiAgICBMaW5lQ3VydmUucHJvdG90eXBlLmlzTGluZUN1cnZlID0gdHJ1ZTtcblxuICAgIExpbmVDdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiAoIHQgKSB7XG5cbiAgICBcdGlmICggdCA9PT0gMSApIHtcblxuICAgIFx0XHRyZXR1cm4gdGhpcy52Mi5jbG9uZSgpO1xuXG4gICAgXHR9XG5cbiAgICBcdHZhciBwb2ludCA9IHRoaXMudjIuY2xvbmUoKS5zdWIoIHRoaXMudjEgKTtcbiAgICBcdHBvaW50Lm11bHRpcGx5U2NhbGFyKCB0ICkuYWRkKCB0aGlzLnYxICk7XG5cbiAgICBcdHJldHVybiBwb2ludDtcblxuICAgIH07XG5cbiAgICAvLyBMaW5lIGN1cnZlIGlzIGxpbmVhciwgc28gd2UgY2FuIG92ZXJ3cml0ZSBkZWZhdWx0IGdldFBvaW50QXRcblxuICAgIExpbmVDdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnRBdCA9IGZ1bmN0aW9uICggdSApIHtcblxuICAgIFx0cmV0dXJuIHRoaXMuZ2V0UG9pbnQoIHUgKTtcblxuICAgIH07XG5cbiAgICBMaW5lQ3VydmUucHJvdG90eXBlLmdldFRhbmdlbnQgPSBmdW5jdGlvbiggdCApIHtcblxuICAgIFx0dmFyIHRhbmdlbnQgPSB0aGlzLnYyLmNsb25lKCkuc3ViKCB0aGlzLnYxICk7XG5cbiAgICBcdHJldHVybiB0YW5nZW50Lm5vcm1hbGl6ZSgpO1xuXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcbiAgICAgKlxuICAgICAqKi9cblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAqXHRDdXJ2ZWQgUGF0aCAtIGEgY3VydmUgcGF0aCBpcyBzaW1wbHkgYSBhcnJheSBvZiBjb25uZWN0ZWRcbiAgICAgKiAgY3VydmVzLCBidXQgcmV0YWlucyB0aGUgYXBpIG9mIGEgY3VydmVcbiAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICBmdW5jdGlvbiBDdXJ2ZVBhdGgoKSB7XG5cbiAgICBcdHRoaXMuY3VydmVzID0gW107XG5cbiAgICBcdHRoaXMuYXV0b0Nsb3NlID0gZmFsc2U7IC8vIEF1dG9tYXRpY2FsbHkgY2xvc2VzIHRoZSBwYXRoXG5cbiAgICB9XG5cbiAgICBDdXJ2ZVBhdGgucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggQ3VydmUucHJvdG90eXBlICksIHtcblxuICAgIFx0Y29uc3RydWN0b3I6IEN1cnZlUGF0aCxcblxuICAgIFx0YWRkOiBmdW5jdGlvbiAoIGN1cnZlICkge1xuXG4gICAgXHRcdHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGNsb3NlUGF0aDogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdC8vIEFkZCBhIGxpbmUgY3VydmUgaWYgc3RhcnQgYW5kIGVuZCBvZiBsaW5lcyBhcmUgbm90IGNvbm5lY3RlZFxuICAgIFx0XHR2YXIgc3RhcnRQb2ludCA9IHRoaXMuY3VydmVzWyAwIF0uZ2V0UG9pbnQoIDAgKTtcbiAgICBcdFx0dmFyIGVuZFBvaW50ID0gdGhpcy5jdXJ2ZXNbIHRoaXMuY3VydmVzLmxlbmd0aCAtIDEgXS5nZXRQb2ludCggMSApO1xuXG4gICAgXHRcdGlmICggISBzdGFydFBvaW50LmVxdWFscyggZW5kUG9pbnQgKSApIHtcblxuICAgIFx0XHRcdHRoaXMuY3VydmVzLnB1c2goIG5ldyBMaW5lQ3VydmUoIGVuZFBvaW50LCBzdGFydFBvaW50ICkgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdH0sXG5cbiAgICBcdC8vIFRvIGdldCBhY2N1cmF0ZSBwb2ludCB3aXRoIHJlZmVyZW5jZSB0b1xuICAgIFx0Ly8gZW50aXJlIHBhdGggZGlzdGFuY2UgYXQgdGltZSB0LFxuICAgIFx0Ly8gZm9sbG93aW5nIGhhcyB0byBiZSBkb25lOlxuXG4gICAgXHQvLyAxLiBMZW5ndGggb2YgZWFjaCBzdWIgcGF0aCBoYXZlIHRvIGJlIGtub3duXG4gICAgXHQvLyAyLiBMb2NhdGUgYW5kIGlkZW50aWZ5IHR5cGUgb2YgY3VydmVcbiAgICBcdC8vIDMuIEdldCB0IGZvciB0aGUgY3VydmVcbiAgICBcdC8vIDQuIFJldHVybiBjdXJ2ZS5nZXRQb2ludEF0KHQnKVxuXG4gICAgXHRnZXRQb2ludDogZnVuY3Rpb24gKCB0ICkge1xuXG4gICAgXHRcdHZhciBkID0gdCAqIHRoaXMuZ2V0TGVuZ3RoKCk7XG4gICAgXHRcdHZhciBjdXJ2ZUxlbmd0aHMgPSB0aGlzLmdldEN1cnZlTGVuZ3RocygpO1xuICAgIFx0XHR2YXIgaSA9IDA7XG5cbiAgICBcdFx0Ly8gVG8gdGhpbmsgYWJvdXQgYm91bmRhcmllcyBwb2ludHMuXG5cbiAgICBcdFx0d2hpbGUgKCBpIDwgY3VydmVMZW5ndGhzLmxlbmd0aCApIHtcblxuICAgIFx0XHRcdGlmICggY3VydmVMZW5ndGhzWyBpIF0gPj0gZCApIHtcblxuICAgIFx0XHRcdFx0dmFyIGRpZmYgPSBjdXJ2ZUxlbmd0aHNbIGkgXSAtIGQ7XG4gICAgXHRcdFx0XHR2YXIgY3VydmUgPSB0aGlzLmN1cnZlc1sgaSBdO1xuXG4gICAgXHRcdFx0XHR2YXIgc2VnbWVudExlbmd0aCA9IGN1cnZlLmdldExlbmd0aCgpO1xuICAgIFx0XHRcdFx0dmFyIHUgPSBzZWdtZW50TGVuZ3RoID09PSAwID8gMCA6IDEgLSBkaWZmIC8gc2VnbWVudExlbmd0aDtcblxuICAgIFx0XHRcdFx0cmV0dXJuIGN1cnZlLmdldFBvaW50QXQoIHUgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGkgKys7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiBudWxsO1xuXG4gICAgXHRcdC8vIGxvb3Agd2hlcmUgc3VtICE9IDAsIHN1bSA+IGQgLCBzdW0rMSA8ZFxuXG4gICAgXHR9LFxuXG4gICAgXHQvLyBXZSBjYW5ub3QgdXNlIHRoZSBkZWZhdWx0IFRIUkVFLkN1cnZlIGdldFBvaW50KCkgd2l0aCBnZXRMZW5ndGgoKSBiZWNhdXNlIGluXG4gICAgXHQvLyBUSFJFRS5DdXJ2ZSwgZ2V0TGVuZ3RoKCkgZGVwZW5kcyBvbiBnZXRQb2ludCgpIGJ1dCBpbiBUSFJFRS5DdXJ2ZVBhdGhcbiAgICBcdC8vIGdldFBvaW50KCkgZGVwZW5kcyBvbiBnZXRMZW5ndGhcblxuICAgIFx0Z2V0TGVuZ3RoOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dmFyIGxlbnMgPSB0aGlzLmdldEN1cnZlTGVuZ3RocygpO1xuICAgIFx0XHRyZXR1cm4gbGVuc1sgbGVucy5sZW5ndGggLSAxIF07XG5cbiAgICBcdH0sXG5cbiAgICBcdC8vIGNhY2hlTGVuZ3RocyBtdXN0IGJlIHJlY2FsY3VsYXRlZC5cbiAgICBcdHVwZGF0ZUFyY0xlbmd0aHM6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICBcdFx0dGhpcy5jYWNoZUxlbmd0aHMgPSBudWxsO1xuICAgIFx0XHR0aGlzLmdldExlbmd0aHMoKTtcblxuICAgIFx0fSxcblxuICAgIFx0Ly8gQ29tcHV0ZSBsZW5ndGhzIGFuZCBjYWNoZSB0aGVtXG4gICAgXHQvLyBXZSBjYW5ub3Qgb3ZlcndyaXRlIGdldExlbmd0aHMoKSBiZWNhdXNlIFV0b1QgbWFwcGluZyB1c2VzIGl0LlxuXG4gICAgXHRnZXRDdXJ2ZUxlbmd0aHM6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHQvLyBXZSB1c2UgY2FjaGUgdmFsdWVzIGlmIGN1cnZlcyBhbmQgY2FjaGUgYXJyYXkgYXJlIHNhbWUgbGVuZ3RoXG5cbiAgICBcdFx0aWYgKCB0aGlzLmNhY2hlTGVuZ3RocyAmJiB0aGlzLmNhY2hlTGVuZ3Rocy5sZW5ndGggPT09IHRoaXMuY3VydmVzLmxlbmd0aCApIHtcblxuICAgIFx0XHRcdHJldHVybiB0aGlzLmNhY2hlTGVuZ3RocztcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0Ly8gR2V0IGxlbmd0aCBvZiBzdWItY3VydmVcbiAgICBcdFx0Ly8gUHVzaCBzdW1zIGludG8gY2FjaGVkIGFycmF5XG5cbiAgICBcdFx0dmFyIGxlbmd0aHMgPSBbXSwgc3VtcyA9IDA7XG5cbiAgICBcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy5jdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgIFx0XHRcdHN1bXMgKz0gdGhpcy5jdXJ2ZXNbIGkgXS5nZXRMZW5ndGgoKTtcbiAgICBcdFx0XHRsZW5ndGhzLnB1c2goIHN1bXMgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0dGhpcy5jYWNoZUxlbmd0aHMgPSBsZW5ndGhzO1xuXG4gICAgXHRcdHJldHVybiBsZW5ndGhzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRnZXRTcGFjZWRQb2ludHM6IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xuXG4gICAgXHRcdGlmICggISBkaXZpc2lvbnMgKSBkaXZpc2lvbnMgPSA0MDtcblxuICAgIFx0XHR2YXIgcG9pbnRzID0gW107XG5cbiAgICBcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDw9IGRpdmlzaW9uczsgaSArKyApIHtcblxuICAgIFx0XHRcdHBvaW50cy5wdXNoKCB0aGlzLmdldFBvaW50KCBpIC8gZGl2aXNpb25zICkgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKCB0aGlzLmF1dG9DbG9zZSApIHtcblxuICAgIFx0XHRcdHBvaW50cy5wdXNoKCBwb2ludHNbIDAgXSApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gcG9pbnRzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRnZXRQb2ludHM6IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xuXG4gICAgXHRcdGRpdmlzaW9ucyA9IGRpdmlzaW9ucyB8fCAxMjtcblxuICAgIFx0XHR2YXIgcG9pbnRzID0gW10sIGxhc3Q7XG5cbiAgICBcdFx0Zm9yICggdmFyIGkgPSAwLCBjdXJ2ZXMgPSB0aGlzLmN1cnZlczsgaSA8IGN1cnZlcy5sZW5ndGg7IGkgKysgKSB7XG5cbiAgICBcdFx0XHR2YXIgY3VydmUgPSBjdXJ2ZXNbIGkgXTtcbiAgICBcdFx0XHR2YXIgcmVzb2x1dGlvbiA9IChjdXJ2ZSAmJiBjdXJ2ZS5pc0VsbGlwc2VDdXJ2ZSkgPyBkaXZpc2lvbnMgKiAyXG4gICAgXHRcdFx0XHQ6IChjdXJ2ZSAmJiBjdXJ2ZS5pc0xpbmVDdXJ2ZSkgPyAxXG4gICAgXHRcdFx0XHQ6IChjdXJ2ZSAmJiBjdXJ2ZS5pc1NwbGluZUN1cnZlKSA/IGRpdmlzaW9ucyAqIGN1cnZlLnBvaW50cy5sZW5ndGhcbiAgICBcdFx0XHRcdDogZGl2aXNpb25zO1xuXG4gICAgXHRcdFx0dmFyIHB0cyA9IGN1cnZlLmdldFBvaW50cyggcmVzb2x1dGlvbiApO1xuXG4gICAgXHRcdFx0Zm9yICggdmFyIGogPSAwOyBqIDwgcHRzLmxlbmd0aDsgaisrICkge1xuXG4gICAgXHRcdFx0XHR2YXIgcG9pbnQgPSBwdHNbIGogXTtcblxuICAgIFx0XHRcdFx0aWYgKCBsYXN0ICYmIGxhc3QuZXF1YWxzKCBwb2ludCApICkgY29udGludWU7IC8vIGVuc3VyZXMgbm8gY29uc2VjdXRpdmUgcG9pbnRzIGFyZSBkdXBsaWNhdGVzXG5cbiAgICBcdFx0XHRcdHBvaW50cy5wdXNoKCBwb2ludCApO1xuICAgIFx0XHRcdFx0bGFzdCA9IHBvaW50O1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoIHRoaXMuYXV0b0Nsb3NlICYmIHBvaW50cy5sZW5ndGggPiAxICYmICFwb2ludHNbIHBvaW50cy5sZW5ndGggLSAxIF0uZXF1YWxzKCBwb2ludHNbIDAgXSApICkge1xuXG4gICAgXHRcdFx0cG9pbnRzLnB1c2goIHBvaW50c1sgMCBdICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiBwb2ludHM7XG5cbiAgICBcdH0sXG5cbiAgICBcdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgIFx0ICpcdENyZWF0ZSBHZW9tZXRyaWVzIEhlbHBlcnNcbiAgICBcdCAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgIFx0Ly8vIEdlbmVyYXRlIGdlb21ldHJ5IGZyb20gcGF0aCBwb2ludHMgKGZvciBMaW5lIG9yIFBvaW50cyBvYmplY3RzKVxuXG4gICAgXHRjcmVhdGVQb2ludHNHZW9tZXRyeTogZnVuY3Rpb24gKCBkaXZpc2lvbnMgKSB7XG5cbiAgICBcdFx0dmFyIHB0cyA9IHRoaXMuZ2V0UG9pbnRzKCBkaXZpc2lvbnMgKTtcbiAgICBcdFx0cmV0dXJuIHRoaXMuY3JlYXRlR2VvbWV0cnkoIHB0cyApO1xuXG4gICAgXHR9LFxuXG4gICAgXHQvLyBHZW5lcmF0ZSBnZW9tZXRyeSBmcm9tIGVxdWlkaXN0YW50IHNhbXBsaW5nIGFsb25nIHRoZSBwYXRoXG5cbiAgICBcdGNyZWF0ZVNwYWNlZFBvaW50c0dlb21ldHJ5OiBmdW5jdGlvbiAoIGRpdmlzaW9ucyApIHtcblxuICAgIFx0XHR2YXIgcHRzID0gdGhpcy5nZXRTcGFjZWRQb2ludHMoIGRpdmlzaW9ucyApO1xuICAgIFx0XHRyZXR1cm4gdGhpcy5jcmVhdGVHZW9tZXRyeSggcHRzICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGNyZWF0ZUdlb21ldHJ5OiBmdW5jdGlvbiAoIHBvaW50cyApIHtcblxuICAgIFx0XHR2YXIgZ2VvbWV0cnkgPSBuZXcgR2VvbWV0cnkoKTtcblxuICAgIFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBwb2ludHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgIFx0XHRcdHZhciBwb2ludCA9IHBvaW50c1sgaSBdO1xuICAgIFx0XHRcdGdlb21ldHJ5LnZlcnRpY2VzLnB1c2goIG5ldyBWZWN0b3IzKCBwb2ludC54LCBwb2ludC55LCBwb2ludC56IHx8IDAgKSApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gZ2VvbWV0cnk7XG5cbiAgICBcdH1cblxuICAgIH0gKTtcblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAqXHRFbGxpcHNlIGN1cnZlXG4gICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgZnVuY3Rpb24gRWxsaXBzZUN1cnZlKCBhWCwgYVksIHhSYWRpdXMsIHlSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UsIGFSb3RhdGlvbiApIHtcblxuICAgIFx0dGhpcy5hWCA9IGFYO1xuICAgIFx0dGhpcy5hWSA9IGFZO1xuXG4gICAgXHR0aGlzLnhSYWRpdXMgPSB4UmFkaXVzO1xuICAgIFx0dGhpcy55UmFkaXVzID0geVJhZGl1cztcblxuICAgIFx0dGhpcy5hU3RhcnRBbmdsZSA9IGFTdGFydEFuZ2xlO1xuICAgIFx0dGhpcy5hRW5kQW5nbGUgPSBhRW5kQW5nbGU7XG5cbiAgICBcdHRoaXMuYUNsb2Nrd2lzZSA9IGFDbG9ja3dpc2U7XG5cbiAgICBcdHRoaXMuYVJvdGF0aW9uID0gYVJvdGF0aW9uIHx8IDA7XG5cbiAgICB9XG5cbiAgICBFbGxpcHNlQ3VydmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ3VydmUucHJvdG90eXBlICk7XG4gICAgRWxsaXBzZUN1cnZlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEVsbGlwc2VDdXJ2ZTtcblxuICAgIEVsbGlwc2VDdXJ2ZS5wcm90b3R5cGUuaXNFbGxpcHNlQ3VydmUgPSB0cnVlO1xuXG4gICAgRWxsaXBzZUN1cnZlLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uKCB0ICkge1xuXG4gICAgXHR2YXIgdHdvUGkgPSBNYXRoLlBJICogMjtcbiAgICBcdHZhciBkZWx0YUFuZ2xlID0gdGhpcy5hRW5kQW5nbGUgLSB0aGlzLmFTdGFydEFuZ2xlO1xuICAgIFx0dmFyIHNhbWVQb2ludHMgPSBNYXRoLmFicyggZGVsdGFBbmdsZSApIDwgTnVtYmVyLkVQU0lMT047XG5cbiAgICBcdC8vIGVuc3VyZXMgdGhhdCBkZWx0YUFuZ2xlIGlzIDAgLi4gMiBQSVxuICAgIFx0d2hpbGUgKCBkZWx0YUFuZ2xlIDwgMCApIGRlbHRhQW5nbGUgKz0gdHdvUGk7XG4gICAgXHR3aGlsZSAoIGRlbHRhQW5nbGUgPiB0d29QaSApIGRlbHRhQW5nbGUgLT0gdHdvUGk7XG5cbiAgICBcdGlmICggZGVsdGFBbmdsZSA8IE51bWJlci5FUFNJTE9OICkge1xuXG4gICAgXHRcdGlmICggc2FtZVBvaW50cyApIHtcblxuICAgIFx0XHRcdGRlbHRhQW5nbGUgPSAwO1xuXG4gICAgXHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRkZWx0YUFuZ2xlID0gdHdvUGk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9XG5cbiAgICBcdGlmICggdGhpcy5hQ2xvY2t3aXNlID09PSB0cnVlICYmICEgc2FtZVBvaW50cyApIHtcblxuICAgIFx0XHRpZiAoIGRlbHRhQW5nbGUgPT09IHR3b1BpICkge1xuXG4gICAgXHRcdFx0ZGVsdGFBbmdsZSA9IC0gdHdvUGk7XG5cbiAgICBcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdGRlbHRhQW5nbGUgPSBkZWx0YUFuZ2xlIC0gdHdvUGk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9XG5cbiAgICBcdHZhciBhbmdsZSA9IHRoaXMuYVN0YXJ0QW5nbGUgKyB0ICogZGVsdGFBbmdsZTtcbiAgICBcdHZhciB4ID0gdGhpcy5hWCArIHRoaXMueFJhZGl1cyAqIE1hdGguY29zKCBhbmdsZSApO1xuICAgIFx0dmFyIHkgPSB0aGlzLmFZICsgdGhpcy55UmFkaXVzICogTWF0aC5zaW4oIGFuZ2xlICk7XG5cbiAgICBcdGlmICggdGhpcy5hUm90YXRpb24gIT09IDAgKSB7XG5cbiAgICBcdFx0dmFyIGNvcyA9IE1hdGguY29zKCB0aGlzLmFSb3RhdGlvbiApO1xuICAgIFx0XHR2YXIgc2luID0gTWF0aC5zaW4oIHRoaXMuYVJvdGF0aW9uICk7XG5cbiAgICBcdFx0dmFyIHR4ID0geCAtIHRoaXMuYVg7XG4gICAgXHRcdHZhciB0eSA9IHkgLSB0aGlzLmFZO1xuXG4gICAgXHRcdC8vIFJvdGF0ZSB0aGUgcG9pbnQgYWJvdXQgdGhlIGNlbnRlciBvZiB0aGUgZWxsaXBzZS5cbiAgICBcdFx0eCA9IHR4ICogY29zIC0gdHkgKiBzaW4gKyB0aGlzLmFYO1xuICAgIFx0XHR5ID0gdHggKiBzaW4gKyB0eSAqIGNvcyArIHRoaXMuYVk7XG5cbiAgICBcdH1cblxuICAgIFx0cmV0dXJuIG5ldyBWZWN0b3IyKCB4LCB5ICk7XG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xuICAgICAqL1xuXG4gICAgZXhwb3J0cy5DdXJ2ZVV0aWxzID0ge1xuXG4gICAgXHR0YW5nZW50UXVhZHJhdGljQmV6aWVyOiBmdW5jdGlvbiAoIHQsIHAwLCBwMSwgcDIgKSB7XG5cbiAgICBcdFx0cmV0dXJuIDIgKiAoIDEgLSB0ICkgKiAoIHAxIC0gcDAgKSArIDIgKiB0ICogKCBwMiAtIHAxICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdC8vIFB1YXkgQmluZywgdGhhbmtzIGZvciBoZWxwaW5nIHdpdGggdGhpcyBkZXJpdmF0aXZlIVxuXG4gICAgXHR0YW5nZW50Q3ViaWNCZXppZXI6IGZ1bmN0aW9uICggdCwgcDAsIHAxLCBwMiwgcDMgKSB7XG5cbiAgICBcdFx0cmV0dXJuIC0gMyAqIHAwICogKCAxIC0gdCApICogKCAxIC0gdCApICArXG4gICAgXHRcdFx0MyAqIHAxICogKCAxIC0gdCApICogKCAxIC0gdCApIC0gNiAqIHQgKiBwMSAqICggMSAtIHQgKSArXG4gICAgXHRcdFx0NiAqIHQgKiAgcDIgKiAoIDEgLSB0ICkgLSAzICogdCAqIHQgKiBwMiArXG4gICAgXHRcdFx0MyAqIHQgKiB0ICogcDM7XG5cbiAgICBcdH0sXG5cbiAgICBcdHRhbmdlbnRTcGxpbmU6IGZ1bmN0aW9uICggdCwgcDAsIHAxLCBwMiwgcDMgKSB7XG5cbiAgICBcdFx0Ly8gVG8gY2hlY2sgaWYgbXkgZm9ybXVsYXMgYXJlIGNvcnJlY3RcblxuICAgIFx0XHR2YXIgaDAwID0gNiAqIHQgKiB0IC0gNiAqIHQ7IFx0Ly8gZGVyaXZlZCBmcm9tIDJ0XjMg4oiSIDN0XjIgKyAxXG4gICAgXHRcdHZhciBoMTAgPSAzICogdCAqIHQgLSA0ICogdCArIDE7IC8vIHReMyDiiJIgMnReMiArIHRcbiAgICBcdFx0dmFyIGgwMSA9IC0gNiAqIHQgKiB0ICsgNiAqIHQ7IFx0Ly8g4oiSIDJ0MyArIDN0MlxuICAgIFx0XHR2YXIgaDExID0gMyAqIHQgKiB0IC0gMiAqIHQ7XHQvLyB0MyDiiJIgdDJcblxuICAgIFx0XHRyZXR1cm4gaDAwICsgaDEwICsgaDAxICsgaDExO1xuXG4gICAgXHR9LFxuXG4gICAgXHQvLyBDYXRtdWxsLVJvbVxuXG4gICAgXHRpbnRlcnBvbGF0ZTogZnVuY3Rpb24oIHAwLCBwMSwgcDIsIHAzLCB0ICkge1xuXG4gICAgXHRcdHZhciB2MCA9ICggcDIgLSBwMCApICogMC41O1xuICAgIFx0XHR2YXIgdjEgPSAoIHAzIC0gcDEgKSAqIDAuNTtcbiAgICBcdFx0dmFyIHQyID0gdCAqIHQ7XG4gICAgXHRcdHZhciB0MyA9IHQgKiB0MjtcbiAgICBcdFx0cmV0dXJuICggMiAqIHAxIC0gMiAqIHAyICsgdjAgKyB2MSApICogdDMgKyAoIC0gMyAqIHAxICsgMyAqIHAyIC0gMiAqIHYwIC0gdjEgKSAqIHQyICsgdjAgKiB0ICsgcDE7XG5cbiAgICBcdH1cblxuICAgIH07XG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgKlx0U3BsaW5lIGN1cnZlXG4gICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgZnVuY3Rpb24gU3BsaW5lQ3VydmUoIHBvaW50cyAvKiBhcnJheSBvZiBWZWN0b3IyICovICkge1xuXG4gICAgXHR0aGlzLnBvaW50cyA9ICggcG9pbnRzID09PSB1bmRlZmluZWQgKSA/IFtdIDogcG9pbnRzO1xuXG4gICAgfVxuXG4gICAgU3BsaW5lQ3VydmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ3VydmUucHJvdG90eXBlICk7XG4gICAgU3BsaW5lQ3VydmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3BsaW5lQ3VydmU7XG5cbiAgICBTcGxpbmVDdXJ2ZS5wcm90b3R5cGUuaXNTcGxpbmVDdXJ2ZSA9IHRydWU7XG5cbiAgICBTcGxpbmVDdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiAoIHQgKSB7XG5cbiAgICBcdHZhciBwb2ludHMgPSB0aGlzLnBvaW50cztcbiAgICBcdHZhciBwb2ludCA9ICggcG9pbnRzLmxlbmd0aCAtIDEgKSAqIHQ7XG5cbiAgICBcdHZhciBpbnRQb2ludCA9IE1hdGguZmxvb3IoIHBvaW50ICk7XG4gICAgXHR2YXIgd2VpZ2h0ID0gcG9pbnQgLSBpbnRQb2ludDtcblxuICAgIFx0dmFyIHBvaW50MCA9IHBvaW50c1sgaW50UG9pbnQgPT09IDAgPyBpbnRQb2ludCA6IGludFBvaW50IC0gMSBdO1xuICAgIFx0dmFyIHBvaW50MSA9IHBvaW50c1sgaW50UG9pbnQgXTtcbiAgICBcdHZhciBwb2ludDIgPSBwb2ludHNbIGludFBvaW50ID4gcG9pbnRzLmxlbmd0aCAtIDIgPyBwb2ludHMubGVuZ3RoIC0gMSA6IGludFBvaW50ICsgMSBdO1xuICAgIFx0dmFyIHBvaW50MyA9IHBvaW50c1sgaW50UG9pbnQgPiBwb2ludHMubGVuZ3RoIC0gMyA/IHBvaW50cy5sZW5ndGggLSAxIDogaW50UG9pbnQgKyAyIF07XG5cbiAgICBcdHZhciBpbnRlcnBvbGF0ZSA9IGV4cG9ydHMuQ3VydmVVdGlscy5pbnRlcnBvbGF0ZTtcblxuICAgIFx0cmV0dXJuIG5ldyBWZWN0b3IyKFxuICAgIFx0XHRpbnRlcnBvbGF0ZSggcG9pbnQwLngsIHBvaW50MS54LCBwb2ludDIueCwgcG9pbnQzLngsIHdlaWdodCApLFxuICAgIFx0XHRpbnRlcnBvbGF0ZSggcG9pbnQwLnksIHBvaW50MS55LCBwb2ludDIueSwgcG9pbnQzLnksIHdlaWdodCApXG4gICAgXHQpO1xuXG4gICAgfTtcblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAqXHRDdWJpYyBCZXppZXIgY3VydmVcbiAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICBmdW5jdGlvbiBDdWJpY0JlemllckN1cnZlKCB2MCwgdjEsIHYyLCB2MyApIHtcblxuICAgIFx0dGhpcy52MCA9IHYwO1xuICAgIFx0dGhpcy52MSA9IHYxO1xuICAgIFx0dGhpcy52MiA9IHYyO1xuICAgIFx0dGhpcy52MyA9IHYzO1xuXG4gICAgfVxuXG4gICAgQ3ViaWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBDdXJ2ZS5wcm90b3R5cGUgKTtcbiAgICBDdWJpY0JlemllckN1cnZlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEN1YmljQmV6aWVyQ3VydmU7XG5cbiAgICBDdWJpY0JlemllckN1cnZlLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uICggdCApIHtcblxuICAgIFx0dmFyIGIzID0gZXhwb3J0cy5TaGFwZVV0aWxzLmIzO1xuXG4gICAgXHRyZXR1cm4gbmV3IFZlY3RvcjIoXG4gICAgXHRcdGIzKCB0LCB0aGlzLnYwLngsIHRoaXMudjEueCwgdGhpcy52Mi54LCB0aGlzLnYzLnggKSxcbiAgICBcdFx0YjMoIHQsIHRoaXMudjAueSwgdGhpcy52MS55LCB0aGlzLnYyLnksIHRoaXMudjMueSApXG4gICAgXHQpO1xuXG4gICAgfTtcblxuICAgIEN1YmljQmV6aWVyQ3VydmUucHJvdG90eXBlLmdldFRhbmdlbnQgPSBmdW5jdGlvbiggdCApIHtcblxuICAgIFx0dmFyIHRhbmdlbnRDdWJpY0JlemllciA9IGV4cG9ydHMuQ3VydmVVdGlscy50YW5nZW50Q3ViaWNCZXppZXI7XG5cbiAgICBcdHJldHVybiBuZXcgVmVjdG9yMihcbiAgICBcdFx0dGFuZ2VudEN1YmljQmV6aWVyKCB0LCB0aGlzLnYwLngsIHRoaXMudjEueCwgdGhpcy52Mi54LCB0aGlzLnYzLnggKSxcbiAgICBcdFx0dGFuZ2VudEN1YmljQmV6aWVyKCB0LCB0aGlzLnYwLnksIHRoaXMudjEueSwgdGhpcy52Mi55LCB0aGlzLnYzLnkgKVxuICAgIFx0KS5ub3JtYWxpemUoKTtcblxuICAgIH07XG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgKlx0UXVhZHJhdGljIEJlemllciBjdXJ2ZVxuICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXG4gICAgZnVuY3Rpb24gUXVhZHJhdGljQmV6aWVyQ3VydmUoIHYwLCB2MSwgdjIgKSB7XG5cbiAgICBcdHRoaXMudjAgPSB2MDtcbiAgICBcdHRoaXMudjEgPSB2MTtcbiAgICBcdHRoaXMudjIgPSB2MjtcblxuICAgIH1cblxuICAgIFF1YWRyYXRpY0JlemllckN1cnZlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEN1cnZlLnByb3RvdHlwZSApO1xuICAgIFF1YWRyYXRpY0JlemllckN1cnZlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFF1YWRyYXRpY0JlemllckN1cnZlO1xuXG5cbiAgICBRdWFkcmF0aWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiAoIHQgKSB7XG5cbiAgICBcdHZhciBiMiA9IGV4cG9ydHMuU2hhcGVVdGlscy5iMjtcblxuICAgIFx0cmV0dXJuIG5ldyBWZWN0b3IyKFxuICAgIFx0XHRiMiggdCwgdGhpcy52MC54LCB0aGlzLnYxLngsIHRoaXMudjIueCApLFxuICAgIFx0XHRiMiggdCwgdGhpcy52MC55LCB0aGlzLnYxLnksIHRoaXMudjIueSApXG4gICAgXHQpO1xuXG4gICAgfTtcblxuXG4gICAgUXVhZHJhdGljQmV6aWVyQ3VydmUucHJvdG90eXBlLmdldFRhbmdlbnQgPSBmdW5jdGlvbiggdCApIHtcblxuICAgIFx0dmFyIHRhbmdlbnRRdWFkcmF0aWNCZXppZXIgPSBleHBvcnRzLkN1cnZlVXRpbHMudGFuZ2VudFF1YWRyYXRpY0JlemllcjtcblxuICAgIFx0cmV0dXJuIG5ldyBWZWN0b3IyKFxuICAgIFx0XHR0YW5nZW50UXVhZHJhdGljQmV6aWVyKCB0LCB0aGlzLnYwLngsIHRoaXMudjEueCwgdGhpcy52Mi54ICksXG4gICAgXHRcdHRhbmdlbnRRdWFkcmF0aWNCZXppZXIoIHQsIHRoaXMudjAueSwgdGhpcy52MS55LCB0aGlzLnYyLnkgKVxuICAgIFx0KS5ub3JtYWxpemUoKTtcblxuICAgIH07XG5cbiAgICB2YXIgUGF0aFByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIEN1cnZlUGF0aC5wcm90b3R5cGUgKSwge1xuXG4gICAgXHRmcm9tUG9pbnRzOiBmdW5jdGlvbiAoIHZlY3RvcnMgKSB7XG5cbiAgICBcdFx0dGhpcy5tb3ZlVG8oIHZlY3RvcnNbIDAgXS54LCB2ZWN0b3JzWyAwIF0ueSApO1xuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMSwgbCA9IHZlY3RvcnMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgIFx0XHRcdHRoaXMubGluZVRvKCB2ZWN0b3JzWyBpIF0ueCwgdmVjdG9yc1sgaSBdLnkgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdH0sXG5cbiAgICBcdG1vdmVUbzogZnVuY3Rpb24gKCB4LCB5ICkge1xuXG4gICAgXHRcdHRoaXMuY3VycmVudFBvaW50LnNldCggeCwgeSApOyAvLyBUT0RPIGNvbnNpZGVyIHJlZmVyZW5jaW5nIHZlY3RvcnMgaW5zdGVhZCBvZiBjb3B5aW5nP1xuXG4gICAgXHR9LFxuXG4gICAgXHRsaW5lVG86IGZ1bmN0aW9uICggeCwgeSApIHtcblxuICAgIFx0XHR2YXIgY3VydmUgPSBuZXcgTGluZUN1cnZlKCB0aGlzLmN1cnJlbnRQb2ludC5jbG9uZSgpLCBuZXcgVmVjdG9yMiggeCwgeSApICk7XG4gICAgXHRcdHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XG5cbiAgICBcdFx0dGhpcy5jdXJyZW50UG9pbnQuc2V0KCB4LCB5ICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdHF1YWRyYXRpY0N1cnZlVG86IGZ1bmN0aW9uICggYUNQeCwgYUNQeSwgYVgsIGFZICkge1xuXG4gICAgXHRcdHZhciBjdXJ2ZSA9IG5ldyBRdWFkcmF0aWNCZXppZXJDdXJ2ZShcbiAgICBcdFx0XHR0aGlzLmN1cnJlbnRQb2ludC5jbG9uZSgpLFxuICAgIFx0XHRcdG5ldyBWZWN0b3IyKCBhQ1B4LCBhQ1B5ICksXG4gICAgXHRcdFx0bmV3IFZlY3RvcjIoIGFYLCBhWSApXG4gICAgXHRcdCk7XG5cbiAgICBcdFx0dGhpcy5jdXJ2ZXMucHVzaCggY3VydmUgKTtcblxuICAgIFx0XHR0aGlzLmN1cnJlbnRQb2ludC5zZXQoIGFYLCBhWSApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRiZXppZXJDdXJ2ZVRvOiBmdW5jdGlvbiAoIGFDUDF4LCBhQ1AxeSwgYUNQMngsIGFDUDJ5LCBhWCwgYVkgKSB7XG5cbiAgICBcdFx0dmFyIGN1cnZlID0gbmV3IEN1YmljQmV6aWVyQ3VydmUoXG4gICAgXHRcdFx0dGhpcy5jdXJyZW50UG9pbnQuY2xvbmUoKSxcbiAgICBcdFx0XHRuZXcgVmVjdG9yMiggYUNQMXgsIGFDUDF5ICksXG4gICAgXHRcdFx0bmV3IFZlY3RvcjIoIGFDUDJ4LCBhQ1AyeSApLFxuICAgIFx0XHRcdG5ldyBWZWN0b3IyKCBhWCwgYVkgKVxuICAgIFx0XHQpO1xuXG4gICAgXHRcdHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XG5cbiAgICBcdFx0dGhpcy5jdXJyZW50UG9pbnQuc2V0KCBhWCwgYVkgKTtcblxuICAgIFx0fSxcblxuICAgIFx0c3BsaW5lVGhydTogZnVuY3Rpb24gKCBwdHMgLypBcnJheSBvZiBWZWN0b3IqLyApIHtcblxuICAgIFx0XHR2YXIgbnB0cyA9IFsgdGhpcy5jdXJyZW50UG9pbnQuY2xvbmUoKSBdLmNvbmNhdCggcHRzICk7XG5cbiAgICBcdFx0dmFyIGN1cnZlID0gbmV3IFNwbGluZUN1cnZlKCBucHRzICk7XG4gICAgXHRcdHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XG5cbiAgICBcdFx0dGhpcy5jdXJyZW50UG9pbnQuY29weSggcHRzWyBwdHMubGVuZ3RoIC0gMSBdICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGFyYzogZnVuY3Rpb24gKCBhWCwgYVksIGFSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKSB7XG5cbiAgICBcdFx0dmFyIHgwID0gdGhpcy5jdXJyZW50UG9pbnQueDtcbiAgICBcdFx0dmFyIHkwID0gdGhpcy5jdXJyZW50UG9pbnQueTtcblxuICAgIFx0XHR0aGlzLmFic2FyYyggYVggKyB4MCwgYVkgKyB5MCwgYVJhZGl1cyxcbiAgICBcdFx0XHRhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGFic2FyYzogZnVuY3Rpb24gKCBhWCwgYVksIGFSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKSB7XG5cbiAgICBcdFx0dGhpcy5hYnNlbGxpcHNlKCBhWCwgYVksIGFSYWRpdXMsIGFSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKTtcblxuICAgIFx0fSxcblxuICAgIFx0ZWxsaXBzZTogZnVuY3Rpb24gKCBhWCwgYVksIHhSYWRpdXMsIHlSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UsIGFSb3RhdGlvbiApIHtcblxuICAgIFx0XHR2YXIgeDAgPSB0aGlzLmN1cnJlbnRQb2ludC54O1xuICAgIFx0XHR2YXIgeTAgPSB0aGlzLmN1cnJlbnRQb2ludC55O1xuXG4gICAgXHRcdHRoaXMuYWJzZWxsaXBzZSggYVggKyB4MCwgYVkgKyB5MCwgeFJhZGl1cywgeVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSwgYVJvdGF0aW9uICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGFic2VsbGlwc2U6IGZ1bmN0aW9uICggYVgsIGFZLCB4UmFkaXVzLCB5UmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlLCBhUm90YXRpb24gKSB7XG5cbiAgICBcdFx0dmFyIGN1cnZlID0gbmV3IEVsbGlwc2VDdXJ2ZSggYVgsIGFZLCB4UmFkaXVzLCB5UmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlLCBhUm90YXRpb24gKTtcblxuICAgIFx0XHRpZiAoIHRoaXMuY3VydmVzLmxlbmd0aCA+IDAgKSB7XG5cbiAgICBcdFx0XHQvLyBpZiBhIHByZXZpb3VzIGN1cnZlIGlzIHByZXNlbnQsIGF0dGVtcHQgdG8gam9pblxuICAgIFx0XHRcdHZhciBmaXJzdFBvaW50ID0gY3VydmUuZ2V0UG9pbnQoIDAgKTtcblxuICAgIFx0XHRcdGlmICggISBmaXJzdFBvaW50LmVxdWFscyggdGhpcy5jdXJyZW50UG9pbnQgKSApIHtcblxuICAgIFx0XHRcdFx0dGhpcy5saW5lVG8oIGZpcnN0UG9pbnQueCwgZmlyc3RQb2ludC55ICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XG5cbiAgICBcdFx0dmFyIGxhc3RQb2ludCA9IGN1cnZlLmdldFBvaW50KCAxICk7XG4gICAgXHRcdHRoaXMuY3VycmVudFBvaW50LmNvcHkoIGxhc3RQb2ludCApO1xuXG4gICAgXHR9XG5cbiAgICB9ICk7XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXG4gICAgICogRGVmaW5lcyBhIDJkIHNoYXBlIHBsYW5lIHVzaW5nIHBhdGhzLlxuICAgICAqKi9cblxuICAgIC8vIFNURVAgMSBDcmVhdGUgYSBwYXRoLlxuICAgIC8vIFNURVAgMiBUdXJuIHBhdGggaW50byBzaGFwZS5cbiAgICAvLyBTVEVQIDMgRXh0cnVkZUdlb21ldHJ5IHRha2VzIGluIFNoYXBlL1NoYXBlc1xuICAgIC8vIFNURVAgM2EgLSBFeHRyYWN0IHBvaW50cyBmcm9tIGVhY2ggc2hhcGUsIHR1cm4gdG8gdmVydGljZXNcbiAgICAvLyBTVEVQIDNiIC0gVHJpYW5ndWxhdGUgZWFjaCBzaGFwZSwgYWRkIGZhY2VzLlxuXG4gICAgZnVuY3Rpb24gU2hhcGUoKSB7XG5cbiAgICBcdFBhdGguYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXG4gICAgXHR0aGlzLmhvbGVzID0gW107XG5cbiAgICB9XG5cbiAgICBTaGFwZS5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBQYXRoUHJvdG90eXBlICksIHtcblxuICAgIFx0Y29uc3RydWN0b3I6IFNoYXBlLFxuXG4gICAgXHRnZXRQb2ludHNIb2xlczogZnVuY3Rpb24gKCBkaXZpc2lvbnMgKSB7XG5cbiAgICBcdFx0dmFyIGhvbGVzUHRzID0gW107XG5cbiAgICBcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy5ob2xlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgXHRcdFx0aG9sZXNQdHNbIGkgXSA9IHRoaXMuaG9sZXNbIGkgXS5nZXRQb2ludHMoIGRpdmlzaW9ucyApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gaG9sZXNQdHM7XG5cbiAgICBcdH0sXG5cbiAgICBcdC8vIEdldCBwb2ludHMgb2Ygc2hhcGUgYW5kIGhvbGVzIChrZXlwb2ludHMgYmFzZWQgb24gc2VnbWVudHMgcGFyYW1ldGVyKVxuXG4gICAgXHRleHRyYWN0QWxsUG9pbnRzOiBmdW5jdGlvbiAoIGRpdmlzaW9ucyApIHtcblxuICAgIFx0XHRyZXR1cm4ge1xuXG4gICAgXHRcdFx0c2hhcGU6IHRoaXMuZ2V0UG9pbnRzKCBkaXZpc2lvbnMgKSxcbiAgICBcdFx0XHRob2xlczogdGhpcy5nZXRQb2ludHNIb2xlcyggZGl2aXNpb25zIClcblxuICAgIFx0XHR9O1xuXG4gICAgXHR9LFxuXG4gICAgXHRleHRyYWN0UG9pbnRzOiBmdW5jdGlvbiAoIGRpdmlzaW9ucyApIHtcblxuICAgIFx0XHRyZXR1cm4gdGhpcy5leHRyYWN0QWxsUG9pbnRzKCBkaXZpc2lvbnMgKTtcblxuICAgIFx0fVxuXG4gICAgfSApO1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xuICAgICAqIENyZWF0ZXMgZnJlZSBmb3JtIDJkIHBhdGggdXNpbmcgc2VyaWVzIG9mIHBvaW50cywgbGluZXMgb3IgY3VydmVzLlxuICAgICAqXG4gICAgICoqL1xuXG4gICAgZnVuY3Rpb24gUGF0aCggcG9pbnRzICkge1xuXG4gICAgXHRDdXJ2ZVBhdGguY2FsbCggdGhpcyApO1xuICAgIFx0dGhpcy5jdXJyZW50UG9pbnQgPSBuZXcgVmVjdG9yMigpO1xuXG4gICAgXHRpZiAoIHBvaW50cyApIHtcblxuICAgIFx0XHR0aGlzLmZyb21Qb2ludHMoIHBvaW50cyApO1xuXG4gICAgXHR9XG5cbiAgICB9XG5cbiAgICBQYXRoLnByb3RvdHlwZSA9IFBhdGhQcm90b3R5cGU7XG4gICAgUGF0aFByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBhdGg7XG5cblxuICAgIC8vIG1pbmltYWwgY2xhc3MgZm9yIHByb3hpbmcgZnVuY3Rpb25zIHRvIFBhdGguIFJlcGxhY2VzIG9sZCBcImV4dHJhY3RTdWJwYXRocygpXCJcbiAgICBmdW5jdGlvbiBTaGFwZVBhdGgoKSB7XG4gICAgXHR0aGlzLnN1YlBhdGhzID0gW107XG4gICAgXHR0aGlzLmN1cnJlbnRQYXRoID0gbnVsbDtcbiAgICB9XG5cbiAgICBTaGFwZVBhdGgucHJvdG90eXBlID0ge1xuICAgIFx0bW92ZVRvOiBmdW5jdGlvbiAoIHgsIHkgKSB7XG4gICAgXHRcdHRoaXMuY3VycmVudFBhdGggPSBuZXcgUGF0aCgpO1xuICAgIFx0XHR0aGlzLnN1YlBhdGhzLnB1c2godGhpcy5jdXJyZW50UGF0aCk7XG4gICAgXHRcdHRoaXMuY3VycmVudFBhdGgubW92ZVRvKCB4LCB5ICk7XG4gICAgXHR9LFxuICAgIFx0bGluZVRvOiBmdW5jdGlvbiAoIHgsIHkgKSB7XG4gICAgXHRcdHRoaXMuY3VycmVudFBhdGgubGluZVRvKCB4LCB5ICk7XG4gICAgXHR9LFxuICAgIFx0cXVhZHJhdGljQ3VydmVUbzogZnVuY3Rpb24gKCBhQ1B4LCBhQ1B5LCBhWCwgYVkgKSB7XG4gICAgXHRcdHRoaXMuY3VycmVudFBhdGgucXVhZHJhdGljQ3VydmVUbyggYUNQeCwgYUNQeSwgYVgsIGFZICk7XG4gICAgXHR9LFxuICAgIFx0YmV6aWVyQ3VydmVUbzogZnVuY3Rpb24gKCBhQ1AxeCwgYUNQMXksIGFDUDJ4LCBhQ1AyeSwgYVgsIGFZICkge1xuICAgIFx0XHR0aGlzLmN1cnJlbnRQYXRoLmJlemllckN1cnZlVG8oIGFDUDF4LCBhQ1AxeSwgYUNQMngsIGFDUDJ5LCBhWCwgYVkgKTtcbiAgICBcdH0sXG4gICAgXHRzcGxpbmVUaHJ1OiBmdW5jdGlvbiAoIHB0cyApIHtcbiAgICBcdFx0dGhpcy5jdXJyZW50UGF0aC5zcGxpbmVUaHJ1KCBwdHMgKTtcbiAgICBcdH0sXG5cbiAgICBcdHRvU2hhcGVzOiBmdW5jdGlvbiAoIGlzQ0NXLCBub0hvbGVzICkge1xuXG4gICAgXHRcdGZ1bmN0aW9uIHRvU2hhcGVzTm9Ib2xlcyggaW5TdWJwYXRocyApIHtcblxuICAgIFx0XHRcdHZhciBzaGFwZXMgPSBbXTtcblxuICAgIFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGluU3VicGF0aHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgIFx0XHRcdFx0dmFyIHRtcFBhdGggPSBpblN1YnBhdGhzWyBpIF07XG5cbiAgICBcdFx0XHRcdHZhciB0bXBTaGFwZSA9IG5ldyBTaGFwZSgpO1xuICAgIFx0XHRcdFx0dG1wU2hhcGUuY3VydmVzID0gdG1wUGF0aC5jdXJ2ZXM7XG5cbiAgICBcdFx0XHRcdHNoYXBlcy5wdXNoKCB0bXBTaGFwZSApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0cmV0dXJuIHNoYXBlcztcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0ZnVuY3Rpb24gaXNQb2ludEluc2lkZVBvbHlnb24oIGluUHQsIGluUG9seWdvbiApIHtcblxuICAgIFx0XHRcdHZhciBwb2x5TGVuID0gaW5Qb2x5Z29uLmxlbmd0aDtcblxuICAgIFx0XHRcdC8vIGluUHQgb24gcG9seWdvbiBjb250b3VyID0+IGltbWVkaWF0ZSBzdWNjZXNzICAgIG9yXG4gICAgXHRcdFx0Ly8gdG9nZ2xpbmcgb2YgaW5zaWRlL291dHNpZGUgYXQgZXZlcnkgc2luZ2xlISBpbnRlcnNlY3Rpb24gcG9pbnQgb2YgYW4gZWRnZVxuICAgIFx0XHRcdC8vICB3aXRoIHRoZSBob3Jpem9udGFsIGxpbmUgdGhyb3VnaCBpblB0LCBsZWZ0IG9mIGluUHRcbiAgICBcdFx0XHQvLyAgbm90IGNvdW50aW5nIGxvd2VyWSBlbmRwb2ludHMgb2YgZWRnZXMgYW5kIHdob2xlIGVkZ2VzIG9uIHRoYXQgbGluZVxuICAgIFx0XHRcdHZhciBpbnNpZGUgPSBmYWxzZTtcbiAgICBcdFx0XHRmb3IgKCB2YXIgcCA9IHBvbHlMZW4gLSAxLCBxID0gMDsgcSA8IHBvbHlMZW47IHAgPSBxICsrICkge1xuXG4gICAgXHRcdFx0XHR2YXIgZWRnZUxvd1B0ICA9IGluUG9seWdvblsgcCBdO1xuICAgIFx0XHRcdFx0dmFyIGVkZ2VIaWdoUHQgPSBpblBvbHlnb25bIHEgXTtcblxuICAgIFx0XHRcdFx0dmFyIGVkZ2VEeCA9IGVkZ2VIaWdoUHQueCAtIGVkZ2VMb3dQdC54O1xuICAgIFx0XHRcdFx0dmFyIGVkZ2VEeSA9IGVkZ2VIaWdoUHQueSAtIGVkZ2VMb3dQdC55O1xuXG4gICAgXHRcdFx0XHRpZiAoIE1hdGguYWJzKCBlZGdlRHkgKSA+IE51bWJlci5FUFNJTE9OICkge1xuXG4gICAgXHRcdFx0XHRcdC8vIG5vdCBwYXJhbGxlbFxuICAgIFx0XHRcdFx0XHRpZiAoIGVkZ2VEeSA8IDAgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHRlZGdlTG93UHQgID0gaW5Qb2x5Z29uWyBxIF07IGVkZ2VEeCA9IC0gZWRnZUR4O1xuICAgIFx0XHRcdFx0XHRcdGVkZ2VIaWdoUHQgPSBpblBvbHlnb25bIHAgXTsgZWRnZUR5ID0gLSBlZGdlRHk7XG5cbiAgICBcdFx0XHRcdFx0fVxuICAgIFx0XHRcdFx0XHRpZiAoICggaW5QdC55IDwgZWRnZUxvd1B0LnkgKSB8fCAoIGluUHQueSA+IGVkZ2VIaWdoUHQueSApICkgXHRcdGNvbnRpbnVlO1xuXG4gICAgXHRcdFx0XHRcdGlmICggaW5QdC55ID09PSBlZGdlTG93UHQueSApIHtcblxuICAgIFx0XHRcdFx0XHRcdGlmICggaW5QdC54ID09PSBlZGdlTG93UHQueCApXHRcdHJldHVyblx0dHJ1ZTtcdFx0Ly8gaW5QdCBpcyBvbiBjb250b3VyID9cbiAgICBcdFx0XHRcdFx0XHQvLyBjb250aW51ZTtcdFx0XHRcdC8vIG5vIGludGVyc2VjdGlvbiBvciBlZGdlTG93UHQgPT4gZG9lc24ndCBjb3VudCAhISFcblxuICAgIFx0XHRcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRcdFx0dmFyIHBlcnBFZGdlID0gZWRnZUR5ICogKCBpblB0LnggLSBlZGdlTG93UHQueCApIC0gZWRnZUR4ICogKCBpblB0LnkgLSBlZGdlTG93UHQueSApO1xuICAgIFx0XHRcdFx0XHRcdGlmICggcGVycEVkZ2UgPT09IDAgKVx0XHRcdFx0cmV0dXJuXHR0cnVlO1x0XHQvLyBpblB0IGlzIG9uIGNvbnRvdXIgP1xuICAgIFx0XHRcdFx0XHRcdGlmICggcGVycEVkZ2UgPCAwICkgXHRcdFx0XHRjb250aW51ZTtcbiAgICBcdFx0XHRcdFx0XHRpbnNpZGUgPSAhIGluc2lkZTtcdFx0Ly8gdHJ1ZSBpbnRlcnNlY3Rpb24gbGVmdCBvZiBpblB0XG5cbiAgICBcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRcdC8vIHBhcmFsbGVsIG9yIGNvbGxpbmVhclxuICAgIFx0XHRcdFx0XHRpZiAoIGluUHQueSAhPT0gZWRnZUxvd1B0LnkgKSBcdFx0Y29udGludWU7XHRcdFx0Ly8gcGFyYWxsZWxcbiAgICBcdFx0XHRcdFx0Ly8gZWRnZSBsaWVzIG9uIHRoZSBzYW1lIGhvcml6b250YWwgbGluZSBhcyBpblB0XG4gICAgXHRcdFx0XHRcdGlmICggKCAoIGVkZ2VIaWdoUHQueCA8PSBpblB0LnggKSAmJiAoIGluUHQueCA8PSBlZGdlTG93UHQueCApICkgfHxcbiAgICBcdFx0XHRcdFx0XHQgKCAoIGVkZ2VMb3dQdC54IDw9IGluUHQueCApICYmICggaW5QdC54IDw9IGVkZ2VIaWdoUHQueCApICkgKVx0XHRyZXR1cm5cdHRydWU7XHQvLyBpblB0OiBQb2ludCBvbiBjb250b3VyICFcbiAgICBcdFx0XHRcdFx0Ly8gY29udGludWU7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdHJldHVyblx0aW5zaWRlO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHR2YXIgaXNDbG9ja1dpc2UgPSBleHBvcnRzLlNoYXBlVXRpbHMuaXNDbG9ja1dpc2U7XG5cbiAgICBcdFx0dmFyIHN1YlBhdGhzID0gdGhpcy5zdWJQYXRocztcbiAgICBcdFx0aWYgKCBzdWJQYXRocy5sZW5ndGggPT09IDAgKSByZXR1cm4gW107XG5cbiAgICBcdFx0aWYgKCBub0hvbGVzID09PSB0cnVlIClcdHJldHVyblx0dG9TaGFwZXNOb0hvbGVzKCBzdWJQYXRocyApO1xuXG5cbiAgICBcdFx0dmFyIHNvbGlkLCB0bXBQYXRoLCB0bXBTaGFwZSwgc2hhcGVzID0gW107XG5cbiAgICBcdFx0aWYgKCBzdWJQYXRocy5sZW5ndGggPT09IDEgKSB7XG5cbiAgICBcdFx0XHR0bXBQYXRoID0gc3ViUGF0aHNbIDAgXTtcbiAgICBcdFx0XHR0bXBTaGFwZSA9IG5ldyBTaGFwZSgpO1xuICAgIFx0XHRcdHRtcFNoYXBlLmN1cnZlcyA9IHRtcFBhdGguY3VydmVzO1xuICAgIFx0XHRcdHNoYXBlcy5wdXNoKCB0bXBTaGFwZSApO1xuICAgIFx0XHRcdHJldHVybiBzaGFwZXM7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHZhciBob2xlc0ZpcnN0ID0gISBpc0Nsb2NrV2lzZSggc3ViUGF0aHNbIDAgXS5nZXRQb2ludHMoKSApO1xuICAgIFx0XHRob2xlc0ZpcnN0ID0gaXNDQ1cgPyAhIGhvbGVzRmlyc3QgOiBob2xlc0ZpcnN0O1xuXG4gICAgXHRcdC8vIGNvbnNvbGUubG9nKFwiSG9sZXMgZmlyc3RcIiwgaG9sZXNGaXJzdCk7XG5cbiAgICBcdFx0dmFyIGJldHRlclNoYXBlSG9sZXMgPSBbXTtcbiAgICBcdFx0dmFyIG5ld1NoYXBlcyA9IFtdO1xuICAgIFx0XHR2YXIgbmV3U2hhcGVIb2xlcyA9IFtdO1xuICAgIFx0XHR2YXIgbWFpbklkeCA9IDA7XG4gICAgXHRcdHZhciB0bXBQb2ludHM7XG5cbiAgICBcdFx0bmV3U2hhcGVzWyBtYWluSWR4IF0gPSB1bmRlZmluZWQ7XG4gICAgXHRcdG5ld1NoYXBlSG9sZXNbIG1haW5JZHggXSA9IFtdO1xuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHN1YlBhdGhzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICBcdFx0XHR0bXBQYXRoID0gc3ViUGF0aHNbIGkgXTtcbiAgICBcdFx0XHR0bXBQb2ludHMgPSB0bXBQYXRoLmdldFBvaW50cygpO1xuICAgIFx0XHRcdHNvbGlkID0gaXNDbG9ja1dpc2UoIHRtcFBvaW50cyApO1xuICAgIFx0XHRcdHNvbGlkID0gaXNDQ1cgPyAhIHNvbGlkIDogc29saWQ7XG5cbiAgICBcdFx0XHRpZiAoIHNvbGlkICkge1xuXG4gICAgXHRcdFx0XHRpZiAoICggISBob2xlc0ZpcnN0ICkgJiYgKCBuZXdTaGFwZXNbIG1haW5JZHggXSApIClcdG1haW5JZHggKys7XG5cbiAgICBcdFx0XHRcdG5ld1NoYXBlc1sgbWFpbklkeCBdID0geyBzOiBuZXcgU2hhcGUoKSwgcDogdG1wUG9pbnRzIH07XG4gICAgXHRcdFx0XHRuZXdTaGFwZXNbIG1haW5JZHggXS5zLmN1cnZlcyA9IHRtcFBhdGguY3VydmVzO1xuXG4gICAgXHRcdFx0XHRpZiAoIGhvbGVzRmlyc3QgKVx0bWFpbklkeCArKztcbiAgICBcdFx0XHRcdG5ld1NoYXBlSG9sZXNbIG1haW5JZHggXSA9IFtdO1xuXG4gICAgXHRcdFx0XHQvL2NvbnNvbGUubG9nKCdjdycsIGkpO1xuXG4gICAgXHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0bmV3U2hhcGVIb2xlc1sgbWFpbklkeCBdLnB1c2goIHsgaDogdG1wUGF0aCwgcDogdG1wUG9pbnRzWyAwIF0gfSApO1xuXG4gICAgXHRcdFx0XHQvL2NvbnNvbGUubG9nKCdjY3cnLCBpKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdFx0Ly8gb25seSBIb2xlcz8gLT4gcHJvYmFibHkgYWxsIFNoYXBlcyB3aXRoIHdyb25nIG9yaWVudGF0aW9uXG4gICAgXHRcdGlmICggISBuZXdTaGFwZXNbIDAgXSApXHRyZXR1cm5cdHRvU2hhcGVzTm9Ib2xlcyggc3ViUGF0aHMgKTtcblxuXG4gICAgXHRcdGlmICggbmV3U2hhcGVzLmxlbmd0aCA+IDEgKSB7XG5cbiAgICBcdFx0XHR2YXIgYW1iaWd1b3VzID0gZmFsc2U7XG4gICAgXHRcdFx0dmFyIHRvQ2hhbmdlID0gW107XG5cbiAgICBcdFx0XHRmb3IgKCB2YXIgc0lkeCA9IDAsIHNMZW4gPSBuZXdTaGFwZXMubGVuZ3RoOyBzSWR4IDwgc0xlbjsgc0lkeCArKyApIHtcblxuICAgIFx0XHRcdFx0YmV0dGVyU2hhcGVIb2xlc1sgc0lkeCBdID0gW107XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRmb3IgKCB2YXIgc0lkeCA9IDAsIHNMZW4gPSBuZXdTaGFwZXMubGVuZ3RoOyBzSWR4IDwgc0xlbjsgc0lkeCArKyApIHtcblxuICAgIFx0XHRcdFx0dmFyIHNobyA9IG5ld1NoYXBlSG9sZXNbIHNJZHggXTtcblxuICAgIFx0XHRcdFx0Zm9yICggdmFyIGhJZHggPSAwOyBoSWR4IDwgc2hvLmxlbmd0aDsgaElkeCArKyApIHtcblxuICAgIFx0XHRcdFx0XHR2YXIgaG8gPSBzaG9bIGhJZHggXTtcbiAgICBcdFx0XHRcdFx0dmFyIGhvbGVfdW5hc3NpZ25lZCA9IHRydWU7XG5cbiAgICBcdFx0XHRcdFx0Zm9yICggdmFyIHMySWR4ID0gMDsgczJJZHggPCBuZXdTaGFwZXMubGVuZ3RoOyBzMklkeCArKyApIHtcblxuICAgIFx0XHRcdFx0XHRcdGlmICggaXNQb2ludEluc2lkZVBvbHlnb24oIGhvLnAsIG5ld1NoYXBlc1sgczJJZHggXS5wICkgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHRcdGlmICggc0lkeCAhPT0gczJJZHggKVx0dG9DaGFuZ2UucHVzaCggeyBmcm9tczogc0lkeCwgdG9zOiBzMklkeCwgaG9sZTogaElkeCB9ICk7XG4gICAgXHRcdFx0XHRcdFx0XHRpZiAoIGhvbGVfdW5hc3NpZ25lZCApIHtcblxuICAgIFx0XHRcdFx0XHRcdFx0XHRob2xlX3VuYXNzaWduZWQgPSBmYWxzZTtcbiAgICBcdFx0XHRcdFx0XHRcdFx0YmV0dGVyU2hhcGVIb2xlc1sgczJJZHggXS5wdXNoKCBobyApO1xuXG4gICAgXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRcdFx0XHRcdGFtYmlndW91cyA9IHRydWU7XG5cbiAgICBcdFx0XHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0XHR9XG4gICAgXHRcdFx0XHRcdGlmICggaG9sZV91bmFzc2lnbmVkICkge1xuXG4gICAgXHRcdFx0XHRcdFx0YmV0dGVyU2hhcGVIb2xlc1sgc0lkeCBdLnB1c2goIGhvICk7XG5cbiAgICBcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9XG4gICAgXHRcdFx0Ly8gY29uc29sZS5sb2coXCJhbWJpZ3VvdXM6IFwiLCBhbWJpZ3VvdXMpO1xuICAgIFx0XHRcdGlmICggdG9DaGFuZ2UubGVuZ3RoID4gMCApIHtcblxuICAgIFx0XHRcdFx0Ly8gY29uc29sZS5sb2coXCJ0byBjaGFuZ2U6IFwiLCB0b0NoYW5nZSk7XG4gICAgXHRcdFx0XHRpZiAoICEgYW1iaWd1b3VzIClcdG5ld1NoYXBlSG9sZXMgPSBiZXR0ZXJTaGFwZUhvbGVzO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHR2YXIgdG1wSG9sZXM7XG5cbiAgICBcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IG5ld1NoYXBlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgIFx0XHRcdHRtcFNoYXBlID0gbmV3U2hhcGVzWyBpIF0ucztcbiAgICBcdFx0XHRzaGFwZXMucHVzaCggdG1wU2hhcGUgKTtcbiAgICBcdFx0XHR0bXBIb2xlcyA9IG5ld1NoYXBlSG9sZXNbIGkgXTtcblxuICAgIFx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSB0bXBIb2xlcy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuICAgIFx0XHRcdFx0dG1wU2hhcGUuaG9sZXMucHVzaCggdG1wSG9sZXNbIGogXS5oICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdC8vY29uc29sZS5sb2coXCJzaGFwZVwiLCBzaGFwZXMpO1xuXG4gICAgXHRcdHJldHVybiBzaGFwZXM7XG5cbiAgICBcdH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXG4gICAgICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIEZvbnQoIGRhdGEgKSB7XG5cbiAgICBcdHRoaXMuZGF0YSA9IGRhdGE7XG5cbiAgICB9XG5cbiAgICBPYmplY3QuYXNzaWduKCBGb250LnByb3RvdHlwZSwge1xuXG4gICAgXHRpc0ZvbnQ6IHRydWUsXG5cbiAgICBcdGdlbmVyYXRlU2hhcGVzOiBmdW5jdGlvbiAoIHRleHQsIHNpemUsIGRpdmlzaW9ucyApIHtcblxuICAgIFx0XHRmdW5jdGlvbiBjcmVhdGVQYXRocyggdGV4dCApIHtcblxuICAgIFx0XHRcdHZhciBjaGFycyA9IFN0cmluZyggdGV4dCApLnNwbGl0KCAnJyApO1xuICAgIFx0XHRcdHZhciBzY2FsZSA9IHNpemUgLyBkYXRhLnJlc29sdXRpb247XG4gICAgXHRcdFx0dmFyIG9mZnNldCA9IDA7XG5cbiAgICBcdFx0XHR2YXIgcGF0aHMgPSBbXTtcblxuICAgIFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGNoYXJzLmxlbmd0aDsgaSArKyApIHtcblxuICAgIFx0XHRcdFx0dmFyIHJldCA9IGNyZWF0ZVBhdGgoIGNoYXJzWyBpIF0sIHNjYWxlLCBvZmZzZXQgKTtcbiAgICBcdFx0XHRcdG9mZnNldCArPSByZXQub2Zmc2V0O1xuXG4gICAgXHRcdFx0XHRwYXRocy5wdXNoKCByZXQucGF0aCApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0cmV0dXJuIHBhdGhzO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRmdW5jdGlvbiBjcmVhdGVQYXRoKCBjLCBzY2FsZSwgb2Zmc2V0ICkge1xuXG4gICAgXHRcdFx0dmFyIGdseXBoID0gZGF0YS5nbHlwaHNbIGMgXSB8fCBkYXRhLmdseXBoc1sgJz8nIF07XG5cbiAgICBcdFx0XHRpZiAoICEgZ2x5cGggKSByZXR1cm47XG5cbiAgICBcdFx0XHR2YXIgcGF0aCA9IG5ldyBTaGFwZVBhdGgoKTtcblxuICAgIFx0XHRcdHZhciBwdHMgPSBbXSwgYjIgPSBleHBvcnRzLlNoYXBlVXRpbHMuYjIsIGIzID0gZXhwb3J0cy5TaGFwZVV0aWxzLmIzO1xuICAgIFx0XHRcdHZhciB4LCB5LCBjcHgsIGNweSwgY3B4MCwgY3B5MCwgY3B4MSwgY3B5MSwgY3B4MiwgY3B5MiwgbGFzdGU7XG5cbiAgICBcdFx0XHRpZiAoIGdseXBoLm8gKSB7XG5cbiAgICBcdFx0XHRcdHZhciBvdXRsaW5lID0gZ2x5cGguX2NhY2hlZE91dGxpbmUgfHwgKCBnbHlwaC5fY2FjaGVkT3V0bGluZSA9IGdseXBoLm8uc3BsaXQoICcgJyApICk7XG5cbiAgICBcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IG91dGxpbmUubGVuZ3RoOyBpIDwgbDsgKSB7XG5cbiAgICBcdFx0XHRcdFx0dmFyIGFjdGlvbiA9IG91dGxpbmVbIGkgKysgXTtcblxuICAgIFx0XHRcdFx0XHRzd2l0Y2ggKCBhY3Rpb24gKSB7XG5cbiAgICBcdFx0XHRcdFx0XHRjYXNlICdtJzogLy8gbW92ZVRvXG5cbiAgICBcdFx0XHRcdFx0XHRcdHggPSBvdXRsaW5lWyBpICsrIF0gKiBzY2FsZSArIG9mZnNldDtcbiAgICBcdFx0XHRcdFx0XHRcdHkgPSBvdXRsaW5lWyBpICsrIF0gKiBzY2FsZTtcblxuICAgIFx0XHRcdFx0XHRcdFx0cGF0aC5tb3ZlVG8oIHgsIHkgKTtcblxuICAgIFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cbiAgICBcdFx0XHRcdFx0XHRjYXNlICdsJzogLy8gbGluZVRvXG5cbiAgICBcdFx0XHRcdFx0XHRcdHggPSBvdXRsaW5lWyBpICsrIF0gKiBzY2FsZSArIG9mZnNldDtcbiAgICBcdFx0XHRcdFx0XHRcdHkgPSBvdXRsaW5lWyBpICsrIF0gKiBzY2FsZTtcblxuICAgIFx0XHRcdFx0XHRcdFx0cGF0aC5saW5lVG8oIHgsIHkgKTtcblxuICAgIFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cbiAgICBcdFx0XHRcdFx0XHRjYXNlICdxJzogLy8gcXVhZHJhdGljQ3VydmVUb1xuXG4gICAgXHRcdFx0XHRcdFx0XHRjcHggID0gb3V0bGluZVsgaSArKyBdICogc2NhbGUgKyBvZmZzZXQ7XG4gICAgXHRcdFx0XHRcdFx0XHRjcHkgID0gb3V0bGluZVsgaSArKyBdICogc2NhbGU7XG4gICAgXHRcdFx0XHRcdFx0XHRjcHgxID0gb3V0bGluZVsgaSArKyBdICogc2NhbGUgKyBvZmZzZXQ7XG4gICAgXHRcdFx0XHRcdFx0XHRjcHkxID0gb3V0bGluZVsgaSArKyBdICogc2NhbGU7XG5cbiAgICBcdFx0XHRcdFx0XHRcdHBhdGgucXVhZHJhdGljQ3VydmVUbyggY3B4MSwgY3B5MSwgY3B4LCBjcHkgKTtcblxuICAgIFx0XHRcdFx0XHRcdFx0bGFzdGUgPSBwdHNbIHB0cy5sZW5ndGggLSAxIF07XG5cbiAgICBcdFx0XHRcdFx0XHRcdGlmICggbGFzdGUgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHRcdFx0Y3B4MCA9IGxhc3RlLng7XG4gICAgXHRcdFx0XHRcdFx0XHRcdGNweTAgPSBsYXN0ZS55O1xuXG4gICAgXHRcdFx0XHRcdFx0XHRcdGZvciAoIHZhciBpMiA9IDE7IGkyIDw9IGRpdmlzaW9uczsgaTIgKysgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHRcdFx0XHR2YXIgdCA9IGkyIC8gZGl2aXNpb25zO1xuICAgIFx0XHRcdFx0XHRcdFx0XHRcdGIyKCB0LCBjcHgwLCBjcHgxLCBjcHggKTtcbiAgICBcdFx0XHRcdFx0XHRcdFx0XHRiMiggdCwgY3B5MCwgY3B5MSwgY3B5ICk7XG5cbiAgICBcdFx0XHRcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG4gICAgXHRcdFx0XHRcdFx0Y2FzZSAnYic6IC8vIGJlemllckN1cnZlVG9cblxuICAgIFx0XHRcdFx0XHRcdFx0Y3B4ICA9IG91dGxpbmVbIGkgKysgXSAqIHNjYWxlICsgb2Zmc2V0O1xuICAgIFx0XHRcdFx0XHRcdFx0Y3B5ICA9IG91dGxpbmVbIGkgKysgXSAqIHNjYWxlO1xuICAgIFx0XHRcdFx0XHRcdFx0Y3B4MSA9IG91dGxpbmVbIGkgKysgXSAqIHNjYWxlICsgb2Zmc2V0O1xuICAgIFx0XHRcdFx0XHRcdFx0Y3B5MSA9IG91dGxpbmVbIGkgKysgXSAqIHNjYWxlO1xuICAgIFx0XHRcdFx0XHRcdFx0Y3B4MiA9IG91dGxpbmVbIGkgKysgXSAqIHNjYWxlICsgb2Zmc2V0O1xuICAgIFx0XHRcdFx0XHRcdFx0Y3B5MiA9IG91dGxpbmVbIGkgKysgXSAqIHNjYWxlO1xuXG4gICAgXHRcdFx0XHRcdFx0XHRwYXRoLmJlemllckN1cnZlVG8oIGNweDEsIGNweTEsIGNweDIsIGNweTIsIGNweCwgY3B5ICk7XG5cbiAgICBcdFx0XHRcdFx0XHRcdGxhc3RlID0gcHRzWyBwdHMubGVuZ3RoIC0gMSBdO1xuXG4gICAgXHRcdFx0XHRcdFx0XHRpZiAoIGxhc3RlICkge1xuXG4gICAgXHRcdFx0XHRcdFx0XHRcdGNweDAgPSBsYXN0ZS54O1xuICAgIFx0XHRcdFx0XHRcdFx0XHRjcHkwID0gbGFzdGUueTtcblxuICAgIFx0XHRcdFx0XHRcdFx0XHRmb3IgKCB2YXIgaTIgPSAxOyBpMiA8PSBkaXZpc2lvbnM7IGkyICsrICkge1xuXG4gICAgXHRcdFx0XHRcdFx0XHRcdFx0dmFyIHQgPSBpMiAvIGRpdmlzaW9ucztcbiAgICBcdFx0XHRcdFx0XHRcdFx0XHRiMyggdCwgY3B4MCwgY3B4MSwgY3B4MiwgY3B4ICk7XG4gICAgXHRcdFx0XHRcdFx0XHRcdFx0YjMoIHQsIGNweTAsIGNweTEsIGNweTIsIGNweSApO1xuXG4gICAgXHRcdFx0XHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRcdFx0XHRicmVhaztcblxuICAgIFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdHJldHVybiB7IG9mZnNldDogZ2x5cGguaGEgKiBzY2FsZSwgcGF0aDogcGF0aCB9O1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHQvL1xuXG4gICAgXHRcdGlmICggc2l6ZSA9PT0gdW5kZWZpbmVkICkgc2l6ZSA9IDEwMDtcbiAgICBcdFx0aWYgKCBkaXZpc2lvbnMgPT09IHVuZGVmaW5lZCApIGRpdmlzaW9ucyA9IDQ7XG5cbiAgICBcdFx0dmFyIGRhdGEgPSB0aGlzLmRhdGE7XG5cbiAgICBcdFx0dmFyIHBhdGhzID0gY3JlYXRlUGF0aHMoIHRleHQgKTtcbiAgICBcdFx0dmFyIHNoYXBlcyA9IFtdO1xuXG4gICAgXHRcdGZvciAoIHZhciBwID0gMCwgcGwgPSBwYXRocy5sZW5ndGg7IHAgPCBwbDsgcCArKyApIHtcblxuICAgIFx0XHRcdEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KCBzaGFwZXMsIHBhdGhzWyBwIF0udG9TaGFwZXMoKSApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gc2hhcGVzO1xuXG4gICAgXHR9XG5cbiAgICB9ICk7XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gRm9udExvYWRlciggbWFuYWdlciApIHtcblxuICAgIFx0dGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBleHBvcnRzLkRlZmF1bHRMb2FkaW5nTWFuYWdlcjtcblxuICAgIH1cblxuICAgIE9iamVjdC5hc3NpZ24oIEZvbnRMb2FkZXIucHJvdG90eXBlLCB7XG5cbiAgICBcdGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cbiAgICBcdFx0dmFyIHNjb3BlID0gdGhpcztcblxuICAgIFx0XHR2YXIgbG9hZGVyID0gbmV3IFhIUkxvYWRlciggdGhpcy5tYW5hZ2VyICk7XG4gICAgXHRcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggdGV4dCApIHtcblxuICAgIFx0XHRcdHZhciBqc29uO1xuXG4gICAgXHRcdFx0dHJ5IHtcblxuICAgIFx0XHRcdFx0anNvbiA9IEpTT04ucGFyc2UoIHRleHQgKTtcblxuICAgIFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG4gICAgXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Gb250TG9hZGVyOiB0eXBlZmFjZS5qcyBzdXBwb3J0IGlzIGJlaW5nIGRlcHJlY2F0ZWQuIFVzZSB0eXBlZmFjZS5qc29uIGluc3RlYWQuJyApO1xuICAgIFx0XHRcdFx0anNvbiA9IEpTT04ucGFyc2UoIHRleHQuc3Vic3RyaW5nKCA2NSwgdGV4dC5sZW5ndGggLSAyICkgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdHZhciBmb250ID0gc2NvcGUucGFyc2UoIGpzb24gKTtcblxuICAgIFx0XHRcdGlmICggb25Mb2FkICkgb25Mb2FkKCBmb250ICk7XG5cbiAgICBcdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRwYXJzZTogZnVuY3Rpb24gKCBqc29uICkge1xuXG4gICAgXHRcdHJldHVybiBuZXcgRm9udCgganNvbiApO1xuXG4gICAgXHR9XG5cbiAgICB9ICk7XG5cbiAgICB2YXIgY29udGV4dDtcblxuICAgIGZ1bmN0aW9uIGdldEF1ZGlvQ29udGV4dCgpIHtcblxuICAgIFx0aWYgKCBjb250ZXh0ID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0Y29udGV4dCA9IG5ldyAoIHdpbmRvdy5BdWRpb0NvbnRleHQgfHwgd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dCApKCk7XG5cbiAgICBcdH1cblxuICAgIFx0cmV0dXJuIGNvbnRleHQ7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIFJlZWNlIEFhcm9uIExlY3JpdmFpbiAvIGh0dHA6Ly9yZWVjZW5vdGVzLmNvbS9cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIEF1ZGlvTG9hZGVyKCBtYW5hZ2VyICkge1xuXG4gICAgXHR0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IGV4cG9ydHMuRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xuXG4gICAgfVxuXG4gICAgT2JqZWN0LmFzc2lnbiggQXVkaW9Mb2FkZXIucHJvdG90eXBlLCB7XG5cbiAgICBcdGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cbiAgICBcdFx0dmFyIGxvYWRlciA9IG5ldyBYSFJMb2FkZXIoIHRoaXMubWFuYWdlciApO1xuICAgIFx0XHRsb2FkZXIuc2V0UmVzcG9uc2VUeXBlKCAnYXJyYXlidWZmZXInICk7XG4gICAgXHRcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggYnVmZmVyICkge1xuXG4gICAgXHRcdFx0dmFyIGNvbnRleHQgPSBnZXRBdWRpb0NvbnRleHQoKTtcblxuICAgIFx0XHRcdGNvbnRleHQuZGVjb2RlQXVkaW9EYXRhKCBidWZmZXIsIGZ1bmN0aW9uICggYXVkaW9CdWZmZXIgKSB7XG5cbiAgICBcdFx0XHRcdG9uTG9hZCggYXVkaW9CdWZmZXIgKTtcblxuICAgIFx0XHRcdH0gKTtcblxuICAgIFx0XHR9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XG5cbiAgICBcdH1cblxuICAgIH0gKTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBTdGVyZW9DYW1lcmEoKSB7XG5cbiAgICBcdHRoaXMudHlwZSA9ICdTdGVyZW9DYW1lcmEnO1xuXG4gICAgXHR0aGlzLmFzcGVjdCA9IDE7XG5cbiAgICBcdHRoaXMuZXllU2VwID0gMC4wNjQ7XG5cbiAgICBcdHRoaXMuY2FtZXJhTCA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSgpO1xuICAgIFx0dGhpcy5jYW1lcmFMLmxheWVycy5lbmFibGUoIDEgKTtcbiAgICBcdHRoaXMuY2FtZXJhTC5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cbiAgICBcdHRoaXMuY2FtZXJhUiA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSgpO1xuICAgIFx0dGhpcy5jYW1lcmFSLmxheWVycy5lbmFibGUoIDIgKTtcbiAgICBcdHRoaXMuY2FtZXJhUi5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cbiAgICB9XG5cbiAgICBPYmplY3QuYXNzaWduKCBTdGVyZW9DYW1lcmEucHJvdG90eXBlLCB7XG5cbiAgICBcdHVwZGF0ZTogKCBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dmFyIGluc3RhbmNlLCBmb2N1cywgZm92LCBhc3BlY3QsIG5lYXIsIGZhciwgem9vbTtcblxuICAgIFx0XHR2YXIgZXllUmlnaHQgPSBuZXcgTWF0cml4NCgpO1xuICAgIFx0XHR2YXIgZXllTGVmdCA9IG5ldyBNYXRyaXg0KCk7XG5cbiAgICBcdFx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSggY2FtZXJhICkge1xuXG4gICAgXHRcdFx0dmFyIG5lZWRzVXBkYXRlID0gaW5zdGFuY2UgIT09IHRoaXMgfHwgZm9jdXMgIT09IGNhbWVyYS5mb2N1cyB8fCBmb3YgIT09IGNhbWVyYS5mb3YgfHxcbiAgICBcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhc3BlY3QgIT09IGNhbWVyYS5hc3BlY3QgKiB0aGlzLmFzcGVjdCB8fCBuZWFyICE9PSBjYW1lcmEubmVhciB8fFxuICAgIFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGZhciAhPT0gY2FtZXJhLmZhciB8fCB6b29tICE9PSBjYW1lcmEuem9vbTtcblxuICAgIFx0XHRcdGlmICggbmVlZHNVcGRhdGUgKSB7XG5cbiAgICBcdFx0XHRcdGluc3RhbmNlID0gdGhpcztcbiAgICBcdFx0XHRcdGZvY3VzID0gY2FtZXJhLmZvY3VzO1xuICAgIFx0XHRcdFx0Zm92ID0gY2FtZXJhLmZvdjtcbiAgICBcdFx0XHRcdGFzcGVjdCA9IGNhbWVyYS5hc3BlY3QgKiB0aGlzLmFzcGVjdDtcbiAgICBcdFx0XHRcdG5lYXIgPSBjYW1lcmEubmVhcjtcbiAgICBcdFx0XHRcdGZhciA9IGNhbWVyYS5mYXI7XG4gICAgXHRcdFx0XHR6b29tID0gY2FtZXJhLnpvb207XG5cbiAgICBcdFx0XHRcdC8vIE9mZi1heGlzIHN0ZXJlb3Njb3BpYyBlZmZlY3QgYmFzZWQgb25cbiAgICBcdFx0XHRcdC8vIGh0dHA6Ly9wYXVsYm91cmtlLm5ldC9zdGVyZW9ncmFwaGljcy9zdGVyZW9yZW5kZXIvXG5cbiAgICBcdFx0XHRcdHZhciBwcm9qZWN0aW9uTWF0cml4ID0gY2FtZXJhLnByb2plY3Rpb25NYXRyaXguY2xvbmUoKTtcbiAgICBcdFx0XHRcdHZhciBleWVTZXAgPSB0aGlzLmV5ZVNlcCAvIDI7XG4gICAgXHRcdFx0XHR2YXIgZXllU2VwT25Qcm9qZWN0aW9uID0gZXllU2VwICogbmVhciAvIGZvY3VzO1xuICAgIFx0XHRcdFx0dmFyIHltYXggPSAoIG5lYXIgKiBNYXRoLnRhbiggZXhwb3J0cy5NYXRoLkRFRzJSQUQgKiBmb3YgKiAwLjUgKSApIC8gem9vbTtcbiAgICBcdFx0XHRcdHZhciB4bWluLCB4bWF4O1xuXG4gICAgXHRcdFx0XHQvLyB0cmFuc2xhdGUgeE9mZnNldFxuXG4gICAgXHRcdFx0XHRleWVMZWZ0LmVsZW1lbnRzWyAxMiBdID0gLSBleWVTZXA7XG4gICAgXHRcdFx0XHRleWVSaWdodC5lbGVtZW50c1sgMTIgXSA9IGV5ZVNlcDtcblxuICAgIFx0XHRcdFx0Ly8gZm9yIGxlZnQgZXllXG5cbiAgICBcdFx0XHRcdHhtaW4gPSAtIHltYXggKiBhc3BlY3QgKyBleWVTZXBPblByb2plY3Rpb247XG4gICAgXHRcdFx0XHR4bWF4ID0geW1heCAqIGFzcGVjdCArIGV5ZVNlcE9uUHJvamVjdGlvbjtcblxuICAgIFx0XHRcdFx0cHJvamVjdGlvbk1hdHJpeC5lbGVtZW50c1sgMCBdID0gMiAqIG5lYXIgLyAoIHhtYXggLSB4bWluICk7XG4gICAgXHRcdFx0XHRwcm9qZWN0aW9uTWF0cml4LmVsZW1lbnRzWyA4IF0gPSAoIHhtYXggKyB4bWluICkgLyAoIHhtYXggLSB4bWluICk7XG5cbiAgICBcdFx0XHRcdHRoaXMuY2FtZXJhTC5wcm9qZWN0aW9uTWF0cml4LmNvcHkoIHByb2plY3Rpb25NYXRyaXggKTtcblxuICAgIFx0XHRcdFx0Ly8gZm9yIHJpZ2h0IGV5ZVxuXG4gICAgXHRcdFx0XHR4bWluID0gLSB5bWF4ICogYXNwZWN0IC0gZXllU2VwT25Qcm9qZWN0aW9uO1xuICAgIFx0XHRcdFx0eG1heCA9IHltYXggKiBhc3BlY3QgLSBleWVTZXBPblByb2plY3Rpb247XG5cbiAgICBcdFx0XHRcdHByb2plY3Rpb25NYXRyaXguZWxlbWVudHNbIDAgXSA9IDIgKiBuZWFyIC8gKCB4bWF4IC0geG1pbiApO1xuICAgIFx0XHRcdFx0cHJvamVjdGlvbk1hdHJpeC5lbGVtZW50c1sgOCBdID0gKCB4bWF4ICsgeG1pbiApIC8gKCB4bWF4IC0geG1pbiApO1xuXG4gICAgXHRcdFx0XHR0aGlzLmNhbWVyYVIucHJvamVjdGlvbk1hdHJpeC5jb3B5KCBwcm9qZWN0aW9uTWF0cml4ICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHR0aGlzLmNhbWVyYUwubWF0cml4V29ybGQuY29weSggY2FtZXJhLm1hdHJpeFdvcmxkICkubXVsdGlwbHkoIGV5ZUxlZnQgKTtcbiAgICBcdFx0XHR0aGlzLmNhbWVyYVIubWF0cml4V29ybGQuY29weSggY2FtZXJhLm1hdHJpeFdvcmxkICkubXVsdGlwbHkoIGV5ZVJpZ2h0ICk7XG5cbiAgICBcdFx0fTtcblxuICAgIFx0fSApKClcblxuICAgIH0gKTtcblxuICAgIC8qKlxuICAgICAqIENhbWVyYSBmb3IgcmVuZGVyaW5nIGN1YmUgbWFwc1xuICAgICAqXHQtIHJlbmRlcnMgc2NlbmUgaW50byBheGlzLWFsaWduZWQgY3ViZVxuICAgICAqXG4gICAgICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIEN1YmVDYW1lcmEoIG5lYXIsIGZhciwgY3ViZVJlc29sdXRpb24gKSB7XG5cbiAgICBcdE9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuICAgIFx0dGhpcy50eXBlID0gJ0N1YmVDYW1lcmEnO1xuXG4gICAgXHR2YXIgZm92ID0gOTAsIGFzcGVjdCA9IDE7XG5cbiAgICBcdHZhciBjYW1lcmFQWCA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApO1xuICAgIFx0Y2FtZXJhUFgudXAuc2V0KCAwLCAtIDEsIDAgKTtcbiAgICBcdGNhbWVyYVBYLmxvb2tBdCggbmV3IFZlY3RvcjMoIDEsIDAsIDAgKSApO1xuICAgIFx0dGhpcy5hZGQoIGNhbWVyYVBYICk7XG5cbiAgICBcdHZhciBjYW1lcmFOWCA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApO1xuICAgIFx0Y2FtZXJhTlgudXAuc2V0KCAwLCAtIDEsIDAgKTtcbiAgICBcdGNhbWVyYU5YLmxvb2tBdCggbmV3IFZlY3RvcjMoIC0gMSwgMCwgMCApICk7XG4gICAgXHR0aGlzLmFkZCggY2FtZXJhTlggKTtcblxuICAgIFx0dmFyIGNhbWVyYVBZID0gbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICk7XG4gICAgXHRjYW1lcmFQWS51cC5zZXQoIDAsIDAsIDEgKTtcbiAgICBcdGNhbWVyYVBZLmxvb2tBdCggbmV3IFZlY3RvcjMoIDAsIDEsIDAgKSApO1xuICAgIFx0dGhpcy5hZGQoIGNhbWVyYVBZICk7XG5cbiAgICBcdHZhciBjYW1lcmFOWSA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApO1xuICAgIFx0Y2FtZXJhTlkudXAuc2V0KCAwLCAwLCAtIDEgKTtcbiAgICBcdGNhbWVyYU5ZLmxvb2tBdCggbmV3IFZlY3RvcjMoIDAsIC0gMSwgMCApICk7XG4gICAgXHR0aGlzLmFkZCggY2FtZXJhTlkgKTtcblxuICAgIFx0dmFyIGNhbWVyYVBaID0gbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICk7XG4gICAgXHRjYW1lcmFQWi51cC5zZXQoIDAsIC0gMSwgMCApO1xuICAgIFx0Y2FtZXJhUFoubG9va0F0KCBuZXcgVmVjdG9yMyggMCwgMCwgMSApICk7XG4gICAgXHR0aGlzLmFkZCggY2FtZXJhUFogKTtcblxuICAgIFx0dmFyIGNhbWVyYU5aID0gbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICk7XG4gICAgXHRjYW1lcmFOWi51cC5zZXQoIDAsIC0gMSwgMCApO1xuICAgIFx0Y2FtZXJhTloubG9va0F0KCBuZXcgVmVjdG9yMyggMCwgMCwgLSAxICkgKTtcbiAgICBcdHRoaXMuYWRkKCBjYW1lcmFOWiApO1xuXG4gICAgXHR2YXIgb3B0aW9ucyA9IHsgZm9ybWF0OiBSR0JGb3JtYXQsIG1hZ0ZpbHRlcjogTGluZWFyRmlsdGVyLCBtaW5GaWx0ZXI6IExpbmVhckZpbHRlciB9O1xuXG4gICAgXHR0aGlzLnJlbmRlclRhcmdldCA9IG5ldyBXZWJHTFJlbmRlclRhcmdldEN1YmUoIGN1YmVSZXNvbHV0aW9uLCBjdWJlUmVzb2x1dGlvbiwgb3B0aW9ucyApO1xuXG4gICAgXHR0aGlzLnVwZGF0ZUN1YmVNYXAgPSBmdW5jdGlvbiAoIHJlbmRlcmVyLCBzY2VuZSApIHtcblxuICAgIFx0XHRpZiAoIHRoaXMucGFyZW50ID09PSBudWxsICkgdGhpcy51cGRhdGVNYXRyaXhXb3JsZCgpO1xuXG4gICAgXHRcdHZhciByZW5kZXJUYXJnZXQgPSB0aGlzLnJlbmRlclRhcmdldDtcbiAgICBcdFx0dmFyIGdlbmVyYXRlTWlwbWFwcyA9IHJlbmRlclRhcmdldC50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcztcblxuICAgIFx0XHRyZW5kZXJUYXJnZXQudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcblxuICAgIFx0XHRyZW5kZXJUYXJnZXQuYWN0aXZlQ3ViZUZhY2UgPSAwO1xuICAgIFx0XHRyZW5kZXJlci5yZW5kZXIoIHNjZW5lLCBjYW1lcmFQWCwgcmVuZGVyVGFyZ2V0ICk7XG5cbiAgICBcdFx0cmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlID0gMTtcbiAgICBcdFx0cmVuZGVyZXIucmVuZGVyKCBzY2VuZSwgY2FtZXJhTlgsIHJlbmRlclRhcmdldCApO1xuXG4gICAgXHRcdHJlbmRlclRhcmdldC5hY3RpdmVDdWJlRmFjZSA9IDI7XG4gICAgXHRcdHJlbmRlcmVyLnJlbmRlciggc2NlbmUsIGNhbWVyYVBZLCByZW5kZXJUYXJnZXQgKTtcblxuICAgIFx0XHRyZW5kZXJUYXJnZXQuYWN0aXZlQ3ViZUZhY2UgPSAzO1xuICAgIFx0XHRyZW5kZXJlci5yZW5kZXIoIHNjZW5lLCBjYW1lcmFOWSwgcmVuZGVyVGFyZ2V0ICk7XG5cbiAgICBcdFx0cmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlID0gNDtcbiAgICBcdFx0cmVuZGVyZXIucmVuZGVyKCBzY2VuZSwgY2FtZXJhUFosIHJlbmRlclRhcmdldCApO1xuXG4gICAgXHRcdHJlbmRlclRhcmdldC50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGdlbmVyYXRlTWlwbWFwcztcblxuICAgIFx0XHRyZW5kZXJUYXJnZXQuYWN0aXZlQ3ViZUZhY2UgPSA1O1xuICAgIFx0XHRyZW5kZXJlci5yZW5kZXIoIHNjZW5lLCBjYW1lcmFOWiwgcmVuZGVyVGFyZ2V0ICk7XG5cbiAgICBcdFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KCBudWxsICk7XG5cbiAgICBcdH07XG5cbiAgICB9XG5cbiAgICBDdWJlQ2FtZXJhLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE9iamVjdDNELnByb3RvdHlwZSApO1xuICAgIEN1YmVDYW1lcmEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ3ViZUNhbWVyYTtcblxuICAgIGZ1bmN0aW9uIEF1ZGlvTGlzdGVuZXIoKSB7XG5cbiAgICBcdE9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuICAgIFx0dGhpcy50eXBlID0gJ0F1ZGlvTGlzdGVuZXInO1xuXG4gICAgXHR0aGlzLmNvbnRleHQgPSBnZXRBdWRpb0NvbnRleHQoKTtcblxuICAgIFx0dGhpcy5nYWluID0gdGhpcy5jb250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgICBcdHRoaXMuZ2Fpbi5jb25uZWN0KCB0aGlzLmNvbnRleHQuZGVzdGluYXRpb24gKTtcblxuICAgIFx0dGhpcy5maWx0ZXIgPSBudWxsO1xuXG4gICAgfVxuXG4gICAgQXVkaW9MaXN0ZW5lci5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBPYmplY3QzRC5wcm90b3R5cGUgKSwge1xuXG4gICAgXHRjb25zdHJ1Y3RvcjogQXVkaW9MaXN0ZW5lcixcblxuICAgIFx0Z2V0SW5wdXQ6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHRyZXR1cm4gdGhpcy5nYWluO1xuXG4gICAgXHR9LFxuXG4gICAgXHRyZW1vdmVGaWx0ZXI6IGZ1bmN0aW9uICggKSB7XG5cbiAgICBcdFx0aWYgKCB0aGlzLmZpbHRlciAhPT0gbnVsbCApIHtcblxuICAgIFx0XHRcdHRoaXMuZ2Fpbi5kaXNjb25uZWN0KCB0aGlzLmZpbHRlciApO1xuICAgIFx0XHRcdHRoaXMuZmlsdGVyLmRpc2Nvbm5lY3QoIHRoaXMuY29udGV4dC5kZXN0aW5hdGlvbiApO1xuICAgIFx0XHRcdHRoaXMuZ2Fpbi5jb25uZWN0KCB0aGlzLmNvbnRleHQuZGVzdGluYXRpb24gKTtcbiAgICBcdFx0XHR0aGlzLmZpbHRlciA9IG51bGw7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9LFxuXG4gICAgXHRnZXRGaWx0ZXI6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHRyZXR1cm4gdGhpcy5maWx0ZXI7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldEZpbHRlcjogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuICAgIFx0XHRpZiAoIHRoaXMuZmlsdGVyICE9PSBudWxsICkge1xuXG4gICAgXHRcdFx0dGhpcy5nYWluLmRpc2Nvbm5lY3QoIHRoaXMuZmlsdGVyICk7XG4gICAgXHRcdFx0dGhpcy5maWx0ZXIuZGlzY29ubmVjdCggdGhpcy5jb250ZXh0LmRlc3RpbmF0aW9uICk7XG5cbiAgICBcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdHRoaXMuZ2Fpbi5kaXNjb25uZWN0KCB0aGlzLmNvbnRleHQuZGVzdGluYXRpb24gKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0dGhpcy5maWx0ZXIgPSB2YWx1ZTtcbiAgICBcdFx0dGhpcy5nYWluLmNvbm5lY3QoIHRoaXMuZmlsdGVyICk7XG4gICAgXHRcdHRoaXMuZmlsdGVyLmNvbm5lY3QoIHRoaXMuY29udGV4dC5kZXN0aW5hdGlvbiApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRnZXRNYXN0ZXJWb2x1bWU6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHRyZXR1cm4gdGhpcy5nYWluLmdhaW4udmFsdWU7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldE1hc3RlclZvbHVtZTogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuICAgIFx0XHR0aGlzLmdhaW4uZ2Fpbi52YWx1ZSA9IHZhbHVlO1xuXG4gICAgXHR9LFxuXG4gICAgXHR1cGRhdGVNYXRyaXhXb3JsZDogKCBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dmFyIHBvc2l0aW9uID0gbmV3IFZlY3RvcjMoKTtcbiAgICBcdFx0dmFyIHF1YXRlcm5pb24gPSBuZXcgUXVhdGVybmlvbigpO1xuICAgIFx0XHR2YXIgc2NhbGUgPSBuZXcgVmVjdG9yMygpO1xuXG4gICAgXHRcdHZhciBvcmllbnRhdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG5cbiAgICBcdFx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZU1hdHJpeFdvcmxkKCBmb3JjZSApIHtcblxuICAgIFx0XHRcdE9iamVjdDNELnByb3RvdHlwZS51cGRhdGVNYXRyaXhXb3JsZC5jYWxsKCB0aGlzLCBmb3JjZSApO1xuXG4gICAgXHRcdFx0dmFyIGxpc3RlbmVyID0gdGhpcy5jb250ZXh0Lmxpc3RlbmVyO1xuICAgIFx0XHRcdHZhciB1cCA9IHRoaXMudXA7XG5cbiAgICBcdFx0XHR0aGlzLm1hdHJpeFdvcmxkLmRlY29tcG9zZSggcG9zaXRpb24sIHF1YXRlcm5pb24sIHNjYWxlICk7XG5cbiAgICBcdFx0XHRvcmllbnRhdGlvbi5zZXQoIDAsIDAsIC0gMSApLmFwcGx5UXVhdGVybmlvbiggcXVhdGVybmlvbiApO1xuXG4gICAgXHRcdFx0bGlzdGVuZXIuc2V0UG9zaXRpb24oIHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHBvc2l0aW9uLnogKTtcbiAgICBcdFx0XHRsaXN0ZW5lci5zZXRPcmllbnRhdGlvbiggb3JpZW50YXRpb24ueCwgb3JpZW50YXRpb24ueSwgb3JpZW50YXRpb24ueiwgdXAueCwgdXAueSwgdXAueiApO1xuXG4gICAgXHRcdH07XG5cbiAgICBcdH0gKSgpXG5cbiAgICB9ICk7XG5cbiAgICBmdW5jdGlvbiBBdWRpbyggbGlzdGVuZXIgKSB7XG5cbiAgICBcdE9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuICAgIFx0dGhpcy50eXBlID0gJ0F1ZGlvJztcblxuICAgIFx0dGhpcy5jb250ZXh0ID0gbGlzdGVuZXIuY29udGV4dDtcbiAgICBcdHRoaXMuc291cmNlID0gdGhpcy5jb250ZXh0LmNyZWF0ZUJ1ZmZlclNvdXJjZSgpO1xuICAgIFx0dGhpcy5zb3VyY2Uub25lbmRlZCA9IHRoaXMub25FbmRlZC5iaW5kKCB0aGlzICk7XG5cbiAgICBcdHRoaXMuZ2FpbiA9IHRoaXMuY29udGV4dC5jcmVhdGVHYWluKCk7XG4gICAgXHR0aGlzLmdhaW4uY29ubmVjdCggbGlzdGVuZXIuZ2V0SW5wdXQoKSApO1xuXG4gICAgXHR0aGlzLmF1dG9wbGF5ID0gZmFsc2U7XG5cbiAgICBcdHRoaXMuc3RhcnRUaW1lID0gMDtcbiAgICBcdHRoaXMucGxheWJhY2tSYXRlID0gMTtcbiAgICBcdHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XG4gICAgXHR0aGlzLmhhc1BsYXliYWNrQ29udHJvbCA9IHRydWU7XG4gICAgXHR0aGlzLnNvdXJjZVR5cGUgPSAnZW1wdHknO1xuXG4gICAgXHR0aGlzLmZpbHRlcnMgPSBbXTtcblxuICAgIH1cblxuICAgIEF1ZGlvLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIE9iamVjdDNELnByb3RvdHlwZSApLCB7XG5cbiAgICBcdGNvbnN0cnVjdG9yOiBBdWRpbyxcblxuICAgIFx0Z2V0T3V0cHV0OiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMuZ2FpbjtcblxuICAgIFx0fSxcblxuICAgIFx0c2V0Tm9kZVNvdXJjZTogZnVuY3Rpb24gKCBhdWRpb05vZGUgKSB7XG5cbiAgICBcdFx0dGhpcy5oYXNQbGF5YmFja0NvbnRyb2wgPSBmYWxzZTtcbiAgICBcdFx0dGhpcy5zb3VyY2VUeXBlID0gJ2F1ZGlvTm9kZSc7XG4gICAgXHRcdHRoaXMuc291cmNlID0gYXVkaW9Ob2RlO1xuICAgIFx0XHR0aGlzLmNvbm5lY3QoKTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0c2V0QnVmZmVyOiBmdW5jdGlvbiAoIGF1ZGlvQnVmZmVyICkge1xuXG4gICAgXHRcdHRoaXMuc291cmNlLmJ1ZmZlciA9IGF1ZGlvQnVmZmVyO1xuICAgIFx0XHR0aGlzLnNvdXJjZVR5cGUgPSAnYnVmZmVyJztcblxuICAgIFx0XHRpZiAoIHRoaXMuYXV0b3BsYXkgKSB0aGlzLnBsYXkoKTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0cGxheTogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdGlmICggdGhpcy5pc1BsYXlpbmcgPT09IHRydWUgKSB7XG5cbiAgICBcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5BdWRpbzogQXVkaW8gaXMgYWxyZWFkeSBwbGF5aW5nLicgKTtcbiAgICBcdFx0XHRyZXR1cm47XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGlmICggdGhpcy5oYXNQbGF5YmFja0NvbnRyb2wgPT09IGZhbHNlICkge1xuXG4gICAgXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQXVkaW86IHRoaXMgQXVkaW8gaGFzIG5vIHBsYXliYWNrIGNvbnRyb2wuJyApO1xuICAgIFx0XHRcdHJldHVybjtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0dmFyIHNvdXJjZSA9IHRoaXMuY29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKTtcblxuICAgIFx0XHRzb3VyY2UuYnVmZmVyID0gdGhpcy5zb3VyY2UuYnVmZmVyO1xuICAgIFx0XHRzb3VyY2UubG9vcCA9IHRoaXMuc291cmNlLmxvb3A7XG4gICAgXHRcdHNvdXJjZS5vbmVuZGVkID0gdGhpcy5zb3VyY2Uub25lbmRlZDtcbiAgICBcdFx0c291cmNlLnN0YXJ0KCAwLCB0aGlzLnN0YXJ0VGltZSApO1xuICAgIFx0XHRzb3VyY2UucGxheWJhY2tSYXRlLnZhbHVlID0gdGhpcy5wbGF5YmFja1JhdGU7XG5cbiAgICBcdFx0dGhpcy5pc1BsYXlpbmcgPSB0cnVlO1xuXG4gICAgXHRcdHRoaXMuc291cmNlID0gc291cmNlO1xuXG4gICAgXHRcdHJldHVybiB0aGlzLmNvbm5lY3QoKTtcblxuICAgIFx0fSxcblxuICAgIFx0cGF1c2U6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHRpZiAoIHRoaXMuaGFzUGxheWJhY2tDb250cm9sID09PSBmYWxzZSApIHtcblxuICAgIFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkF1ZGlvOiB0aGlzIEF1ZGlvIGhhcyBubyBwbGF5YmFjayBjb250cm9sLicgKTtcbiAgICBcdFx0XHRyZXR1cm47XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHRoaXMuc291cmNlLnN0b3AoKTtcbiAgICBcdFx0dGhpcy5zdGFydFRpbWUgPSB0aGlzLmNvbnRleHQuY3VycmVudFRpbWU7XG4gICAgXHRcdHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdHN0b3A6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHRpZiAoIHRoaXMuaGFzUGxheWJhY2tDb250cm9sID09PSBmYWxzZSApIHtcblxuICAgIFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkF1ZGlvOiB0aGlzIEF1ZGlvIGhhcyBubyBwbGF5YmFjayBjb250cm9sLicgKTtcbiAgICBcdFx0XHRyZXR1cm47XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHRoaXMuc291cmNlLnN0b3AoKTtcbiAgICBcdFx0dGhpcy5zdGFydFRpbWUgPSAwO1xuICAgIFx0XHR0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRjb25uZWN0OiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0aWYgKCB0aGlzLmZpbHRlcnMubGVuZ3RoID4gMCApIHtcblxuICAgIFx0XHRcdHRoaXMuc291cmNlLmNvbm5lY3QoIHRoaXMuZmlsdGVyc1sgMCBdICk7XG5cbiAgICBcdFx0XHRmb3IgKCB2YXIgaSA9IDEsIGwgPSB0aGlzLmZpbHRlcnMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgIFx0XHRcdFx0dGhpcy5maWx0ZXJzWyBpIC0gMSBdLmNvbm5lY3QoIHRoaXMuZmlsdGVyc1sgaSBdICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHR0aGlzLmZpbHRlcnNbIHRoaXMuZmlsdGVycy5sZW5ndGggLSAxIF0uY29ubmVjdCggdGhpcy5nZXRPdXRwdXQoKSApO1xuXG4gICAgXHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHR0aGlzLnNvdXJjZS5jb25uZWN0KCB0aGlzLmdldE91dHB1dCgpICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRkaXNjb25uZWN0OiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0aWYgKCB0aGlzLmZpbHRlcnMubGVuZ3RoID4gMCApIHtcblxuICAgIFx0XHRcdHRoaXMuc291cmNlLmRpc2Nvbm5lY3QoIHRoaXMuZmlsdGVyc1sgMCBdICk7XG5cbiAgICBcdFx0XHRmb3IgKCB2YXIgaSA9IDEsIGwgPSB0aGlzLmZpbHRlcnMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgIFx0XHRcdFx0dGhpcy5maWx0ZXJzWyBpIC0gMSBdLmRpc2Nvbm5lY3QoIHRoaXMuZmlsdGVyc1sgaSBdICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHR0aGlzLmZpbHRlcnNbIHRoaXMuZmlsdGVycy5sZW5ndGggLSAxIF0uZGlzY29ubmVjdCggdGhpcy5nZXRPdXRwdXQoKSApO1xuXG4gICAgXHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHR0aGlzLnNvdXJjZS5kaXNjb25uZWN0KCB0aGlzLmdldE91dHB1dCgpICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRnZXRGaWx0ZXJzOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMuZmlsdGVycztcblxuICAgIFx0fSxcblxuICAgIFx0c2V0RmlsdGVyczogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuICAgIFx0XHRpZiAoICEgdmFsdWUgKSB2YWx1ZSA9IFtdO1xuXG4gICAgXHRcdGlmICggdGhpcy5pc1BsYXlpbmcgPT09IHRydWUgKSB7XG5cbiAgICBcdFx0XHR0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICBcdFx0XHR0aGlzLmZpbHRlcnMgPSB2YWx1ZTtcbiAgICBcdFx0XHR0aGlzLmNvbm5lY3QoKTtcblxuICAgIFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0dGhpcy5maWx0ZXJzID0gdmFsdWU7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRnZXRGaWx0ZXI6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHRyZXR1cm4gdGhpcy5nZXRGaWx0ZXJzKClbIDAgXTtcblxuICAgIFx0fSxcblxuICAgIFx0c2V0RmlsdGVyOiBmdW5jdGlvbiAoIGZpbHRlciApIHtcblxuICAgIFx0XHRyZXR1cm4gdGhpcy5zZXRGaWx0ZXJzKCBmaWx0ZXIgPyBbIGZpbHRlciBdIDogW10gKTtcblxuICAgIFx0fSxcblxuICAgIFx0c2V0UGxheWJhY2tSYXRlOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG4gICAgXHRcdGlmICggdGhpcy5oYXNQbGF5YmFja0NvbnRyb2wgPT09IGZhbHNlICkge1xuXG4gICAgXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQXVkaW86IHRoaXMgQXVkaW8gaGFzIG5vIHBsYXliYWNrIGNvbnRyb2wuJyApO1xuICAgIFx0XHRcdHJldHVybjtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0dGhpcy5wbGF5YmFja1JhdGUgPSB2YWx1ZTtcblxuICAgIFx0XHRpZiAoIHRoaXMuaXNQbGF5aW5nID09PSB0cnVlICkge1xuXG4gICAgXHRcdFx0dGhpcy5zb3VyY2UucGxheWJhY2tSYXRlLnZhbHVlID0gdGhpcy5wbGF5YmFja1JhdGU7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRnZXRQbGF5YmFja1JhdGU6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHRyZXR1cm4gdGhpcy5wbGF5YmFja1JhdGU7XG5cbiAgICBcdH0sXG5cbiAgICBcdG9uRW5kZWQ6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xuXG4gICAgXHR9LFxuXG4gICAgXHRnZXRMb29wOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0aWYgKCB0aGlzLmhhc1BsYXliYWNrQ29udHJvbCA9PT0gZmFsc2UgKSB7XG5cbiAgICBcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5BdWRpbzogdGhpcyBBdWRpbyBoYXMgbm8gcGxheWJhY2sgY29udHJvbC4nICk7XG4gICAgXHRcdFx0cmV0dXJuIGZhbHNlO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gdGhpcy5zb3VyY2UubG9vcDtcblxuICAgIFx0fSxcblxuICAgIFx0c2V0TG9vcDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuICAgIFx0XHRpZiAoIHRoaXMuaGFzUGxheWJhY2tDb250cm9sID09PSBmYWxzZSApIHtcblxuICAgIFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkF1ZGlvOiB0aGlzIEF1ZGlvIGhhcyBubyBwbGF5YmFjayBjb250cm9sLicgKTtcbiAgICBcdFx0XHRyZXR1cm47XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHRoaXMuc291cmNlLmxvb3AgPSB2YWx1ZTtcblxuICAgIFx0fSxcblxuICAgIFx0Z2V0Vm9sdW1lOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMuZ2Fpbi5nYWluLnZhbHVlO1xuXG4gICAgXHR9LFxuXG5cbiAgICBcdHNldFZvbHVtZTogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuICAgIFx0XHR0aGlzLmdhaW4uZ2Fpbi52YWx1ZSA9IHZhbHVlO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9XG5cbiAgICB9ICk7XG5cbiAgICBmdW5jdGlvbiBQb3NpdGlvbmFsQXVkaW8oIGxpc3RlbmVyICkge1xuXG4gICAgXHRBdWRpby5jYWxsKCB0aGlzLCBsaXN0ZW5lciApO1xuXG4gICAgXHR0aGlzLnBhbm5lciA9IHRoaXMuY29udGV4dC5jcmVhdGVQYW5uZXIoKTtcbiAgICBcdHRoaXMucGFubmVyLmNvbm5lY3QoIHRoaXMuZ2FpbiApO1xuXG4gICAgfVxuXG4gICAgUG9zaXRpb25hbEF1ZGlvLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIEF1ZGlvLnByb3RvdHlwZSApLCB7XG5cbiAgICBcdGNvbnN0cnVjdG9yOiBQb3NpdGlvbmFsQXVkaW8sXG5cbiAgICBcdGdldE91dHB1dDogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHJldHVybiB0aGlzLnBhbm5lcjtcblxuICAgIFx0fSxcblxuICAgIFx0Z2V0UmVmRGlzdGFuY2U6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHRyZXR1cm4gdGhpcy5wYW5uZXIucmVmRGlzdGFuY2U7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldFJlZkRpc3RhbmNlOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG4gICAgXHRcdHRoaXMucGFubmVyLnJlZkRpc3RhbmNlID0gdmFsdWU7XG5cbiAgICBcdH0sXG5cbiAgICBcdGdldFJvbGxvZmZGYWN0b3I6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHRyZXR1cm4gdGhpcy5wYW5uZXIucm9sbG9mZkZhY3RvcjtcblxuICAgIFx0fSxcblxuICAgIFx0c2V0Um9sbG9mZkZhY3RvcjogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuICAgIFx0XHR0aGlzLnBhbm5lci5yb2xsb2ZmRmFjdG9yID0gdmFsdWU7XG5cbiAgICBcdH0sXG5cbiAgICBcdGdldERpc3RhbmNlTW9kZWw6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHRyZXR1cm4gdGhpcy5wYW5uZXIuZGlzdGFuY2VNb2RlbDtcblxuICAgIFx0fSxcblxuICAgIFx0c2V0RGlzdGFuY2VNb2RlbDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuICAgIFx0XHR0aGlzLnBhbm5lci5kaXN0YW5jZU1vZGVsID0gdmFsdWU7XG5cbiAgICBcdH0sXG5cbiAgICBcdGdldE1heERpc3RhbmNlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMucGFubmVyLm1heERpc3RhbmNlO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzZXRNYXhEaXN0YW5jZTogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuICAgIFx0XHR0aGlzLnBhbm5lci5tYXhEaXN0YW5jZSA9IHZhbHVlO1xuXG4gICAgXHR9LFxuXG4gICAgXHR1cGRhdGVNYXRyaXhXb3JsZDogKCBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dmFyIHBvc2l0aW9uID0gbmV3IFZlY3RvcjMoKTtcblxuICAgIFx0XHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlTWF0cml4V29ybGQoIGZvcmNlICkge1xuXG4gICAgXHRcdFx0T2JqZWN0M0QucHJvdG90eXBlLnVwZGF0ZU1hdHJpeFdvcmxkLmNhbGwoIHRoaXMsIGZvcmNlICk7XG5cbiAgICBcdFx0XHRwb3NpdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubWF0cml4V29ybGQgKTtcblxuICAgIFx0XHRcdHRoaXMucGFubmVyLnNldFBvc2l0aW9uKCBwb3NpdGlvbi54LCBwb3NpdGlvbi55LCBwb3NpdGlvbi56ICk7XG5cbiAgICBcdFx0fTtcblxuICAgIFx0fSApKClcblxuXG4gICAgfSApO1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIEF1ZGlvQW5hbHlzZXIoIGF1ZGlvLCBmZnRTaXplICkge1xuXG4gICAgXHR0aGlzLmFuYWx5c2VyID0gYXVkaW8uY29udGV4dC5jcmVhdGVBbmFseXNlcigpO1xuICAgIFx0dGhpcy5hbmFseXNlci5mZnRTaXplID0gZmZ0U2l6ZSAhPT0gdW5kZWZpbmVkID8gZmZ0U2l6ZSA6IDIwNDg7XG5cbiAgICBcdHRoaXMuZGF0YSA9IG5ldyBVaW50OEFycmF5KCB0aGlzLmFuYWx5c2VyLmZyZXF1ZW5jeUJpbkNvdW50ICk7XG5cbiAgICBcdGF1ZGlvLmdldE91dHB1dCgpLmNvbm5lY3QoIHRoaXMuYW5hbHlzZXIgKTtcblxuICAgIH1cblxuICAgIE9iamVjdC5hc3NpZ24oIEF1ZGlvQW5hbHlzZXIucHJvdG90eXBlLCB7XG5cbiAgICBcdGdldEZyZXF1ZW5jeURhdGE6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR0aGlzLmFuYWx5c2VyLmdldEJ5dGVGcmVxdWVuY3lEYXRhKCB0aGlzLmRhdGEgKTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcy5kYXRhO1xuXG4gICAgXHR9LFxuXG4gICAgXHRnZXRBdmVyYWdlRnJlcXVlbmN5OiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dmFyIHZhbHVlID0gMCwgZGF0YSA9IHRoaXMuZ2V0RnJlcXVlbmN5RGF0YSgpO1xuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpICsrICkge1xuXG4gICAgXHRcdFx0dmFsdWUgKz0gZGF0YVsgaSBdO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gdmFsdWUgLyBkYXRhLmxlbmd0aDtcblxuICAgIFx0fVxuXG4gICAgfSApO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBCdWZmZXJlZCBzY2VuZSBncmFwaCBwcm9wZXJ0eSB0aGF0IGFsbG93cyB3ZWlnaHRlZCBhY2N1bXVsYXRpb24uXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBhdXRob3IgQmVuIEhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW8vXG4gICAgICogQGF1dGhvciBEYXZpZCBTYXJubyAvIGh0dHA6Ly9saWdodGhhdXMudXMvXG4gICAgICogQGF1dGhvciB0c2Nod1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gUHJvcGVydHlNaXhlciggYmluZGluZywgdHlwZU5hbWUsIHZhbHVlU2l6ZSApIHtcblxuICAgIFx0dGhpcy5iaW5kaW5nID0gYmluZGluZztcbiAgICBcdHRoaXMudmFsdWVTaXplID0gdmFsdWVTaXplO1xuXG4gICAgXHR2YXIgYnVmZmVyVHlwZSA9IEZsb2F0NjRBcnJheSxcbiAgICBcdFx0bWl4RnVuY3Rpb247XG5cbiAgICBcdHN3aXRjaCAoIHR5cGVOYW1lICkge1xuXG4gICAgXHRcdGNhc2UgJ3F1YXRlcm5pb24nOlx0XHRcdG1peEZ1bmN0aW9uID0gdGhpcy5fc2xlcnA7XHRcdGJyZWFrO1xuXG4gICAgXHRcdGNhc2UgJ3N0cmluZyc6XG4gICAgXHRcdGNhc2UgJ2Jvb2wnOlxuXG4gICAgXHRcdFx0YnVmZmVyVHlwZSA9IEFycmF5LFx0XHRtaXhGdW5jdGlvbiA9IHRoaXMuX3NlbGVjdDtcdFx0YnJlYWs7XG5cbiAgICBcdFx0ZGVmYXVsdDpcdFx0XHRcdFx0bWl4RnVuY3Rpb24gPSB0aGlzLl9sZXJwO1xuXG4gICAgXHR9XG5cbiAgICBcdHRoaXMuYnVmZmVyID0gbmV3IGJ1ZmZlclR5cGUoIHZhbHVlU2l6ZSAqIDQgKTtcbiAgICBcdC8vIGxheW91dDogWyBpbmNvbWluZyB8IGFjY3UwIHwgYWNjdTEgfCBvcmlnIF1cbiAgICBcdC8vXG4gICAgXHQvLyBpbnRlcnBvbGF0b3JzIGNhbiB1c2UgLmJ1ZmZlciBhcyB0aGVpciAucmVzdWx0XG4gICAgXHQvLyB0aGUgZGF0YSB0aGVuIGdvZXMgdG8gJ2luY29taW5nJ1xuICAgIFx0Ly9cbiAgICBcdC8vICdhY2N1MCcgYW5kICdhY2N1MScgYXJlIHVzZWQgZnJhbWUtaW50ZXJsZWF2ZWQgZm9yXG4gICAgXHQvLyB0aGUgY3VtdWxhdGl2ZSByZXN1bHQgYW5kIGFyZSBjb21wYXJlZCB0byBkZXRlY3RcbiAgICBcdC8vIGNoYW5nZXNcbiAgICBcdC8vXG4gICAgXHQvLyAnb3JpZycgc3RvcmVzIHRoZSBvcmlnaW5hbCBzdGF0ZSBvZiB0aGUgcHJvcGVydHlcblxuICAgIFx0dGhpcy5fbWl4QnVmZmVyUmVnaW9uID0gbWl4RnVuY3Rpb247XG5cbiAgICBcdHRoaXMuY3VtdWxhdGl2ZVdlaWdodCA9IDA7XG5cbiAgICBcdHRoaXMudXNlQ291bnQgPSAwO1xuICAgIFx0dGhpcy5yZWZlcmVuY2VDb3VudCA9IDA7XG5cbiAgICB9XG5cbiAgICBQcm9wZXJ0eU1peGVyLnByb3RvdHlwZSA9IHtcblxuICAgIFx0Y29uc3RydWN0b3I6IFByb3BlcnR5TWl4ZXIsXG5cbiAgICBcdC8vIGFjY3VtdWxhdGUgZGF0YSBpbiB0aGUgJ2luY29taW5nJyByZWdpb24gaW50byAnYWNjdTxpPidcbiAgICBcdGFjY3VtdWxhdGU6IGZ1bmN0aW9uKCBhY2N1SW5kZXgsIHdlaWdodCApIHtcblxuICAgIFx0XHQvLyBub3RlOiBoYXBwaWx5IGFjY3VtdWxhdGluZyBub3RoaW5nIHdoZW4gd2VpZ2h0ID0gMCwgdGhlIGNhbGxlciBrbm93c1xuICAgIFx0XHQvLyB0aGUgd2VpZ2h0IGFuZCBzaG91bGRuJ3QgaGF2ZSBtYWRlIHRoZSBjYWxsIGluIHRoZSBmaXJzdCBwbGFjZVxuXG4gICAgXHRcdHZhciBidWZmZXIgPSB0aGlzLmJ1ZmZlcixcbiAgICBcdFx0XHRzdHJpZGUgPSB0aGlzLnZhbHVlU2l6ZSxcbiAgICBcdFx0XHRvZmZzZXQgPSBhY2N1SW5kZXggKiBzdHJpZGUgKyBzdHJpZGUsXG5cbiAgICBcdFx0XHRjdXJyZW50V2VpZ2h0ID0gdGhpcy5jdW11bGF0aXZlV2VpZ2h0O1xuXG4gICAgXHRcdGlmICggY3VycmVudFdlaWdodCA9PT0gMCApIHtcblxuICAgIFx0XHRcdC8vIGFjY3VOIDo9IGluY29taW5nICogd2VpZ2h0XG5cbiAgICBcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgIT09IHN0cmlkZTsgKysgaSApIHtcblxuICAgIFx0XHRcdFx0YnVmZmVyWyBvZmZzZXQgKyBpIF0gPSBidWZmZXJbIGkgXTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGN1cnJlbnRXZWlnaHQgPSB3ZWlnaHQ7XG5cbiAgICBcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdC8vIGFjY3VOIDo9IGFjY3VOICsgaW5jb21pbmcgKiB3ZWlnaHRcblxuICAgIFx0XHRcdGN1cnJlbnRXZWlnaHQgKz0gd2VpZ2h0O1xuICAgIFx0XHRcdHZhciBtaXggPSB3ZWlnaHQgLyBjdXJyZW50V2VpZ2h0O1xuICAgIFx0XHRcdHRoaXMuX21peEJ1ZmZlclJlZ2lvbiggYnVmZmVyLCBvZmZzZXQsIDAsIG1peCwgc3RyaWRlICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHRoaXMuY3VtdWxhdGl2ZVdlaWdodCA9IGN1cnJlbnRXZWlnaHQ7XG5cbiAgICBcdH0sXG5cbiAgICBcdC8vIGFwcGx5IHRoZSBzdGF0ZSBvZiAnYWNjdTxpPicgdG8gdGhlIGJpbmRpbmcgd2hlbiBhY2N1cyBkaWZmZXJcbiAgICBcdGFwcGx5OiBmdW5jdGlvbiggYWNjdUluZGV4ICkge1xuXG4gICAgXHRcdHZhciBzdHJpZGUgPSB0aGlzLnZhbHVlU2l6ZSxcbiAgICBcdFx0XHRidWZmZXIgPSB0aGlzLmJ1ZmZlcixcbiAgICBcdFx0XHRvZmZzZXQgPSBhY2N1SW5kZXggKiBzdHJpZGUgKyBzdHJpZGUsXG5cbiAgICBcdFx0XHR3ZWlnaHQgPSB0aGlzLmN1bXVsYXRpdmVXZWlnaHQsXG5cbiAgICBcdFx0XHRiaW5kaW5nID0gdGhpcy5iaW5kaW5nO1xuXG4gICAgXHRcdHRoaXMuY3VtdWxhdGl2ZVdlaWdodCA9IDA7XG5cbiAgICBcdFx0aWYgKCB3ZWlnaHQgPCAxICkge1xuXG4gICAgXHRcdFx0Ly8gYWNjdU4gOj0gYWNjdU4gKyBvcmlnaW5hbCAqICggMSAtIGN1bXVsYXRpdmVXZWlnaHQgKVxuXG4gICAgXHRcdFx0dmFyIG9yaWdpbmFsVmFsdWVPZmZzZXQgPSBzdHJpZGUgKiAzO1xuXG4gICAgXHRcdFx0dGhpcy5fbWl4QnVmZmVyUmVnaW9uKFxuICAgIFx0XHRcdFx0XHRidWZmZXIsIG9mZnNldCwgb3JpZ2luYWxWYWx1ZU9mZnNldCwgMSAtIHdlaWdodCwgc3RyaWRlICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGZvciAoIHZhciBpID0gc3RyaWRlLCBlID0gc3RyaWRlICsgc3RyaWRlOyBpICE9PSBlOyArKyBpICkge1xuXG4gICAgXHRcdFx0aWYgKCBidWZmZXJbIGkgXSAhPT0gYnVmZmVyWyBpICsgc3RyaWRlIF0gKSB7XG5cbiAgICBcdFx0XHRcdC8vIHZhbHVlIGhhcyBjaGFuZ2VkIC0+IHVwZGF0ZSBzY2VuZSBncmFwaFxuXG4gICAgXHRcdFx0XHRiaW5kaW5nLnNldFZhbHVlKCBidWZmZXIsIG9mZnNldCApO1xuICAgIFx0XHRcdFx0YnJlYWs7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9LFxuXG4gICAgXHQvLyByZW1lbWJlciB0aGUgc3RhdGUgb2YgdGhlIGJvdW5kIHByb3BlcnR5IGFuZCBjb3B5IGl0IHRvIGJvdGggYWNjdXNcbiAgICBcdHNhdmVPcmlnaW5hbFN0YXRlOiBmdW5jdGlvbigpIHtcblxuICAgIFx0XHR2YXIgYmluZGluZyA9IHRoaXMuYmluZGluZztcblxuICAgIFx0XHR2YXIgYnVmZmVyID0gdGhpcy5idWZmZXIsXG4gICAgXHRcdFx0c3RyaWRlID0gdGhpcy52YWx1ZVNpemUsXG5cbiAgICBcdFx0XHRvcmlnaW5hbFZhbHVlT2Zmc2V0ID0gc3RyaWRlICogMztcblxuICAgIFx0XHRiaW5kaW5nLmdldFZhbHVlKCBidWZmZXIsIG9yaWdpbmFsVmFsdWVPZmZzZXQgKTtcblxuICAgIFx0XHQvLyBhY2N1WzAuLjFdIDo9IG9yaWcgLS0gaW5pdGlhbGx5IGRldGVjdCBjaGFuZ2VzIGFnYWluc3QgdGhlIG9yaWdpbmFsXG4gICAgXHRcdGZvciAoIHZhciBpID0gc3RyaWRlLCBlID0gb3JpZ2luYWxWYWx1ZU9mZnNldDsgaSAhPT0gZTsgKysgaSApIHtcblxuICAgIFx0XHRcdGJ1ZmZlclsgaSBdID0gYnVmZmVyWyBvcmlnaW5hbFZhbHVlT2Zmc2V0ICsgKCBpICUgc3RyaWRlICkgXTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0dGhpcy5jdW11bGF0aXZlV2VpZ2h0ID0gMDtcblxuICAgIFx0fSxcblxuICAgIFx0Ly8gYXBwbHkgdGhlIHN0YXRlIHByZXZpb3VzbHkgdGFrZW4gdmlhICdzYXZlT3JpZ2luYWxTdGF0ZScgdG8gdGhlIGJpbmRpbmdcbiAgICBcdHJlc3RvcmVPcmlnaW5hbFN0YXRlOiBmdW5jdGlvbigpIHtcblxuICAgIFx0XHR2YXIgb3JpZ2luYWxWYWx1ZU9mZnNldCA9IHRoaXMudmFsdWVTaXplICogMztcbiAgICBcdFx0dGhpcy5iaW5kaW5nLnNldFZhbHVlKCB0aGlzLmJ1ZmZlciwgb3JpZ2luYWxWYWx1ZU9mZnNldCApO1xuXG4gICAgXHR9LFxuXG5cbiAgICBcdC8vIG1peCBmdW5jdGlvbnNcblxuICAgIFx0X3NlbGVjdDogZnVuY3Rpb24oIGJ1ZmZlciwgZHN0T2Zmc2V0LCBzcmNPZmZzZXQsIHQsIHN0cmlkZSApIHtcblxuICAgIFx0XHRpZiAoIHQgPj0gMC41ICkge1xuXG4gICAgXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpICE9PSBzdHJpZGU7ICsrIGkgKSB7XG5cbiAgICBcdFx0XHRcdGJ1ZmZlclsgZHN0T2Zmc2V0ICsgaSBdID0gYnVmZmVyWyBzcmNPZmZzZXQgKyBpIF07XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9LFxuXG4gICAgXHRfc2xlcnA6IGZ1bmN0aW9uKCBidWZmZXIsIGRzdE9mZnNldCwgc3JjT2Zmc2V0LCB0LCBzdHJpZGUgKSB7XG5cbiAgICBcdFx0UXVhdGVybmlvbi5zbGVycEZsYXQoIGJ1ZmZlciwgZHN0T2Zmc2V0LFxuICAgIFx0XHRcdFx0YnVmZmVyLCBkc3RPZmZzZXQsIGJ1ZmZlciwgc3JjT2Zmc2V0LCB0ICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdF9sZXJwOiBmdW5jdGlvbiggYnVmZmVyLCBkc3RPZmZzZXQsIHNyY09mZnNldCwgdCwgc3RyaWRlICkge1xuXG4gICAgXHRcdHZhciBzID0gMSAtIHQ7XG5cbiAgICBcdFx0Zm9yICggdmFyIGkgPSAwOyBpICE9PSBzdHJpZGU7ICsrIGkgKSB7XG5cbiAgICBcdFx0XHR2YXIgaiA9IGRzdE9mZnNldCArIGk7XG5cbiAgICBcdFx0XHRidWZmZXJbIGogXSA9IGJ1ZmZlclsgaiBdICogcyArIGJ1ZmZlclsgc3JjT2Zmc2V0ICsgaSBdICogdDtcblxuICAgIFx0XHR9XG5cbiAgICBcdH1cblxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEEgcmVmZXJlbmNlIHRvIGEgcmVhbCBwcm9wZXJ0eSBpbiB0aGUgc2NlbmUgZ3JhcGguXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBhdXRob3IgQmVuIEhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW8vXG4gICAgICogQGF1dGhvciBEYXZpZCBTYXJubyAvIGh0dHA6Ly9saWdodGhhdXMudXMvXG4gICAgICogQGF1dGhvciB0c2Nod1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gUHJvcGVydHlCaW5kaW5nKCByb290Tm9kZSwgcGF0aCwgcGFyc2VkUGF0aCApIHtcblxuICAgIFx0dGhpcy5wYXRoID0gcGF0aDtcbiAgICBcdHRoaXMucGFyc2VkUGF0aCA9IHBhcnNlZFBhdGggfHxcbiAgICBcdFx0XHRQcm9wZXJ0eUJpbmRpbmcucGFyc2VUcmFja05hbWUoIHBhdGggKTtcblxuICAgIFx0dGhpcy5ub2RlID0gUHJvcGVydHlCaW5kaW5nLmZpbmROb2RlKFxuICAgIFx0XHRcdHJvb3ROb2RlLCB0aGlzLnBhcnNlZFBhdGgubm9kZU5hbWUgKSB8fCByb290Tm9kZTtcblxuICAgIFx0dGhpcy5yb290Tm9kZSA9IHJvb3ROb2RlO1xuXG4gICAgfVxuXG4gICAgUHJvcGVydHlCaW5kaW5nLnByb3RvdHlwZSA9IHtcblxuICAgIFx0Y29uc3RydWN0b3I6IFByb3BlcnR5QmluZGluZyxcblxuICAgIFx0Z2V0VmFsdWU6IGZ1bmN0aW9uIGdldFZhbHVlX3VuYm91bmQoIHRhcmdldEFycmF5LCBvZmZzZXQgKSB7XG5cbiAgICBcdFx0dGhpcy5iaW5kKCk7XG4gICAgXHRcdHRoaXMuZ2V0VmFsdWUoIHRhcmdldEFycmF5LCBvZmZzZXQgKTtcblxuICAgIFx0XHQvLyBOb3RlOiBUaGlzIGNsYXNzIHVzZXMgYSBTdGF0ZSBwYXR0ZXJuIG9uIGEgcGVyLW1ldGhvZCBiYXNpczpcbiAgICBcdFx0Ly8gJ2JpbmQnIHNldHMgJ3RoaXMuZ2V0VmFsdWUnIC8gJ3NldFZhbHVlJyBhbmQgc2hhZG93cyB0aGVcbiAgICBcdFx0Ly8gcHJvdG90eXBlIHZlcnNpb24gb2YgdGhlc2UgbWV0aG9kcyB3aXRoIG9uZSB0aGF0IHJlcHJlc2VudHNcbiAgICBcdFx0Ly8gdGhlIGJvdW5kIHN0YXRlLiBXaGVuIHRoZSBwcm9wZXJ0eSBpcyBub3QgZm91bmQsIHRoZSBtZXRob2RzXG4gICAgXHRcdC8vIGJlY29tZSBuby1vcHMuXG5cbiAgICBcdH0sXG5cbiAgICBcdHNldFZhbHVlOiBmdW5jdGlvbiBnZXRWYWx1ZV91bmJvdW5kKCBzb3VyY2VBcnJheSwgb2Zmc2V0ICkge1xuXG4gICAgXHRcdHRoaXMuYmluZCgpO1xuICAgIFx0XHR0aGlzLnNldFZhbHVlKCBzb3VyY2VBcnJheSwgb2Zmc2V0ICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdC8vIGNyZWF0ZSBnZXR0ZXIgLyBzZXR0ZXIgcGFpciBmb3IgYSBwcm9wZXJ0eSBpbiB0aGUgc2NlbmUgZ3JhcGhcbiAgICBcdGJpbmQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgXHRcdHZhciB0YXJnZXRPYmplY3QgPSB0aGlzLm5vZGUsXG4gICAgXHRcdFx0cGFyc2VkUGF0aCA9IHRoaXMucGFyc2VkUGF0aCxcblxuICAgIFx0XHRcdG9iamVjdE5hbWUgPSBwYXJzZWRQYXRoLm9iamVjdE5hbWUsXG4gICAgXHRcdFx0cHJvcGVydHlOYW1lID0gcGFyc2VkUGF0aC5wcm9wZXJ0eU5hbWUsXG4gICAgXHRcdFx0cHJvcGVydHlJbmRleCA9IHBhcnNlZFBhdGgucHJvcGVydHlJbmRleDtcblxuICAgIFx0XHRpZiAoICEgdGFyZ2V0T2JqZWN0ICkge1xuXG4gICAgXHRcdFx0dGFyZ2V0T2JqZWN0ID0gUHJvcGVydHlCaW5kaW5nLmZpbmROb2RlKFxuICAgIFx0XHRcdFx0XHR0aGlzLnJvb3ROb2RlLCBwYXJzZWRQYXRoLm5vZGVOYW1lICkgfHwgdGhpcy5yb290Tm9kZTtcblxuICAgIFx0XHRcdHRoaXMubm9kZSA9IHRhcmdldE9iamVjdDtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0Ly8gc2V0IGZhaWwgc3RhdGUgc28gd2UgY2FuIGp1c3QgJ3JldHVybicgb24gZXJyb3JcbiAgICBcdFx0dGhpcy5nZXRWYWx1ZSA9IHRoaXMuX2dldFZhbHVlX3VuYXZhaWxhYmxlO1xuICAgIFx0XHR0aGlzLnNldFZhbHVlID0gdGhpcy5fc2V0VmFsdWVfdW5hdmFpbGFibGU7XG5cbiAgICAgXHRcdC8vIGVuc3VyZSB0aGVyZSBpcyBhIHZhbHVlIG5vZGVcbiAgICBcdFx0aWYgKCAhIHRhcmdldE9iamVjdCApIHtcblxuICAgIFx0XHRcdGNvbnNvbGUuZXJyb3IoIFwiICB0cnlpbmcgdG8gdXBkYXRlIG5vZGUgZm9yIHRyYWNrOiBcIiArIHRoaXMucGF0aCArIFwiIGJ1dCBpdCB3YXNuJ3QgZm91bmQuXCIgKTtcbiAgICBcdFx0XHRyZXR1cm47XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGlmICggb2JqZWN0TmFtZSApIHtcblxuICAgIFx0XHRcdHZhciBvYmplY3RJbmRleCA9IHBhcnNlZFBhdGgub2JqZWN0SW5kZXg7XG5cbiAgICBcdFx0XHQvLyBzcGVjaWFsIGNhc2VzIHdlcmUgd2UgbmVlZCB0byByZWFjaCBkZWVwZXIgaW50byB0aGUgaGllcmFyY2h5IHRvIGdldCB0aGUgZmFjZSBtYXRlcmlhbHMuLi4uXG4gICAgXHRcdFx0c3dpdGNoICggb2JqZWN0TmFtZSApIHtcblxuICAgIFx0XHRcdFx0Y2FzZSAnbWF0ZXJpYWxzJzpcblxuICAgIFx0XHRcdFx0XHRpZiAoICEgdGFyZ2V0T2JqZWN0Lm1hdGVyaWFsICkge1xuXG4gICAgXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJyAgY2FuIG5vdCBiaW5kIHRvIG1hdGVyaWFsIGFzIG5vZGUgZG9lcyBub3QgaGF2ZSBhIG1hdGVyaWFsJywgdGhpcyApO1xuICAgIFx0XHRcdFx0XHRcdHJldHVybjtcblxuICAgIFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdFx0aWYgKCAhIHRhcmdldE9iamVjdC5tYXRlcmlhbC5tYXRlcmlhbHMgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnICBjYW4gbm90IGJpbmQgdG8gbWF0ZXJpYWwubWF0ZXJpYWxzIGFzIG5vZGUubWF0ZXJpYWwgZG9lcyBub3QgaGF2ZSBhIG1hdGVyaWFscyBhcnJheScsIHRoaXMgKTtcbiAgICBcdFx0XHRcdFx0XHRyZXR1cm47XG5cbiAgICBcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRcdHRhcmdldE9iamVjdCA9IHRhcmdldE9iamVjdC5tYXRlcmlhbC5tYXRlcmlhbHM7XG5cbiAgICBcdFx0XHRcdFx0YnJlYWs7XG5cbiAgICBcdFx0XHRcdGNhc2UgJ2JvbmVzJzpcblxuICAgIFx0XHRcdFx0XHRpZiAoICEgdGFyZ2V0T2JqZWN0LnNrZWxldG9uICkge1xuXG4gICAgXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJyAgY2FuIG5vdCBiaW5kIHRvIGJvbmVzIGFzIG5vZGUgZG9lcyBub3QgaGF2ZSBhIHNrZWxldG9uJywgdGhpcyApO1xuICAgIFx0XHRcdFx0XHRcdHJldHVybjtcblxuICAgIFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdFx0Ly8gcG90ZW50aWFsIGZ1dHVyZSBvcHRpbWl6YXRpb246IHNraXAgdGhpcyBpZiBwcm9wZXJ0eUluZGV4IGlzIGFscmVhZHkgYW4gaW50ZWdlclxuICAgIFx0XHRcdFx0XHQvLyBhbmQgY29udmVydCB0aGUgaW50ZWdlciBzdHJpbmcgdG8gYSB0cnVlIGludGVnZXIuXG5cbiAgICBcdFx0XHRcdFx0dGFyZ2V0T2JqZWN0ID0gdGFyZ2V0T2JqZWN0LnNrZWxldG9uLmJvbmVzO1xuXG4gICAgXHRcdFx0XHRcdC8vIHN1cHBvcnQgcmVzb2x2aW5nIG1vcnBoVGFyZ2V0IG5hbWVzIGludG8gaW5kaWNlcy5cbiAgICBcdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGFyZ2V0T2JqZWN0Lmxlbmd0aDsgaSArKyApIHtcblxuICAgIFx0XHRcdFx0XHRcdGlmICggdGFyZ2V0T2JqZWN0WyBpIF0ubmFtZSA9PT0gb2JqZWN0SW5kZXggKSB7XG5cbiAgICBcdFx0XHRcdFx0XHRcdG9iamVjdEluZGV4ID0gaTtcbiAgICBcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG4gICAgXHRcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0XHRicmVhaztcblxuICAgIFx0XHRcdFx0ZGVmYXVsdDpcblxuICAgIFx0XHRcdFx0XHRpZiAoIHRhcmdldE9iamVjdFsgb2JqZWN0TmFtZSBdID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnICBjYW4gbm90IGJpbmQgdG8gb2JqZWN0TmFtZSBvZiBub2RlLCB1bmRlZmluZWQnLCB0aGlzICk7XG4gICAgXHRcdFx0XHRcdFx0cmV0dXJuO1xuXG4gICAgXHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0XHR0YXJnZXRPYmplY3QgPSB0YXJnZXRPYmplY3RbIG9iamVjdE5hbWUgXTtcblxuICAgIFx0XHRcdH1cblxuXG4gICAgXHRcdFx0aWYgKCBvYmplY3RJbmRleCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0XHRpZiAoIHRhcmdldE9iamVjdFsgb2JqZWN0SW5kZXggXSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoIFwiICB0cnlpbmcgdG8gYmluZCB0byBvYmplY3RJbmRleCBvZiBvYmplY3ROYW1lLCBidXQgaXMgdW5kZWZpbmVkOlwiLCB0aGlzLCB0YXJnZXRPYmplY3QgKTtcbiAgICBcdFx0XHRcdFx0cmV0dXJuO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdHRhcmdldE9iamVjdCA9IHRhcmdldE9iamVjdFsgb2JqZWN0SW5kZXggXTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdFx0Ly8gcmVzb2x2ZSBwcm9wZXJ0eVxuICAgIFx0XHR2YXIgbm9kZVByb3BlcnR5ID0gdGFyZ2V0T2JqZWN0WyBwcm9wZXJ0eU5hbWUgXTtcblxuICAgIFx0XHRpZiAoIG5vZGVQcm9wZXJ0eSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0dmFyIG5vZGVOYW1lID0gcGFyc2VkUGF0aC5ub2RlTmFtZTtcblxuICAgIFx0XHRcdGNvbnNvbGUuZXJyb3IoIFwiICB0cnlpbmcgdG8gdXBkYXRlIHByb3BlcnR5IGZvciB0cmFjazogXCIgKyBub2RlTmFtZSArXG4gICAgXHRcdFx0XHRcdCcuJyArIHByb3BlcnR5TmFtZSArIFwiIGJ1dCBpdCB3YXNuJ3QgZm91bmQuXCIsIHRhcmdldE9iamVjdCApO1xuICAgIFx0XHRcdHJldHVybjtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0Ly8gZGV0ZXJtaW5lIHZlcnNpb25pbmcgc2NoZW1lXG4gICAgXHRcdHZhciB2ZXJzaW9uaW5nID0gdGhpcy5WZXJzaW9uaW5nLk5vbmU7XG5cbiAgICBcdFx0aWYgKCB0YXJnZXRPYmplY3QubmVlZHNVcGRhdGUgIT09IHVuZGVmaW5lZCApIHsgLy8gbWF0ZXJpYWxcblxuICAgIFx0XHRcdHZlcnNpb25pbmcgPSB0aGlzLlZlcnNpb25pbmcuTmVlZHNVcGRhdGU7XG4gICAgXHRcdFx0dGhpcy50YXJnZXRPYmplY3QgPSB0YXJnZXRPYmplY3Q7XG5cbiAgICBcdFx0fSBlbHNlIGlmICggdGFyZ2V0T2JqZWN0Lm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgIT09IHVuZGVmaW5lZCApIHsgLy8gbm9kZSB0cmFuc2Zvcm1cblxuICAgIFx0XHRcdHZlcnNpb25pbmcgPSB0aGlzLlZlcnNpb25pbmcuTWF0cml4V29ybGROZWVkc1VwZGF0ZTtcbiAgICBcdFx0XHR0aGlzLnRhcmdldE9iamVjdCA9IHRhcmdldE9iamVjdDtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0Ly8gZGV0ZXJtaW5lIGhvdyB0aGUgcHJvcGVydHkgZ2V0cyBib3VuZFxuICAgIFx0XHR2YXIgYmluZGluZ1R5cGUgPSB0aGlzLkJpbmRpbmdUeXBlLkRpcmVjdDtcblxuICAgIFx0XHRpZiAoIHByb3BlcnR5SW5kZXggIT09IHVuZGVmaW5lZCApIHtcbiAgICBcdFx0XHQvLyBhY2Nlc3MgYSBzdWIgZWxlbWVudCBvZiB0aGUgcHJvcGVydHkgYXJyYXkgKG9ubHkgcHJpbWl0aXZlcyBhcmUgc3VwcG9ydGVkIHJpZ2h0IG5vdylcblxuICAgIFx0XHRcdGlmICggcHJvcGVydHlOYW1lID09PSBcIm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1wiICkge1xuICAgIFx0XHRcdFx0Ly8gcG90ZW50aWFsIG9wdGltaXphdGlvbiwgc2tpcCB0aGlzIGlmIHByb3BlcnR5SW5kZXggaXMgYWxyZWFkeSBhbiBpbnRlZ2VyLCBhbmQgY29udmVydCB0aGUgaW50ZWdlciBzdHJpbmcgdG8gYSB0cnVlIGludGVnZXIuXG5cbiAgICBcdFx0XHRcdC8vIHN1cHBvcnQgcmVzb2x2aW5nIG1vcnBoVGFyZ2V0IG5hbWVzIGludG8gaW5kaWNlcy5cbiAgICBcdFx0XHRcdGlmICggISB0YXJnZXRPYmplY3QuZ2VvbWV0cnkgKSB7XG5cbiAgICBcdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJyAgY2FuIG5vdCBiaW5kIHRvIG1vcnBoVGFyZ2V0SW5mbHVlbmNlcyBiZWNhc3VzZSBub2RlIGRvZXMgbm90IGhhdmUgYSBnZW9tZXRyeScsIHRoaXMgKTtcbiAgICBcdFx0XHRcdFx0cmV0dXJuO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdGlmICggISB0YXJnZXRPYmplY3QuZ2VvbWV0cnkubW9ycGhUYXJnZXRzICkge1xuXG4gICAgXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICcgIGNhbiBub3QgYmluZCB0byBtb3JwaFRhcmdldEluZmx1ZW5jZXMgYmVjYXN1c2Ugbm9kZSBkb2VzIG5vdCBoYXZlIGEgZ2VvbWV0cnkubW9ycGhUYXJnZXRzJywgdGhpcyApO1xuICAgIFx0XHRcdFx0XHRyZXR1cm47XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5ub2RlLmdlb21ldHJ5Lm1vcnBoVGFyZ2V0cy5sZW5ndGg7IGkgKysgKSB7XG5cbiAgICBcdFx0XHRcdFx0aWYgKCB0YXJnZXRPYmplY3QuZ2VvbWV0cnkubW9ycGhUYXJnZXRzWyBpIF0ubmFtZSA9PT0gcHJvcGVydHlJbmRleCApIHtcblxuICAgIFx0XHRcdFx0XHRcdHByb3BlcnR5SW5kZXggPSBpO1xuICAgIFx0XHRcdFx0XHRcdGJyZWFrO1xuXG4gICAgXHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0YmluZGluZ1R5cGUgPSB0aGlzLkJpbmRpbmdUeXBlLkFycmF5RWxlbWVudDtcblxuICAgIFx0XHRcdHRoaXMucmVzb2x2ZWRQcm9wZXJ0eSA9IG5vZGVQcm9wZXJ0eTtcbiAgICBcdFx0XHR0aGlzLnByb3BlcnR5SW5kZXggPSBwcm9wZXJ0eUluZGV4O1xuXG4gICAgXHRcdH0gZWxzZSBpZiAoIG5vZGVQcm9wZXJ0eS5mcm9tQXJyYXkgIT09IHVuZGVmaW5lZCAmJiBub2RlUHJvcGVydHkudG9BcnJheSAhPT0gdW5kZWZpbmVkICkge1xuICAgIFx0XHRcdC8vIG11c3QgdXNlIGNvcHkgZm9yIE9iamVjdDNELkV1bGVyL1F1YXRlcm5pb25cblxuICAgIFx0XHRcdGJpbmRpbmdUeXBlID0gdGhpcy5CaW5kaW5nVHlwZS5IYXNGcm9tVG9BcnJheTtcblxuICAgIFx0XHRcdHRoaXMucmVzb2x2ZWRQcm9wZXJ0eSA9IG5vZGVQcm9wZXJ0eTtcblxuICAgIFx0XHR9IGVsc2UgaWYgKCBub2RlUHJvcGVydHkubGVuZ3RoICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRiaW5kaW5nVHlwZSA9IHRoaXMuQmluZGluZ1R5cGUuRW50aXJlQXJyYXk7XG5cbiAgICBcdFx0XHR0aGlzLnJlc29sdmVkUHJvcGVydHkgPSBub2RlUHJvcGVydHk7XG5cbiAgICBcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdHRoaXMucHJvcGVydHlOYW1lID0gcHJvcGVydHlOYW1lO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHQvLyBzZWxlY3QgZ2V0dGVyIC8gc2V0dGVyXG4gICAgXHRcdHRoaXMuZ2V0VmFsdWUgPSB0aGlzLkdldHRlckJ5QmluZGluZ1R5cGVbIGJpbmRpbmdUeXBlIF07XG4gICAgXHRcdHRoaXMuc2V0VmFsdWUgPSB0aGlzLlNldHRlckJ5QmluZGluZ1R5cGVBbmRWZXJzaW9uaW5nWyBiaW5kaW5nVHlwZSBdWyB2ZXJzaW9uaW5nIF07XG5cbiAgICBcdH0sXG5cbiAgICBcdHVuYmluZDogZnVuY3Rpb24oKSB7XG5cbiAgICBcdFx0dGhpcy5ub2RlID0gbnVsbDtcblxuICAgIFx0XHQvLyBiYWNrIHRvIHRoZSBwcm90b3R5cGUgdmVyc2lvbiBvZiBnZXRWYWx1ZSAvIHNldFZhbHVlXG4gICAgXHRcdC8vIG5vdGU6IGF2b2lkaW5nIHRvIG11dGF0ZSB0aGUgc2hhcGUgb2YgJ3RoaXMnIHZpYSAnZGVsZXRlJ1xuICAgIFx0XHR0aGlzLmdldFZhbHVlID0gdGhpcy5fZ2V0VmFsdWVfdW5ib3VuZDtcbiAgICBcdFx0dGhpcy5zZXRWYWx1ZSA9IHRoaXMuX3NldFZhbHVlX3VuYm91bmQ7XG5cbiAgICBcdH1cblxuICAgIH07XG5cbiAgICBPYmplY3QuYXNzaWduKCBQcm9wZXJ0eUJpbmRpbmcucHJvdG90eXBlLCB7IC8vIHByb3RvdHlwZSwgY29udGludWVkXG5cbiAgICBcdC8vIHRoZXNlIGFyZSB1c2VkIHRvIFwiYmluZFwiIGEgbm9uZXhpc3RlbnQgcHJvcGVydHlcbiAgICBcdF9nZXRWYWx1ZV91bmF2YWlsYWJsZTogZnVuY3Rpb24oKSB7fSxcbiAgICBcdF9zZXRWYWx1ZV91bmF2YWlsYWJsZTogZnVuY3Rpb24oKSB7fSxcblxuICAgIFx0Ly8gaW5pdGlhbCBzdGF0ZSBvZiB0aGVzZSBtZXRob2RzIHRoYXQgY2FsbHMgJ2JpbmQnXG4gICAgXHRfZ2V0VmFsdWVfdW5ib3VuZDogUHJvcGVydHlCaW5kaW5nLnByb3RvdHlwZS5nZXRWYWx1ZSxcbiAgICBcdF9zZXRWYWx1ZV91bmJvdW5kOiBQcm9wZXJ0eUJpbmRpbmcucHJvdG90eXBlLnNldFZhbHVlLFxuXG4gICAgXHRCaW5kaW5nVHlwZToge1xuICAgIFx0XHREaXJlY3Q6IDAsXG4gICAgXHRcdEVudGlyZUFycmF5OiAxLFxuICAgIFx0XHRBcnJheUVsZW1lbnQ6IDIsXG4gICAgXHRcdEhhc0Zyb21Ub0FycmF5OiAzXG4gICAgXHR9LFxuXG4gICAgXHRWZXJzaW9uaW5nOiB7XG4gICAgXHRcdE5vbmU6IDAsXG4gICAgXHRcdE5lZWRzVXBkYXRlOiAxLFxuICAgIFx0XHRNYXRyaXhXb3JsZE5lZWRzVXBkYXRlOiAyXG4gICAgXHR9LFxuXG4gICAgXHRHZXR0ZXJCeUJpbmRpbmdUeXBlOiBbXG5cbiAgICBcdFx0ZnVuY3Rpb24gZ2V0VmFsdWVfZGlyZWN0KCBidWZmZXIsIG9mZnNldCApIHtcblxuICAgIFx0XHRcdGJ1ZmZlclsgb2Zmc2V0IF0gPSB0aGlzLm5vZGVbIHRoaXMucHJvcGVydHlOYW1lIF07XG5cbiAgICBcdFx0fSxcblxuICAgIFx0XHRmdW5jdGlvbiBnZXRWYWx1ZV9hcnJheSggYnVmZmVyLCBvZmZzZXQgKSB7XG5cbiAgICBcdFx0XHR2YXIgc291cmNlID0gdGhpcy5yZXNvbHZlZFByb3BlcnR5O1xuXG4gICAgXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBuID0gc291cmNlLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcblxuICAgIFx0XHRcdFx0YnVmZmVyWyBvZmZzZXQgKysgXSA9IHNvdXJjZVsgaSBdO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH0sXG5cbiAgICBcdFx0ZnVuY3Rpb24gZ2V0VmFsdWVfYXJyYXlFbGVtZW50KCBidWZmZXIsIG9mZnNldCApIHtcblxuICAgIFx0XHRcdGJ1ZmZlclsgb2Zmc2V0IF0gPSB0aGlzLnJlc29sdmVkUHJvcGVydHlbIHRoaXMucHJvcGVydHlJbmRleCBdO1xuXG4gICAgXHRcdH0sXG5cbiAgICBcdFx0ZnVuY3Rpb24gZ2V0VmFsdWVfdG9BcnJheSggYnVmZmVyLCBvZmZzZXQgKSB7XG5cbiAgICBcdFx0XHR0aGlzLnJlc29sdmVkUHJvcGVydHkudG9BcnJheSggYnVmZmVyLCBvZmZzZXQgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdF0sXG5cbiAgICBcdFNldHRlckJ5QmluZGluZ1R5cGVBbmRWZXJzaW9uaW5nOiBbXG5cbiAgICBcdFx0W1xuICAgIFx0XHRcdC8vIERpcmVjdFxuXG4gICAgXHRcdFx0ZnVuY3Rpb24gc2V0VmFsdWVfZGlyZWN0KCBidWZmZXIsIG9mZnNldCApIHtcblxuICAgIFx0XHRcdFx0dGhpcy5ub2RlWyB0aGlzLnByb3BlcnR5TmFtZSBdID0gYnVmZmVyWyBvZmZzZXQgXTtcblxuICAgIFx0XHRcdH0sXG5cbiAgICBcdFx0XHRmdW5jdGlvbiBzZXRWYWx1ZV9kaXJlY3Rfc2V0TmVlZHNVcGRhdGUoIGJ1ZmZlciwgb2Zmc2V0ICkge1xuXG4gICAgXHRcdFx0XHR0aGlzLm5vZGVbIHRoaXMucHJvcGVydHlOYW1lIF0gPSBidWZmZXJbIG9mZnNldCBdO1xuICAgIFx0XHRcdFx0dGhpcy50YXJnZXRPYmplY3QubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgXHRcdFx0fSxcblxuICAgIFx0XHRcdGZ1bmN0aW9uIHNldFZhbHVlX2RpcmVjdF9zZXRNYXRyaXhXb3JsZE5lZWRzVXBkYXRlKCBidWZmZXIsIG9mZnNldCApIHtcblxuICAgIFx0XHRcdFx0dGhpcy5ub2RlWyB0aGlzLnByb3BlcnR5TmFtZSBdID0gYnVmZmVyWyBvZmZzZXQgXTtcbiAgICBcdFx0XHRcdHRoaXMudGFyZ2V0T2JqZWN0Lm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdF0sIFtcblxuICAgIFx0XHRcdC8vIEVudGlyZUFycmF5XG5cbiAgICBcdFx0XHRmdW5jdGlvbiBzZXRWYWx1ZV9hcnJheSggYnVmZmVyLCBvZmZzZXQgKSB7XG5cbiAgICBcdFx0XHRcdHZhciBkZXN0ID0gdGhpcy5yZXNvbHZlZFByb3BlcnR5O1xuXG4gICAgXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIG4gPSBkZXN0Lmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcblxuICAgIFx0XHRcdFx0XHRkZXN0WyBpIF0gPSBidWZmZXJbIG9mZnNldCArKyBdO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9LFxuXG4gICAgXHRcdFx0ZnVuY3Rpb24gc2V0VmFsdWVfYXJyYXlfc2V0TmVlZHNVcGRhdGUoIGJ1ZmZlciwgb2Zmc2V0ICkge1xuXG4gICAgXHRcdFx0XHR2YXIgZGVzdCA9IHRoaXMucmVzb2x2ZWRQcm9wZXJ0eTtcblxuICAgIFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBuID0gZGVzdC5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cbiAgICBcdFx0XHRcdFx0ZGVzdFsgaSBdID0gYnVmZmVyWyBvZmZzZXQgKysgXTtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHR0aGlzLnRhcmdldE9iamVjdC5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICBcdFx0XHR9LFxuXG4gICAgXHRcdFx0ZnVuY3Rpb24gc2V0VmFsdWVfYXJyYXlfc2V0TWF0cml4V29ybGROZWVkc1VwZGF0ZSggYnVmZmVyLCBvZmZzZXQgKSB7XG5cbiAgICBcdFx0XHRcdHZhciBkZXN0ID0gdGhpcy5yZXNvbHZlZFByb3BlcnR5O1xuXG4gICAgXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIG4gPSBkZXN0Lmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcblxuICAgIFx0XHRcdFx0XHRkZXN0WyBpIF0gPSBidWZmZXJbIG9mZnNldCArKyBdO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdHRoaXMudGFyZ2V0T2JqZWN0Lm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdF0sIFtcblxuICAgIFx0XHRcdC8vIEFycmF5RWxlbWVudFxuXG4gICAgXHRcdFx0ZnVuY3Rpb24gc2V0VmFsdWVfYXJyYXlFbGVtZW50KCBidWZmZXIsIG9mZnNldCApIHtcblxuICAgIFx0XHRcdFx0dGhpcy5yZXNvbHZlZFByb3BlcnR5WyB0aGlzLnByb3BlcnR5SW5kZXggXSA9IGJ1ZmZlclsgb2Zmc2V0IF07XG5cbiAgICBcdFx0XHR9LFxuXG4gICAgXHRcdFx0ZnVuY3Rpb24gc2V0VmFsdWVfYXJyYXlFbGVtZW50X3NldE5lZWRzVXBkYXRlKCBidWZmZXIsIG9mZnNldCApIHtcblxuICAgIFx0XHRcdFx0dGhpcy5yZXNvbHZlZFByb3BlcnR5WyB0aGlzLnByb3BlcnR5SW5kZXggXSA9IGJ1ZmZlclsgb2Zmc2V0IF07XG4gICAgXHRcdFx0XHR0aGlzLnRhcmdldE9iamVjdC5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICBcdFx0XHR9LFxuXG4gICAgXHRcdFx0ZnVuY3Rpb24gc2V0VmFsdWVfYXJyYXlFbGVtZW50X3NldE1hdHJpeFdvcmxkTmVlZHNVcGRhdGUoIGJ1ZmZlciwgb2Zmc2V0ICkge1xuXG4gICAgXHRcdFx0XHR0aGlzLnJlc29sdmVkUHJvcGVydHlbIHRoaXMucHJvcGVydHlJbmRleCBdID0gYnVmZmVyWyBvZmZzZXQgXTtcbiAgICBcdFx0XHRcdHRoaXMudGFyZ2V0T2JqZWN0Lm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdF0sIFtcblxuICAgIFx0XHRcdC8vIEhhc1RvRnJvbUFycmF5XG5cbiAgICBcdFx0XHRmdW5jdGlvbiBzZXRWYWx1ZV9mcm9tQXJyYXkoIGJ1ZmZlciwgb2Zmc2V0ICkge1xuXG4gICAgXHRcdFx0XHR0aGlzLnJlc29sdmVkUHJvcGVydHkuZnJvbUFycmF5KCBidWZmZXIsIG9mZnNldCApO1xuXG4gICAgXHRcdFx0fSxcblxuICAgIFx0XHRcdGZ1bmN0aW9uIHNldFZhbHVlX2Zyb21BcnJheV9zZXROZWVkc1VwZGF0ZSggYnVmZmVyLCBvZmZzZXQgKSB7XG5cbiAgICBcdFx0XHRcdHRoaXMucmVzb2x2ZWRQcm9wZXJ0eS5mcm9tQXJyYXkoIGJ1ZmZlciwgb2Zmc2V0ICk7XG4gICAgXHRcdFx0XHR0aGlzLnRhcmdldE9iamVjdC5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICBcdFx0XHR9LFxuXG4gICAgXHRcdFx0ZnVuY3Rpb24gc2V0VmFsdWVfZnJvbUFycmF5X3NldE1hdHJpeFdvcmxkTmVlZHNVcGRhdGUoIGJ1ZmZlciwgb2Zmc2V0ICkge1xuXG4gICAgXHRcdFx0XHR0aGlzLnJlc29sdmVkUHJvcGVydHkuZnJvbUFycmF5KCBidWZmZXIsIG9mZnNldCApO1xuICAgIFx0XHRcdFx0dGhpcy50YXJnZXRPYmplY3QubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XVxuXG4gICAgXHRdXG5cbiAgICB9ICk7XG5cbiAgICBQcm9wZXJ0eUJpbmRpbmcuQ29tcG9zaXRlID1cbiAgICBcdFx0ZnVuY3Rpb24oIHRhcmdldEdyb3VwLCBwYXRoLCBvcHRpb25hbFBhcnNlZFBhdGggKSB7XG5cbiAgICBcdHZhciBwYXJzZWRQYXRoID0gb3B0aW9uYWxQYXJzZWRQYXRoIHx8XG4gICAgXHRcdFx0UHJvcGVydHlCaW5kaW5nLnBhcnNlVHJhY2tOYW1lKCBwYXRoICk7XG5cbiAgICBcdHRoaXMuX3RhcmdldEdyb3VwID0gdGFyZ2V0R3JvdXA7XG4gICAgXHR0aGlzLl9iaW5kaW5ncyA9IHRhcmdldEdyb3VwLnN1YnNjcmliZV8oIHBhdGgsIHBhcnNlZFBhdGggKTtcblxuICAgIH07XG5cbiAgICBQcm9wZXJ0eUJpbmRpbmcuQ29tcG9zaXRlLnByb3RvdHlwZSA9IHtcblxuICAgIFx0Y29uc3RydWN0b3I6IFByb3BlcnR5QmluZGluZy5Db21wb3NpdGUsXG5cbiAgICBcdGdldFZhbHVlOiBmdW5jdGlvbiggYXJyYXksIG9mZnNldCApIHtcblxuICAgIFx0XHR0aGlzLmJpbmQoKTsgLy8gYmluZCBhbGwgYmluZGluZ1xuXG4gICAgXHRcdHZhciBmaXJzdFZhbGlkSW5kZXggPSB0aGlzLl90YXJnZXRHcm91cC5uQ2FjaGVkT2JqZWN0c18sXG4gICAgXHRcdFx0YmluZGluZyA9IHRoaXMuX2JpbmRpbmdzWyBmaXJzdFZhbGlkSW5kZXggXTtcblxuICAgIFx0XHQvLyBhbmQgb25seSBjYWxsIC5nZXRWYWx1ZSBvbiB0aGUgZmlyc3RcbiAgICBcdFx0aWYgKCBiaW5kaW5nICE9PSB1bmRlZmluZWQgKSBiaW5kaW5nLmdldFZhbHVlKCBhcnJheSwgb2Zmc2V0ICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldFZhbHVlOiBmdW5jdGlvbiggYXJyYXksIG9mZnNldCApIHtcblxuICAgIFx0XHR2YXIgYmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncztcblxuICAgIFx0XHRmb3IgKCB2YXIgaSA9IHRoaXMuX3RhcmdldEdyb3VwLm5DYWNoZWRPYmplY3RzXyxcbiAgICBcdFx0XHRcdG4gPSBiaW5kaW5ncy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cbiAgICBcdFx0XHRiaW5kaW5nc1sgaSBdLnNldFZhbHVlKCBhcnJheSwgb2Zmc2V0ICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9LFxuXG4gICAgXHRiaW5kOiBmdW5jdGlvbigpIHtcblxuICAgIFx0XHR2YXIgYmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncztcblxuICAgIFx0XHRmb3IgKCB2YXIgaSA9IHRoaXMuX3RhcmdldEdyb3VwLm5DYWNoZWRPYmplY3RzXyxcbiAgICBcdFx0XHRcdG4gPSBiaW5kaW5ncy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cbiAgICBcdFx0XHRiaW5kaW5nc1sgaSBdLmJpbmQoKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdH0sXG5cbiAgICBcdHVuYmluZDogZnVuY3Rpb24oKSB7XG5cbiAgICBcdFx0dmFyIGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3M7XG5cbiAgICBcdFx0Zm9yICggdmFyIGkgPSB0aGlzLl90YXJnZXRHcm91cC5uQ2FjaGVkT2JqZWN0c18sXG4gICAgXHRcdFx0XHRuID0gYmluZGluZ3MubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xuXG4gICAgXHRcdFx0YmluZGluZ3NbIGkgXS51bmJpbmQoKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdH1cblxuICAgIH07XG5cbiAgICBQcm9wZXJ0eUJpbmRpbmcuY3JlYXRlID0gZnVuY3Rpb24oIHJvb3QsIHBhdGgsIHBhcnNlZFBhdGggKSB7XG5cbiAgICBcdGlmICggISAoIChyb290ICYmIHJvb3QuaXNBbmltYXRpb25PYmplY3RHcm91cCkgKSApIHtcblxuICAgIFx0XHRyZXR1cm4gbmV3IFByb3BlcnR5QmluZGluZyggcm9vdCwgcGF0aCwgcGFyc2VkUGF0aCApO1xuXG4gICAgXHR9IGVsc2Uge1xuXG4gICAgXHRcdHJldHVybiBuZXcgUHJvcGVydHlCaW5kaW5nLkNvbXBvc2l0ZSggcm9vdCwgcGF0aCwgcGFyc2VkUGF0aCApO1xuXG4gICAgXHR9XG5cbiAgICB9O1xuXG4gICAgUHJvcGVydHlCaW5kaW5nLnBhcnNlVHJhY2tOYW1lID0gZnVuY3Rpb24oIHRyYWNrTmFtZSApIHtcblxuICAgIFx0Ly8gbWF0Y2hlcyBzdHJpbmdzIGluIHRoZSBmb3JtIG9mOlxuICAgIFx0Ly8gICAgbm9kZU5hbWUucHJvcGVydHlcbiAgICBcdC8vICAgIG5vZGVOYW1lLnByb3BlcnR5W2FjY2Vzc29yXVxuICAgIFx0Ly8gICAgbm9kZU5hbWUubWF0ZXJpYWwucHJvcGVydHlbYWNjZXNzb3JdXG4gICAgXHQvLyAgICB1dWlkLnByb3BlcnR5W2FjY2Vzc29yXVxuICAgIFx0Ly8gICAgdXVpZC5vYmplY3ROYW1lW29iamVjdEluZGV4XS5wcm9wZXJ0eU5hbWVbcHJvcGVydHlJbmRleF1cbiAgICBcdC8vICAgIHBhcmVudE5hbWUvbm9kZU5hbWUucHJvcGVydHlcbiAgICBcdC8vICAgIHBhcmVudE5hbWUvcGFyZW50TmFtZS9ub2RlTmFtZS5wcm9wZXJ0eVtpbmRleF1cbiAgICBcdC8vICAgIC5ib25lW0FybWF0dXJlLkRFRl9jb2ddLnBvc2l0aW9uXG4gICAgXHQvLyAgICBzY2VuZTpoZWxpdW1fYmFsbG9vbl9tb2RlbDpoZWxpdW1fYmFsbG9vbl9tb2RlbC5wb3NpdGlvblxuICAgIFx0Ly8gY3JlYXRlZCBhbmQgdGVzdGVkIHZpYSBodHRwczovL3JlZ2V4MTAxLmNvbS8jamF2YXNjcmlwdFxuXG4gICAgXHR2YXIgcmUgPSAvXigoPzpcXHcrW1xcLzpdKSopKFxcdyspPyg/OlxcLihcXHcrKSg/OlxcWyguKylcXF0pPyk/XFwuKFxcdyspKD86XFxbKC4rKVxcXSk/JC87XG4gICAgXHR2YXIgbWF0Y2hlcyA9IHJlLmV4ZWMoIHRyYWNrTmFtZSApO1xuXG4gICAgXHRpZiAoICEgbWF0Y2hlcyApIHtcblxuICAgIFx0XHR0aHJvdyBuZXcgRXJyb3IoIFwiY2Fubm90IHBhcnNlIHRyYWNrTmFtZSBhdCBhbGw6IFwiICsgdHJhY2tOYW1lICk7XG5cbiAgICBcdH1cblxuICAgIFx0dmFyIHJlc3VsdHMgPSB7XG4gICAgXHRcdC8vIGRpcmVjdG9yeU5hbWU6IG1hdGNoZXNbIDEgXSwgLy8gKHRzY2h3KSBjdXJyZW50bHkgdW51c2VkXG4gICAgXHRcdG5vZGVOYW1lOiBtYXRjaGVzWyAyIF0sIFx0Ly8gYWxsb3dlZCB0byBiZSBudWxsLCBzcGVjaWZpZWQgcm9vdCBub2RlLlxuICAgIFx0XHRvYmplY3ROYW1lOiBtYXRjaGVzWyAzIF0sXG4gICAgXHRcdG9iamVjdEluZGV4OiBtYXRjaGVzWyA0IF0sXG4gICAgXHRcdHByb3BlcnR5TmFtZTogbWF0Y2hlc1sgNSBdLFxuICAgIFx0XHRwcm9wZXJ0eUluZGV4OiBtYXRjaGVzWyA2IF1cdC8vIGFsbG93ZWQgdG8gYmUgbnVsbCwgc3BlY2lmaWVzIHRoYXQgdGhlIHdob2xlIHByb3BlcnR5IGlzIHNldC5cbiAgICBcdH07XG5cbiAgICBcdGlmICggcmVzdWx0cy5wcm9wZXJ0eU5hbWUgPT09IG51bGwgfHwgcmVzdWx0cy5wcm9wZXJ0eU5hbWUubGVuZ3RoID09PSAwICkge1xuXG4gICAgXHRcdHRocm93IG5ldyBFcnJvciggXCJjYW4gbm90IHBhcnNlIHByb3BlcnR5TmFtZSBmcm9tIHRyYWNrTmFtZTogXCIgKyB0cmFja05hbWUgKTtcblxuICAgIFx0fVxuXG4gICAgXHRyZXR1cm4gcmVzdWx0cztcblxuICAgIH07XG5cbiAgICBQcm9wZXJ0eUJpbmRpbmcuZmluZE5vZGUgPSBmdW5jdGlvbiggcm9vdCwgbm9kZU5hbWUgKSB7XG5cbiAgICBcdGlmICggISBub2RlTmFtZSB8fCBub2RlTmFtZSA9PT0gXCJcIiB8fCBub2RlTmFtZSA9PT0gXCJyb290XCIgfHwgbm9kZU5hbWUgPT09IFwiLlwiIHx8IG5vZGVOYW1lID09PSAtMSB8fCBub2RlTmFtZSA9PT0gcm9vdC5uYW1lIHx8IG5vZGVOYW1lID09PSByb290LnV1aWQgKSB7XG5cbiAgICBcdFx0cmV0dXJuIHJvb3Q7XG5cbiAgICBcdH1cblxuICAgIFx0Ly8gc2VhcmNoIGludG8gc2tlbGV0b24gYm9uZXMuXG4gICAgXHRpZiAoIHJvb3Quc2tlbGV0b24gKSB7XG5cbiAgICBcdFx0dmFyIHNlYXJjaFNrZWxldG9uID0gZnVuY3Rpb24oIHNrZWxldG9uICkge1xuXG4gICAgXHRcdFx0Zm9yKCB2YXIgaSA9IDA7IGkgPCBza2VsZXRvbi5ib25lcy5sZW5ndGg7IGkgKysgKSB7XG5cbiAgICBcdFx0XHRcdHZhciBib25lID0gc2tlbGV0b24uYm9uZXNbIGkgXTtcblxuICAgIFx0XHRcdFx0aWYgKCBib25lLm5hbWUgPT09IG5vZGVOYW1lICkge1xuXG4gICAgXHRcdFx0XHRcdHJldHVybiBib25lO1xuXG4gICAgXHRcdFx0XHR9XG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0cmV0dXJuIG51bGw7XG5cbiAgICBcdFx0fTtcblxuICAgIFx0XHR2YXIgYm9uZSA9IHNlYXJjaFNrZWxldG9uKCByb290LnNrZWxldG9uICk7XG5cbiAgICBcdFx0aWYgKCBib25lICkge1xuXG4gICAgXHRcdFx0cmV0dXJuIGJvbmU7XG5cbiAgICBcdFx0fVxuICAgIFx0fVxuXG4gICAgXHQvLyBzZWFyY2ggaW50byBub2RlIHN1YnRyZWUuXG4gICAgXHRpZiAoIHJvb3QuY2hpbGRyZW4gKSB7XG5cbiAgICBcdFx0dmFyIHNlYXJjaE5vZGVTdWJ0cmVlID0gZnVuY3Rpb24oIGNoaWxkcmVuICkge1xuXG4gICAgXHRcdFx0Zm9yKCB2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkgKysgKSB7XG5cbiAgICBcdFx0XHRcdHZhciBjaGlsZE5vZGUgPSBjaGlsZHJlblsgaSBdO1xuXG4gICAgXHRcdFx0XHRpZiAoIGNoaWxkTm9kZS5uYW1lID09PSBub2RlTmFtZSB8fCBjaGlsZE5vZGUudXVpZCA9PT0gbm9kZU5hbWUgKSB7XG5cbiAgICBcdFx0XHRcdFx0cmV0dXJuIGNoaWxkTm9kZTtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHR2YXIgcmVzdWx0ID0gc2VhcmNoTm9kZVN1YnRyZWUoIGNoaWxkTm9kZS5jaGlsZHJlbiApO1xuXG4gICAgXHRcdFx0XHRpZiAoIHJlc3VsdCApIHJldHVybiByZXN1bHQ7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRyZXR1cm4gbnVsbDtcblxuICAgIFx0XHR9O1xuXG4gICAgXHRcdHZhciBzdWJUcmVlTm9kZSA9IHNlYXJjaE5vZGVTdWJ0cmVlKCByb290LmNoaWxkcmVuICk7XG5cbiAgICBcdFx0aWYgKCBzdWJUcmVlTm9kZSApIHtcblxuICAgIFx0XHRcdHJldHVybiBzdWJUcmVlTm9kZTtcblxuICAgIFx0XHR9XG5cbiAgICBcdH1cblxuICAgIFx0cmV0dXJuIG51bGw7XG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBBIGdyb3VwIG9mIG9iamVjdHMgdGhhdCByZWNlaXZlcyBhIHNoYXJlZCBhbmltYXRpb24gc3RhdGUuXG4gICAgICpcbiAgICAgKiBVc2FnZTpcbiAgICAgKlxuICAgICAqIFx0LVx0QWRkIG9iamVjdHMgeW91IHdvdWxkIG90aGVyd2lzZSBwYXNzIGFzICdyb290JyB0byB0aGVcbiAgICAgKiBcdFx0Y29uc3RydWN0b3Igb3IgdGhlIC5jbGlwQWN0aW9uIG1ldGhvZCBvZiBBbmltYXRpb25NaXhlci5cbiAgICAgKlxuICAgICAqIFx0LVx0SW5zdGVhZCBwYXNzIHRoaXMgb2JqZWN0IGFzICdyb290Jy5cbiAgICAgKlxuICAgICAqIFx0LVx0WW91IGNhbiBhbHNvIGFkZCBhbmQgcmVtb3ZlIG9iamVjdHMgbGF0ZXIgd2hlbiB0aGUgbWl4ZXJcbiAgICAgKiBcdFx0aXMgcnVubmluZy5cbiAgICAgKlxuICAgICAqIE5vdGU6XG4gICAgICpcbiAgICAgKiAgXHRPYmplY3RzIG9mIHRoaXMgY2xhc3MgYXBwZWFyIGFzIG9uZSBvYmplY3QgdG8gdGhlIG1peGVyLFxuICAgICAqICBcdHNvIGNhY2hlIGNvbnRyb2wgb2YgdGhlIGluZGl2aWR1YWwgb2JqZWN0cyBtdXN0IGJlIGRvbmVcbiAgICAgKiAgXHRvbiB0aGUgZ3JvdXAuXG4gICAgICpcbiAgICAgKiBMaW1pdGF0aW9uOlxuICAgICAqXG4gICAgICogXHQtIFx0VGhlIGFuaW1hdGVkIHByb3BlcnRpZXMgbXVzdCBiZSBjb21wYXRpYmxlIGFtb25nIHRoZVxuICAgICAqIFx0XHRhbGwgb2JqZWN0cyBpbiB0aGUgZ3JvdXAuXG4gICAgICpcbiAgICAgKiAgLVx0QSBzaW5nbGUgcHJvcGVydHkgY2FuIGVpdGhlciBiZSBjb250cm9sbGVkIHRocm91Z2ggYVxuICAgICAqICBcdHRhcmdldCBncm91cCBvciBkaXJlY3RseSwgYnV0IG5vdCBib3RoLlxuICAgICAqXG4gICAgICogQGF1dGhvciB0c2Nod1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gQW5pbWF0aW9uT2JqZWN0R3JvdXAoIHZhcl9hcmdzICkge1xuXG4gICAgXHR0aGlzLnV1aWQgPSBleHBvcnRzLk1hdGguZ2VuZXJhdGVVVUlEKCk7XG5cbiAgICBcdC8vIGNhY2hlZCBvYmplY3RzIGZvbGxvd2VkIGJ5IHRoZSBhY3RpdmUgb25lc1xuICAgIFx0dGhpcy5fb2JqZWN0cyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBhcmd1bWVudHMgKTtcblxuICAgIFx0dGhpcy5uQ2FjaGVkT2JqZWN0c18gPSAwO1x0XHRcdC8vIHRocmVzaG9sZFxuICAgIFx0Ly8gbm90ZTogcmVhZCBieSBQcm9wZXJ0eUJpbmRpbmcuQ29tcG9zaXRlXG5cbiAgICBcdHZhciBpbmRpY2VzID0ge307XG4gICAgXHR0aGlzLl9pbmRpY2VzQnlVVUlEID0gaW5kaWNlcztcdFx0Ly8gZm9yIGJvb2trZWVwaW5nXG5cbiAgICBcdGZvciAoIHZhciBpID0gMCwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cbiAgICBcdFx0aW5kaWNlc1sgYXJndW1lbnRzWyBpIF0udXVpZCBdID0gaTtcblxuICAgIFx0fVxuXG4gICAgXHR0aGlzLl9wYXRocyA9IFtdO1x0XHRcdFx0XHQvLyBpbnNpZGU6IHN0cmluZ1xuICAgIFx0dGhpcy5fcGFyc2VkUGF0aHMgPSBbXTtcdFx0XHRcdC8vIGluc2lkZTogeyB3ZSBkb24ndCBjYXJlLCBoZXJlIH1cbiAgICBcdHRoaXMuX2JpbmRpbmdzID0gW107IFx0XHRcdFx0Ly8gaW5zaWRlOiBBcnJheTwgUHJvcGVydHlCaW5kaW5nID5cbiAgICBcdHRoaXMuX2JpbmRpbmdzSW5kaWNlc0J5UGF0aCA9IHt9OyBcdC8vIGluc2lkZTogaW5kaWNlcyBpbiB0aGVzZSBhcnJheXNcblxuICAgIFx0dmFyIHNjb3BlID0gdGhpcztcblxuICAgIFx0dGhpcy5zdGF0cyA9IHtcblxuICAgIFx0XHRvYmplY3RzOiB7XG4gICAgXHRcdFx0Z2V0IHRvdGFsKCkgeyByZXR1cm4gc2NvcGUuX29iamVjdHMubGVuZ3RoOyB9LFxuICAgIFx0XHRcdGdldCBpblVzZSgpIHsgcmV0dXJuIHRoaXMudG90YWwgLSBzY29wZS5uQ2FjaGVkT2JqZWN0c187ICB9XG4gICAgXHRcdH0sXG5cbiAgICBcdFx0Z2V0IGJpbmRpbmdzUGVyT2JqZWN0KCkgeyByZXR1cm4gc2NvcGUuX2JpbmRpbmdzLmxlbmd0aDsgfVxuXG4gICAgXHR9O1xuXG4gICAgfVxuXG4gICAgQW5pbWF0aW9uT2JqZWN0R3JvdXAucHJvdG90eXBlID0ge1xuXG4gICAgXHRjb25zdHJ1Y3RvcjogQW5pbWF0aW9uT2JqZWN0R3JvdXAsXG5cbiAgICBcdGlzQW5pbWF0aW9uT2JqZWN0R3JvdXA6IHRydWUsXG5cbiAgICBcdGFkZDogZnVuY3Rpb24oIHZhcl9hcmdzICkge1xuXG4gICAgXHRcdHZhciBvYmplY3RzID0gdGhpcy5fb2JqZWN0cyxcbiAgICBcdFx0XHRuT2JqZWN0cyA9IG9iamVjdHMubGVuZ3RoLFxuICAgIFx0XHRcdG5DYWNoZWRPYmplY3RzID0gdGhpcy5uQ2FjaGVkT2JqZWN0c18sXG4gICAgXHRcdFx0aW5kaWNlc0J5VVVJRCA9IHRoaXMuX2luZGljZXNCeVVVSUQsXG4gICAgXHRcdFx0cGF0aHMgPSB0aGlzLl9wYXRocyxcbiAgICBcdFx0XHRwYXJzZWRQYXRocyA9IHRoaXMuX3BhcnNlZFBhdGhzLFxuICAgIFx0XHRcdGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3MsXG4gICAgXHRcdFx0bkJpbmRpbmdzID0gYmluZGluZ3MubGVuZ3RoO1xuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMCwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cbiAgICBcdFx0XHR2YXIgb2JqZWN0ID0gYXJndW1lbnRzWyBpIF0sXG4gICAgXHRcdFx0XHR1dWlkID0gb2JqZWN0LnV1aWQsXG4gICAgXHRcdFx0XHRpbmRleCA9IGluZGljZXNCeVVVSURbIHV1aWQgXTtcblxuICAgIFx0XHRcdGlmICggaW5kZXggPT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0Ly8gdW5rbm93biBvYmplY3QgLT4gYWRkIGl0IHRvIHRoZSBBQ1RJVkUgcmVnaW9uXG5cbiAgICBcdFx0XHRcdGluZGV4ID0gbk9iamVjdHMgKys7XG4gICAgXHRcdFx0XHRpbmRpY2VzQnlVVUlEWyB1dWlkIF0gPSBpbmRleDtcbiAgICBcdFx0XHRcdG9iamVjdHMucHVzaCggb2JqZWN0ICk7XG5cbiAgICBcdFx0XHRcdC8vIGFjY291bnRpbmcgaXMgZG9uZSwgbm93IGRvIHRoZSBzYW1lIGZvciBhbGwgYmluZGluZ3NcblxuICAgIFx0XHRcdFx0Zm9yICggdmFyIGogPSAwLCBtID0gbkJpbmRpbmdzOyBqICE9PSBtOyArKyBqICkge1xuXG4gICAgXHRcdFx0XHRcdGJpbmRpbmdzWyBqIF0ucHVzaChcbiAgICBcdFx0XHRcdFx0XHRcdG5ldyBQcm9wZXJ0eUJpbmRpbmcoXG4gICAgXHRcdFx0XHRcdFx0XHRcdG9iamVjdCwgcGF0aHNbIGogXSwgcGFyc2VkUGF0aHNbIGogXSApICk7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH0gZWxzZSBpZiAoIGluZGV4IDwgbkNhY2hlZE9iamVjdHMgKSB7XG5cbiAgICBcdFx0XHRcdHZhciBrbm93bk9iamVjdCA9IG9iamVjdHNbIGluZGV4IF07XG5cbiAgICBcdFx0XHRcdC8vIG1vdmUgZXhpc3Rpbmcgb2JqZWN0IHRvIHRoZSBBQ1RJVkUgcmVnaW9uXG5cbiAgICBcdFx0XHRcdHZhciBmaXJzdEFjdGl2ZUluZGV4ID0gLS0gbkNhY2hlZE9iamVjdHMsXG4gICAgXHRcdFx0XHRcdGxhc3RDYWNoZWRPYmplY3QgPSBvYmplY3RzWyBmaXJzdEFjdGl2ZUluZGV4IF07XG5cbiAgICBcdFx0XHRcdGluZGljZXNCeVVVSURbIGxhc3RDYWNoZWRPYmplY3QudXVpZCBdID0gaW5kZXg7XG4gICAgXHRcdFx0XHRvYmplY3RzWyBpbmRleCBdID0gbGFzdENhY2hlZE9iamVjdDtcblxuICAgIFx0XHRcdFx0aW5kaWNlc0J5VVVJRFsgdXVpZCBdID0gZmlyc3RBY3RpdmVJbmRleDtcbiAgICBcdFx0XHRcdG9iamVjdHNbIGZpcnN0QWN0aXZlSW5kZXggXSA9IG9iamVjdDtcblxuICAgIFx0XHRcdFx0Ly8gYWNjb3VudGluZyBpcyBkb25lLCBub3cgZG8gdGhlIHNhbWUgZm9yIGFsbCBiaW5kaW5nc1xuXG4gICAgXHRcdFx0XHRmb3IgKCB2YXIgaiA9IDAsIG0gPSBuQmluZGluZ3M7IGogIT09IG07ICsrIGogKSB7XG5cbiAgICBcdFx0XHRcdFx0dmFyIGJpbmRpbmdzRm9yUGF0aCA9IGJpbmRpbmdzWyBqIF0sXG4gICAgXHRcdFx0XHRcdFx0bGFzdENhY2hlZCA9IGJpbmRpbmdzRm9yUGF0aFsgZmlyc3RBY3RpdmVJbmRleCBdLFxuICAgIFx0XHRcdFx0XHRcdGJpbmRpbmcgPSBiaW5kaW5nc0ZvclBhdGhbIGluZGV4IF07XG5cbiAgICBcdFx0XHRcdFx0YmluZGluZ3NGb3JQYXRoWyBpbmRleCBdID0gbGFzdENhY2hlZDtcblxuICAgIFx0XHRcdFx0XHRpZiAoIGJpbmRpbmcgPT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0XHRcdC8vIHNpbmNlIHdlIGRvIG5vdCBib3RoZXIgdG8gY3JlYXRlIG5ldyBiaW5kaW5nc1xuICAgIFx0XHRcdFx0XHRcdC8vIGZvciBvYmplY3RzIHRoYXQgYXJlIGNhY2hlZCwgdGhlIGJpbmRpbmcgbWF5XG4gICAgXHRcdFx0XHRcdFx0Ly8gb3IgbWF5IG5vdCBleGlzdFxuXG4gICAgXHRcdFx0XHRcdFx0YmluZGluZyA9IG5ldyBQcm9wZXJ0eUJpbmRpbmcoXG4gICAgXHRcdFx0XHRcdFx0XHRcdG9iamVjdCwgcGF0aHNbIGogXSwgcGFyc2VkUGF0aHNbIGogXSApO1xuXG4gICAgXHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0XHRiaW5kaW5nc0ZvclBhdGhbIGZpcnN0QWN0aXZlSW5kZXggXSA9IGJpbmRpbmc7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH0gZWxzZSBpZiAoIG9iamVjdHNbIGluZGV4IF0gIT09IGtub3duT2JqZWN0KSB7XG5cbiAgICBcdFx0XHRcdGNvbnNvbGUuZXJyb3IoIFwiRGlmZmVyZW50IG9iamVjdHMgd2l0aCB0aGUgc2FtZSBVVUlEIFwiICtcbiAgICBcdFx0XHRcdFx0XHRcImRldGVjdGVkLiBDbGVhbiB0aGUgY2FjaGVzIG9yIHJlY3JlYXRlIHlvdXIgXCIgK1xuICAgIFx0XHRcdFx0XHRcdFwiaW5mcmFzdHJ1Y3R1cmUgd2hlbiByZWxvYWRpbmcgc2NlbmVzLi4uXCIgKTtcblxuICAgIFx0XHRcdH0gLy8gZWxzZSB0aGUgb2JqZWN0IGlzIGFscmVhZHkgd2hlcmUgd2Ugd2FudCBpdCB0byBiZVxuXG4gICAgXHRcdH0gLy8gZm9yIGFyZ3VtZW50c1xuXG4gICAgXHRcdHRoaXMubkNhY2hlZE9iamVjdHNfID0gbkNhY2hlZE9iamVjdHM7XG5cbiAgICBcdH0sXG5cbiAgICBcdHJlbW92ZTogZnVuY3Rpb24oIHZhcl9hcmdzICkge1xuXG4gICAgXHRcdHZhciBvYmplY3RzID0gdGhpcy5fb2JqZWN0cyxcbiAgICBcdFx0XHRuQ2FjaGVkT2JqZWN0cyA9IHRoaXMubkNhY2hlZE9iamVjdHNfLFxuICAgIFx0XHRcdGluZGljZXNCeVVVSUQgPSB0aGlzLl9pbmRpY2VzQnlVVUlELFxuICAgIFx0XHRcdGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3MsXG4gICAgXHRcdFx0bkJpbmRpbmdzID0gYmluZGluZ3MubGVuZ3RoO1xuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMCwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cbiAgICBcdFx0XHR2YXIgb2JqZWN0ID0gYXJndW1lbnRzWyBpIF0sXG4gICAgXHRcdFx0XHR1dWlkID0gb2JqZWN0LnV1aWQsXG4gICAgXHRcdFx0XHRpbmRleCA9IGluZGljZXNCeVVVSURbIHV1aWQgXTtcblxuICAgIFx0XHRcdGlmICggaW5kZXggIT09IHVuZGVmaW5lZCAmJiBpbmRleCA+PSBuQ2FjaGVkT2JqZWN0cyApIHtcblxuICAgIFx0XHRcdFx0Ly8gbW92ZSBleGlzdGluZyBvYmplY3QgaW50byB0aGUgQ0FDSEVEIHJlZ2lvblxuXG4gICAgXHRcdFx0XHR2YXIgbGFzdENhY2hlZEluZGV4ID0gbkNhY2hlZE9iamVjdHMgKyssXG4gICAgXHRcdFx0XHRcdGZpcnN0QWN0aXZlT2JqZWN0ID0gb2JqZWN0c1sgbGFzdENhY2hlZEluZGV4IF07XG5cbiAgICBcdFx0XHRcdGluZGljZXNCeVVVSURbIGZpcnN0QWN0aXZlT2JqZWN0LnV1aWQgXSA9IGluZGV4O1xuICAgIFx0XHRcdFx0b2JqZWN0c1sgaW5kZXggXSA9IGZpcnN0QWN0aXZlT2JqZWN0O1xuXG4gICAgXHRcdFx0XHRpbmRpY2VzQnlVVUlEWyB1dWlkIF0gPSBsYXN0Q2FjaGVkSW5kZXg7XG4gICAgXHRcdFx0XHRvYmplY3RzWyBsYXN0Q2FjaGVkSW5kZXggXSA9IG9iamVjdDtcblxuICAgIFx0XHRcdFx0Ly8gYWNjb3VudGluZyBpcyBkb25lLCBub3cgZG8gdGhlIHNhbWUgZm9yIGFsbCBiaW5kaW5nc1xuXG4gICAgXHRcdFx0XHRmb3IgKCB2YXIgaiA9IDAsIG0gPSBuQmluZGluZ3M7IGogIT09IG07ICsrIGogKSB7XG5cbiAgICBcdFx0XHRcdFx0dmFyIGJpbmRpbmdzRm9yUGF0aCA9IGJpbmRpbmdzWyBqIF0sXG4gICAgXHRcdFx0XHRcdFx0Zmlyc3RBY3RpdmUgPSBiaW5kaW5nc0ZvclBhdGhbIGxhc3RDYWNoZWRJbmRleCBdLFxuICAgIFx0XHRcdFx0XHRcdGJpbmRpbmcgPSBiaW5kaW5nc0ZvclBhdGhbIGluZGV4IF07XG5cbiAgICBcdFx0XHRcdFx0YmluZGluZ3NGb3JQYXRoWyBpbmRleCBdID0gZmlyc3RBY3RpdmU7XG4gICAgXHRcdFx0XHRcdGJpbmRpbmdzRm9yUGF0aFsgbGFzdENhY2hlZEluZGV4IF0gPSBiaW5kaW5nO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fSAvLyBmb3IgYXJndW1lbnRzXG5cbiAgICBcdFx0dGhpcy5uQ2FjaGVkT2JqZWN0c18gPSBuQ2FjaGVkT2JqZWN0cztcblxuICAgIFx0fSxcblxuICAgIFx0Ly8gcmVtb3ZlICYgZm9yZ2V0XG4gICAgXHR1bmNhY2hlOiBmdW5jdGlvbiggdmFyX2FyZ3MgKSB7XG5cbiAgICBcdFx0dmFyIG9iamVjdHMgPSB0aGlzLl9vYmplY3RzLFxuICAgIFx0XHRcdG5PYmplY3RzID0gb2JqZWN0cy5sZW5ndGgsXG4gICAgXHRcdFx0bkNhY2hlZE9iamVjdHMgPSB0aGlzLm5DYWNoZWRPYmplY3RzXyxcbiAgICBcdFx0XHRpbmRpY2VzQnlVVUlEID0gdGhpcy5faW5kaWNlc0J5VVVJRCxcbiAgICBcdFx0XHRiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzLFxuICAgIFx0XHRcdG5CaW5kaW5ncyA9IGJpbmRpbmdzLmxlbmd0aDtcblxuICAgIFx0XHRmb3IgKCB2YXIgaSA9IDAsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xuXG4gICAgXHRcdFx0dmFyIG9iamVjdCA9IGFyZ3VtZW50c1sgaSBdLFxuICAgIFx0XHRcdFx0dXVpZCA9IG9iamVjdC51dWlkLFxuICAgIFx0XHRcdFx0aW5kZXggPSBpbmRpY2VzQnlVVUlEWyB1dWlkIF07XG5cbiAgICBcdFx0XHRpZiAoIGluZGV4ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRcdGRlbGV0ZSBpbmRpY2VzQnlVVUlEWyB1dWlkIF07XG5cbiAgICBcdFx0XHRcdGlmICggaW5kZXggPCBuQ2FjaGVkT2JqZWN0cyApIHtcblxuICAgIFx0XHRcdFx0XHQvLyBvYmplY3QgaXMgY2FjaGVkLCBzaHJpbmsgdGhlIENBQ0hFRCByZWdpb25cblxuICAgIFx0XHRcdFx0XHR2YXIgZmlyc3RBY3RpdmVJbmRleCA9IC0tIG5DYWNoZWRPYmplY3RzLFxuICAgIFx0XHRcdFx0XHRcdGxhc3RDYWNoZWRPYmplY3QgPSBvYmplY3RzWyBmaXJzdEFjdGl2ZUluZGV4IF0sXG4gICAgXHRcdFx0XHRcdFx0bGFzdEluZGV4ID0gLS0gbk9iamVjdHMsXG4gICAgXHRcdFx0XHRcdFx0bGFzdE9iamVjdCA9IG9iamVjdHNbIGxhc3RJbmRleCBdO1xuXG4gICAgXHRcdFx0XHRcdC8vIGxhc3QgY2FjaGVkIG9iamVjdCB0YWtlcyB0aGlzIG9iamVjdCdzIHBsYWNlXG4gICAgXHRcdFx0XHRcdGluZGljZXNCeVVVSURbIGxhc3RDYWNoZWRPYmplY3QudXVpZCBdID0gaW5kZXg7XG4gICAgXHRcdFx0XHRcdG9iamVjdHNbIGluZGV4IF0gPSBsYXN0Q2FjaGVkT2JqZWN0O1xuXG4gICAgXHRcdFx0XHRcdC8vIGxhc3Qgb2JqZWN0IGdvZXMgdG8gdGhlIGFjdGl2YXRlZCBzbG90IGFuZCBwb3BcbiAgICBcdFx0XHRcdFx0aW5kaWNlc0J5VVVJRFsgbGFzdE9iamVjdC51dWlkIF0gPSBmaXJzdEFjdGl2ZUluZGV4O1xuICAgIFx0XHRcdFx0XHRvYmplY3RzWyBmaXJzdEFjdGl2ZUluZGV4IF0gPSBsYXN0T2JqZWN0O1xuICAgIFx0XHRcdFx0XHRvYmplY3RzLnBvcCgpO1xuXG4gICAgXHRcdFx0XHRcdC8vIGFjY291bnRpbmcgaXMgZG9uZSwgbm93IGRvIHRoZSBzYW1lIGZvciBhbGwgYmluZGluZ3NcblxuICAgIFx0XHRcdFx0XHRmb3IgKCB2YXIgaiA9IDAsIG0gPSBuQmluZGluZ3M7IGogIT09IG07ICsrIGogKSB7XG5cbiAgICBcdFx0XHRcdFx0XHR2YXIgYmluZGluZ3NGb3JQYXRoID0gYmluZGluZ3NbIGogXSxcbiAgICBcdFx0XHRcdFx0XHRcdGxhc3RDYWNoZWQgPSBiaW5kaW5nc0ZvclBhdGhbIGZpcnN0QWN0aXZlSW5kZXggXSxcbiAgICBcdFx0XHRcdFx0XHRcdGxhc3QgPSBiaW5kaW5nc0ZvclBhdGhbIGxhc3RJbmRleCBdO1xuXG4gICAgXHRcdFx0XHRcdFx0YmluZGluZ3NGb3JQYXRoWyBpbmRleCBdID0gbGFzdENhY2hlZDtcbiAgICBcdFx0XHRcdFx0XHRiaW5kaW5nc0ZvclBhdGhbIGZpcnN0QWN0aXZlSW5kZXggXSA9IGxhc3Q7XG4gICAgXHRcdFx0XHRcdFx0YmluZGluZ3NGb3JQYXRoLnBvcCgpO1xuXG4gICAgXHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0XHQvLyBvYmplY3QgaXMgYWN0aXZlLCBqdXN0IHN3YXAgd2l0aCB0aGUgbGFzdCBhbmQgcG9wXG5cbiAgICBcdFx0XHRcdFx0dmFyIGxhc3RJbmRleCA9IC0tIG5PYmplY3RzLFxuICAgIFx0XHRcdFx0XHRcdGxhc3RPYmplY3QgPSBvYmplY3RzWyBsYXN0SW5kZXggXTtcblxuICAgIFx0XHRcdFx0XHRpbmRpY2VzQnlVVUlEWyBsYXN0T2JqZWN0LnV1aWQgXSA9IGluZGV4O1xuICAgIFx0XHRcdFx0XHRvYmplY3RzWyBpbmRleCBdID0gbGFzdE9iamVjdDtcbiAgICBcdFx0XHRcdFx0b2JqZWN0cy5wb3AoKTtcblxuICAgIFx0XHRcdFx0XHQvLyBhY2NvdW50aW5nIGlzIGRvbmUsIG5vdyBkbyB0aGUgc2FtZSBmb3IgYWxsIGJpbmRpbmdzXG5cbiAgICBcdFx0XHRcdFx0Zm9yICggdmFyIGogPSAwLCBtID0gbkJpbmRpbmdzOyBqICE9PSBtOyArKyBqICkge1xuXG4gICAgXHRcdFx0XHRcdFx0dmFyIGJpbmRpbmdzRm9yUGF0aCA9IGJpbmRpbmdzWyBqIF07XG5cbiAgICBcdFx0XHRcdFx0XHRiaW5kaW5nc0ZvclBhdGhbIGluZGV4IF0gPSBiaW5kaW5nc0ZvclBhdGhbIGxhc3RJbmRleCBdO1xuICAgIFx0XHRcdFx0XHRcdGJpbmRpbmdzRm9yUGF0aC5wb3AoKTtcblxuICAgIFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdH0gLy8gY2FjaGVkIG9yIGFjdGl2ZVxuXG4gICAgXHRcdFx0fSAvLyBpZiBvYmplY3QgaXMga25vd25cblxuICAgIFx0XHR9IC8vIGZvciBhcmd1bWVudHNcblxuICAgIFx0XHR0aGlzLm5DYWNoZWRPYmplY3RzXyA9IG5DYWNoZWRPYmplY3RzO1xuXG4gICAgXHR9LFxuXG4gICAgXHQvLyBJbnRlcm5hbCBpbnRlcmZhY2UgdXNlZCBieSBiZWZyaWVuZGVkIFByb3BlcnR5QmluZGluZy5Db21wb3NpdGU6XG5cbiAgICBcdHN1YnNjcmliZV86IGZ1bmN0aW9uKCBwYXRoLCBwYXJzZWRQYXRoICkge1xuICAgIFx0XHQvLyByZXR1cm5zIGFuIGFycmF5IG9mIGJpbmRpbmdzIGZvciB0aGUgZ2l2ZW4gcGF0aCB0aGF0IGlzIGNoYW5nZWRcbiAgICBcdFx0Ly8gYWNjb3JkaW5nIHRvIHRoZSBjb250YWluZWQgb2JqZWN0cyBpbiB0aGUgZ3JvdXBcblxuICAgIFx0XHR2YXIgaW5kaWNlc0J5UGF0aCA9IHRoaXMuX2JpbmRpbmdzSW5kaWNlc0J5UGF0aCxcbiAgICBcdFx0XHRpbmRleCA9IGluZGljZXNCeVBhdGhbIHBhdGggXSxcbiAgICBcdFx0XHRiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzO1xuXG4gICAgXHRcdGlmICggaW5kZXggIT09IHVuZGVmaW5lZCApIHJldHVybiBiaW5kaW5nc1sgaW5kZXggXTtcblxuICAgIFx0XHR2YXIgcGF0aHMgPSB0aGlzLl9wYXRocyxcbiAgICBcdFx0XHRwYXJzZWRQYXRocyA9IHRoaXMuX3BhcnNlZFBhdGhzLFxuICAgIFx0XHRcdG9iamVjdHMgPSB0aGlzLl9vYmplY3RzLFxuICAgIFx0XHRcdG5PYmplY3RzID0gb2JqZWN0cy5sZW5ndGgsXG4gICAgXHRcdFx0bkNhY2hlZE9iamVjdHMgPSB0aGlzLm5DYWNoZWRPYmplY3RzXyxcbiAgICBcdFx0XHRiaW5kaW5nc0ZvclBhdGggPSBuZXcgQXJyYXkoIG5PYmplY3RzICk7XG5cbiAgICBcdFx0aW5kZXggPSBiaW5kaW5ncy5sZW5ndGg7XG5cbiAgICBcdFx0aW5kaWNlc0J5UGF0aFsgcGF0aCBdID0gaW5kZXg7XG5cbiAgICBcdFx0cGF0aHMucHVzaCggcGF0aCApO1xuICAgIFx0XHRwYXJzZWRQYXRocy5wdXNoKCBwYXJzZWRQYXRoICk7XG4gICAgXHRcdGJpbmRpbmdzLnB1c2goIGJpbmRpbmdzRm9yUGF0aCApO1xuXG4gICAgXHRcdGZvciAoIHZhciBpID0gbkNhY2hlZE9iamVjdHMsXG4gICAgXHRcdFx0XHRuID0gb2JqZWN0cy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cbiAgICBcdFx0XHR2YXIgb2JqZWN0ID0gb2JqZWN0c1sgaSBdO1xuXG4gICAgXHRcdFx0YmluZGluZ3NGb3JQYXRoWyBpIF0gPVxuICAgIFx0XHRcdFx0XHRuZXcgUHJvcGVydHlCaW5kaW5nKCBvYmplY3QsIHBhdGgsIHBhcnNlZFBhdGggKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIGJpbmRpbmdzRm9yUGF0aDtcblxuICAgIFx0fSxcblxuICAgIFx0dW5zdWJzY3JpYmVfOiBmdW5jdGlvbiggcGF0aCApIHtcbiAgICBcdFx0Ly8gdGVsbHMgdGhlIGdyb3VwIHRvIGZvcmdldCBhYm91dCBhIHByb3BlcnR5IHBhdGggYW5kIG5vIGxvbmdlclxuICAgIFx0XHQvLyB1cGRhdGUgdGhlIGFycmF5IHByZXZpb3VzbHkgb2J0YWluZWQgd2l0aCAnc3Vic2NyaWJlXydcblxuICAgIFx0XHR2YXIgaW5kaWNlc0J5UGF0aCA9IHRoaXMuX2JpbmRpbmdzSW5kaWNlc0J5UGF0aCxcbiAgICBcdFx0XHRpbmRleCA9IGluZGljZXNCeVBhdGhbIHBhdGggXTtcblxuICAgIFx0XHRpZiAoIGluZGV4ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHR2YXIgcGF0aHMgPSB0aGlzLl9wYXRocyxcbiAgICBcdFx0XHRcdHBhcnNlZFBhdGhzID0gdGhpcy5fcGFyc2VkUGF0aHMsXG4gICAgXHRcdFx0XHRiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzLFxuICAgIFx0XHRcdFx0bGFzdEJpbmRpbmdzSW5kZXggPSBiaW5kaW5ncy5sZW5ndGggLSAxLFxuICAgIFx0XHRcdFx0bGFzdEJpbmRpbmdzID0gYmluZGluZ3NbIGxhc3RCaW5kaW5nc0luZGV4IF0sXG4gICAgXHRcdFx0XHRsYXN0QmluZGluZ3NQYXRoID0gcGF0aFsgbGFzdEJpbmRpbmdzSW5kZXggXTtcblxuICAgIFx0XHRcdGluZGljZXNCeVBhdGhbIGxhc3RCaW5kaW5nc1BhdGggXSA9IGluZGV4O1xuXG4gICAgXHRcdFx0YmluZGluZ3NbIGluZGV4IF0gPSBsYXN0QmluZGluZ3M7XG4gICAgXHRcdFx0YmluZGluZ3MucG9wKCk7XG5cbiAgICBcdFx0XHRwYXJzZWRQYXRoc1sgaW5kZXggXSA9IHBhcnNlZFBhdGhzWyBsYXN0QmluZGluZ3NJbmRleCBdO1xuICAgIFx0XHRcdHBhcnNlZFBhdGhzLnBvcCgpO1xuXG4gICAgXHRcdFx0cGF0aHNbIGluZGV4IF0gPSBwYXRoc1sgbGFzdEJpbmRpbmdzSW5kZXggXTtcbiAgICBcdFx0XHRwYXRocy5wb3AoKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdH1cblxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEFjdGlvbiBwcm92aWRlZCBieSBBbmltYXRpb25NaXhlciBmb3Igc2NoZWR1bGluZyBjbGlwIHBsYXliYWNrIG9uIHNwZWNpZmljXG4gICAgICogb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgQmVuIEhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW8vXG4gICAgICogQGF1dGhvciBEYXZpZCBTYXJubyAvIGh0dHA6Ly9saWdodGhhdXMudXMvXG4gICAgICogQGF1dGhvciB0c2Nod1xuICAgICAqXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBBbmltYXRpb25BY3Rpb24oIG1peGVyLCBjbGlwLCBsb2NhbFJvb3QgKSB7XG5cbiAgICBcdHRoaXMuX21peGVyID0gbWl4ZXI7XG4gICAgXHR0aGlzLl9jbGlwID0gY2xpcDtcbiAgICBcdHRoaXMuX2xvY2FsUm9vdCA9IGxvY2FsUm9vdCB8fCBudWxsO1xuXG4gICAgXHR2YXIgdHJhY2tzID0gY2xpcC50cmFja3MsXG4gICAgXHRcdG5UcmFja3MgPSB0cmFja3MubGVuZ3RoLFxuICAgIFx0XHRpbnRlcnBvbGFudHMgPSBuZXcgQXJyYXkoIG5UcmFja3MgKTtcblxuICAgIFx0dmFyIGludGVycG9sYW50U2V0dGluZ3MgPSB7XG4gICAgXHRcdFx0ZW5kaW5nU3RhcnQ6IFx0WmVyb0N1cnZhdHVyZUVuZGluZyxcbiAgICBcdFx0XHRlbmRpbmdFbmQ6XHRcdFplcm9DdXJ2YXR1cmVFbmRpbmdcbiAgICBcdH07XG5cbiAgICBcdGZvciAoIHZhciBpID0gMDsgaSAhPT0gblRyYWNrczsgKysgaSApIHtcblxuICAgIFx0XHR2YXIgaW50ZXJwb2xhbnQgPSB0cmFja3NbIGkgXS5jcmVhdGVJbnRlcnBvbGFudCggbnVsbCApO1xuICAgIFx0XHRpbnRlcnBvbGFudHNbIGkgXSA9IGludGVycG9sYW50O1xuICAgIFx0XHRpbnRlcnBvbGFudC5zZXR0aW5ncyA9IGludGVycG9sYW50U2V0dGluZ3M7XG5cbiAgICBcdH1cblxuICAgIFx0dGhpcy5faW50ZXJwb2xhbnRTZXR0aW5ncyA9IGludGVycG9sYW50U2V0dGluZ3M7XG5cbiAgICBcdHRoaXMuX2ludGVycG9sYW50cyA9IGludGVycG9sYW50cztcdC8vIGJvdW5kIGJ5IHRoZSBtaXhlclxuXG4gICAgXHQvLyBpbnNpZGU6IFByb3BlcnR5TWl4ZXIgKG1hbmFnZWQgYnkgdGhlIG1peGVyKVxuICAgIFx0dGhpcy5fcHJvcGVydHlCaW5kaW5ncyA9IG5ldyBBcnJheSggblRyYWNrcyApO1xuXG4gICAgXHR0aGlzLl9jYWNoZUluZGV4ID0gbnVsbDtcdFx0XHQvLyBmb3IgdGhlIG1lbW9yeSBtYW5hZ2VyXG4gICAgXHR0aGlzLl9ieUNsaXBDYWNoZUluZGV4ID0gbnVsbDtcdFx0Ly8gZm9yIHRoZSBtZW1vcnkgbWFuYWdlclxuXG4gICAgXHR0aGlzLl90aW1lU2NhbGVJbnRlcnBvbGFudCA9IG51bGw7XG4gICAgXHR0aGlzLl93ZWlnaHRJbnRlcnBvbGFudCA9IG51bGw7XG5cbiAgICBcdHRoaXMubG9vcCA9IExvb3BSZXBlYXQ7XG4gICAgXHR0aGlzLl9sb29wQ291bnQgPSAtMTtcblxuICAgIFx0Ly8gZ2xvYmFsIG1peGVyIHRpbWUgd2hlbiB0aGUgYWN0aW9uIGlzIHRvIGJlIHN0YXJ0ZWRcbiAgICBcdC8vIGl0J3Mgc2V0IGJhY2sgdG8gJ251bGwnIHVwb24gc3RhcnQgb2YgdGhlIGFjdGlvblxuICAgIFx0dGhpcy5fc3RhcnRUaW1lID0gbnVsbDtcblxuICAgIFx0Ly8gc2NhbGVkIGxvY2FsIHRpbWUgb2YgdGhlIGFjdGlvblxuICAgIFx0Ly8gZ2V0cyBjbGFtcGVkIG9yIHdyYXBwZWQgdG8gMC4uY2xpcC5kdXJhdGlvbiBhY2NvcmRpbmcgdG8gbG9vcFxuICAgIFx0dGhpcy50aW1lID0gMDtcblxuICAgIFx0dGhpcy50aW1lU2NhbGUgPSAxO1xuICAgIFx0dGhpcy5fZWZmZWN0aXZlVGltZVNjYWxlID0gMTtcblxuICAgIFx0dGhpcy53ZWlnaHQgPSAxO1xuICAgIFx0dGhpcy5fZWZmZWN0aXZlV2VpZ2h0ID0gMTtcblxuICAgIFx0dGhpcy5yZXBldGl0aW9ucyA9IEluZmluaXR5OyBcdFx0Ly8gbm8uIG9mIHJlcGV0aXRpb25zIHdoZW4gbG9vcGluZ1xuXG4gICAgXHR0aGlzLnBhdXNlZCA9IGZhbHNlO1x0XHRcdFx0Ly8gZmFsc2UgLT4gemVybyBlZmZlY3RpdmUgdGltZSBzY2FsZVxuICAgIFx0dGhpcy5lbmFibGVkID0gdHJ1ZTtcdFx0XHRcdC8vIHRydWUgLT4gemVybyBlZmZlY3RpdmUgd2VpZ2h0XG5cbiAgICBcdHRoaXMuY2xhbXBXaGVuRmluaXNoZWQgXHQ9IGZhbHNlO1x0Ly8ga2VlcCBmZWVkaW5nIHRoZSBsYXN0IGZyYW1lP1xuXG4gICAgXHR0aGlzLnplcm9TbG9wZUF0U3RhcnQgXHQ9IHRydWU7XHRcdC8vIGZvciBzbW9vdGggaW50ZXJwb2xhdGlvbiB3L28gc2VwYXJhdGVcbiAgICBcdHRoaXMuemVyb1Nsb3BlQXRFbmRcdFx0PSB0cnVlO1x0XHQvLyBjbGlwcyBmb3Igc3RhcnQsIGxvb3AgYW5kIGVuZFxuXG4gICAgfTtcblxuICAgIEFuaW1hdGlvbkFjdGlvbi5wcm90b3R5cGUgPSB7XG5cbiAgICBcdGNvbnN0cnVjdG9yOiBBbmltYXRpb25BY3Rpb24sXG5cbiAgICBcdC8vIFN0YXRlICYgU2NoZWR1bGluZ1xuXG4gICAgXHRwbGF5OiBmdW5jdGlvbigpIHtcblxuICAgIFx0XHR0aGlzLl9taXhlci5fYWN0aXZhdGVBY3Rpb24oIHRoaXMgKTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0c3RvcDogZnVuY3Rpb24oKSB7XG5cbiAgICBcdFx0dGhpcy5fbWl4ZXIuX2RlYWN0aXZhdGVBY3Rpb24oIHRoaXMgKTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcy5yZXNldCgpO1xuXG4gICAgXHR9LFxuXG4gICAgXHRyZXNldDogZnVuY3Rpb24oKSB7XG5cbiAgICBcdFx0dGhpcy5wYXVzZWQgPSBmYWxzZTtcbiAgICBcdFx0dGhpcy5lbmFibGVkID0gdHJ1ZTtcblxuICAgIFx0XHR0aGlzLnRpbWUgPSAwO1x0XHRcdC8vIHJlc3RhcnQgY2xpcFxuICAgIFx0XHR0aGlzLl9sb29wQ291bnQgPSAtMTtcdC8vIGZvcmdldCBwcmV2aW91cyBsb29wc1xuICAgIFx0XHR0aGlzLl9zdGFydFRpbWUgPSBudWxsO1x0Ly8gZm9yZ2V0IHNjaGVkdWxpbmdcblxuICAgIFx0XHRyZXR1cm4gdGhpcy5zdG9wRmFkaW5nKCkuc3RvcFdhcnBpbmcoKTtcblxuICAgIFx0fSxcblxuICAgIFx0aXNSdW5uaW5nOiBmdW5jdGlvbigpIHtcblxuICAgIFx0XHRyZXR1cm4gdGhpcy5lbmFibGVkICYmICEgdGhpcy5wYXVzZWQgJiYgdGhpcy50aW1lU2NhbGUgIT09IDAgJiZcbiAgICBcdFx0XHRcdHRoaXMuX3N0YXJ0VGltZSA9PT0gbnVsbCAmJiB0aGlzLl9taXhlci5faXNBY3RpdmVBY3Rpb24oIHRoaXMgKTtcblxuICAgIFx0fSxcblxuICAgIFx0Ly8gcmV0dXJuIHRydWUgd2hlbiBwbGF5IGhhcyBiZWVuIGNhbGxlZFxuICAgIFx0aXNTY2hlZHVsZWQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgXHRcdHJldHVybiB0aGlzLl9taXhlci5faXNBY3RpdmVBY3Rpb24oIHRoaXMgKTtcblxuICAgIFx0fSxcblxuICAgIFx0c3RhcnRBdDogZnVuY3Rpb24oIHRpbWUgKSB7XG5cbiAgICBcdFx0dGhpcy5fc3RhcnRUaW1lID0gdGltZTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0c2V0TG9vcDogZnVuY3Rpb24oIG1vZGUsIHJlcGV0aXRpb25zICkge1xuXG4gICAgXHRcdHRoaXMubG9vcCA9IG1vZGU7XG4gICAgXHRcdHRoaXMucmVwZXRpdGlvbnMgPSByZXBldGl0aW9ucztcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0Ly8gV2VpZ2h0XG5cbiAgICBcdC8vIHNldCB0aGUgd2VpZ2h0IHN0b3BwaW5nIGFueSBzY2hlZHVsZWQgZmFkaW5nXG4gICAgXHQvLyBhbHRob3VnaCAuZW5hYmxlZCA9IGZhbHNlIHlpZWxkcyBhbiBlZmZlY3RpdmUgd2VpZ2h0IG9mIHplcm8sIHRoaXNcbiAgICBcdC8vIG1ldGhvZCBkb2VzICpub3QqIGNoYW5nZSAuZW5hYmxlZCwgYmVjYXVzZSBpdCB3b3VsZCBiZSBjb25mdXNpbmdcbiAgICBcdHNldEVmZmVjdGl2ZVdlaWdodDogZnVuY3Rpb24oIHdlaWdodCApIHtcblxuICAgIFx0XHR0aGlzLndlaWdodCA9IHdlaWdodDtcblxuICAgIFx0XHQvLyBub3RlOiBzYW1lIGxvZ2ljIGFzIHdoZW4gdXBkYXRlZCBhdCBydW50aW1lXG4gICAgXHRcdHRoaXMuX2VmZmVjdGl2ZVdlaWdodCA9IHRoaXMuZW5hYmxlZCA/IHdlaWdodCA6IDA7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMuc3RvcEZhZGluZygpO1xuXG4gICAgXHR9LFxuXG4gICAgXHQvLyByZXR1cm4gdGhlIHdlaWdodCBjb25zaWRlcmluZyBmYWRpbmcgYW5kIC5lbmFibGVkXG4gICAgXHRnZXRFZmZlY3RpdmVXZWlnaHQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgXHRcdHJldHVybiB0aGlzLl9lZmZlY3RpdmVXZWlnaHQ7XG5cbiAgICBcdH0sXG5cbiAgICBcdGZhZGVJbjogZnVuY3Rpb24oIGR1cmF0aW9uICkge1xuXG4gICAgXHRcdHJldHVybiB0aGlzLl9zY2hlZHVsZUZhZGluZyggZHVyYXRpb24sIDAsIDEgKTtcblxuICAgIFx0fSxcblxuICAgIFx0ZmFkZU91dDogZnVuY3Rpb24oIGR1cmF0aW9uICkge1xuXG4gICAgXHRcdHJldHVybiB0aGlzLl9zY2hlZHVsZUZhZGluZyggZHVyYXRpb24sIDEsIDAgKTtcblxuICAgIFx0fSxcblxuICAgIFx0Y3Jvc3NGYWRlRnJvbTogZnVuY3Rpb24oIGZhZGVPdXRBY3Rpb24sIGR1cmF0aW9uLCB3YXJwICkge1xuXG4gICAgXHRcdGZhZGVPdXRBY3Rpb24uZmFkZU91dCggZHVyYXRpb24gKTtcbiAgICBcdFx0dGhpcy5mYWRlSW4oIGR1cmF0aW9uICk7XG5cbiAgICBcdFx0aWYoIHdhcnAgKSB7XG5cbiAgICBcdFx0XHR2YXIgZmFkZUluRHVyYXRpb24gPSB0aGlzLl9jbGlwLmR1cmF0aW9uLFxuICAgIFx0XHRcdFx0ZmFkZU91dER1cmF0aW9uID0gZmFkZU91dEFjdGlvbi5fY2xpcC5kdXJhdGlvbixcblxuICAgIFx0XHRcdFx0c3RhcnRFbmRSYXRpbyA9IGZhZGVPdXREdXJhdGlvbiAvIGZhZGVJbkR1cmF0aW9uLFxuICAgIFx0XHRcdFx0ZW5kU3RhcnRSYXRpbyA9IGZhZGVJbkR1cmF0aW9uIC8gZmFkZU91dER1cmF0aW9uO1xuXG4gICAgXHRcdFx0ZmFkZU91dEFjdGlvbi53YXJwKCAxLjAsIHN0YXJ0RW5kUmF0aW8sIGR1cmF0aW9uICk7XG4gICAgXHRcdFx0dGhpcy53YXJwKCBlbmRTdGFydFJhdGlvLCAxLjAsIGR1cmF0aW9uICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRjcm9zc0ZhZGVUbzogZnVuY3Rpb24oIGZhZGVJbkFjdGlvbiwgZHVyYXRpb24sIHdhcnAgKSB7XG5cbiAgICBcdFx0cmV0dXJuIGZhZGVJbkFjdGlvbi5jcm9zc0ZhZGVGcm9tKCB0aGlzLCBkdXJhdGlvbiwgd2FycCApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzdG9wRmFkaW5nOiBmdW5jdGlvbigpIHtcblxuICAgIFx0XHR2YXIgd2VpZ2h0SW50ZXJwb2xhbnQgPSB0aGlzLl93ZWlnaHRJbnRlcnBvbGFudDtcblxuICAgIFx0XHRpZiAoIHdlaWdodEludGVycG9sYW50ICE9PSBudWxsICkge1xuXG4gICAgXHRcdFx0dGhpcy5fd2VpZ2h0SW50ZXJwb2xhbnQgPSBudWxsO1xuICAgIFx0XHRcdHRoaXMuX21peGVyLl90YWtlQmFja0NvbnRyb2xJbnRlcnBvbGFudCggd2VpZ2h0SW50ZXJwb2xhbnQgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdC8vIFRpbWUgU2NhbGUgQ29udHJvbFxuXG4gICAgXHQvLyBzZXQgdGhlIHdlaWdodCBzdG9wcGluZyBhbnkgc2NoZWR1bGVkIHdhcnBpbmdcbiAgICBcdC8vIGFsdGhvdWdoIC5wYXVzZWQgPSB0cnVlIHlpZWxkcyBhbiBlZmZlY3RpdmUgdGltZSBzY2FsZSBvZiB6ZXJvLCB0aGlzXG4gICAgXHQvLyBtZXRob2QgZG9lcyAqbm90KiBjaGFuZ2UgLnBhdXNlZCwgYmVjYXVzZSBpdCB3b3VsZCBiZSBjb25mdXNpbmdcbiAgICBcdHNldEVmZmVjdGl2ZVRpbWVTY2FsZTogZnVuY3Rpb24oIHRpbWVTY2FsZSApIHtcblxuICAgIFx0XHR0aGlzLnRpbWVTY2FsZSA9IHRpbWVTY2FsZTtcbiAgICBcdFx0dGhpcy5fZWZmZWN0aXZlVGltZVNjYWxlID0gdGhpcy5wYXVzZWQgPyAwIDp0aW1lU2NhbGU7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMuc3RvcFdhcnBpbmcoKTtcblxuICAgIFx0fSxcblxuICAgIFx0Ly8gcmV0dXJuIHRoZSB0aW1lIHNjYWxlIGNvbnNpZGVyaW5nIHdhcnBpbmcgYW5kIC5wYXVzZWRcbiAgICBcdGdldEVmZmVjdGl2ZVRpbWVTY2FsZTogZnVuY3Rpb24oKSB7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMuX2VmZmVjdGl2ZVRpbWVTY2FsZTtcblxuICAgIFx0fSxcblxuICAgIFx0c2V0RHVyYXRpb246IGZ1bmN0aW9uKCBkdXJhdGlvbiApIHtcblxuICAgIFx0XHR0aGlzLnRpbWVTY2FsZSA9IHRoaXMuX2NsaXAuZHVyYXRpb24gLyBkdXJhdGlvbjtcblxuICAgIFx0XHRyZXR1cm4gdGhpcy5zdG9wV2FycGluZygpO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzeW5jV2l0aDogZnVuY3Rpb24oIGFjdGlvbiApIHtcblxuICAgIFx0XHR0aGlzLnRpbWUgPSBhY3Rpb24udGltZTtcbiAgICBcdFx0dGhpcy50aW1lU2NhbGUgPSBhY3Rpb24udGltZVNjYWxlO1xuXG4gICAgXHRcdHJldHVybiB0aGlzLnN0b3BXYXJwaW5nKCk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGhhbHQ6IGZ1bmN0aW9uKCBkdXJhdGlvbiApIHtcblxuICAgIFx0XHRyZXR1cm4gdGhpcy53YXJwKCB0aGlzLl9lZmZlY3RpdmVUaW1lU2NhbGUsIDAsIGR1cmF0aW9uICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdHdhcnA6IGZ1bmN0aW9uKCBzdGFydFRpbWVTY2FsZSwgZW5kVGltZVNjYWxlLCBkdXJhdGlvbiApIHtcblxuICAgIFx0XHR2YXIgbWl4ZXIgPSB0aGlzLl9taXhlciwgbm93ID0gbWl4ZXIudGltZSxcbiAgICBcdFx0XHRpbnRlcnBvbGFudCA9IHRoaXMuX3RpbWVTY2FsZUludGVycG9sYW50LFxuXG4gICAgXHRcdFx0dGltZVNjYWxlID0gdGhpcy50aW1lU2NhbGU7XG5cbiAgICBcdFx0aWYgKCBpbnRlcnBvbGFudCA9PT0gbnVsbCApIHtcblxuICAgIFx0XHRcdGludGVycG9sYW50ID0gbWl4ZXIuX2xlbmRDb250cm9sSW50ZXJwb2xhbnQoKSxcbiAgICBcdFx0XHR0aGlzLl90aW1lU2NhbGVJbnRlcnBvbGFudCA9IGludGVycG9sYW50O1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHR2YXIgdGltZXMgPSBpbnRlcnBvbGFudC5wYXJhbWV0ZXJQb3NpdGlvbnMsXG4gICAgXHRcdFx0dmFsdWVzID0gaW50ZXJwb2xhbnQuc2FtcGxlVmFsdWVzO1xuXG4gICAgXHRcdHRpbWVzWyAwIF0gPSBub3c7XG4gICAgXHRcdHRpbWVzWyAxIF0gPSBub3cgKyBkdXJhdGlvbjtcblxuICAgIFx0XHR2YWx1ZXNbIDAgXSA9IHN0YXJ0VGltZVNjYWxlIC8gdGltZVNjYWxlO1xuICAgIFx0XHR2YWx1ZXNbIDEgXSA9IGVuZFRpbWVTY2FsZSAvIHRpbWVTY2FsZTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0c3RvcFdhcnBpbmc6IGZ1bmN0aW9uKCkge1xuXG4gICAgXHRcdHZhciB0aW1lU2NhbGVJbnRlcnBvbGFudCA9IHRoaXMuX3RpbWVTY2FsZUludGVycG9sYW50O1xuXG4gICAgXHRcdGlmICggdGltZVNjYWxlSW50ZXJwb2xhbnQgIT09IG51bGwgKSB7XG5cbiAgICBcdFx0XHR0aGlzLl90aW1lU2NhbGVJbnRlcnBvbGFudCA9IG51bGw7XG4gICAgXHRcdFx0dGhpcy5fbWl4ZXIuX3Rha2VCYWNrQ29udHJvbEludGVycG9sYW50KCB0aW1lU2NhbGVJbnRlcnBvbGFudCApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0Ly8gT2JqZWN0IEFjY2Vzc29yc1xuXG4gICAgXHRnZXRNaXhlcjogZnVuY3Rpb24oKSB7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMuX21peGVyO1xuXG4gICAgXHR9LFxuXG4gICAgXHRnZXRDbGlwOiBmdW5jdGlvbigpIHtcblxuICAgIFx0XHRyZXR1cm4gdGhpcy5fY2xpcDtcblxuICAgIFx0fSxcblxuICAgIFx0Z2V0Um9vdDogZnVuY3Rpb24oKSB7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMuX2xvY2FsUm9vdCB8fCB0aGlzLl9taXhlci5fcm9vdDtcblxuICAgIFx0fSxcblxuICAgIFx0Ly8gSW50ZXJuYVxuXG4gICAgXHRfdXBkYXRlOiBmdW5jdGlvbiggdGltZSwgZGVsdGFUaW1lLCB0aW1lRGlyZWN0aW9uLCBhY2N1SW5kZXggKSB7XG4gICAgXHRcdC8vIGNhbGxlZCBieSB0aGUgbWl4ZXJcblxuICAgIFx0XHR2YXIgc3RhcnRUaW1lID0gdGhpcy5fc3RhcnRUaW1lO1xuXG4gICAgXHRcdGlmICggc3RhcnRUaW1lICE9PSBudWxsICkge1xuXG4gICAgXHRcdFx0Ly8gY2hlY2sgZm9yIHNjaGVkdWxlZCBzdGFydCBvZiBhY3Rpb25cblxuICAgIFx0XHRcdHZhciB0aW1lUnVubmluZyA9ICggdGltZSAtIHN0YXJ0VGltZSApICogdGltZURpcmVjdGlvbjtcbiAgICBcdFx0XHRpZiAoIHRpbWVSdW5uaW5nIDwgMCB8fCB0aW1lRGlyZWN0aW9uID09PSAwICkge1xuXG4gICAgXHRcdFx0XHRyZXR1cm47IC8vIHlldCB0byBjb21lIC8gZG9uJ3QgZGVjaWRlIHdoZW4gZGVsdGEgPSAwXG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHQvLyBzdGFydFxuXG4gICAgXHRcdFx0dGhpcy5fc3RhcnRUaW1lID0gbnVsbDsgLy8gdW5zY2hlZHVsZVxuICAgIFx0XHRcdGRlbHRhVGltZSA9IHRpbWVEaXJlY3Rpb24gKiB0aW1lUnVubmluZztcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0Ly8gYXBwbHkgdGltZSBzY2FsZSBhbmQgYWR2YW5jZSB0aW1lXG5cbiAgICBcdFx0ZGVsdGFUaW1lICo9IHRoaXMuX3VwZGF0ZVRpbWVTY2FsZSggdGltZSApO1xuICAgIFx0XHR2YXIgY2xpcFRpbWUgPSB0aGlzLl91cGRhdGVUaW1lKCBkZWx0YVRpbWUgKTtcblxuICAgIFx0XHQvLyBub3RlOiBfdXBkYXRlVGltZSBtYXkgZGlzYWJsZSB0aGUgYWN0aW9uIHJlc3VsdGluZyBpblxuICAgIFx0XHQvLyBhbiBlZmZlY3RpdmUgd2VpZ2h0IG9mIDBcblxuICAgIFx0XHR2YXIgd2VpZ2h0ID0gdGhpcy5fdXBkYXRlV2VpZ2h0KCB0aW1lICk7XG5cbiAgICBcdFx0aWYgKCB3ZWlnaHQgPiAwICkge1xuXG4gICAgXHRcdFx0dmFyIGludGVycG9sYW50cyA9IHRoaXMuX2ludGVycG9sYW50cztcbiAgICBcdFx0XHR2YXIgcHJvcGVydHlNaXhlcnMgPSB0aGlzLl9wcm9wZXJ0eUJpbmRpbmdzO1xuXG4gICAgXHRcdFx0Zm9yICggdmFyIGogPSAwLCBtID0gaW50ZXJwb2xhbnRzLmxlbmd0aDsgaiAhPT0gbTsgKysgaiApIHtcblxuICAgIFx0XHRcdFx0aW50ZXJwb2xhbnRzWyBqIF0uZXZhbHVhdGUoIGNsaXBUaW1lICk7XG4gICAgXHRcdFx0XHRwcm9wZXJ0eU1peGVyc1sgaiBdLmFjY3VtdWxhdGUoIGFjY3VJbmRleCwgd2VpZ2h0ICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9LFxuXG4gICAgXHRfdXBkYXRlV2VpZ2h0OiBmdW5jdGlvbiggdGltZSApIHtcblxuICAgIFx0XHR2YXIgd2VpZ2h0ID0gMDtcblxuICAgIFx0XHRpZiAoIHRoaXMuZW5hYmxlZCApIHtcblxuICAgIFx0XHRcdHdlaWdodCA9IHRoaXMud2VpZ2h0O1xuICAgIFx0XHRcdHZhciBpbnRlcnBvbGFudCA9IHRoaXMuX3dlaWdodEludGVycG9sYW50O1xuXG4gICAgXHRcdFx0aWYgKCBpbnRlcnBvbGFudCAhPT0gbnVsbCApIHtcblxuICAgIFx0XHRcdFx0dmFyIGludGVycG9sYW50VmFsdWUgPSBpbnRlcnBvbGFudC5ldmFsdWF0ZSggdGltZSApWyAwIF07XG5cbiAgICBcdFx0XHRcdHdlaWdodCAqPSBpbnRlcnBvbGFudFZhbHVlO1xuXG4gICAgXHRcdFx0XHRpZiAoIHRpbWUgPiBpbnRlcnBvbGFudC5wYXJhbWV0ZXJQb3NpdGlvbnNbIDEgXSApIHtcblxuICAgIFx0XHRcdFx0XHR0aGlzLnN0b3BGYWRpbmcoKTtcblxuICAgIFx0XHRcdFx0XHRpZiAoIGludGVycG9sYW50VmFsdWUgPT09IDAgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHQvLyBmYWRlZCBvdXQsIGRpc2FibGVcbiAgICBcdFx0XHRcdFx0XHR0aGlzLmVuYWJsZWQgPSBmYWxzZTtcblxuICAgIFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdFx0dGhpcy5fZWZmZWN0aXZlV2VpZ2h0ID0gd2VpZ2h0O1xuICAgIFx0XHRyZXR1cm4gd2VpZ2h0O1xuXG4gICAgXHR9LFxuXG4gICAgXHRfdXBkYXRlVGltZVNjYWxlOiBmdW5jdGlvbiggdGltZSApIHtcblxuICAgIFx0XHR2YXIgdGltZVNjYWxlID0gMDtcblxuICAgIFx0XHRpZiAoICEgdGhpcy5wYXVzZWQgKSB7XG5cbiAgICBcdFx0XHR0aW1lU2NhbGUgPSB0aGlzLnRpbWVTY2FsZTtcblxuICAgIFx0XHRcdHZhciBpbnRlcnBvbGFudCA9IHRoaXMuX3RpbWVTY2FsZUludGVycG9sYW50O1xuXG4gICAgXHRcdFx0aWYgKCBpbnRlcnBvbGFudCAhPT0gbnVsbCApIHtcblxuICAgIFx0XHRcdFx0dmFyIGludGVycG9sYW50VmFsdWUgPSBpbnRlcnBvbGFudC5ldmFsdWF0ZSggdGltZSApWyAwIF07XG5cbiAgICBcdFx0XHRcdHRpbWVTY2FsZSAqPSBpbnRlcnBvbGFudFZhbHVlO1xuXG4gICAgXHRcdFx0XHRpZiAoIHRpbWUgPiBpbnRlcnBvbGFudC5wYXJhbWV0ZXJQb3NpdGlvbnNbIDEgXSApIHtcblxuICAgIFx0XHRcdFx0XHR0aGlzLnN0b3BXYXJwaW5nKCk7XG5cbiAgICBcdFx0XHRcdFx0aWYgKCB0aW1lU2NhbGUgPT09IDAgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHQvLyBtb3Rpb24gaGFzIGhhbHRlZCwgcGF1c2VcbiAgICBcdFx0XHRcdFx0XHR0aGlzLnBhdXNlZCA9IHRydWU7XG5cbiAgICBcdFx0XHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0XHRcdC8vIHdhcnAgZG9uZSAtIGFwcGx5IGZpbmFsIHRpbWUgc2NhbGVcbiAgICBcdFx0XHRcdFx0XHR0aGlzLnRpbWVTY2FsZSA9IHRpbWVTY2FsZTtcblxuICAgIFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdFx0dGhpcy5fZWZmZWN0aXZlVGltZVNjYWxlID0gdGltZVNjYWxlO1xuICAgIFx0XHRyZXR1cm4gdGltZVNjYWxlO1xuXG4gICAgXHR9LFxuXG4gICAgXHRfdXBkYXRlVGltZTogZnVuY3Rpb24oIGRlbHRhVGltZSApIHtcblxuICAgIFx0XHR2YXIgdGltZSA9IHRoaXMudGltZSArIGRlbHRhVGltZTtcblxuICAgIFx0XHRpZiAoIGRlbHRhVGltZSA9PT0gMCApIHJldHVybiB0aW1lO1xuXG4gICAgXHRcdHZhciBkdXJhdGlvbiA9IHRoaXMuX2NsaXAuZHVyYXRpb24sXG5cbiAgICBcdFx0XHRsb29wID0gdGhpcy5sb29wLFxuICAgIFx0XHRcdGxvb3BDb3VudCA9IHRoaXMuX2xvb3BDb3VudDtcblxuICAgIFx0XHRpZiAoIGxvb3AgPT09IExvb3BPbmNlICkge1xuXG4gICAgXHRcdFx0aWYgKCBsb29wQ291bnQgPT09IC0xICkge1xuICAgIFx0XHRcdFx0Ly8ganVzdCBzdGFydGVkXG5cbiAgICBcdFx0XHRcdHRoaXMubG9vcENvdW50ID0gMDtcbiAgICBcdFx0XHRcdHRoaXMuX3NldEVuZGluZ3MoIHRydWUsIHRydWUsIGZhbHNlICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRoYW5kbGVfc3RvcDoge1xuXG4gICAgXHRcdFx0XHRpZiAoIHRpbWUgPj0gZHVyYXRpb24gKSB7XG5cbiAgICBcdFx0XHRcdFx0dGltZSA9IGR1cmF0aW9uO1xuXG4gICAgXHRcdFx0XHR9IGVsc2UgaWYgKCB0aW1lIDwgMCApIHtcblxuICAgIFx0XHRcdFx0XHR0aW1lID0gMDtcblxuICAgIFx0XHRcdFx0fSBlbHNlIGJyZWFrIGhhbmRsZV9zdG9wO1xuXG4gICAgXHRcdFx0XHRpZiAoIHRoaXMuY2xhbXBXaGVuRmluaXNoZWQgKSB0aGlzLnBhdXNlZCA9IHRydWU7XG4gICAgXHRcdFx0XHRlbHNlIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuXG4gICAgXHRcdFx0XHR0aGlzLl9taXhlci5kaXNwYXRjaEV2ZW50KCB7XG4gICAgXHRcdFx0XHRcdHR5cGU6ICdmaW5pc2hlZCcsIGFjdGlvbjogdGhpcyxcbiAgICBcdFx0XHRcdFx0ZGlyZWN0aW9uOiBkZWx0YVRpbWUgPCAwID8gLTEgOiAxXG4gICAgXHRcdFx0XHR9ICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fSBlbHNlIHsgLy8gcmVwZXRpdGl2ZSBSZXBlYXQgb3IgUGluZ1BvbmdcblxuICAgIFx0XHRcdHZhciBwaW5nUG9uZyA9ICggbG9vcCA9PT0gTG9vcFBpbmdQb25nICk7XG5cbiAgICBcdFx0XHRpZiAoIGxvb3BDb3VudCA9PT0gLTEgKSB7XG4gICAgXHRcdFx0XHQvLyBqdXN0IHN0YXJ0ZWRcblxuICAgIFx0XHRcdFx0aWYgKCBkZWx0YVRpbWUgPj0gMCApIHtcblxuICAgIFx0XHRcdFx0XHRsb29wQ291bnQgPSAwO1xuXG4gICAgXHRcdFx0XHRcdHRoaXMuX3NldEVuZGluZ3MoXG4gICAgXHRcdFx0XHRcdFx0XHR0cnVlLCB0aGlzLnJlcGV0aXRpb25zID09PSAwLCBwaW5nUG9uZyApO1xuXG4gICAgXHRcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRcdC8vIHdoZW4gbG9vcGluZyBpbiByZXZlcnNlIGRpcmVjdGlvbiwgdGhlIGluaXRpYWxcbiAgICBcdFx0XHRcdFx0Ly8gdHJhbnNpdGlvbiB0aHJvdWdoIHplcm8gY291bnRzIGFzIGEgcmVwZXRpdGlvbixcbiAgICBcdFx0XHRcdFx0Ly8gc28gbGVhdmUgbG9vcENvdW50IGF0IC0xXG5cbiAgICBcdFx0XHRcdFx0dGhpcy5fc2V0RW5kaW5ncyhcbiAgICBcdFx0XHRcdFx0XHRcdHRoaXMucmVwZXRpdGlvbnMgPT09IDAsIHRydWUsIHBpbmdQb25nICk7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGlmICggdGltZSA+PSBkdXJhdGlvbiB8fCB0aW1lIDwgMCApIHtcbiAgICBcdFx0XHRcdC8vIHdyYXAgYXJvdW5kXG5cbiAgICBcdFx0XHRcdHZhciBsb29wRGVsdGEgPSBNYXRoLmZsb29yKCB0aW1lIC8gZHVyYXRpb24gKTsgLy8gc2lnbmVkXG4gICAgXHRcdFx0XHR0aW1lIC09IGR1cmF0aW9uICogbG9vcERlbHRhO1xuXG4gICAgXHRcdFx0XHRsb29wQ291bnQgKz0gTWF0aC5hYnMoIGxvb3BEZWx0YSApO1xuXG4gICAgXHRcdFx0XHR2YXIgcGVuZGluZyA9IHRoaXMucmVwZXRpdGlvbnMgLSBsb29wQ291bnQ7XG5cbiAgICBcdFx0XHRcdGlmICggcGVuZGluZyA8IDAgKSB7XG4gICAgXHRcdFx0XHRcdC8vIGhhdmUgdG8gc3RvcCAoc3dpdGNoIHN0YXRlLCBjbGFtcCB0aW1lLCBmaXJlIGV2ZW50KVxuXG4gICAgXHRcdFx0XHRcdGlmICggdGhpcy5jbGFtcFdoZW5GaW5pc2hlZCApIHRoaXMucGF1c2VkID0gdHJ1ZTtcbiAgICBcdFx0XHRcdFx0ZWxzZSB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcblxuICAgIFx0XHRcdFx0XHR0aW1lID0gZGVsdGFUaW1lID4gMCA/IGR1cmF0aW9uIDogMDtcblxuICAgIFx0XHRcdFx0XHR0aGlzLl9taXhlci5kaXNwYXRjaEV2ZW50KCB7XG4gICAgXHRcdFx0XHRcdFx0dHlwZTogJ2ZpbmlzaGVkJywgYWN0aW9uOiB0aGlzLFxuICAgIFx0XHRcdFx0XHRcdGRpcmVjdGlvbjogZGVsdGFUaW1lID4gMCA/IDEgOiAtMVxuICAgIFx0XHRcdFx0XHR9ICk7XG5cbiAgICBcdFx0XHRcdH0gZWxzZSB7XG4gICAgXHRcdFx0XHRcdC8vIGtlZXAgcnVubmluZ1xuXG4gICAgXHRcdFx0XHRcdGlmICggcGVuZGluZyA9PT0gMCApIHtcbiAgICBcdFx0XHRcdFx0XHQvLyBlbnRlcmluZyB0aGUgbGFzdCByb3VuZFxuXG4gICAgXHRcdFx0XHRcdFx0dmFyIGF0U3RhcnQgPSBkZWx0YVRpbWUgPCAwO1xuICAgIFx0XHRcdFx0XHRcdHRoaXMuX3NldEVuZGluZ3MoIGF0U3RhcnQsICEgYXRTdGFydCwgcGluZ1BvbmcgKTtcblxuICAgIFx0XHRcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRcdFx0dGhpcy5fc2V0RW5kaW5ncyggZmFsc2UsIGZhbHNlLCBwaW5nUG9uZyApO1xuXG4gICAgXHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0XHR0aGlzLl9sb29wQ291bnQgPSBsb29wQ291bnQ7XG5cbiAgICBcdFx0XHRcdFx0dGhpcy5fbWl4ZXIuZGlzcGF0Y2hFdmVudCgge1xuICAgIFx0XHRcdFx0XHRcdHR5cGU6ICdsb29wJywgYWN0aW9uOiB0aGlzLCBsb29wRGVsdGE6IGxvb3BEZWx0YVxuICAgIFx0XHRcdFx0XHR9ICk7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGlmICggcGluZ1BvbmcgJiYgKCBsb29wQ291bnQgJiAxICkgPT09IDEgKSB7XG4gICAgXHRcdFx0XHQvLyBpbnZlcnQgdGltZSBmb3IgdGhlIFwicG9uZyByb3VuZFwiXG5cbiAgICBcdFx0XHRcdHRoaXMudGltZSA9IHRpbWU7XG4gICAgXHRcdFx0XHRyZXR1cm4gZHVyYXRpb24gLSB0aW1lO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHR0aGlzLnRpbWUgPSB0aW1lO1xuICAgIFx0XHRyZXR1cm4gdGltZTtcblxuICAgIFx0fSxcblxuICAgIFx0X3NldEVuZGluZ3M6IGZ1bmN0aW9uKCBhdFN0YXJ0LCBhdEVuZCwgcGluZ1BvbmcgKSB7XG5cbiAgICBcdFx0dmFyIHNldHRpbmdzID0gdGhpcy5faW50ZXJwb2xhbnRTZXR0aW5ncztcblxuICAgIFx0XHRpZiAoIHBpbmdQb25nICkge1xuXG4gICAgXHRcdFx0c2V0dGluZ3MuZW5kaW5nU3RhcnQgXHQ9IFplcm9TbG9wZUVuZGluZztcbiAgICBcdFx0XHRzZXR0aW5ncy5lbmRpbmdFbmRcdFx0PSBaZXJvU2xvcGVFbmRpbmc7XG5cbiAgICBcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdC8vIGFzc3VtaW5nIGZvciBMb29wT25jZSBhdFN0YXJ0ID09IGF0RW5kID09IHRydWVcblxuICAgIFx0XHRcdGlmICggYXRTdGFydCApIHtcblxuICAgIFx0XHRcdFx0c2V0dGluZ3MuZW5kaW5nU3RhcnQgPSB0aGlzLnplcm9TbG9wZUF0U3RhcnQgP1xuICAgIFx0XHRcdFx0XHRcdFplcm9TbG9wZUVuZGluZyA6IFplcm9DdXJ2YXR1cmVFbmRpbmc7XG5cbiAgICBcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRzZXR0aW5ncy5lbmRpbmdTdGFydCA9IFdyYXBBcm91bmRFbmRpbmc7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRpZiAoIGF0RW5kICkge1xuXG4gICAgXHRcdFx0XHRzZXR0aW5ncy5lbmRpbmdFbmQgPSB0aGlzLnplcm9TbG9wZUF0RW5kID9cbiAgICBcdFx0XHRcdFx0XHRaZXJvU2xvcGVFbmRpbmcgOiBaZXJvQ3VydmF0dXJlRW5kaW5nO1xuXG4gICAgXHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0c2V0dGluZ3MuZW5kaW5nRW5kIFx0ID0gV3JhcEFyb3VuZEVuZGluZztcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdH0sXG5cbiAgICBcdF9zY2hlZHVsZUZhZGluZzogZnVuY3Rpb24oIGR1cmF0aW9uLCB3ZWlnaHROb3csIHdlaWdodFRoZW4gKSB7XG5cbiAgICBcdFx0dmFyIG1peGVyID0gdGhpcy5fbWl4ZXIsIG5vdyA9IG1peGVyLnRpbWUsXG4gICAgXHRcdFx0aW50ZXJwb2xhbnQgPSB0aGlzLl93ZWlnaHRJbnRlcnBvbGFudDtcblxuICAgIFx0XHRpZiAoIGludGVycG9sYW50ID09PSBudWxsICkge1xuXG4gICAgXHRcdFx0aW50ZXJwb2xhbnQgPSBtaXhlci5fbGVuZENvbnRyb2xJbnRlcnBvbGFudCgpLFxuICAgIFx0XHRcdHRoaXMuX3dlaWdodEludGVycG9sYW50ID0gaW50ZXJwb2xhbnQ7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHZhciB0aW1lcyA9IGludGVycG9sYW50LnBhcmFtZXRlclBvc2l0aW9ucyxcbiAgICBcdFx0XHR2YWx1ZXMgPSBpbnRlcnBvbGFudC5zYW1wbGVWYWx1ZXM7XG5cbiAgICBcdFx0dGltZXNbIDAgXSA9IG5vdzsgXHRcdFx0XHR2YWx1ZXNbIDAgXSA9IHdlaWdodE5vdztcbiAgICBcdFx0dGltZXNbIDEgXSA9IG5vdyArIGR1cmF0aW9uO1x0dmFsdWVzWyAxIF0gPSB3ZWlnaHRUaGVuO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9XG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBQbGF5ZXIgZm9yIEFuaW1hdGlvbkNsaXBzLlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAYXV0aG9yIEJlbiBIb3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvL1xuICAgICAqIEBhdXRob3IgRGF2aWQgU2Fybm8gLyBodHRwOi8vbGlnaHRoYXVzLnVzL1xuICAgICAqIEBhdXRob3IgdHNjaHdcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIEFuaW1hdGlvbk1peGVyKCByb290ICkge1xuXG4gICAgXHR0aGlzLl9yb290ID0gcm9vdDtcbiAgICBcdHRoaXMuX2luaXRNZW1vcnlNYW5hZ2VyKCk7XG4gICAgXHR0aGlzLl9hY2N1SW5kZXggPSAwO1xuXG4gICAgXHR0aGlzLnRpbWUgPSAwO1xuXG4gICAgXHR0aGlzLnRpbWVTY2FsZSA9IDEuMDtcblxuICAgIH1cblxuICAgIE9iamVjdC5hc3NpZ24oIEFuaW1hdGlvbk1peGVyLnByb3RvdHlwZSwgRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZSwge1xuXG4gICAgXHQvLyByZXR1cm4gYW4gYWN0aW9uIGZvciBhIGNsaXAgb3B0aW9uYWxseSB1c2luZyBhIGN1c3RvbSByb290IHRhcmdldFxuICAgIFx0Ly8gb2JqZWN0ICh0aGlzIG1ldGhvZCBhbGxvY2F0ZXMgYSBsb3Qgb2YgZHluYW1pYyBtZW1vcnkgaW4gY2FzZSBhXG4gICAgXHQvLyBwcmV2aW91c2x5IHVua25vd24gY2xpcC9yb290IGNvbWJpbmF0aW9uIGlzIHNwZWNpZmllZClcbiAgICBcdGNsaXBBY3Rpb246IGZ1bmN0aW9uKCBjbGlwLCBvcHRpb25hbFJvb3QgKSB7XG5cbiAgICBcdFx0dmFyIHJvb3QgPSBvcHRpb25hbFJvb3QgfHwgdGhpcy5fcm9vdCxcbiAgICBcdFx0XHRyb290VXVpZCA9IHJvb3QudXVpZCxcblxuICAgIFx0XHRcdGNsaXBPYmplY3QgPSB0eXBlb2YgY2xpcCA9PT0gJ3N0cmluZycgP1xuICAgIFx0XHRcdFx0XHRBbmltYXRpb25DbGlwLmZpbmRCeU5hbWUoIHJvb3QsIGNsaXAgKSA6IGNsaXAsXG5cbiAgICBcdFx0XHRjbGlwVXVpZCA9IGNsaXBPYmplY3QgIT09IG51bGwgPyBjbGlwT2JqZWN0LnV1aWQgOiBjbGlwLFxuXG4gICAgXHRcdFx0YWN0aW9uc0ZvckNsaXAgPSB0aGlzLl9hY3Rpb25zQnlDbGlwWyBjbGlwVXVpZCBdLFxuICAgIFx0XHRcdHByb3RvdHlwZUFjdGlvbiA9IG51bGw7XG5cbiAgICBcdFx0aWYgKCBhY3Rpb25zRm9yQ2xpcCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0dmFyIGV4aXN0aW5nQWN0aW9uID1cbiAgICBcdFx0XHRcdFx0YWN0aW9uc0ZvckNsaXAuYWN0aW9uQnlSb290WyByb290VXVpZCBdO1xuXG4gICAgXHRcdFx0aWYgKCBleGlzdGluZ0FjdGlvbiAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0XHRyZXR1cm4gZXhpc3RpbmdBY3Rpb247XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHQvLyB3ZSBrbm93IHRoZSBjbGlwLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHBhcnNlIGFsbFxuICAgIFx0XHRcdC8vIHRoZSBiaW5kaW5ncyBhZ2FpbiBidXQgY2FuIGp1c3QgY29weVxuICAgIFx0XHRcdHByb3RvdHlwZUFjdGlvbiA9IGFjdGlvbnNGb3JDbGlwLmtub3duQWN0aW9uc1sgMCBdO1xuXG4gICAgXHRcdFx0Ly8gYWxzbywgdGFrZSB0aGUgY2xpcCBmcm9tIHRoZSBwcm90b3R5cGUgYWN0aW9uXG4gICAgXHRcdFx0aWYgKCBjbGlwT2JqZWN0ID09PSBudWxsIClcbiAgICBcdFx0XHRcdGNsaXBPYmplY3QgPSBwcm90b3R5cGVBY3Rpb24uX2NsaXA7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdC8vIGNsaXAgbXVzdCBiZSBrbm93biB3aGVuIHNwZWNpZmllZCB2aWEgc3RyaW5nXG4gICAgXHRcdGlmICggY2xpcE9iamVjdCA9PT0gbnVsbCApIHJldHVybiBudWxsO1xuXG4gICAgXHRcdC8vIGFsbG9jYXRlIGFsbCByZXNvdXJjZXMgcmVxdWlyZWQgdG8gcnVuIGl0XG4gICAgXHRcdHZhciBuZXdBY3Rpb24gPSBuZXcgQW5pbWF0aW9uQWN0aW9uKCB0aGlzLCBjbGlwT2JqZWN0LCBvcHRpb25hbFJvb3QgKTtcblxuICAgIFx0XHR0aGlzLl9iaW5kQWN0aW9uKCBuZXdBY3Rpb24sIHByb3RvdHlwZUFjdGlvbiApO1xuXG4gICAgXHRcdC8vIGFuZCBtYWtlIHRoZSBhY3Rpb24ga25vd24gdG8gdGhlIG1lbW9yeSBtYW5hZ2VyXG4gICAgXHRcdHRoaXMuX2FkZEluYWN0aXZlQWN0aW9uKCBuZXdBY3Rpb24sIGNsaXBVdWlkLCByb290VXVpZCApO1xuXG4gICAgXHRcdHJldHVybiBuZXdBY3Rpb247XG5cbiAgICBcdH0sXG5cbiAgICBcdC8vIGdldCBhbiBleGlzdGluZyBhY3Rpb25cbiAgICBcdGV4aXN0aW5nQWN0aW9uOiBmdW5jdGlvbiggY2xpcCwgb3B0aW9uYWxSb290ICkge1xuXG4gICAgXHRcdHZhciByb290ID0gb3B0aW9uYWxSb290IHx8IHRoaXMuX3Jvb3QsXG4gICAgXHRcdFx0cm9vdFV1aWQgPSByb290LnV1aWQsXG5cbiAgICBcdFx0XHRjbGlwT2JqZWN0ID0gdHlwZW9mIGNsaXAgPT09ICdzdHJpbmcnID9cbiAgICBcdFx0XHRcdFx0QW5pbWF0aW9uQ2xpcC5maW5kQnlOYW1lKCByb290LCBjbGlwICkgOiBjbGlwLFxuXG4gICAgXHRcdFx0Y2xpcFV1aWQgPSBjbGlwT2JqZWN0ID8gY2xpcE9iamVjdC51dWlkIDogY2xpcCxcblxuICAgIFx0XHRcdGFjdGlvbnNGb3JDbGlwID0gdGhpcy5fYWN0aW9uc0J5Q2xpcFsgY2xpcFV1aWQgXTtcblxuICAgIFx0XHRpZiAoIGFjdGlvbnNGb3JDbGlwICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRyZXR1cm4gYWN0aW9uc0ZvckNsaXAuYWN0aW9uQnlSb290WyByb290VXVpZCBdIHx8IG51bGw7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiBudWxsO1xuXG4gICAgXHR9LFxuXG4gICAgXHQvLyBkZWFjdGl2YXRlcyBhbGwgcHJldmlvdXNseSBzY2hlZHVsZWQgYWN0aW9uc1xuICAgIFx0c3RvcEFsbEFjdGlvbjogZnVuY3Rpb24oKSB7XG5cbiAgICBcdFx0dmFyIGFjdGlvbnMgPSB0aGlzLl9hY3Rpb25zLFxuICAgIFx0XHRcdG5BY3Rpb25zID0gdGhpcy5fbkFjdGl2ZUFjdGlvbnMsXG4gICAgXHRcdFx0YmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncyxcbiAgICBcdFx0XHRuQmluZGluZ3MgPSB0aGlzLl9uQWN0aXZlQmluZGluZ3M7XG5cbiAgICBcdFx0dGhpcy5fbkFjdGl2ZUFjdGlvbnMgPSAwO1xuICAgIFx0XHR0aGlzLl9uQWN0aXZlQmluZGluZ3MgPSAwO1xuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMDsgaSAhPT0gbkFjdGlvbnM7ICsrIGkgKSB7XG5cbiAgICBcdFx0XHRhY3Rpb25zWyBpIF0ucmVzZXQoKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0Zm9yICggdmFyIGkgPSAwOyBpICE9PSBuQmluZGluZ3M7ICsrIGkgKSB7XG5cbiAgICBcdFx0XHRiaW5kaW5nc1sgaSBdLnVzZUNvdW50ID0gMDtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdC8vIGFkdmFuY2UgdGhlIHRpbWUgYW5kIHVwZGF0ZSBhcHBseSB0aGUgYW5pbWF0aW9uXG4gICAgXHR1cGRhdGU6IGZ1bmN0aW9uKCBkZWx0YVRpbWUgKSB7XG5cbiAgICBcdFx0ZGVsdGFUaW1lICo9IHRoaXMudGltZVNjYWxlO1xuXG4gICAgXHRcdHZhciBhY3Rpb25zID0gdGhpcy5fYWN0aW9ucyxcbiAgICBcdFx0XHRuQWN0aW9ucyA9IHRoaXMuX25BY3RpdmVBY3Rpb25zLFxuXG4gICAgXHRcdFx0dGltZSA9IHRoaXMudGltZSArPSBkZWx0YVRpbWUsXG4gICAgXHRcdFx0dGltZURpcmVjdGlvbiA9IE1hdGguc2lnbiggZGVsdGFUaW1lICksXG5cbiAgICBcdFx0XHRhY2N1SW5kZXggPSB0aGlzLl9hY2N1SW5kZXggXj0gMTtcblxuICAgIFx0XHQvLyBydW4gYWN0aXZlIGFjdGlvbnNcblxuICAgIFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgIT09IG5BY3Rpb25zOyArKyBpICkge1xuXG4gICAgXHRcdFx0dmFyIGFjdGlvbiA9IGFjdGlvbnNbIGkgXTtcblxuICAgIFx0XHRcdGlmICggYWN0aW9uLmVuYWJsZWQgKSB7XG5cbiAgICBcdFx0XHRcdGFjdGlvbi5fdXBkYXRlKCB0aW1lLCBkZWx0YVRpbWUsIHRpbWVEaXJlY3Rpb24sIGFjY3VJbmRleCApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHQvLyB1cGRhdGUgc2NlbmUgZ3JhcGhcblxuICAgIFx0XHR2YXIgYmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncyxcbiAgICBcdFx0XHRuQmluZGluZ3MgPSB0aGlzLl9uQWN0aXZlQmluZGluZ3M7XG5cbiAgICBcdFx0Zm9yICggdmFyIGkgPSAwOyBpICE9PSBuQmluZGluZ3M7ICsrIGkgKSB7XG5cbiAgICBcdFx0XHRiaW5kaW5nc1sgaSBdLmFwcGx5KCBhY2N1SW5kZXggKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdC8vIHJldHVybiB0aGlzIG1peGVyJ3Mgcm9vdCB0YXJnZXQgb2JqZWN0XG4gICAgXHRnZXRSb290OiBmdW5jdGlvbigpIHtcblxuICAgIFx0XHRyZXR1cm4gdGhpcy5fcm9vdDtcblxuICAgIFx0fSxcblxuICAgIFx0Ly8gZnJlZSBhbGwgcmVzb3VyY2VzIHNwZWNpZmljIHRvIGEgcGFydGljdWxhciBjbGlwXG4gICAgXHR1bmNhY2hlQ2xpcDogZnVuY3Rpb24oIGNsaXAgKSB7XG5cbiAgICBcdFx0dmFyIGFjdGlvbnMgPSB0aGlzLl9hY3Rpb25zLFxuICAgIFx0XHRcdGNsaXBVdWlkID0gY2xpcC51dWlkLFxuICAgIFx0XHRcdGFjdGlvbnNCeUNsaXAgPSB0aGlzLl9hY3Rpb25zQnlDbGlwLFxuICAgIFx0XHRcdGFjdGlvbnNGb3JDbGlwID0gYWN0aW9uc0J5Q2xpcFsgY2xpcFV1aWQgXTtcblxuICAgIFx0XHRpZiAoIGFjdGlvbnNGb3JDbGlwICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHQvLyBub3RlOiBqdXN0IGNhbGxpbmcgX3JlbW92ZUluYWN0aXZlQWN0aW9uIHdvdWxkIG1lc3MgdXAgdGhlXG4gICAgXHRcdFx0Ly8gaXRlcmF0aW9uIHN0YXRlIGFuZCBhbHNvIHJlcXVpcmUgdXBkYXRpbmcgdGhlIHN0YXRlIHdlIGNhblxuICAgIFx0XHRcdC8vIGp1c3QgdGhyb3cgYXdheVxuXG4gICAgXHRcdFx0dmFyIGFjdGlvbnNUb1JlbW92ZSA9IGFjdGlvbnNGb3JDbGlwLmtub3duQWN0aW9ucztcblxuICAgIFx0XHRcdGZvciAoIHZhciBpID0gMCwgbiA9IGFjdGlvbnNUb1JlbW92ZS5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cbiAgICBcdFx0XHRcdHZhciBhY3Rpb24gPSBhY3Rpb25zVG9SZW1vdmVbIGkgXTtcblxuICAgIFx0XHRcdFx0dGhpcy5fZGVhY3RpdmF0ZUFjdGlvbiggYWN0aW9uICk7XG5cbiAgICBcdFx0XHRcdHZhciBjYWNoZUluZGV4ID0gYWN0aW9uLl9jYWNoZUluZGV4LFxuICAgIFx0XHRcdFx0XHRsYXN0SW5hY3RpdmVBY3Rpb24gPSBhY3Rpb25zWyBhY3Rpb25zLmxlbmd0aCAtIDEgXTtcblxuICAgIFx0XHRcdFx0YWN0aW9uLl9jYWNoZUluZGV4ID0gbnVsbDtcbiAgICBcdFx0XHRcdGFjdGlvbi5fYnlDbGlwQ2FjaGVJbmRleCA9IG51bGw7XG5cbiAgICBcdFx0XHRcdGxhc3RJbmFjdGl2ZUFjdGlvbi5fY2FjaGVJbmRleCA9IGNhY2hlSW5kZXg7XG4gICAgXHRcdFx0XHRhY3Rpb25zWyBjYWNoZUluZGV4IF0gPSBsYXN0SW5hY3RpdmVBY3Rpb247XG4gICAgXHRcdFx0XHRhY3Rpb25zLnBvcCgpO1xuXG4gICAgXHRcdFx0XHR0aGlzLl9yZW1vdmVJbmFjdGl2ZUJpbmRpbmdzRm9yQWN0aW9uKCBhY3Rpb24gKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGRlbGV0ZSBhY3Rpb25zQnlDbGlwWyBjbGlwVXVpZCBdO1xuXG4gICAgXHRcdH1cblxuICAgIFx0fSxcblxuICAgIFx0Ly8gZnJlZSBhbGwgcmVzb3VyY2VzIHNwZWNpZmljIHRvIGEgcGFydGljdWxhciByb290IHRhcmdldCBvYmplY3RcbiAgICBcdHVuY2FjaGVSb290OiBmdW5jdGlvbiggcm9vdCApIHtcblxuICAgIFx0XHR2YXIgcm9vdFV1aWQgPSByb290LnV1aWQsXG4gICAgXHRcdFx0YWN0aW9uc0J5Q2xpcCA9IHRoaXMuX2FjdGlvbnNCeUNsaXA7XG5cbiAgICBcdFx0Zm9yICggdmFyIGNsaXBVdWlkIGluIGFjdGlvbnNCeUNsaXAgKSB7XG5cbiAgICBcdFx0XHR2YXIgYWN0aW9uQnlSb290ID0gYWN0aW9uc0J5Q2xpcFsgY2xpcFV1aWQgXS5hY3Rpb25CeVJvb3QsXG4gICAgXHRcdFx0XHRhY3Rpb24gPSBhY3Rpb25CeVJvb3RbIHJvb3RVdWlkIF07XG5cbiAgICBcdFx0XHRpZiAoIGFjdGlvbiAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0XHR0aGlzLl9kZWFjdGl2YXRlQWN0aW9uKCBhY3Rpb24gKTtcbiAgICBcdFx0XHRcdHRoaXMuX3JlbW92ZUluYWN0aXZlQWN0aW9uKCBhY3Rpb24gKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdFx0dmFyIGJpbmRpbmdzQnlSb290ID0gdGhpcy5fYmluZGluZ3NCeVJvb3RBbmROYW1lLFxuICAgIFx0XHRcdGJpbmRpbmdCeU5hbWUgPSBiaW5kaW5nc0J5Um9vdFsgcm9vdFV1aWQgXTtcblxuICAgIFx0XHRpZiAoIGJpbmRpbmdCeU5hbWUgIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdGZvciAoIHZhciB0cmFja05hbWUgaW4gYmluZGluZ0J5TmFtZSApIHtcblxuICAgIFx0XHRcdFx0dmFyIGJpbmRpbmcgPSBiaW5kaW5nQnlOYW1lWyB0cmFja05hbWUgXTtcbiAgICBcdFx0XHRcdGJpbmRpbmcucmVzdG9yZU9yaWdpbmFsU3RhdGUoKTtcbiAgICBcdFx0XHRcdHRoaXMuX3JlbW92ZUluYWN0aXZlQmluZGluZyggYmluZGluZyApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0fSxcblxuICAgIFx0Ly8gcmVtb3ZlIGEgdGFyZ2V0ZWQgY2xpcCBmcm9tIHRoZSBjYWNoZVxuICAgIFx0dW5jYWNoZUFjdGlvbjogZnVuY3Rpb24oIGNsaXAsIG9wdGlvbmFsUm9vdCApIHtcblxuICAgIFx0XHR2YXIgYWN0aW9uID0gdGhpcy5leGlzdGluZ0FjdGlvbiggY2xpcCwgb3B0aW9uYWxSb290ICk7XG5cbiAgICBcdFx0aWYgKCBhY3Rpb24gIT09IG51bGwgKSB7XG5cbiAgICBcdFx0XHR0aGlzLl9kZWFjdGl2YXRlQWN0aW9uKCBhY3Rpb24gKTtcbiAgICBcdFx0XHR0aGlzLl9yZW1vdmVJbmFjdGl2ZUFjdGlvbiggYWN0aW9uICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9XG5cbiAgICB9ICk7XG5cbiAgICAvLyBJbXBsZW1lbnRhdGlvbiBkZXRhaWxzOlxuXG4gICAgT2JqZWN0LmFzc2lnbiggQW5pbWF0aW9uTWl4ZXIucHJvdG90eXBlLCB7XG5cbiAgICBcdF9iaW5kQWN0aW9uOiBmdW5jdGlvbiggYWN0aW9uLCBwcm90b3R5cGVBY3Rpb24gKSB7XG5cbiAgICBcdFx0dmFyIHJvb3QgPSBhY3Rpb24uX2xvY2FsUm9vdCB8fCB0aGlzLl9yb290LFxuICAgIFx0XHRcdHRyYWNrcyA9IGFjdGlvbi5fY2xpcC50cmFja3MsXG4gICAgXHRcdFx0blRyYWNrcyA9IHRyYWNrcy5sZW5ndGgsXG4gICAgXHRcdFx0YmluZGluZ3MgPSBhY3Rpb24uX3Byb3BlcnR5QmluZGluZ3MsXG4gICAgXHRcdFx0aW50ZXJwb2xhbnRzID0gYWN0aW9uLl9pbnRlcnBvbGFudHMsXG4gICAgXHRcdFx0cm9vdFV1aWQgPSByb290LnV1aWQsXG4gICAgXHRcdFx0YmluZGluZ3NCeVJvb3QgPSB0aGlzLl9iaW5kaW5nc0J5Um9vdEFuZE5hbWUsXG4gICAgXHRcdFx0YmluZGluZ3NCeU5hbWUgPSBiaW5kaW5nc0J5Um9vdFsgcm9vdFV1aWQgXTtcblxuICAgIFx0XHRpZiAoIGJpbmRpbmdzQnlOYW1lID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRiaW5kaW5nc0J5TmFtZSA9IHt9O1xuICAgIFx0XHRcdGJpbmRpbmdzQnlSb290WyByb290VXVpZCBdID0gYmluZGluZ3NCeU5hbWU7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMDsgaSAhPT0gblRyYWNrczsgKysgaSApIHtcblxuICAgIFx0XHRcdHZhciB0cmFjayA9IHRyYWNrc1sgaSBdLFxuICAgIFx0XHRcdFx0dHJhY2tOYW1lID0gdHJhY2submFtZSxcbiAgICBcdFx0XHRcdGJpbmRpbmcgPSBiaW5kaW5nc0J5TmFtZVsgdHJhY2tOYW1lIF07XG5cbiAgICBcdFx0XHRpZiAoIGJpbmRpbmcgIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0YmluZGluZ3NbIGkgXSA9IGJpbmRpbmc7XG5cbiAgICBcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRiaW5kaW5nID0gYmluZGluZ3NbIGkgXTtcblxuICAgIFx0XHRcdFx0aWYgKCBiaW5kaW5nICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRcdFx0Ly8gZXhpc3RpbmcgYmluZGluZywgbWFrZSBzdXJlIHRoZSBjYWNoZSBrbm93c1xuXG4gICAgXHRcdFx0XHRcdGlmICggYmluZGluZy5fY2FjaGVJbmRleCA9PT0gbnVsbCApIHtcblxuICAgIFx0XHRcdFx0XHRcdCsrIGJpbmRpbmcucmVmZXJlbmNlQ291bnQ7XG4gICAgXHRcdFx0XHRcdFx0dGhpcy5fYWRkSW5hY3RpdmVCaW5kaW5nKCBiaW5kaW5nLCByb290VXVpZCwgdHJhY2tOYW1lICk7XG5cbiAgICBcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRcdGNvbnRpbnVlO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdHZhciBwYXRoID0gcHJvdG90eXBlQWN0aW9uICYmIHByb3RvdHlwZUFjdGlvbi5cbiAgICBcdFx0XHRcdFx0XHRfcHJvcGVydHlCaW5kaW5nc1sgaSBdLmJpbmRpbmcucGFyc2VkUGF0aDtcblxuICAgIFx0XHRcdFx0YmluZGluZyA9IG5ldyBQcm9wZXJ0eU1peGVyKFxuICAgIFx0XHRcdFx0XHRcdFByb3BlcnR5QmluZGluZy5jcmVhdGUoIHJvb3QsIHRyYWNrTmFtZSwgcGF0aCApLFxuICAgIFx0XHRcdFx0XHRcdHRyYWNrLlZhbHVlVHlwZU5hbWUsIHRyYWNrLmdldFZhbHVlU2l6ZSgpICk7XG5cbiAgICBcdFx0XHRcdCsrIGJpbmRpbmcucmVmZXJlbmNlQ291bnQ7XG4gICAgXHRcdFx0XHR0aGlzLl9hZGRJbmFjdGl2ZUJpbmRpbmcoIGJpbmRpbmcsIHJvb3RVdWlkLCB0cmFja05hbWUgKTtcblxuICAgIFx0XHRcdFx0YmluZGluZ3NbIGkgXSA9IGJpbmRpbmc7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRpbnRlcnBvbGFudHNbIGkgXS5yZXN1bHRCdWZmZXIgPSBiaW5kaW5nLmJ1ZmZlcjtcblxuICAgIFx0XHR9XG5cbiAgICBcdH0sXG5cbiAgICBcdF9hY3RpdmF0ZUFjdGlvbjogZnVuY3Rpb24oIGFjdGlvbiApIHtcblxuICAgIFx0XHRpZiAoICEgdGhpcy5faXNBY3RpdmVBY3Rpb24oIGFjdGlvbiApICkge1xuXG4gICAgXHRcdFx0aWYgKCBhY3Rpb24uX2NhY2hlSW5kZXggPT09IG51bGwgKSB7XG5cbiAgICBcdFx0XHRcdC8vIHRoaXMgYWN0aW9uIGhhcyBiZWVuIGZvcmdvdHRlbiBieSB0aGUgY2FjaGUsIGJ1dCB0aGUgdXNlclxuICAgIFx0XHRcdFx0Ly8gYXBwZWFycyB0byBiZSBzdGlsbCB1c2luZyBpdCAtPiByZWJpbmRcblxuICAgIFx0XHRcdFx0dmFyIHJvb3RVdWlkID0gKCBhY3Rpb24uX2xvY2FsUm9vdCB8fCB0aGlzLl9yb290ICkudXVpZCxcbiAgICBcdFx0XHRcdFx0Y2xpcFV1aWQgPSBhY3Rpb24uX2NsaXAudXVpZCxcbiAgICBcdFx0XHRcdFx0YWN0aW9uc0ZvckNsaXAgPSB0aGlzLl9hY3Rpb25zQnlDbGlwWyBjbGlwVXVpZCBdO1xuXG4gICAgXHRcdFx0XHR0aGlzLl9iaW5kQWN0aW9uKCBhY3Rpb24sXG4gICAgXHRcdFx0XHRcdFx0YWN0aW9uc0ZvckNsaXAgJiYgYWN0aW9uc0ZvckNsaXAua25vd25BY3Rpb25zWyAwIF0gKTtcblxuICAgIFx0XHRcdFx0dGhpcy5fYWRkSW5hY3RpdmVBY3Rpb24oIGFjdGlvbiwgY2xpcFV1aWQsIHJvb3RVdWlkICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHR2YXIgYmluZGluZ3MgPSBhY3Rpb24uX3Byb3BlcnR5QmluZGluZ3M7XG5cbiAgICBcdFx0XHQvLyBpbmNyZW1lbnQgcmVmZXJlbmNlIGNvdW50cyAvIHNvcnQgb3V0IHN0YXRlXG4gICAgXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBuID0gYmluZGluZ3MubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xuXG4gICAgXHRcdFx0XHR2YXIgYmluZGluZyA9IGJpbmRpbmdzWyBpIF07XG5cbiAgICBcdFx0XHRcdGlmICggYmluZGluZy51c2VDb3VudCArKyA9PT0gMCApIHtcblxuICAgIFx0XHRcdFx0XHR0aGlzLl9sZW5kQmluZGluZyggYmluZGluZyApO1xuICAgIFx0XHRcdFx0XHRiaW5kaW5nLnNhdmVPcmlnaW5hbFN0YXRlKCk7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdHRoaXMuX2xlbmRBY3Rpb24oIGFjdGlvbiApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0fSxcblxuICAgIFx0X2RlYWN0aXZhdGVBY3Rpb246IGZ1bmN0aW9uKCBhY3Rpb24gKSB7XG5cbiAgICBcdFx0aWYgKCB0aGlzLl9pc0FjdGl2ZUFjdGlvbiggYWN0aW9uICkgKSB7XG5cbiAgICBcdFx0XHR2YXIgYmluZGluZ3MgPSBhY3Rpb24uX3Byb3BlcnR5QmluZGluZ3M7XG5cbiAgICBcdFx0XHQvLyBkZWNyZW1lbnQgcmVmZXJlbmNlIGNvdW50cyAvIHNvcnQgb3V0IHN0YXRlXG4gICAgXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBuID0gYmluZGluZ3MubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xuXG4gICAgXHRcdFx0XHR2YXIgYmluZGluZyA9IGJpbmRpbmdzWyBpIF07XG5cbiAgICBcdFx0XHRcdGlmICggLS0gYmluZGluZy51c2VDb3VudCA9PT0gMCApIHtcblxuICAgIFx0XHRcdFx0XHRiaW5kaW5nLnJlc3RvcmVPcmlnaW5hbFN0YXRlKCk7XG4gICAgXHRcdFx0XHRcdHRoaXMuX3Rha2VCYWNrQmluZGluZyggYmluZGluZyApO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHR0aGlzLl90YWtlQmFja0FjdGlvbiggYWN0aW9uICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9LFxuXG4gICAgXHQvLyBNZW1vcnkgbWFuYWdlclxuXG4gICAgXHRfaW5pdE1lbW9yeU1hbmFnZXI6IGZ1bmN0aW9uKCkge1xuXG4gICAgXHRcdHRoaXMuX2FjdGlvbnMgPSBbXTsgLy8gJ25BY3RpdmVBY3Rpb25zJyBmb2xsb3dlZCBieSBpbmFjdGl2ZSBvbmVzXG4gICAgXHRcdHRoaXMuX25BY3RpdmVBY3Rpb25zID0gMDtcblxuICAgIFx0XHR0aGlzLl9hY3Rpb25zQnlDbGlwID0ge307XG4gICAgXHRcdC8vIGluc2lkZTpcbiAgICBcdFx0Ly8ge1xuICAgIFx0XHQvLyBcdFx0a25vd25BY3Rpb25zOiBBcnJheTwgQW5pbWF0aW9uQWN0aW9uID5cdC0gdXNlZCBhcyBwcm90b3R5cGVzXG4gICAgXHRcdC8vIFx0XHRhY3Rpb25CeVJvb3Q6IEFuaW1hdGlvbkFjdGlvblx0XHRcdC0gbG9va3VwXG4gICAgXHRcdC8vIH1cblxuXG4gICAgXHRcdHRoaXMuX2JpbmRpbmdzID0gW107IC8vICduQWN0aXZlQmluZGluZ3MnIGZvbGxvd2VkIGJ5IGluYWN0aXZlIG9uZXNcbiAgICBcdFx0dGhpcy5fbkFjdGl2ZUJpbmRpbmdzID0gMDtcblxuICAgIFx0XHR0aGlzLl9iaW5kaW5nc0J5Um9vdEFuZE5hbWUgPSB7fTsgLy8gaW5zaWRlOiBNYXA8IG5hbWUsIFByb3BlcnR5TWl4ZXIgPlxuXG5cbiAgICBcdFx0dGhpcy5fY29udHJvbEludGVycG9sYW50cyA9IFtdOyAvLyBzYW1lIGdhbWUgYXMgYWJvdmVcbiAgICBcdFx0dGhpcy5fbkFjdGl2ZUNvbnRyb2xJbnRlcnBvbGFudHMgPSAwO1xuXG4gICAgXHRcdHZhciBzY29wZSA9IHRoaXM7XG5cbiAgICBcdFx0dGhpcy5zdGF0cyA9IHtcblxuICAgIFx0XHRcdGFjdGlvbnM6IHtcbiAgICBcdFx0XHRcdGdldCB0b3RhbCgpIHsgcmV0dXJuIHNjb3BlLl9hY3Rpb25zLmxlbmd0aDsgfSxcbiAgICBcdFx0XHRcdGdldCBpblVzZSgpIHsgcmV0dXJuIHNjb3BlLl9uQWN0aXZlQWN0aW9uczsgfVxuICAgIFx0XHRcdH0sXG4gICAgXHRcdFx0YmluZGluZ3M6IHtcbiAgICBcdFx0XHRcdGdldCB0b3RhbCgpIHsgcmV0dXJuIHNjb3BlLl9iaW5kaW5ncy5sZW5ndGg7IH0sXG4gICAgXHRcdFx0XHRnZXQgaW5Vc2UoKSB7IHJldHVybiBzY29wZS5fbkFjdGl2ZUJpbmRpbmdzOyB9XG4gICAgXHRcdFx0fSxcbiAgICBcdFx0XHRjb250cm9sSW50ZXJwb2xhbnRzOiB7XG4gICAgXHRcdFx0XHRnZXQgdG90YWwoKSB7IHJldHVybiBzY29wZS5fY29udHJvbEludGVycG9sYW50cy5sZW5ndGg7IH0sXG4gICAgXHRcdFx0XHRnZXQgaW5Vc2UoKSB7IHJldHVybiBzY29wZS5fbkFjdGl2ZUNvbnRyb2xJbnRlcnBvbGFudHM7IH1cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fTtcblxuICAgIFx0fSxcblxuICAgIFx0Ly8gTWVtb3J5IG1hbmFnZW1lbnQgZm9yIEFuaW1hdGlvbkFjdGlvbiBvYmplY3RzXG5cbiAgICBcdF9pc0FjdGl2ZUFjdGlvbjogZnVuY3Rpb24oIGFjdGlvbiApIHtcblxuICAgIFx0XHR2YXIgaW5kZXggPSBhY3Rpb24uX2NhY2hlSW5kZXg7XG4gICAgXHRcdHJldHVybiBpbmRleCAhPT0gbnVsbCAmJiBpbmRleCA8IHRoaXMuX25BY3RpdmVBY3Rpb25zO1xuXG4gICAgXHR9LFxuXG4gICAgXHRfYWRkSW5hY3RpdmVBY3Rpb246IGZ1bmN0aW9uKCBhY3Rpb24sIGNsaXBVdWlkLCByb290VXVpZCApIHtcblxuICAgIFx0XHR2YXIgYWN0aW9ucyA9IHRoaXMuX2FjdGlvbnMsXG4gICAgXHRcdFx0YWN0aW9uc0J5Q2xpcCA9IHRoaXMuX2FjdGlvbnNCeUNsaXAsXG4gICAgXHRcdFx0YWN0aW9uc0ZvckNsaXAgPSBhY3Rpb25zQnlDbGlwWyBjbGlwVXVpZCBdO1xuXG4gICAgXHRcdGlmICggYWN0aW9uc0ZvckNsaXAgPT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdGFjdGlvbnNGb3JDbGlwID0ge1xuXG4gICAgXHRcdFx0XHRrbm93bkFjdGlvbnM6IFsgYWN0aW9uIF0sXG4gICAgXHRcdFx0XHRhY3Rpb25CeVJvb3Q6IHt9XG5cbiAgICBcdFx0XHR9O1xuXG4gICAgXHRcdFx0YWN0aW9uLl9ieUNsaXBDYWNoZUluZGV4ID0gMDtcblxuICAgIFx0XHRcdGFjdGlvbnNCeUNsaXBbIGNsaXBVdWlkIF0gPSBhY3Rpb25zRm9yQ2xpcDtcblxuICAgIFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0dmFyIGtub3duQWN0aW9ucyA9IGFjdGlvbnNGb3JDbGlwLmtub3duQWN0aW9ucztcblxuICAgIFx0XHRcdGFjdGlvbi5fYnlDbGlwQ2FjaGVJbmRleCA9IGtub3duQWN0aW9ucy5sZW5ndGg7XG4gICAgXHRcdFx0a25vd25BY3Rpb25zLnB1c2goIGFjdGlvbiApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRhY3Rpb24uX2NhY2hlSW5kZXggPSBhY3Rpb25zLmxlbmd0aDtcbiAgICBcdFx0YWN0aW9ucy5wdXNoKCBhY3Rpb24gKTtcblxuICAgIFx0XHRhY3Rpb25zRm9yQ2xpcC5hY3Rpb25CeVJvb3RbIHJvb3RVdWlkIF0gPSBhY3Rpb247XG5cbiAgICBcdH0sXG5cbiAgICBcdF9yZW1vdmVJbmFjdGl2ZUFjdGlvbjogZnVuY3Rpb24oIGFjdGlvbiApIHtcblxuICAgIFx0XHR2YXIgYWN0aW9ucyA9IHRoaXMuX2FjdGlvbnMsXG4gICAgXHRcdFx0bGFzdEluYWN0aXZlQWN0aW9uID0gYWN0aW9uc1sgYWN0aW9ucy5sZW5ndGggLSAxIF0sXG4gICAgXHRcdFx0Y2FjaGVJbmRleCA9IGFjdGlvbi5fY2FjaGVJbmRleDtcblxuICAgIFx0XHRsYXN0SW5hY3RpdmVBY3Rpb24uX2NhY2hlSW5kZXggPSBjYWNoZUluZGV4O1xuICAgIFx0XHRhY3Rpb25zWyBjYWNoZUluZGV4IF0gPSBsYXN0SW5hY3RpdmVBY3Rpb247XG4gICAgXHRcdGFjdGlvbnMucG9wKCk7XG5cbiAgICBcdFx0YWN0aW9uLl9jYWNoZUluZGV4ID0gbnVsbDtcblxuXG4gICAgXHRcdHZhciBjbGlwVXVpZCA9IGFjdGlvbi5fY2xpcC51dWlkLFxuICAgIFx0XHRcdGFjdGlvbnNCeUNsaXAgPSB0aGlzLl9hY3Rpb25zQnlDbGlwLFxuICAgIFx0XHRcdGFjdGlvbnNGb3JDbGlwID0gYWN0aW9uc0J5Q2xpcFsgY2xpcFV1aWQgXSxcbiAgICBcdFx0XHRrbm93bkFjdGlvbnNGb3JDbGlwID0gYWN0aW9uc0ZvckNsaXAua25vd25BY3Rpb25zLFxuXG4gICAgXHRcdFx0bGFzdEtub3duQWN0aW9uID1cbiAgICBcdFx0XHRcdGtub3duQWN0aW9uc0ZvckNsaXBbIGtub3duQWN0aW9uc0ZvckNsaXAubGVuZ3RoIC0gMSBdLFxuXG4gICAgXHRcdFx0YnlDbGlwQ2FjaGVJbmRleCA9IGFjdGlvbi5fYnlDbGlwQ2FjaGVJbmRleDtcblxuICAgIFx0XHRsYXN0S25vd25BY3Rpb24uX2J5Q2xpcENhY2hlSW5kZXggPSBieUNsaXBDYWNoZUluZGV4O1xuICAgIFx0XHRrbm93bkFjdGlvbnNGb3JDbGlwWyBieUNsaXBDYWNoZUluZGV4IF0gPSBsYXN0S25vd25BY3Rpb247XG4gICAgXHRcdGtub3duQWN0aW9uc0ZvckNsaXAucG9wKCk7XG5cbiAgICBcdFx0YWN0aW9uLl9ieUNsaXBDYWNoZUluZGV4ID0gbnVsbDtcblxuXG4gICAgXHRcdHZhciBhY3Rpb25CeVJvb3QgPSBhY3Rpb25zRm9yQ2xpcC5hY3Rpb25CeVJvb3QsXG4gICAgXHRcdFx0cm9vdFV1aWQgPSAoIGFjdGlvbnMuX2xvY2FsUm9vdCB8fCB0aGlzLl9yb290ICkudXVpZDtcblxuICAgIFx0XHRkZWxldGUgYWN0aW9uQnlSb290WyByb290VXVpZCBdO1xuXG4gICAgXHRcdGlmICgga25vd25BY3Rpb25zRm9yQ2xpcC5sZW5ndGggPT09IDAgKSB7XG5cbiAgICBcdFx0XHRkZWxldGUgYWN0aW9uc0J5Q2xpcFsgY2xpcFV1aWQgXTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0dGhpcy5fcmVtb3ZlSW5hY3RpdmVCaW5kaW5nc0ZvckFjdGlvbiggYWN0aW9uICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdF9yZW1vdmVJbmFjdGl2ZUJpbmRpbmdzRm9yQWN0aW9uOiBmdW5jdGlvbiggYWN0aW9uICkge1xuXG4gICAgXHRcdHZhciBiaW5kaW5ncyA9IGFjdGlvbi5fcHJvcGVydHlCaW5kaW5ncztcbiAgICBcdFx0Zm9yICggdmFyIGkgPSAwLCBuID0gYmluZGluZ3MubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xuXG4gICAgXHRcdFx0dmFyIGJpbmRpbmcgPSBiaW5kaW5nc1sgaSBdO1xuXG4gICAgXHRcdFx0aWYgKCAtLSBiaW5kaW5nLnJlZmVyZW5jZUNvdW50ID09PSAwICkge1xuXG4gICAgXHRcdFx0XHR0aGlzLl9yZW1vdmVJbmFjdGl2ZUJpbmRpbmcoIGJpbmRpbmcgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdH0sXG5cbiAgICBcdF9sZW5kQWN0aW9uOiBmdW5jdGlvbiggYWN0aW9uICkge1xuXG4gICAgXHRcdC8vIFsgYWN0aXZlIGFjdGlvbnMgfCAgaW5hY3RpdmUgYWN0aW9ucyAgXVxuICAgIFx0XHQvLyBbICBhY3RpdmUgYWN0aW9ucyA+fCBpbmFjdGl2ZSBhY3Rpb25zIF1cbiAgICBcdFx0Ly8gICAgICAgICAgICAgICAgIHMgICAgICAgIGFcbiAgICBcdFx0Ly8gICAgICAgICAgICAgICAgICA8LXN3YXAtPlxuICAgIFx0XHQvLyAgICAgICAgICAgICAgICAgYSAgICAgICAgc1xuXG4gICAgXHRcdHZhciBhY3Rpb25zID0gdGhpcy5fYWN0aW9ucyxcbiAgICBcdFx0XHRwcmV2SW5kZXggPSBhY3Rpb24uX2NhY2hlSW5kZXgsXG5cbiAgICBcdFx0XHRsYXN0QWN0aXZlSW5kZXggPSB0aGlzLl9uQWN0aXZlQWN0aW9ucyArKyxcblxuICAgIFx0XHRcdGZpcnN0SW5hY3RpdmVBY3Rpb24gPSBhY3Rpb25zWyBsYXN0QWN0aXZlSW5kZXggXTtcblxuICAgIFx0XHRhY3Rpb24uX2NhY2hlSW5kZXggPSBsYXN0QWN0aXZlSW5kZXg7XG4gICAgXHRcdGFjdGlvbnNbIGxhc3RBY3RpdmVJbmRleCBdID0gYWN0aW9uO1xuXG4gICAgXHRcdGZpcnN0SW5hY3RpdmVBY3Rpb24uX2NhY2hlSW5kZXggPSBwcmV2SW5kZXg7XG4gICAgXHRcdGFjdGlvbnNbIHByZXZJbmRleCBdID0gZmlyc3RJbmFjdGl2ZUFjdGlvbjtcblxuICAgIFx0fSxcblxuICAgIFx0X3Rha2VCYWNrQWN0aW9uOiBmdW5jdGlvbiggYWN0aW9uICkge1xuXG4gICAgXHRcdC8vIFsgIGFjdGl2ZSBhY3Rpb25zICB8IGluYWN0aXZlIGFjdGlvbnMgXVxuICAgIFx0XHQvLyBbIGFjdGl2ZSBhY3Rpb25zIHw8IGluYWN0aXZlIGFjdGlvbnMgIF1cbiAgICBcdFx0Ly8gICAgICAgIGEgICAgICAgIHNcbiAgICBcdFx0Ly8gICAgICAgICA8LXN3YXAtPlxuICAgIFx0XHQvLyAgICAgICAgcyAgICAgICAgYVxuXG4gICAgXHRcdHZhciBhY3Rpb25zID0gdGhpcy5fYWN0aW9ucyxcbiAgICBcdFx0XHRwcmV2SW5kZXggPSBhY3Rpb24uX2NhY2hlSW5kZXgsXG5cbiAgICBcdFx0XHRmaXJzdEluYWN0aXZlSW5kZXggPSAtLSB0aGlzLl9uQWN0aXZlQWN0aW9ucyxcblxuICAgIFx0XHRcdGxhc3RBY3RpdmVBY3Rpb24gPSBhY3Rpb25zWyBmaXJzdEluYWN0aXZlSW5kZXggXTtcblxuICAgIFx0XHRhY3Rpb24uX2NhY2hlSW5kZXggPSBmaXJzdEluYWN0aXZlSW5kZXg7XG4gICAgXHRcdGFjdGlvbnNbIGZpcnN0SW5hY3RpdmVJbmRleCBdID0gYWN0aW9uO1xuXG4gICAgXHRcdGxhc3RBY3RpdmVBY3Rpb24uX2NhY2hlSW5kZXggPSBwcmV2SW5kZXg7XG4gICAgXHRcdGFjdGlvbnNbIHByZXZJbmRleCBdID0gbGFzdEFjdGl2ZUFjdGlvbjtcblxuICAgIFx0fSxcblxuICAgIFx0Ly8gTWVtb3J5IG1hbmFnZW1lbnQgZm9yIFByb3BlcnR5TWl4ZXIgb2JqZWN0c1xuXG4gICAgXHRfYWRkSW5hY3RpdmVCaW5kaW5nOiBmdW5jdGlvbiggYmluZGluZywgcm9vdFV1aWQsIHRyYWNrTmFtZSApIHtcblxuICAgIFx0XHR2YXIgYmluZGluZ3NCeVJvb3QgPSB0aGlzLl9iaW5kaW5nc0J5Um9vdEFuZE5hbWUsXG4gICAgXHRcdFx0YmluZGluZ0J5TmFtZSA9IGJpbmRpbmdzQnlSb290WyByb290VXVpZCBdLFxuXG4gICAgXHRcdFx0YmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncztcblxuICAgIFx0XHRpZiAoIGJpbmRpbmdCeU5hbWUgPT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdGJpbmRpbmdCeU5hbWUgPSB7fTtcbiAgICBcdFx0XHRiaW5kaW5nc0J5Um9vdFsgcm9vdFV1aWQgXSA9IGJpbmRpbmdCeU5hbWU7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGJpbmRpbmdCeU5hbWVbIHRyYWNrTmFtZSBdID0gYmluZGluZztcblxuICAgIFx0XHRiaW5kaW5nLl9jYWNoZUluZGV4ID0gYmluZGluZ3MubGVuZ3RoO1xuICAgIFx0XHRiaW5kaW5ncy5wdXNoKCBiaW5kaW5nICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdF9yZW1vdmVJbmFjdGl2ZUJpbmRpbmc6IGZ1bmN0aW9uKCBiaW5kaW5nICkge1xuXG4gICAgXHRcdHZhciBiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzLFxuICAgIFx0XHRcdHByb3BCaW5kaW5nID0gYmluZGluZy5iaW5kaW5nLFxuICAgIFx0XHRcdHJvb3RVdWlkID0gcHJvcEJpbmRpbmcucm9vdE5vZGUudXVpZCxcbiAgICBcdFx0XHR0cmFja05hbWUgPSBwcm9wQmluZGluZy5wYXRoLFxuICAgIFx0XHRcdGJpbmRpbmdzQnlSb290ID0gdGhpcy5fYmluZGluZ3NCeVJvb3RBbmROYW1lLFxuICAgIFx0XHRcdGJpbmRpbmdCeU5hbWUgPSBiaW5kaW5nc0J5Um9vdFsgcm9vdFV1aWQgXSxcblxuICAgIFx0XHRcdGxhc3RJbmFjdGl2ZUJpbmRpbmcgPSBiaW5kaW5nc1sgYmluZGluZ3MubGVuZ3RoIC0gMSBdLFxuICAgIFx0XHRcdGNhY2hlSW5kZXggPSBiaW5kaW5nLl9jYWNoZUluZGV4O1xuXG4gICAgXHRcdGxhc3RJbmFjdGl2ZUJpbmRpbmcuX2NhY2hlSW5kZXggPSBjYWNoZUluZGV4O1xuICAgIFx0XHRiaW5kaW5nc1sgY2FjaGVJbmRleCBdID0gbGFzdEluYWN0aXZlQmluZGluZztcbiAgICBcdFx0YmluZGluZ3MucG9wKCk7XG5cbiAgICBcdFx0ZGVsZXRlIGJpbmRpbmdCeU5hbWVbIHRyYWNrTmFtZSBdO1xuXG4gICAgXHRcdHJlbW92ZV9lbXB0eV9tYXA6IHtcblxuICAgIFx0XHRcdGZvciAoIHZhciBfIGluIGJpbmRpbmdCeU5hbWUgKSBicmVhayByZW1vdmVfZW1wdHlfbWFwO1xuXG4gICAgXHRcdFx0ZGVsZXRlIGJpbmRpbmdzQnlSb290WyByb290VXVpZCBdO1xuXG4gICAgXHRcdH1cblxuICAgIFx0fSxcblxuICAgIFx0X2xlbmRCaW5kaW5nOiBmdW5jdGlvbiggYmluZGluZyApIHtcblxuICAgIFx0XHR2YXIgYmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncyxcbiAgICBcdFx0XHRwcmV2SW5kZXggPSBiaW5kaW5nLl9jYWNoZUluZGV4LFxuXG4gICAgXHRcdFx0bGFzdEFjdGl2ZUluZGV4ID0gdGhpcy5fbkFjdGl2ZUJpbmRpbmdzICsrLFxuXG4gICAgXHRcdFx0Zmlyc3RJbmFjdGl2ZUJpbmRpbmcgPSBiaW5kaW5nc1sgbGFzdEFjdGl2ZUluZGV4IF07XG5cbiAgICBcdFx0YmluZGluZy5fY2FjaGVJbmRleCA9IGxhc3RBY3RpdmVJbmRleDtcbiAgICBcdFx0YmluZGluZ3NbIGxhc3RBY3RpdmVJbmRleCBdID0gYmluZGluZztcblxuICAgIFx0XHRmaXJzdEluYWN0aXZlQmluZGluZy5fY2FjaGVJbmRleCA9IHByZXZJbmRleDtcbiAgICBcdFx0YmluZGluZ3NbIHByZXZJbmRleCBdID0gZmlyc3RJbmFjdGl2ZUJpbmRpbmc7XG5cbiAgICBcdH0sXG5cbiAgICBcdF90YWtlQmFja0JpbmRpbmc6IGZ1bmN0aW9uKCBiaW5kaW5nICkge1xuXG4gICAgXHRcdHZhciBiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzLFxuICAgIFx0XHRcdHByZXZJbmRleCA9IGJpbmRpbmcuX2NhY2hlSW5kZXgsXG5cbiAgICBcdFx0XHRmaXJzdEluYWN0aXZlSW5kZXggPSAtLSB0aGlzLl9uQWN0aXZlQmluZGluZ3MsXG5cbiAgICBcdFx0XHRsYXN0QWN0aXZlQmluZGluZyA9IGJpbmRpbmdzWyBmaXJzdEluYWN0aXZlSW5kZXggXTtcblxuICAgIFx0XHRiaW5kaW5nLl9jYWNoZUluZGV4ID0gZmlyc3RJbmFjdGl2ZUluZGV4O1xuICAgIFx0XHRiaW5kaW5nc1sgZmlyc3RJbmFjdGl2ZUluZGV4IF0gPSBiaW5kaW5nO1xuXG4gICAgXHRcdGxhc3RBY3RpdmVCaW5kaW5nLl9jYWNoZUluZGV4ID0gcHJldkluZGV4O1xuICAgIFx0XHRiaW5kaW5nc1sgcHJldkluZGV4IF0gPSBsYXN0QWN0aXZlQmluZGluZztcblxuICAgIFx0fSxcblxuXG4gICAgXHQvLyBNZW1vcnkgbWFuYWdlbWVudCBvZiBJbnRlcnBvbGFudHMgZm9yIHdlaWdodCBhbmQgdGltZSBzY2FsZVxuXG4gICAgXHRfbGVuZENvbnRyb2xJbnRlcnBvbGFudDogZnVuY3Rpb24oKSB7XG5cbiAgICBcdFx0dmFyIGludGVycG9sYW50cyA9IHRoaXMuX2NvbnRyb2xJbnRlcnBvbGFudHMsXG4gICAgXHRcdFx0bGFzdEFjdGl2ZUluZGV4ID0gdGhpcy5fbkFjdGl2ZUNvbnRyb2xJbnRlcnBvbGFudHMgKyssXG4gICAgXHRcdFx0aW50ZXJwb2xhbnQgPSBpbnRlcnBvbGFudHNbIGxhc3RBY3RpdmVJbmRleCBdO1xuXG4gICAgXHRcdGlmICggaW50ZXJwb2xhbnQgPT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdGludGVycG9sYW50ID0gbmV3IExpbmVhckludGVycG9sYW50KFxuICAgIFx0XHRcdFx0XHRuZXcgRmxvYXQzMkFycmF5KCAyICksIG5ldyBGbG9hdDMyQXJyYXkoIDIgKSxcbiAgICBcdFx0XHRcdFx0XHQxLCB0aGlzLl9jb250cm9sSW50ZXJwb2xhbnRzUmVzdWx0QnVmZmVyICk7XG5cbiAgICBcdFx0XHRpbnRlcnBvbGFudC5fX2NhY2hlSW5kZXggPSBsYXN0QWN0aXZlSW5kZXg7XG4gICAgXHRcdFx0aW50ZXJwb2xhbnRzWyBsYXN0QWN0aXZlSW5kZXggXSA9IGludGVycG9sYW50O1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gaW50ZXJwb2xhbnQ7XG5cbiAgICBcdH0sXG5cbiAgICBcdF90YWtlQmFja0NvbnRyb2xJbnRlcnBvbGFudDogZnVuY3Rpb24oIGludGVycG9sYW50ICkge1xuXG4gICAgXHRcdHZhciBpbnRlcnBvbGFudHMgPSB0aGlzLl9jb250cm9sSW50ZXJwb2xhbnRzLFxuICAgIFx0XHRcdHByZXZJbmRleCA9IGludGVycG9sYW50Ll9fY2FjaGVJbmRleCxcblxuICAgIFx0XHRcdGZpcnN0SW5hY3RpdmVJbmRleCA9IC0tIHRoaXMuX25BY3RpdmVDb250cm9sSW50ZXJwb2xhbnRzLFxuXG4gICAgXHRcdFx0bGFzdEFjdGl2ZUludGVycG9sYW50ID0gaW50ZXJwb2xhbnRzWyBmaXJzdEluYWN0aXZlSW5kZXggXTtcblxuICAgIFx0XHRpbnRlcnBvbGFudC5fX2NhY2hlSW5kZXggPSBmaXJzdEluYWN0aXZlSW5kZXg7XG4gICAgXHRcdGludGVycG9sYW50c1sgZmlyc3RJbmFjdGl2ZUluZGV4IF0gPSBpbnRlcnBvbGFudDtcblxuICAgIFx0XHRsYXN0QWN0aXZlSW50ZXJwb2xhbnQuX19jYWNoZUluZGV4ID0gcHJldkluZGV4O1xuICAgIFx0XHRpbnRlcnBvbGFudHNbIHByZXZJbmRleCBdID0gbGFzdEFjdGl2ZUludGVycG9sYW50O1xuXG4gICAgXHR9LFxuXG4gICAgXHRfY29udHJvbEludGVycG9sYW50c1Jlc3VsdEJ1ZmZlcjogbmV3IEZsb2F0MzJBcnJheSggMSApXG5cbiAgICB9ICk7XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gVW5pZm9ybSggdmFsdWUgKSB7XG5cbiAgICBcdGlmICggdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyApIHtcblxuICAgIFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Vbmlmb3JtOiBUeXBlIHBhcmFtZXRlciBpcyBubyBsb25nZXIgbmVlZGVkLicgKTtcbiAgICBcdFx0dmFsdWUgPSBhcmd1bWVudHNbIDEgXTtcblxuICAgIFx0fVxuXG4gICAgXHR0aGlzLnZhbHVlID0gdmFsdWU7XG5cbiAgICBcdHRoaXMuZHluYW1pYyA9IGZhbHNlO1xuXG4gICAgfVxuXG4gICAgVW5pZm9ybS5wcm90b3R5cGUgPSB7XG5cbiAgICBcdGNvbnN0cnVjdG9yOiBVbmlmb3JtLFxuXG4gICAgXHRvblVwZGF0ZTogZnVuY3Rpb24gKCBjYWxsYmFjayApIHtcblxuICAgIFx0XHR0aGlzLmR5bmFtaWMgPSB0cnVlO1xuICAgIFx0XHR0aGlzLm9uVXBkYXRlQ2FsbGJhY2sgPSBjYWxsYmFjaztcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fVxuXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgYmVuYWFkYW1zIC8gaHR0cHM6Ly90d2l0dGVyLmNvbS9iZW5fYV9hZGFtc1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkoKSB7XG5cbiAgICBcdEJ1ZmZlckdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuICAgIFx0dGhpcy50eXBlID0gJ0luc3RhbmNlZEJ1ZmZlckdlb21ldHJ5JztcbiAgICBcdHRoaXMubWF4SW5zdGFuY2VkQ291bnQgPSB1bmRlZmluZWQ7XG5cbiAgICB9XG5cbiAgICBJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcbiAgICBJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeTtcblxuICAgIEluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5pc0luc3RhbmNlZEJ1ZmZlckdlb21ldHJ5ID0gdHJ1ZTtcblxuICAgIEluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5hZGRHcm91cCA9IGZ1bmN0aW9uICggc3RhcnQsIGNvdW50LCBpbnN0YW5jZXMgKSB7XG5cbiAgICBcdHRoaXMuZ3JvdXBzLnB1c2goIHtcblxuICAgIFx0XHRzdGFydDogc3RhcnQsXG4gICAgXHRcdGNvdW50OiBjb3VudCxcbiAgICBcdFx0aW5zdGFuY2VzOiBpbnN0YW5jZXNcblxuICAgIFx0fSApO1xuXG4gICAgfTtcblxuICAgIEluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cbiAgICBcdHZhciBpbmRleCA9IHNvdXJjZS5pbmRleDtcblxuICAgIFx0aWYgKCBpbmRleCAhPT0gbnVsbCApIHtcblxuICAgIFx0XHR0aGlzLnNldEluZGV4KCBpbmRleC5jbG9uZSgpICk7XG5cbiAgICBcdH1cblxuICAgIFx0dmFyIGF0dHJpYnV0ZXMgPSBzb3VyY2UuYXR0cmlidXRlcztcblxuICAgIFx0Zm9yICggdmFyIG5hbWUgaW4gYXR0cmlidXRlcyApIHtcblxuICAgIFx0XHR2YXIgYXR0cmlidXRlID0gYXR0cmlidXRlc1sgbmFtZSBdO1xuICAgIFx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggbmFtZSwgYXR0cmlidXRlLmNsb25lKCkgKTtcblxuICAgIFx0fVxuXG4gICAgXHR2YXIgZ3JvdXBzID0gc291cmNlLmdyb3VwcztcblxuICAgIFx0Zm9yICggdmFyIGkgPSAwLCBsID0gZ3JvdXBzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICBcdFx0dmFyIGdyb3VwID0gZ3JvdXBzWyBpIF07XG4gICAgXHRcdHRoaXMuYWRkR3JvdXAoIGdyb3VwLnN0YXJ0LCBncm91cC5jb3VudCwgZ3JvdXAuaW5zdGFuY2VzICk7XG5cbiAgICBcdH1cblxuICAgIFx0cmV0dXJuIHRoaXM7XG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBiZW5hYWRhbXMgLyBodHRwczovL3R3aXR0ZXIuY29tL2Jlbl9hX2FkYW1zXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSggaW50ZXJsZWF2ZWRCdWZmZXIsIGl0ZW1TaXplLCBvZmZzZXQsIG5vcm1hbGl6ZWQgKSB7XG5cbiAgICBcdHRoaXMudXVpZCA9IGV4cG9ydHMuTWF0aC5nZW5lcmF0ZVVVSUQoKTtcblxuICAgIFx0dGhpcy5kYXRhID0gaW50ZXJsZWF2ZWRCdWZmZXI7XG4gICAgXHR0aGlzLml0ZW1TaXplID0gaXRlbVNpemU7XG4gICAgXHR0aGlzLm9mZnNldCA9IG9mZnNldDtcblxuICAgIFx0dGhpcy5ub3JtYWxpemVkID0gbm9ybWFsaXplZCA9PT0gdHJ1ZTtcblxuICAgIH1cblxuXG4gICAgSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlID0ge1xuXG4gICAgXHRjb25zdHJ1Y3RvcjogSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUsXG5cbiAgICBcdGlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGU6IHRydWUsXG5cbiAgICBcdGdldCBjb3VudCgpIHtcblxuICAgIFx0XHRyZXR1cm4gdGhpcy5kYXRhLmNvdW50O1xuXG4gICAgXHR9LFxuXG4gICAgXHRnZXQgYXJyYXkoKSB7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMuZGF0YS5hcnJheTtcblxuICAgIFx0fSxcblxuICAgIFx0c2V0WDogZnVuY3Rpb24gKCBpbmRleCwgeCApIHtcblxuICAgIFx0XHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0IF0gPSB4O1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzZXRZOiBmdW5jdGlvbiAoIGluZGV4LCB5ICkge1xuXG4gICAgXHRcdHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQgKyAxIF0gPSB5O1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzZXRaOiBmdW5jdGlvbiAoIGluZGV4LCB6ICkge1xuXG4gICAgXHRcdHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQgKyAyIF0gPSB6O1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzZXRXOiBmdW5jdGlvbiAoIGluZGV4LCB3ICkge1xuXG4gICAgXHRcdHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQgKyAzIF0gPSB3O1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRnZXRYOiBmdW5jdGlvbiAoIGluZGV4ICkge1xuXG4gICAgXHRcdHJldHVybiB0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0IF07XG5cbiAgICBcdH0sXG5cbiAgICBcdGdldFk6IGZ1bmN0aW9uICggaW5kZXggKSB7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQgKyAxIF07XG5cbiAgICBcdH0sXG5cbiAgICBcdGdldFo6IGZ1bmN0aW9uICggaW5kZXggKSB7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQgKyAyIF07XG5cbiAgICBcdH0sXG5cbiAgICBcdGdldFc6IGZ1bmN0aW9uICggaW5kZXggKSB7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQgKyAzIF07XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldFhZOiBmdW5jdGlvbiAoIGluZGV4LCB4LCB5ICkge1xuXG4gICAgXHRcdGluZGV4ID0gaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQ7XG5cbiAgICBcdFx0dGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDAgXSA9IHg7XG4gICAgXHRcdHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKyAxIF0gPSB5O1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzZXRYWVo6IGZ1bmN0aW9uICggaW5kZXgsIHgsIHksIHogKSB7XG5cbiAgICBcdFx0aW5kZXggPSBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldDtcblxuICAgIFx0XHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMCBdID0geDtcbiAgICBcdFx0dGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDEgXSA9IHk7XG4gICAgXHRcdHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKyAyIF0gPSB6O1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzZXRYWVpXOiBmdW5jdGlvbiAoIGluZGV4LCB4LCB5LCB6LCB3ICkge1xuXG4gICAgXHRcdGluZGV4ID0gaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQ7XG5cbiAgICBcdFx0dGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDAgXSA9IHg7XG4gICAgXHRcdHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKyAxIF0gPSB5O1xuICAgIFx0XHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMiBdID0gejtcbiAgICBcdFx0dGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDMgXSA9IHc7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH1cblxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIGJlbmFhZGFtcyAvIGh0dHBzOi8vdHdpdHRlci5jb20vYmVuX2FfYWRhbXNcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIEludGVybGVhdmVkQnVmZmVyKCBhcnJheSwgc3RyaWRlICkge1xuXG4gICAgXHR0aGlzLnV1aWQgPSBleHBvcnRzLk1hdGguZ2VuZXJhdGVVVUlEKCk7XG5cbiAgICBcdHRoaXMuYXJyYXkgPSBhcnJheTtcbiAgICBcdHRoaXMuc3RyaWRlID0gc3RyaWRlO1xuICAgIFx0dGhpcy5jb3VudCA9IGFycmF5ICE9PSB1bmRlZmluZWQgPyBhcnJheS5sZW5ndGggLyBzdHJpZGUgOiAwO1xuXG4gICAgXHR0aGlzLmR5bmFtaWMgPSBmYWxzZTtcbiAgICBcdHRoaXMudXBkYXRlUmFuZ2UgPSB7IG9mZnNldDogMCwgY291bnQ6IC0gMSB9O1xuXG4gICAgXHR0aGlzLnZlcnNpb24gPSAwO1xuXG4gICAgfVxuXG4gICAgSW50ZXJsZWF2ZWRCdWZmZXIucHJvdG90eXBlID0ge1xuXG4gICAgXHRjb25zdHJ1Y3RvcjogSW50ZXJsZWF2ZWRCdWZmZXIsXG5cbiAgICBcdGlzSW50ZXJsZWF2ZWRCdWZmZXI6IHRydWUsXG5cbiAgICBcdHNldCBuZWVkc1VwZGF0ZSggdmFsdWUgKSB7XG5cbiAgICBcdFx0aWYgKCB2YWx1ZSA9PT0gdHJ1ZSApIHRoaXMudmVyc2lvbiArKztcblxuICAgIFx0fSxcblxuICAgIFx0c2V0RHluYW1pYzogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuICAgIFx0XHR0aGlzLmR5bmFtaWMgPSB2YWx1ZTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cbiAgICBcdFx0dGhpcy5hcnJheSA9IG5ldyBzb3VyY2UuYXJyYXkuY29uc3RydWN0b3IoIHNvdXJjZS5hcnJheSApO1xuICAgIFx0XHR0aGlzLmNvdW50ID0gc291cmNlLmNvdW50O1xuICAgIFx0XHR0aGlzLnN0cmlkZSA9IHNvdXJjZS5zdHJpZGU7XG4gICAgXHRcdHRoaXMuZHluYW1pYyA9IHNvdXJjZS5keW5hbWljO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRjb3B5QXQ6IGZ1bmN0aW9uICggaW5kZXgxLCBhdHRyaWJ1dGUsIGluZGV4MiApIHtcblxuICAgIFx0XHRpbmRleDEgKj0gdGhpcy5zdHJpZGU7XG4gICAgXHRcdGluZGV4MiAqPSBhdHRyaWJ1dGUuc3RyaWRlO1xuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuc3RyaWRlOyBpIDwgbDsgaSArKyApIHtcblxuICAgIFx0XHRcdHRoaXMuYXJyYXlbIGluZGV4MSArIGkgXSA9IGF0dHJpYnV0ZS5hcnJheVsgaW5kZXgyICsgaSBdO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlLCBvZmZzZXQgKSB7XG5cbiAgICBcdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cbiAgICBcdFx0dGhpcy5hcnJheS5zZXQoIHZhbHVlLCBvZmZzZXQgKTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cbiAgICBcdH1cblxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIGJlbmFhZGFtcyAvIGh0dHBzOi8vdHdpdHRlci5jb20vYmVuX2FfYWRhbXNcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIEluc3RhbmNlZEludGVybGVhdmVkQnVmZmVyKCBhcnJheSwgc3RyaWRlLCBtZXNoUGVyQXR0cmlidXRlICkge1xuXG4gICAgXHRJbnRlcmxlYXZlZEJ1ZmZlci5jYWxsKCB0aGlzLCBhcnJheSwgc3RyaWRlICk7XG5cbiAgICBcdHRoaXMubWVzaFBlckF0dHJpYnV0ZSA9IG1lc2hQZXJBdHRyaWJ1dGUgfHwgMTtcblxuICAgIH1cblxuICAgIEluc3RhbmNlZEludGVybGVhdmVkQnVmZmVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEludGVybGVhdmVkQnVmZmVyLnByb3RvdHlwZSApO1xuICAgIEluc3RhbmNlZEludGVybGVhdmVkQnVmZmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEluc3RhbmNlZEludGVybGVhdmVkQnVmZmVyO1xuXG4gICAgSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIucHJvdG90eXBlLmlzSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIgPSB0cnVlO1xuXG4gICAgSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuICAgIFx0SW50ZXJsZWF2ZWRCdWZmZXIucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cbiAgICBcdHRoaXMubWVzaFBlckF0dHJpYnV0ZSA9IHNvdXJjZS5tZXNoUGVyQXR0cmlidXRlO1xuXG4gICAgXHRyZXR1cm4gdGhpcztcblxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIGJlbmFhZGFtcyAvIGh0dHBzOi8vdHdpdHRlci5jb20vYmVuX2FfYWRhbXNcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIEluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplLCBtZXNoUGVyQXR0cmlidXRlICkge1xuXG4gICAgXHRCdWZmZXJBdHRyaWJ1dGUuY2FsbCggdGhpcywgYXJyYXksIGl0ZW1TaXplICk7XG5cbiAgICBcdHRoaXMubWVzaFBlckF0dHJpYnV0ZSA9IG1lc2hQZXJBdHRyaWJ1dGUgfHwgMTtcblxuICAgIH1cblxuICAgIEluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlICk7XG4gICAgSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZTtcblxuICAgIEluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUuaXNJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUgPSB0cnVlO1xuXG4gICAgSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cbiAgICBcdEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuICAgIFx0dGhpcy5tZXNoUGVyQXR0cmlidXRlID0gc291cmNlLm1lc2hQZXJBdHRyaWJ1dGU7XG5cbiAgICBcdHJldHVybiB0aGlzO1xuXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gICAgICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pby9cbiAgICAgKiBAYXV0aG9yIHN0ZXBob21pIC8gaHR0cDovL3N0ZXBoYW5lZ2luaWVyLmNvbS9cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIFJheWNhc3Rlciggb3JpZ2luLCBkaXJlY3Rpb24sIG5lYXIsIGZhciApIHtcblxuICAgIFx0dGhpcy5yYXkgPSBuZXcgUmF5KCBvcmlnaW4sIGRpcmVjdGlvbiApO1xuICAgIFx0Ly8gZGlyZWN0aW9uIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZCAoZm9yIGFjY3VyYXRlIGRpc3RhbmNlIGNhbGN1bGF0aW9ucylcblxuICAgIFx0dGhpcy5uZWFyID0gbmVhciB8fCAwO1xuICAgIFx0dGhpcy5mYXIgPSBmYXIgfHwgSW5maW5pdHk7XG5cbiAgICBcdHRoaXMucGFyYW1zID0ge1xuICAgIFx0XHRNZXNoOiB7fSxcbiAgICBcdFx0TGluZToge30sXG4gICAgXHRcdExPRDoge30sXG4gICAgXHRcdFBvaW50czogeyB0aHJlc2hvbGQ6IDEgfSxcbiAgICBcdFx0U3ByaXRlOiB7fVxuICAgIFx0fTtcblxuICAgIFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIHRoaXMucGFyYW1zLCB7XG4gICAgXHRcdFBvaW50Q2xvdWQ6IHtcbiAgICBcdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlJheWNhc3RlcjogcGFyYW1zLlBvaW50Q2xvdWQgaGFzIGJlZW4gcmVuYW1lZCB0byBwYXJhbXMuUG9pbnRzLicgKTtcbiAgICBcdFx0XHRcdHJldHVybiB0aGlzLlBvaW50cztcbiAgICBcdFx0XHR9XG4gICAgXHRcdH1cbiAgICBcdH0gKTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFzY1NvcnQoIGEsIGIgKSB7XG5cbiAgICBcdHJldHVybiBhLmRpc3RhbmNlIC0gYi5kaXN0YW5jZTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGludGVyc2VjdE9iamVjdCggb2JqZWN0LCByYXljYXN0ZXIsIGludGVyc2VjdHMsIHJlY3Vyc2l2ZSApIHtcblxuICAgIFx0aWYgKCBvYmplY3QudmlzaWJsZSA9PT0gZmFsc2UgKSByZXR1cm47XG5cbiAgICBcdG9iamVjdC5yYXljYXN0KCByYXljYXN0ZXIsIGludGVyc2VjdHMgKTtcblxuICAgIFx0aWYgKCByZWN1cnNpdmUgPT09IHRydWUgKSB7XG5cbiAgICBcdFx0dmFyIGNoaWxkcmVuID0gb2JqZWN0LmNoaWxkcmVuO1xuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICBcdFx0XHRpbnRlcnNlY3RPYmplY3QoIGNoaWxkcmVuWyBpIF0sIHJheWNhc3RlciwgaW50ZXJzZWN0cywgdHJ1ZSApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0fVxuXG4gICAgfVxuXG4gICAgLy9cblxuICAgIFJheWNhc3Rlci5wcm90b3R5cGUgPSB7XG5cbiAgICBcdGNvbnN0cnVjdG9yOiBSYXljYXN0ZXIsXG5cbiAgICBcdGxpbmVQcmVjaXNpb246IDEsXG5cbiAgICBcdHNldDogZnVuY3Rpb24gKCBvcmlnaW4sIGRpcmVjdGlvbiApIHtcblxuICAgIFx0XHQvLyBkaXJlY3Rpb24gaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkIChmb3IgYWNjdXJhdGUgZGlzdGFuY2UgY2FsY3VsYXRpb25zKVxuXG4gICAgXHRcdHRoaXMucmF5LnNldCggb3JpZ2luLCBkaXJlY3Rpb24gKTtcblxuICAgIFx0fSxcblxuICAgIFx0c2V0RnJvbUNhbWVyYTogZnVuY3Rpb24gKCBjb29yZHMsIGNhbWVyYSApIHtcblxuICAgIFx0XHRpZiAoIChjYW1lcmEgJiYgY2FtZXJhLmlzUGVyc3BlY3RpdmVDYW1lcmEpICkge1xuXG4gICAgXHRcdFx0dGhpcy5yYXkub3JpZ2luLnNldEZyb21NYXRyaXhQb3NpdGlvbiggY2FtZXJhLm1hdHJpeFdvcmxkICk7XG4gICAgXHRcdFx0dGhpcy5yYXkuZGlyZWN0aW9uLnNldCggY29vcmRzLngsIGNvb3Jkcy55LCAwLjUgKS51bnByb2plY3QoIGNhbWVyYSApLnN1YiggdGhpcy5yYXkub3JpZ2luICkubm9ybWFsaXplKCk7XG5cbiAgICBcdFx0fSBlbHNlIGlmICggKGNhbWVyYSAmJiBjYW1lcmEuaXNPcnRob2dyYXBoaWNDYW1lcmEpICkge1xuXG4gICAgXHRcdFx0dGhpcy5yYXkub3JpZ2luLnNldCggY29vcmRzLngsIGNvb3Jkcy55LCAoIGNhbWVyYS5uZWFyICsgY2FtZXJhLmZhciApIC8gKCBjYW1lcmEubmVhciAtIGNhbWVyYS5mYXIgKSApLnVucHJvamVjdCggY2FtZXJhICk7IC8vIHNldCBvcmlnaW4gaW4gcGxhbmUgb2YgY2FtZXJhXG4gICAgXHRcdFx0dGhpcy5yYXkuZGlyZWN0aW9uLnNldCggMCwgMCwgLSAxICkudHJhbnNmb3JtRGlyZWN0aW9uKCBjYW1lcmEubWF0cml4V29ybGQgKTtcblxuICAgIFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlJheWNhc3RlcjogVW5zdXBwb3J0ZWQgY2FtZXJhIHR5cGUuJyApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0fSxcblxuICAgIFx0aW50ZXJzZWN0T2JqZWN0OiBmdW5jdGlvbiAoIG9iamVjdCwgcmVjdXJzaXZlICkge1xuXG4gICAgXHRcdHZhciBpbnRlcnNlY3RzID0gW107XG5cbiAgICBcdFx0aW50ZXJzZWN0T2JqZWN0KCBvYmplY3QsIHRoaXMsIGludGVyc2VjdHMsIHJlY3Vyc2l2ZSApO1xuXG4gICAgXHRcdGludGVyc2VjdHMuc29ydCggYXNjU29ydCApO1xuXG4gICAgXHRcdHJldHVybiBpbnRlcnNlY3RzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRpbnRlcnNlY3RPYmplY3RzOiBmdW5jdGlvbiAoIG9iamVjdHMsIHJlY3Vyc2l2ZSApIHtcblxuICAgIFx0XHR2YXIgaW50ZXJzZWN0cyA9IFtdO1xuXG4gICAgXHRcdGlmICggQXJyYXkuaXNBcnJheSggb2JqZWN0cyApID09PSBmYWxzZSApIHtcblxuICAgIFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlJheWNhc3Rlci5pbnRlcnNlY3RPYmplY3RzOiBvYmplY3RzIGlzIG5vdCBhbiBBcnJheS4nICk7XG4gICAgXHRcdFx0cmV0dXJuIGludGVyc2VjdHM7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IG9iamVjdHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgIFx0XHRcdGludGVyc2VjdE9iamVjdCggb2JqZWN0c1sgaSBdLCB0aGlzLCBpbnRlcnNlY3RzLCByZWN1cnNpdmUgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0aW50ZXJzZWN0cy5zb3J0KCBhc2NTb3J0ICk7XG5cbiAgICBcdFx0cmV0dXJuIGludGVyc2VjdHM7XG5cbiAgICBcdH1cblxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gQ2xvY2soIGF1dG9TdGFydCApIHtcblxuICAgIFx0dGhpcy5hdXRvU3RhcnQgPSAoIGF1dG9TdGFydCAhPT0gdW5kZWZpbmVkICkgPyBhdXRvU3RhcnQgOiB0cnVlO1xuXG4gICAgXHR0aGlzLnN0YXJ0VGltZSA9IDA7XG4gICAgXHR0aGlzLm9sZFRpbWUgPSAwO1xuICAgIFx0dGhpcy5lbGFwc2VkVGltZSA9IDA7XG5cbiAgICBcdHRoaXMucnVubmluZyA9IGZhbHNlO1xuXG4gICAgfVxuXG4gICAgQ2xvY2sucHJvdG90eXBlID0ge1xuXG4gICAgXHRjb25zdHJ1Y3RvcjogQ2xvY2ssXG5cbiAgICBcdHN0YXJ0OiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dGhpcy5zdGFydFRpbWUgPSAoIHBlcmZvcm1hbmNlIHx8IERhdGUgKS5ub3coKTtcblxuICAgIFx0XHR0aGlzLm9sZFRpbWUgPSB0aGlzLnN0YXJ0VGltZTtcbiAgICBcdFx0dGhpcy5ydW5uaW5nID0gdHJ1ZTtcblxuICAgIFx0fSxcblxuICAgIFx0c3RvcDogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHRoaXMuZ2V0RWxhcHNlZFRpbWUoKTtcbiAgICBcdFx0dGhpcy5ydW5uaW5nID0gZmFsc2U7XG5cbiAgICBcdH0sXG5cbiAgICBcdGdldEVsYXBzZWRUaW1lOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dGhpcy5nZXREZWx0YSgpO1xuICAgIFx0XHRyZXR1cm4gdGhpcy5lbGFwc2VkVGltZTtcblxuICAgIFx0fSxcblxuICAgIFx0Z2V0RGVsdGE6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR2YXIgZGlmZiA9IDA7XG5cbiAgICBcdFx0aWYgKCB0aGlzLmF1dG9TdGFydCAmJiAhIHRoaXMucnVubmluZyApIHtcblxuICAgIFx0XHRcdHRoaXMuc3RhcnQoKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKCB0aGlzLnJ1bm5pbmcgKSB7XG5cbiAgICBcdFx0XHR2YXIgbmV3VGltZSA9ICggcGVyZm9ybWFuY2UgfHwgRGF0ZSApLm5vdygpO1xuXG4gICAgXHRcdFx0ZGlmZiA9ICggbmV3VGltZSAtIHRoaXMub2xkVGltZSApIC8gMTAwMDtcbiAgICBcdFx0XHR0aGlzLm9sZFRpbWUgPSBuZXdUaW1lO1xuXG4gICAgXHRcdFx0dGhpcy5lbGFwc2VkVGltZSArPSBkaWZmO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gZGlmZjtcblxuICAgIFx0fVxuXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNwbGluZSBmcm9tIFR3ZWVuLmpzLCBzbGlnaHRseSBvcHRpbWl6ZWQgKGFuZCB0cmFzaGVkKVxuICAgICAqIGh0dHA6Ly9zb2xlLmdpdGh1Yi5jb20vdHdlZW4uanMvZXhhbXBsZXMvMDVfc3BsaW5lLmh0bWxcbiAgICAgKlxuICAgICAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gICAgICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIFNwbGluZSggcG9pbnRzICkge1xuXG4gICAgXHR0aGlzLnBvaW50cyA9IHBvaW50cztcblxuICAgIFx0dmFyIGMgPSBbXSwgdjMgPSB7IHg6IDAsIHk6IDAsIHo6IDAgfSxcbiAgICBcdHBvaW50LCBpbnRQb2ludCwgd2VpZ2h0LCB3MiwgdzMsXG4gICAgXHRwYSwgcGIsIHBjLCBwZDtcblxuICAgIFx0dGhpcy5pbml0RnJvbUFycmF5ID0gZnVuY3Rpb24gKCBhICkge1xuXG4gICAgXHRcdHRoaXMucG9pbnRzID0gW107XG5cbiAgICBcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkgKysgKSB7XG5cbiAgICBcdFx0XHR0aGlzLnBvaW50c1sgaSBdID0geyB4OiBhWyBpIF1bIDAgXSwgeTogYVsgaSBdWyAxIF0sIHo6IGFbIGkgXVsgMiBdIH07XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9O1xuXG4gICAgXHR0aGlzLmdldFBvaW50ID0gZnVuY3Rpb24gKCBrICkge1xuXG4gICAgXHRcdHBvaW50ID0gKCB0aGlzLnBvaW50cy5sZW5ndGggLSAxICkgKiBrO1xuICAgIFx0XHRpbnRQb2ludCA9IE1hdGguZmxvb3IoIHBvaW50ICk7XG4gICAgXHRcdHdlaWdodCA9IHBvaW50IC0gaW50UG9pbnQ7XG5cbiAgICBcdFx0Y1sgMCBdID0gaW50UG9pbnQgPT09IDAgPyBpbnRQb2ludCA6IGludFBvaW50IC0gMTtcbiAgICBcdFx0Y1sgMSBdID0gaW50UG9pbnQ7XG4gICAgXHRcdGNbIDIgXSA9IGludFBvaW50ICA+IHRoaXMucG9pbnRzLmxlbmd0aCAtIDIgPyB0aGlzLnBvaW50cy5sZW5ndGggLSAxIDogaW50UG9pbnQgKyAxO1xuICAgIFx0XHRjWyAzIF0gPSBpbnRQb2ludCAgPiB0aGlzLnBvaW50cy5sZW5ndGggLSAzID8gdGhpcy5wb2ludHMubGVuZ3RoIC0gMSA6IGludFBvaW50ICsgMjtcblxuICAgIFx0XHRwYSA9IHRoaXMucG9pbnRzWyBjWyAwIF0gXTtcbiAgICBcdFx0cGIgPSB0aGlzLnBvaW50c1sgY1sgMSBdIF07XG4gICAgXHRcdHBjID0gdGhpcy5wb2ludHNbIGNbIDIgXSBdO1xuICAgIFx0XHRwZCA9IHRoaXMucG9pbnRzWyBjWyAzIF0gXTtcblxuICAgIFx0XHR3MiA9IHdlaWdodCAqIHdlaWdodDtcbiAgICBcdFx0dzMgPSB3ZWlnaHQgKiB3MjtcblxuICAgIFx0XHR2My54ID0gaW50ZXJwb2xhdGUoIHBhLngsIHBiLngsIHBjLngsIHBkLngsIHdlaWdodCwgdzIsIHczICk7XG4gICAgXHRcdHYzLnkgPSBpbnRlcnBvbGF0ZSggcGEueSwgcGIueSwgcGMueSwgcGQueSwgd2VpZ2h0LCB3MiwgdzMgKTtcbiAgICBcdFx0djMueiA9IGludGVycG9sYXRlKCBwYS56LCBwYi56LCBwYy56LCBwZC56LCB3ZWlnaHQsIHcyLCB3MyApO1xuXG4gICAgXHRcdHJldHVybiB2MztcblxuICAgIFx0fTtcblxuICAgIFx0dGhpcy5nZXRDb250cm9sUG9pbnRzQXJyYXkgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dmFyIGksIHAsIGwgPSB0aGlzLnBvaW50cy5sZW5ndGgsXG4gICAgXHRcdFx0Y29vcmRzID0gW107XG5cbiAgICBcdFx0Zm9yICggaSA9IDA7IGkgPCBsOyBpICsrICkge1xuXG4gICAgXHRcdFx0cCA9IHRoaXMucG9pbnRzWyBpIF07XG4gICAgXHRcdFx0Y29vcmRzWyBpIF0gPSBbIHAueCwgcC55LCBwLnogXTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIGNvb3JkcztcblxuICAgIFx0fTtcblxuICAgIFx0Ly8gYXBwcm94aW1hdGUgbGVuZ3RoIGJ5IHN1bW1pbmcgbGluZWFyIHNlZ21lbnRzXG5cbiAgICBcdHRoaXMuZ2V0TGVuZ3RoID0gZnVuY3Rpb24gKCBuU3ViRGl2aXNpb25zICkge1xuXG4gICAgXHRcdHZhciBpLCBpbmRleCwgblNhbXBsZXMsIHBvc2l0aW9uLFxuICAgIFx0XHRcdHBvaW50ID0gMCwgaW50UG9pbnQgPSAwLCBvbGRJbnRQb2ludCA9IDAsXG4gICAgXHRcdFx0b2xkUG9zaXRpb24gPSBuZXcgVmVjdG9yMygpLFxuICAgIFx0XHRcdHRtcFZlYyA9IG5ldyBWZWN0b3IzKCksXG4gICAgXHRcdFx0Y2h1bmtMZW5ndGhzID0gW10sXG4gICAgXHRcdFx0dG90YWxMZW5ndGggPSAwO1xuXG4gICAgXHRcdC8vIGZpcnN0IHBvaW50IGhhcyAwIGxlbmd0aFxuXG4gICAgXHRcdGNodW5rTGVuZ3Roc1sgMCBdID0gMDtcblxuICAgIFx0XHRpZiAoICEgblN1YkRpdmlzaW9ucyApIG5TdWJEaXZpc2lvbnMgPSAxMDA7XG5cbiAgICBcdFx0blNhbXBsZXMgPSB0aGlzLnBvaW50cy5sZW5ndGggKiBuU3ViRGl2aXNpb25zO1xuXG4gICAgXHRcdG9sZFBvc2l0aW9uLmNvcHkoIHRoaXMucG9pbnRzWyAwIF0gKTtcblxuICAgIFx0XHRmb3IgKCBpID0gMTsgaSA8IG5TYW1wbGVzOyBpICsrICkge1xuXG4gICAgXHRcdFx0aW5kZXggPSBpIC8gblNhbXBsZXM7XG5cbiAgICBcdFx0XHRwb3NpdGlvbiA9IHRoaXMuZ2V0UG9pbnQoIGluZGV4ICk7XG4gICAgXHRcdFx0dG1wVmVjLmNvcHkoIHBvc2l0aW9uICk7XG5cbiAgICBcdFx0XHR0b3RhbExlbmd0aCArPSB0bXBWZWMuZGlzdGFuY2VUbyggb2xkUG9zaXRpb24gKTtcblxuICAgIFx0XHRcdG9sZFBvc2l0aW9uLmNvcHkoIHBvc2l0aW9uICk7XG5cbiAgICBcdFx0XHRwb2ludCA9ICggdGhpcy5wb2ludHMubGVuZ3RoIC0gMSApICogaW5kZXg7XG4gICAgXHRcdFx0aW50UG9pbnQgPSBNYXRoLmZsb29yKCBwb2ludCApO1xuXG4gICAgXHRcdFx0aWYgKCBpbnRQb2ludCAhPT0gb2xkSW50UG9pbnQgKSB7XG5cbiAgICBcdFx0XHRcdGNodW5rTGVuZ3Roc1sgaW50UG9pbnQgXSA9IHRvdGFsTGVuZ3RoO1xuICAgIFx0XHRcdFx0b2xkSW50UG9pbnQgPSBpbnRQb2ludDtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdFx0Ly8gbGFzdCBwb2ludCBlbmRzIHdpdGggdG90YWwgbGVuZ3RoXG5cbiAgICBcdFx0Y2h1bmtMZW5ndGhzWyBjaHVua0xlbmd0aHMubGVuZ3RoIF0gPSB0b3RhbExlbmd0aDtcblxuICAgIFx0XHRyZXR1cm4geyBjaHVua3M6IGNodW5rTGVuZ3RocywgdG90YWw6IHRvdGFsTGVuZ3RoIH07XG5cbiAgICBcdH07XG5cbiAgICBcdHRoaXMucmVwYXJhbWV0cml6ZUJ5QXJjTGVuZ3RoID0gZnVuY3Rpb24gKCBzYW1wbGluZ0NvZWYgKSB7XG5cbiAgICBcdFx0dmFyIGksIGosXG4gICAgXHRcdFx0aW5kZXgsIGluZGV4Q3VycmVudCwgaW5kZXhOZXh0LFxuICAgIFx0XHRcdHJlYWxEaXN0YW5jZSxcbiAgICBcdFx0XHRzYW1wbGluZywgcG9zaXRpb24sXG4gICAgXHRcdFx0bmV3cG9pbnRzID0gW10sXG4gICAgXHRcdFx0dG1wVmVjID0gbmV3IFZlY3RvcjMoKSxcbiAgICBcdFx0XHRzbCA9IHRoaXMuZ2V0TGVuZ3RoKCk7XG5cbiAgICBcdFx0bmV3cG9pbnRzLnB1c2goIHRtcFZlYy5jb3B5KCB0aGlzLnBvaW50c1sgMCBdICkuY2xvbmUoKSApO1xuXG4gICAgXHRcdGZvciAoIGkgPSAxOyBpIDwgdGhpcy5wb2ludHMubGVuZ3RoOyBpICsrICkge1xuXG4gICAgXHRcdFx0Ly90bXBWZWMuY29weSggdGhpcy5wb2ludHNbIGkgLSAxIF0gKTtcbiAgICBcdFx0XHQvL2xpbmVhckRpc3RhbmNlID0gdG1wVmVjLmRpc3RhbmNlVG8oIHRoaXMucG9pbnRzWyBpIF0gKTtcblxuICAgIFx0XHRcdHJlYWxEaXN0YW5jZSA9IHNsLmNodW5rc1sgaSBdIC0gc2wuY2h1bmtzWyBpIC0gMSBdO1xuXG4gICAgXHRcdFx0c2FtcGxpbmcgPSBNYXRoLmNlaWwoIHNhbXBsaW5nQ29lZiAqIHJlYWxEaXN0YW5jZSAvIHNsLnRvdGFsICk7XG5cbiAgICBcdFx0XHRpbmRleEN1cnJlbnQgPSAoIGkgLSAxICkgLyAoIHRoaXMucG9pbnRzLmxlbmd0aCAtIDEgKTtcbiAgICBcdFx0XHRpbmRleE5leHQgPSBpIC8gKCB0aGlzLnBvaW50cy5sZW5ndGggLSAxICk7XG5cbiAgICBcdFx0XHRmb3IgKCBqID0gMTsgaiA8IHNhbXBsaW5nIC0gMTsgaiArKyApIHtcblxuICAgIFx0XHRcdFx0aW5kZXggPSBpbmRleEN1cnJlbnQgKyBqICogKCAxIC8gc2FtcGxpbmcgKSAqICggaW5kZXhOZXh0IC0gaW5kZXhDdXJyZW50ICk7XG5cbiAgICBcdFx0XHRcdHBvc2l0aW9uID0gdGhpcy5nZXRQb2ludCggaW5kZXggKTtcbiAgICBcdFx0XHRcdG5ld3BvaW50cy5wdXNoKCB0bXBWZWMuY29weSggcG9zaXRpb24gKS5jbG9uZSgpICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRuZXdwb2ludHMucHVzaCggdG1wVmVjLmNvcHkoIHRoaXMucG9pbnRzWyBpIF0gKS5jbG9uZSgpICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHRoaXMucG9pbnRzID0gbmV3cG9pbnRzO1xuXG4gICAgXHR9O1xuXG4gICAgXHQvLyBDYXRtdWxsLVJvbVxuXG4gICAgXHRmdW5jdGlvbiBpbnRlcnBvbGF0ZSggcDAsIHAxLCBwMiwgcDMsIHQsIHQyLCB0MyApIHtcblxuICAgIFx0XHR2YXIgdjAgPSAoIHAyIC0gcDAgKSAqIDAuNSxcbiAgICBcdFx0XHR2MSA9ICggcDMgLSBwMSApICogMC41O1xuXG4gICAgXHRcdHJldHVybiAoIDIgKiAoIHAxIC0gcDIgKSArIHYwICsgdjEgKSAqIHQzICsgKCAtIDMgKiAoIHAxIC0gcDIgKSAtIDIgKiB2MCAtIHYxICkgKiB0MiArIHYwICogdCArIHAxO1xuXG4gICAgXHR9XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXG4gICAgICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4gICAgICpcbiAgICAgKiBSZWY6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NwaGVyaWNhbF9jb29yZGluYXRlX3N5c3RlbVxuICAgICAqXG4gICAgICogVGhlIHBvbGVzIChwaGkpIGFyZSBhdCB0aGUgcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIHkgYXhpcy5cbiAgICAgKiBUaGUgZXF1YXRvciBzdGFydHMgYXQgcG9zaXRpdmUgei5cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIFNwaGVyaWNhbCggcmFkaXVzLCBwaGksIHRoZXRhICkge1xuXG4gICAgXHR0aGlzLnJhZGl1cyA9ICggcmFkaXVzICE9PSB1bmRlZmluZWQgKSA/IHJhZGl1cyA6IDEuMDtcbiAgICBcdHRoaXMucGhpID0gKCBwaGkgIT09IHVuZGVmaW5lZCApID8gcGhpIDogMDsgLy8gdXAgLyBkb3duIHRvd2FyZHMgdG9wIGFuZCBib3R0b20gcG9sZVxuICAgIFx0dGhpcy50aGV0YSA9ICggdGhldGEgIT09IHVuZGVmaW5lZCApID8gdGhldGEgOiAwOyAvLyBhcm91bmQgdGhlIGVxdWF0b3Igb2YgdGhlIHNwaGVyZVxuXG4gICAgXHRyZXR1cm4gdGhpcztcblxuICAgIH1cblxuICAgIFNwaGVyaWNhbC5wcm90b3R5cGUgPSB7XG5cbiAgICBcdGNvbnN0cnVjdG9yOiBTcGhlcmljYWwsXG5cbiAgICBcdHNldDogZnVuY3Rpb24gKCByYWRpdXMsIHBoaSwgdGhldGEgKSB7XG5cbiAgICBcdFx0dGhpcy5yYWRpdXMgPSByYWRpdXM7XG4gICAgXHRcdHRoaXMucGhpID0gcGhpO1xuICAgIFx0XHR0aGlzLnRoZXRhID0gdGhldGE7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRjb3B5OiBmdW5jdGlvbiAoIG90aGVyICkge1xuXG4gICAgXHRcdHRoaXMucmFkaXVzLmNvcHkoIG90aGVyLnJhZGl1cyApO1xuICAgIFx0XHR0aGlzLnBoaS5jb3B5KCBvdGhlci5waGkgKTtcbiAgICBcdFx0dGhpcy50aGV0YS5jb3B5KCBvdGhlci50aGV0YSApO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHQvLyByZXN0cmljdCBwaGkgdG8gYmUgYmV0d2VlIEVQUyBhbmQgUEktRVBTXG4gICAgXHRtYWtlU2FmZTogZnVuY3Rpb24oKSB7XG5cbiAgICBcdFx0dmFyIEVQUyA9IDAuMDAwMDAxO1xuICAgIFx0XHR0aGlzLnBoaSA9IE1hdGgubWF4KCBFUFMsIE1hdGgubWluKCBNYXRoLlBJIC0gRVBTLCB0aGlzLnBoaSApICk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldEZyb21WZWN0b3IzOiBmdW5jdGlvbiggdmVjMyApIHtcblxuICAgIFx0XHR0aGlzLnJhZGl1cyA9IHZlYzMubGVuZ3RoKCk7XG5cbiAgICBcdFx0aWYgKCB0aGlzLnJhZGl1cyA9PT0gMCApIHtcblxuICAgIFx0XHRcdHRoaXMudGhldGEgPSAwO1xuICAgIFx0XHRcdHRoaXMucGhpID0gMDtcblxuICAgIFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0dGhpcy50aGV0YSA9IE1hdGguYXRhbjIoIHZlYzMueCwgdmVjMy56ICk7IC8vIGVxdWF0b3IgYW5nbGUgYXJvdW5kIHktdXAgYXhpc1xuICAgIFx0XHRcdHRoaXMucGhpID0gTWF0aC5hY29zKCBleHBvcnRzLk1hdGguY2xhbXAoIHZlYzMueSAvIHRoaXMucmFkaXVzLCAtIDEsIDEgKSApOyAvLyBwb2xhciBhbmdsZVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIH07XG5cbiAgICAvKipcclxuICAgICAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAgICAgKi9cclxuXHJcbiAgICBmdW5jdGlvbiBNb3JwaEJsZW5kTWVzaCggZ2VvbWV0cnksIG1hdGVyaWFsICkge1xuXHJcbiAgICBcdE1lc2guY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsICk7XHJcblxyXG4gICAgXHR0aGlzLmFuaW1hdGlvbnNNYXAgPSB7fTtcclxuICAgIFx0dGhpcy5hbmltYXRpb25zTGlzdCA9IFtdO1xyXG5cclxuICAgIFx0Ly8gcHJlcGFyZSBkZWZhdWx0IGFuaW1hdGlvblxyXG4gICAgXHQvLyAoYWxsIGZyYW1lcyBwbGF5ZWQgdG9nZXRoZXIgaW4gMSBzZWNvbmQpXHJcblxyXG4gICAgXHR2YXIgbnVtRnJhbWVzID0gdGhpcy5nZW9tZXRyeS5tb3JwaFRhcmdldHMubGVuZ3RoO1xyXG5cclxuICAgIFx0dmFyIG5hbWUgPSBcIl9fZGVmYXVsdFwiO1xyXG5cclxuICAgIFx0dmFyIHN0YXJ0RnJhbWUgPSAwO1xyXG4gICAgXHR2YXIgZW5kRnJhbWUgPSBudW1GcmFtZXMgLSAxO1xyXG5cclxuICAgIFx0dmFyIGZwcyA9IG51bUZyYW1lcyAvIDE7XHJcblxyXG4gICAgXHR0aGlzLmNyZWF0ZUFuaW1hdGlvbiggbmFtZSwgc3RhcnRGcmFtZSwgZW5kRnJhbWUsIGZwcyApO1xyXG4gICAgXHR0aGlzLnNldEFuaW1hdGlvbldlaWdodCggbmFtZSwgMSApO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBNb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBNZXNoLnByb3RvdHlwZSApO1xyXG4gICAgTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTW9ycGhCbGVuZE1lc2g7XHJcblxyXG4gICAgTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLmNyZWF0ZUFuaW1hdGlvbiA9IGZ1bmN0aW9uICggbmFtZSwgc3RhcnQsIGVuZCwgZnBzICkge1xyXG5cclxuICAgIFx0dmFyIGFuaW1hdGlvbiA9IHtcclxuXHJcbiAgICBcdFx0c3RhcnQ6IHN0YXJ0LFxyXG4gICAgXHRcdGVuZDogZW5kLFxyXG5cclxuICAgIFx0XHRsZW5ndGg6IGVuZCAtIHN0YXJ0ICsgMSxcclxuXHJcbiAgICBcdFx0ZnBzOiBmcHMsXHJcbiAgICBcdFx0ZHVyYXRpb246ICggZW5kIC0gc3RhcnQgKSAvIGZwcyxcclxuXHJcbiAgICBcdFx0bGFzdEZyYW1lOiAwLFxyXG4gICAgXHRcdGN1cnJlbnRGcmFtZTogMCxcclxuXHJcbiAgICBcdFx0YWN0aXZlOiBmYWxzZSxcclxuXHJcbiAgICBcdFx0dGltZTogMCxcclxuICAgIFx0XHRkaXJlY3Rpb246IDEsXHJcbiAgICBcdFx0d2VpZ2h0OiAxLFxyXG5cclxuICAgIFx0XHRkaXJlY3Rpb25CYWNrd2FyZHM6IGZhbHNlLFxyXG4gICAgXHRcdG1pcnJvcmVkTG9vcDogZmFsc2VcclxuXHJcbiAgICBcdH07XHJcblxyXG4gICAgXHR0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXSA9IGFuaW1hdGlvbjtcclxuICAgIFx0dGhpcy5hbmltYXRpb25zTGlzdC5wdXNoKCBhbmltYXRpb24gKTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIE1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5hdXRvQ3JlYXRlQW5pbWF0aW9ucyA9IGZ1bmN0aW9uICggZnBzICkge1xyXG5cclxuICAgIFx0dmFyIHBhdHRlcm4gPSAvKFthLXpdKylfPyhcXGQrKS9pO1xyXG5cclxuICAgIFx0dmFyIGZpcnN0QW5pbWF0aW9uLCBmcmFtZVJhbmdlcyA9IHt9O1xyXG5cclxuICAgIFx0dmFyIGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcclxuXHJcbiAgICBcdGZvciAoIHZhciBpID0gMCwgaWwgPSBnZW9tZXRyeS5tb3JwaFRhcmdldHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG4gICAgXHRcdHZhciBtb3JwaCA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1sgaSBdO1xyXG4gICAgXHRcdHZhciBjaHVua3MgPSBtb3JwaC5uYW1lLm1hdGNoKCBwYXR0ZXJuICk7XHJcblxyXG4gICAgXHRcdGlmICggY2h1bmtzICYmIGNodW5rcy5sZW5ndGggPiAxICkge1xyXG5cclxuICAgIFx0XHRcdHZhciBuYW1lID0gY2h1bmtzWyAxIF07XHJcblxyXG4gICAgXHRcdFx0aWYgKCAhIGZyYW1lUmFuZ2VzWyBuYW1lIF0gKSBmcmFtZVJhbmdlc1sgbmFtZSBdID0geyBzdGFydDogSW5maW5pdHksIGVuZDogLSBJbmZpbml0eSB9O1xyXG5cclxuICAgIFx0XHRcdHZhciByYW5nZSA9IGZyYW1lUmFuZ2VzWyBuYW1lIF07XHJcblxyXG4gICAgXHRcdFx0aWYgKCBpIDwgcmFuZ2Uuc3RhcnQgKSByYW5nZS5zdGFydCA9IGk7XHJcbiAgICBcdFx0XHRpZiAoIGkgPiByYW5nZS5lbmQgKSByYW5nZS5lbmQgPSBpO1xyXG5cclxuICAgIFx0XHRcdGlmICggISBmaXJzdEFuaW1hdGlvbiApIGZpcnN0QW5pbWF0aW9uID0gbmFtZTtcclxuXHJcbiAgICBcdFx0fVxyXG5cclxuICAgIFx0fVxyXG5cclxuICAgIFx0Zm9yICggdmFyIG5hbWUgaW4gZnJhbWVSYW5nZXMgKSB7XHJcblxyXG4gICAgXHRcdHZhciByYW5nZSA9IGZyYW1lUmFuZ2VzWyBuYW1lIF07XHJcbiAgICBcdFx0dGhpcy5jcmVhdGVBbmltYXRpb24oIG5hbWUsIHJhbmdlLnN0YXJ0LCByYW5nZS5lbmQsIGZwcyApO1xyXG5cclxuICAgIFx0fVxyXG5cclxuICAgIFx0dGhpcy5maXJzdEFuaW1hdGlvbiA9IGZpcnN0QW5pbWF0aW9uO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLnNldEFuaW1hdGlvbkRpcmVjdGlvbkZvcndhcmQgPSBmdW5jdGlvbiAoIG5hbWUgKSB7XHJcblxyXG4gICAgXHR2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XHJcblxyXG4gICAgXHRpZiAoIGFuaW1hdGlvbiApIHtcclxuXHJcbiAgICBcdFx0YW5pbWF0aW9uLmRpcmVjdGlvbiA9IDE7XHJcbiAgICBcdFx0YW5pbWF0aW9uLmRpcmVjdGlvbkJhY2t3YXJkcyA9IGZhbHNlO1xyXG5cclxuICAgIFx0fVxyXG5cclxuICAgIH07XHJcblxyXG4gICAgTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLnNldEFuaW1hdGlvbkRpcmVjdGlvbkJhY2t3YXJkID0gZnVuY3Rpb24gKCBuYW1lICkge1xyXG5cclxuICAgIFx0dmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc01hcFsgbmFtZSBdO1xyXG5cclxuICAgIFx0aWYgKCBhbmltYXRpb24gKSB7XHJcblxyXG4gICAgXHRcdGFuaW1hdGlvbi5kaXJlY3Rpb24gPSAtIDE7XHJcbiAgICBcdFx0YW5pbWF0aW9uLmRpcmVjdGlvbkJhY2t3YXJkcyA9IHRydWU7XHJcblxyXG4gICAgXHR9XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICBNb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuc2V0QW5pbWF0aW9uRlBTID0gZnVuY3Rpb24gKCBuYW1lLCBmcHMgKSB7XHJcblxyXG4gICAgXHR2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XHJcblxyXG4gICAgXHRpZiAoIGFuaW1hdGlvbiApIHtcclxuXHJcbiAgICBcdFx0YW5pbWF0aW9uLmZwcyA9IGZwcztcclxuICAgIFx0XHRhbmltYXRpb24uZHVyYXRpb24gPSAoIGFuaW1hdGlvbi5lbmQgLSBhbmltYXRpb24uc3RhcnQgKSAvIGFuaW1hdGlvbi5mcHM7XHJcblxyXG4gICAgXHR9XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICBNb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuc2V0QW5pbWF0aW9uRHVyYXRpb24gPSBmdW5jdGlvbiAoIG5hbWUsIGR1cmF0aW9uICkge1xyXG5cclxuICAgIFx0dmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc01hcFsgbmFtZSBdO1xyXG5cclxuICAgIFx0aWYgKCBhbmltYXRpb24gKSB7XHJcblxyXG4gICAgXHRcdGFuaW1hdGlvbi5kdXJhdGlvbiA9IGR1cmF0aW9uO1xyXG4gICAgXHRcdGFuaW1hdGlvbi5mcHMgPSAoIGFuaW1hdGlvbi5lbmQgLSBhbmltYXRpb24uc3RhcnQgKSAvIGFuaW1hdGlvbi5kdXJhdGlvbjtcclxuXHJcbiAgICBcdH1cclxuXHJcbiAgICB9O1xyXG5cclxuICAgIE1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5zZXRBbmltYXRpb25XZWlnaHQgPSBmdW5jdGlvbiAoIG5hbWUsIHdlaWdodCApIHtcclxuXHJcbiAgICBcdHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXTtcclxuXHJcbiAgICBcdGlmICggYW5pbWF0aW9uICkge1xyXG5cclxuICAgIFx0XHRhbmltYXRpb24ud2VpZ2h0ID0gd2VpZ2h0O1xyXG5cclxuICAgIFx0fVxyXG5cclxuICAgIH07XHJcblxyXG4gICAgTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLnNldEFuaW1hdGlvblRpbWUgPSBmdW5jdGlvbiAoIG5hbWUsIHRpbWUgKSB7XHJcblxyXG4gICAgXHR2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XHJcblxyXG4gICAgXHRpZiAoIGFuaW1hdGlvbiApIHtcclxuXHJcbiAgICBcdFx0YW5pbWF0aW9uLnRpbWUgPSB0aW1lO1xyXG5cclxuICAgIFx0fVxyXG5cclxuICAgIH07XHJcblxyXG4gICAgTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLmdldEFuaW1hdGlvblRpbWUgPSBmdW5jdGlvbiAoIG5hbWUgKSB7XHJcblxyXG4gICAgXHR2YXIgdGltZSA9IDA7XHJcblxyXG4gICAgXHR2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XHJcblxyXG4gICAgXHRpZiAoIGFuaW1hdGlvbiApIHtcclxuXHJcbiAgICBcdFx0dGltZSA9IGFuaW1hdGlvbi50aW1lO1xyXG5cclxuICAgIFx0fVxyXG5cclxuICAgIFx0cmV0dXJuIHRpbWU7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICBNb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuZ2V0QW5pbWF0aW9uRHVyYXRpb24gPSBmdW5jdGlvbiAoIG5hbWUgKSB7XHJcblxyXG4gICAgXHR2YXIgZHVyYXRpb24gPSAtIDE7XHJcblxyXG4gICAgXHR2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XHJcblxyXG4gICAgXHRpZiAoIGFuaW1hdGlvbiApIHtcclxuXHJcbiAgICBcdFx0ZHVyYXRpb24gPSBhbmltYXRpb24uZHVyYXRpb247XHJcblxyXG4gICAgXHR9XHJcblxyXG4gICAgXHRyZXR1cm4gZHVyYXRpb247XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICBNb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUucGxheUFuaW1hdGlvbiA9IGZ1bmN0aW9uICggbmFtZSApIHtcclxuXHJcbiAgICBcdHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXTtcclxuXHJcbiAgICBcdGlmICggYW5pbWF0aW9uICkge1xyXG5cclxuICAgIFx0XHRhbmltYXRpb24udGltZSA9IDA7XHJcbiAgICBcdFx0YW5pbWF0aW9uLmFjdGl2ZSA9IHRydWU7XHJcblxyXG4gICAgXHR9IGVsc2Uge1xyXG5cclxuICAgIFx0XHRjb25zb2xlLndhcm4oIFwiVEhSRUUuTW9ycGhCbGVuZE1lc2g6IGFuaW1hdGlvbltcIiArIG5hbWUgKyBcIl0gdW5kZWZpbmVkIGluIC5wbGF5QW5pbWF0aW9uKClcIiApO1xyXG5cclxuICAgIFx0fVxyXG5cclxuICAgIH07XHJcblxyXG4gICAgTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLnN0b3BBbmltYXRpb24gPSBmdW5jdGlvbiAoIG5hbWUgKSB7XHJcblxyXG4gICAgXHR2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XHJcblxyXG4gICAgXHRpZiAoIGFuaW1hdGlvbiApIHtcclxuXHJcbiAgICBcdFx0YW5pbWF0aW9uLmFjdGl2ZSA9IGZhbHNlO1xyXG5cclxuICAgIFx0fVxyXG5cclxuICAgIH07XHJcblxyXG4gICAgTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICggZGVsdGEgKSB7XHJcblxyXG4gICAgXHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gdGhpcy5hbmltYXRpb25zTGlzdC5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcbiAgICBcdFx0dmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc0xpc3RbIGkgXTtcclxuXHJcbiAgICBcdFx0aWYgKCAhIGFuaW1hdGlvbi5hY3RpdmUgKSBjb250aW51ZTtcclxuXHJcbiAgICBcdFx0dmFyIGZyYW1lVGltZSA9IGFuaW1hdGlvbi5kdXJhdGlvbiAvIGFuaW1hdGlvbi5sZW5ndGg7XHJcblxyXG4gICAgXHRcdGFuaW1hdGlvbi50aW1lICs9IGFuaW1hdGlvbi5kaXJlY3Rpb24gKiBkZWx0YTtcclxuXHJcbiAgICBcdFx0aWYgKCBhbmltYXRpb24ubWlycm9yZWRMb29wICkge1xyXG5cclxuICAgIFx0XHRcdGlmICggYW5pbWF0aW9uLnRpbWUgPiBhbmltYXRpb24uZHVyYXRpb24gfHwgYW5pbWF0aW9uLnRpbWUgPCAwICkge1xyXG5cclxuICAgIFx0XHRcdFx0YW5pbWF0aW9uLmRpcmVjdGlvbiAqPSAtIDE7XHJcblxyXG4gICAgXHRcdFx0XHRpZiAoIGFuaW1hdGlvbi50aW1lID4gYW5pbWF0aW9uLmR1cmF0aW9uICkge1xyXG5cclxuICAgIFx0XHRcdFx0XHRhbmltYXRpb24udGltZSA9IGFuaW1hdGlvbi5kdXJhdGlvbjtcclxuICAgIFx0XHRcdFx0XHRhbmltYXRpb24uZGlyZWN0aW9uQmFja3dhcmRzID0gdHJ1ZTtcclxuXHJcbiAgICBcdFx0XHRcdH1cclxuXHJcbiAgICBcdFx0XHRcdGlmICggYW5pbWF0aW9uLnRpbWUgPCAwICkge1xyXG5cclxuICAgIFx0XHRcdFx0XHRhbmltYXRpb24udGltZSA9IDA7XHJcbiAgICBcdFx0XHRcdFx0YW5pbWF0aW9uLmRpcmVjdGlvbkJhY2t3YXJkcyA9IGZhbHNlO1xyXG5cclxuICAgIFx0XHRcdFx0fVxyXG5cclxuICAgIFx0XHRcdH1cclxuXHJcbiAgICBcdFx0fSBlbHNlIHtcclxuXHJcbiAgICBcdFx0XHRhbmltYXRpb24udGltZSA9IGFuaW1hdGlvbi50aW1lICUgYW5pbWF0aW9uLmR1cmF0aW9uO1xyXG5cclxuICAgIFx0XHRcdGlmICggYW5pbWF0aW9uLnRpbWUgPCAwICkgYW5pbWF0aW9uLnRpbWUgKz0gYW5pbWF0aW9uLmR1cmF0aW9uO1xyXG5cclxuICAgIFx0XHR9XHJcblxyXG4gICAgXHRcdHZhciBrZXlmcmFtZSA9IGFuaW1hdGlvbi5zdGFydCArIGV4cG9ydHMuTWF0aC5jbGFtcCggTWF0aC5mbG9vciggYW5pbWF0aW9uLnRpbWUgLyBmcmFtZVRpbWUgKSwgMCwgYW5pbWF0aW9uLmxlbmd0aCAtIDEgKTtcclxuICAgIFx0XHR2YXIgd2VpZ2h0ID0gYW5pbWF0aW9uLndlaWdodDtcclxuXHJcbiAgICBcdFx0aWYgKCBrZXlmcmFtZSAhPT0gYW5pbWF0aW9uLmN1cnJlbnRGcmFtZSApIHtcclxuXHJcbiAgICBcdFx0XHR0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgYW5pbWF0aW9uLmxhc3RGcmFtZSBdID0gMDtcclxuICAgIFx0XHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBhbmltYXRpb24uY3VycmVudEZyYW1lIF0gPSAxICogd2VpZ2h0O1xyXG5cclxuICAgIFx0XHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBrZXlmcmFtZSBdID0gMDtcclxuXHJcbiAgICBcdFx0XHRhbmltYXRpb24ubGFzdEZyYW1lID0gYW5pbWF0aW9uLmN1cnJlbnRGcmFtZTtcclxuICAgIFx0XHRcdGFuaW1hdGlvbi5jdXJyZW50RnJhbWUgPSBrZXlmcmFtZTtcclxuXHJcbiAgICBcdFx0fVxyXG5cclxuICAgIFx0XHR2YXIgbWl4ID0gKCBhbmltYXRpb24udGltZSAlIGZyYW1lVGltZSApIC8gZnJhbWVUaW1lO1xyXG5cclxuICAgIFx0XHRpZiAoIGFuaW1hdGlvbi5kaXJlY3Rpb25CYWNrd2FyZHMgKSBtaXggPSAxIC0gbWl4O1xyXG5cclxuICAgIFx0XHRpZiAoIGFuaW1hdGlvbi5jdXJyZW50RnJhbWUgIT09IGFuaW1hdGlvbi5sYXN0RnJhbWUgKSB7XHJcblxyXG4gICAgXHRcdFx0dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXNbIGFuaW1hdGlvbi5jdXJyZW50RnJhbWUgXSA9IG1peCAqIHdlaWdodDtcclxuICAgIFx0XHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBhbmltYXRpb24ubGFzdEZyYW1lIF0gPSAoIDEgLSBtaXggKSAqIHdlaWdodDtcclxuXHJcbiAgICBcdFx0fSBlbHNlIHtcclxuXHJcbiAgICBcdFx0XHR0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgYW5pbWF0aW9uLmN1cnJlbnRGcmFtZSBdID0gd2VpZ2h0O1xyXG5cclxuICAgIFx0XHR9XHJcblxyXG4gICAgXHR9XHJcblxyXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBJbW1lZGlhdGVSZW5kZXJPYmplY3QoIG1hdGVyaWFsICkge1xuXG4gICAgXHRPYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cbiAgICBcdHRoaXMubWF0ZXJpYWwgPSBtYXRlcmlhbDtcbiAgICBcdHRoaXMucmVuZGVyID0gZnVuY3Rpb24gKCByZW5kZXJDYWxsYmFjayApIHt9O1xuXG4gICAgfVxuXG4gICAgSW1tZWRpYXRlUmVuZGVyT2JqZWN0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE9iamVjdDNELnByb3RvdHlwZSApO1xuICAgIEltbWVkaWF0ZVJlbmRlck9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBJbW1lZGlhdGVSZW5kZXJPYmplY3Q7XG5cbiAgICBJbW1lZGlhdGVSZW5kZXJPYmplY3QucHJvdG90eXBlLmlzSW1tZWRpYXRlUmVuZGVyT2JqZWN0ID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gICAgICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4gICAgKi9cblxuICAgIGZ1bmN0aW9uIFZlcnRleE5vcm1hbHNIZWxwZXIoIG9iamVjdCwgc2l6ZSwgaGV4LCBsaW5ld2lkdGggKSB7XG5cbiAgICBcdHRoaXMub2JqZWN0ID0gb2JqZWN0O1xuXG4gICAgXHR0aGlzLnNpemUgPSAoIHNpemUgIT09IHVuZGVmaW5lZCApID8gc2l6ZSA6IDE7XG5cbiAgICBcdHZhciBjb2xvciA9ICggaGV4ICE9PSB1bmRlZmluZWQgKSA/IGhleCA6IDB4ZmYwMDAwO1xuXG4gICAgXHR2YXIgd2lkdGggPSAoIGxpbmV3aWR0aCAhPT0gdW5kZWZpbmVkICkgPyBsaW5ld2lkdGggOiAxO1xuXG4gICAgXHQvL1xuXG4gICAgXHR2YXIgbk5vcm1hbHMgPSAwO1xuXG4gICAgXHR2YXIgb2JqR2VvbWV0cnkgPSB0aGlzLm9iamVjdC5nZW9tZXRyeTtcblxuICAgIFx0aWYgKCAob2JqR2VvbWV0cnkgJiYgb2JqR2VvbWV0cnkuaXNHZW9tZXRyeSkgKSB7XG5cbiAgICBcdFx0bk5vcm1hbHMgPSBvYmpHZW9tZXRyeS5mYWNlcy5sZW5ndGggKiAzO1xuXG4gICAgXHR9IGVsc2UgaWYgKCAob2JqR2VvbWV0cnkgJiYgb2JqR2VvbWV0cnkuaXNCdWZmZXJHZW9tZXRyeSkgKSB7XG5cbiAgICBcdFx0bk5vcm1hbHMgPSBvYmpHZW9tZXRyeS5hdHRyaWJ1dGVzLm5vcm1hbC5jb3VudDtcblxuICAgIFx0fVxuXG4gICAgXHQvL1xuXG4gICAgXHR2YXIgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblxuICAgIFx0dmFyIHBvc2l0aW9ucyA9IG5ldyBGbG9hdDMyQXR0cmlidXRlKCBuTm9ybWFscyAqIDIgKiAzLCAzICk7XG5cbiAgICBcdGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgcG9zaXRpb25zICk7XG5cbiAgICBcdExpbmVTZWdtZW50cy5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbmV3IExpbmVCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBjb2xvciwgbGluZXdpZHRoOiB3aWR0aCB9ICkgKTtcblxuICAgIFx0Ly9cblxuICAgIFx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cbiAgICBcdHRoaXMudXBkYXRlKCk7XG5cbiAgICB9XG5cbiAgICBWZXJ0ZXhOb3JtYWxzSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIExpbmVTZWdtZW50cy5wcm90b3R5cGUgKTtcbiAgICBWZXJ0ZXhOb3JtYWxzSGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFZlcnRleE5vcm1hbHNIZWxwZXI7XG5cbiAgICBWZXJ0ZXhOb3JtYWxzSGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSAoIGZ1bmN0aW9uICgpIHtcblxuICAgIFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoKTtcbiAgICBcdHZhciB2MiA9IG5ldyBWZWN0b3IzKCk7XG4gICAgXHR2YXIgbm9ybWFsTWF0cml4ID0gbmV3IE1hdHJpeDMoKTtcblxuICAgIFx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcblxuICAgIFx0XHR2YXIga2V5cyA9IFsgJ2EnLCAnYicsICdjJyBdO1xuXG4gICAgXHRcdHRoaXMub2JqZWN0LnVwZGF0ZU1hdHJpeFdvcmxkKCB0cnVlICk7XG5cbiAgICBcdFx0bm9ybWFsTWF0cml4LmdldE5vcm1hbE1hdHJpeCggdGhpcy5vYmplY3QubWF0cml4V29ybGQgKTtcblxuICAgIFx0XHR2YXIgbWF0cml4V29ybGQgPSB0aGlzLm9iamVjdC5tYXRyaXhXb3JsZDtcblxuICAgIFx0XHR2YXIgcG9zaXRpb24gPSB0aGlzLmdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cbiAgICBcdFx0Ly9cblxuICAgIFx0XHR2YXIgb2JqR2VvbWV0cnkgPSB0aGlzLm9iamVjdC5nZW9tZXRyeTtcblxuICAgIFx0XHRpZiAoIChvYmpHZW9tZXRyeSAmJiBvYmpHZW9tZXRyeS5pc0dlb21ldHJ5KSApIHtcblxuICAgIFx0XHRcdHZhciB2ZXJ0aWNlcyA9IG9iakdlb21ldHJ5LnZlcnRpY2VzO1xuXG4gICAgXHRcdFx0dmFyIGZhY2VzID0gb2JqR2VvbWV0cnkuZmFjZXM7XG5cbiAgICBcdFx0XHR2YXIgaWR4ID0gMDtcblxuICAgIFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGZhY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICBcdFx0XHRcdHZhciBmYWNlID0gZmFjZXNbIGkgXTtcblxuICAgIFx0XHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IGZhY2UudmVydGV4Tm9ybWFscy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuICAgIFx0XHRcdFx0XHR2YXIgdmVydGV4ID0gdmVydGljZXNbIGZhY2VbIGtleXNbIGogXSBdIF07XG5cbiAgICBcdFx0XHRcdFx0dmFyIG5vcm1hbCA9IGZhY2UudmVydGV4Tm9ybWFsc1sgaiBdO1xuXG4gICAgXHRcdFx0XHRcdHYxLmNvcHkoIHZlcnRleCApLmFwcGx5TWF0cml4NCggbWF0cml4V29ybGQgKTtcblxuICAgIFx0XHRcdFx0XHR2Mi5jb3B5KCBub3JtYWwgKS5hcHBseU1hdHJpeDMoIG5vcm1hbE1hdHJpeCApLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKCB0aGlzLnNpemUgKS5hZGQoIHYxICk7XG5cbiAgICBcdFx0XHRcdFx0cG9zaXRpb24uc2V0WFlaKCBpZHgsIHYxLngsIHYxLnksIHYxLnogKTtcblxuICAgIFx0XHRcdFx0XHRpZHggPSBpZHggKyAxO1xuXG4gICAgXHRcdFx0XHRcdHBvc2l0aW9uLnNldFhZWiggaWR4LCB2Mi54LCB2Mi55LCB2Mi56ICk7XG5cbiAgICBcdFx0XHRcdFx0aWR4ID0gaWR4ICsgMTtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH0gZWxzZSBpZiAoIChvYmpHZW9tZXRyeSAmJiBvYmpHZW9tZXRyeS5pc0J1ZmZlckdlb21ldHJ5KSApIHtcblxuICAgIFx0XHRcdHZhciBvYmpQb3MgPSBvYmpHZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXG4gICAgXHRcdFx0dmFyIG9iak5vcm0gPSBvYmpHZW9tZXRyeS5hdHRyaWJ1dGVzLm5vcm1hbDtcblxuICAgIFx0XHRcdHZhciBpZHggPSAwO1xuXG4gICAgXHRcdFx0Ly8gZm9yIHNpbXBsaWNpdHksIGlnbm9yZSBpbmRleCBhbmQgZHJhd2NhbGxzLCBhbmQgcmVuZGVyIGV2ZXJ5IG5vcm1hbFxuXG4gICAgXHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IG9ialBvcy5jb3VudDsgaiA8IGpsOyBqICsrICkge1xuXG4gICAgXHRcdFx0XHR2MS5zZXQoIG9ialBvcy5nZXRYKCBqICksIG9ialBvcy5nZXRZKCBqICksIG9ialBvcy5nZXRaKCBqICkgKS5hcHBseU1hdHJpeDQoIG1hdHJpeFdvcmxkICk7XG5cbiAgICBcdFx0XHRcdHYyLnNldCggb2JqTm9ybS5nZXRYKCBqICksIG9iak5vcm0uZ2V0WSggaiApLCBvYmpOb3JtLmdldFooIGogKSApO1xuXG4gICAgXHRcdFx0XHR2Mi5hcHBseU1hdHJpeDMoIG5vcm1hbE1hdHJpeCApLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKCB0aGlzLnNpemUgKS5hZGQoIHYxICk7XG5cbiAgICBcdFx0XHRcdHBvc2l0aW9uLnNldFhZWiggaWR4LCB2MS54LCB2MS55LCB2MS56ICk7XG5cbiAgICBcdFx0XHRcdGlkeCA9IGlkeCArIDE7XG5cbiAgICBcdFx0XHRcdHBvc2l0aW9uLnNldFhZWiggaWR4LCB2Mi54LCB2Mi55LCB2Mi56ICk7XG5cbiAgICBcdFx0XHRcdGlkeCA9IGlkeCArIDE7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHBvc2l0aW9uLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fTtcblxuICAgIH0oKSApO1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAgICAgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICAgICAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuICAgICovXG5cbiAgICBmdW5jdGlvbiBTcG90TGlnaHRIZWxwZXIoIGxpZ2h0ICkge1xuXG4gICAgXHRPYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cbiAgICBcdHRoaXMubGlnaHQgPSBsaWdodDtcbiAgICBcdHRoaXMubGlnaHQudXBkYXRlTWF0cml4V29ybGQoKTtcblxuICAgIFx0dGhpcy5tYXRyaXggPSBsaWdodC5tYXRyaXhXb3JsZDtcbiAgICBcdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXG4gICAgXHR2YXIgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblxuICAgIFx0dmFyIHBvc2l0aW9ucyA9IFtcbiAgICBcdFx0MCwgMCwgMCwgICAwLCAgIDAsICAgMSxcbiAgICBcdFx0MCwgMCwgMCwgICAxLCAgIDAsICAgMSxcbiAgICBcdFx0MCwgMCwgMCwgLSAxLCAgIDAsICAgMSxcbiAgICBcdFx0MCwgMCwgMCwgICAwLCAgIDEsICAgMSxcbiAgICBcdFx0MCwgMCwgMCwgICAwLCAtIDEsICAgMVxuICAgIFx0XTtcblxuICAgIFx0Zm9yICggdmFyIGkgPSAwLCBqID0gMSwgbCA9IDMyOyBpIDwgbDsgaSArKywgaiArKyApIHtcblxuICAgIFx0XHR2YXIgcDEgPSAoIGkgLyBsICkgKiBNYXRoLlBJICogMjtcbiAgICBcdFx0dmFyIHAyID0gKCBqIC8gbCApICogTWF0aC5QSSAqIDI7XG5cbiAgICBcdFx0cG9zaXRpb25zLnB1c2goXG4gICAgXHRcdFx0TWF0aC5jb3MoIHAxICksIE1hdGguc2luKCBwMSApLCAxLFxuICAgIFx0XHRcdE1hdGguY29zKCBwMiApLCBNYXRoLnNpbiggcDIgKSwgMVxuICAgIFx0XHQpO1xuXG4gICAgXHR9XG5cbiAgICBcdGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJBdHRyaWJ1dGUoIHBvc2l0aW9ucywgMyApICk7XG5cbiAgICBcdHZhciBtYXRlcmlhbCA9IG5ldyBMaW5lQmFzaWNNYXRlcmlhbCggeyBmb2c6IGZhbHNlIH0gKTtcblxuICAgIFx0dGhpcy5jb25lID0gbmV3IExpbmVTZWdtZW50cyggZ2VvbWV0cnksIG1hdGVyaWFsICk7XG4gICAgXHR0aGlzLmFkZCggdGhpcy5jb25lICk7XG5cbiAgICBcdHRoaXMudXBkYXRlKCk7XG5cbiAgICB9XG5cbiAgICBTcG90TGlnaHRIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggT2JqZWN0M0QucHJvdG90eXBlICk7XG4gICAgU3BvdExpZ2h0SGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNwb3RMaWdodEhlbHBlcjtcblxuICAgIFNwb3RMaWdodEhlbHBlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0dGhpcy5jb25lLmdlb21ldHJ5LmRpc3Bvc2UoKTtcbiAgICBcdHRoaXMuY29uZS5tYXRlcmlhbC5kaXNwb3NlKCk7XG5cbiAgICB9O1xuXG4gICAgU3BvdExpZ2h0SGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdHZhciB2ZWN0b3IgPSBuZXcgVmVjdG9yMygpO1xuICAgIFx0dmFyIHZlY3RvcjIgPSBuZXcgVmVjdG9yMygpO1xuXG4gICAgXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlKCkge1xuXG4gICAgXHRcdHZhciBjb25lTGVuZ3RoID0gdGhpcy5saWdodC5kaXN0YW5jZSA/IHRoaXMubGlnaHQuZGlzdGFuY2UgOiAxMDAwO1xuICAgIFx0XHR2YXIgY29uZVdpZHRoID0gY29uZUxlbmd0aCAqIE1hdGgudGFuKCB0aGlzLmxpZ2h0LmFuZ2xlICk7XG5cbiAgICBcdFx0dGhpcy5jb25lLnNjYWxlLnNldCggY29uZVdpZHRoLCBjb25lV2lkdGgsIGNvbmVMZW5ndGggKTtcblxuICAgIFx0XHR2ZWN0b3Iuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLmxpZ2h0Lm1hdHJpeFdvcmxkICk7XG4gICAgXHRcdHZlY3RvcjIuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLmxpZ2h0LnRhcmdldC5tYXRyaXhXb3JsZCApO1xuXG4gICAgXHRcdHRoaXMuY29uZS5sb29rQXQoIHZlY3RvcjIuc3ViKCB2ZWN0b3IgKSApO1xuXG4gICAgXHRcdHRoaXMuY29uZS5tYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmxpZ2h0LmNvbG9yICkubXVsdGlwbHlTY2FsYXIoIHRoaXMubGlnaHQuaW50ZW5zaXR5ICk7XG5cbiAgICBcdH07XG5cbiAgICB9KCk7XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIFNlYW4gR3JpZmZpbiAvIGh0dHA6Ly90d2l0dGVyLmNvbS9zZ3JpZlxuICAgICAqIEBhdXRob3IgTWljaGFlbCBHdWVycmVybyAvIGh0dHA6Ly9yZWFsaXR5bWVsdGRvd24uY29tXG4gICAgICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAgICAgKiBAYXV0aG9yIGlrZXJyIC8gaHR0cDovL3Zlcm9sZC5jb21cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIFNrZWxldG9uSGVscGVyKCBvYmplY3QgKSB7XG5cbiAgICBcdHRoaXMuYm9uZXMgPSB0aGlzLmdldEJvbmVMaXN0KCBvYmplY3QgKTtcblxuICAgIFx0dmFyIGdlb21ldHJ5ID0gbmV3IEdlb21ldHJ5KCk7XG5cbiAgICBcdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMuYm9uZXMubGVuZ3RoOyBpICsrICkge1xuXG4gICAgXHRcdHZhciBib25lID0gdGhpcy5ib25lc1sgaSBdO1xuXG4gICAgXHRcdGlmICggKGJvbmUucGFyZW50ICYmIGJvbmUucGFyZW50LmlzQm9uZSkgKSB7XG5cbiAgICBcdFx0XHRnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKCBuZXcgVmVjdG9yMygpICk7XG4gICAgXHRcdFx0Z2VvbWV0cnkudmVydGljZXMucHVzaCggbmV3IFZlY3RvcjMoKSApO1xuICAgIFx0XHRcdGdlb21ldHJ5LmNvbG9ycy5wdXNoKCBuZXcgQ29sb3IoIDAsIDAsIDEgKSApO1xuICAgIFx0XHRcdGdlb21ldHJ5LmNvbG9ycy5wdXNoKCBuZXcgQ29sb3IoIDAsIDEsIDAgKSApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0fVxuXG4gICAgXHRnZW9tZXRyeS5keW5hbWljID0gdHJ1ZTtcblxuICAgIFx0dmFyIG1hdGVyaWFsID0gbmV3IExpbmVCYXNpY01hdGVyaWFsKCB7IHZlcnRleENvbG9yczogVmVydGV4Q29sb3JzLCBkZXB0aFRlc3Q6IGZhbHNlLCBkZXB0aFdyaXRlOiBmYWxzZSwgdHJhbnNwYXJlbnQ6IHRydWUgfSApO1xuXG4gICAgXHRMaW5lU2VnbWVudHMuY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cbiAgICBcdHRoaXMucm9vdCA9IG9iamVjdDtcblxuICAgIFx0dGhpcy5tYXRyaXggPSBvYmplY3QubWF0cml4V29ybGQ7XG4gICAgXHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblxuICAgIFx0dGhpcy51cGRhdGUoKTtcblxuICAgIH1cblxuXG4gICAgU2tlbGV0b25IZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTGluZVNlZ21lbnRzLnByb3RvdHlwZSApO1xuICAgIFNrZWxldG9uSGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNrZWxldG9uSGVscGVyO1xuXG4gICAgU2tlbGV0b25IZWxwZXIucHJvdG90eXBlLmdldEJvbmVMaXN0ID0gZnVuY3Rpb24oIG9iamVjdCApIHtcblxuICAgIFx0dmFyIGJvbmVMaXN0ID0gW107XG5cbiAgICBcdGlmICggKG9iamVjdCAmJiBvYmplY3QuaXNCb25lKSApIHtcblxuICAgIFx0XHRib25lTGlzdC5wdXNoKCBvYmplY3QgKTtcblxuICAgIFx0fVxuXG4gICAgXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBvYmplY3QuY2hpbGRyZW4ubGVuZ3RoOyBpICsrICkge1xuXG4gICAgXHRcdGJvbmVMaXN0LnB1c2guYXBwbHkoIGJvbmVMaXN0LCB0aGlzLmdldEJvbmVMaXN0KCBvYmplY3QuY2hpbGRyZW5bIGkgXSApICk7XG5cbiAgICBcdH1cblxuICAgIFx0cmV0dXJuIGJvbmVMaXN0O1xuXG4gICAgfTtcblxuICAgIFNrZWxldG9uSGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdHZhciBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG5cbiAgICBcdHZhciBtYXRyaXhXb3JsZEludiA9IG5ldyBNYXRyaXg0KCkuZ2V0SW52ZXJzZSggdGhpcy5yb290Lm1hdHJpeFdvcmxkICk7XG5cbiAgICBcdHZhciBib25lTWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcblxuICAgIFx0dmFyIGogPSAwO1xuXG4gICAgXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmJvbmVzLmxlbmd0aDsgaSArKyApIHtcblxuICAgIFx0XHR2YXIgYm9uZSA9IHRoaXMuYm9uZXNbIGkgXTtcblxuICAgIFx0XHRpZiAoIChib25lLnBhcmVudCAmJiBib25lLnBhcmVudC5pc0JvbmUpICkge1xuXG4gICAgXHRcdFx0Ym9uZU1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBtYXRyaXhXb3JsZEludiwgYm9uZS5tYXRyaXhXb3JsZCApO1xuICAgIFx0XHRcdGdlb21ldHJ5LnZlcnRpY2VzWyBqIF0uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBib25lTWF0cml4ICk7XG5cbiAgICBcdFx0XHRib25lTWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIG1hdHJpeFdvcmxkSW52LCBib25lLnBhcmVudC5tYXRyaXhXb3JsZCApO1xuICAgIFx0XHRcdGdlb21ldHJ5LnZlcnRpY2VzWyBqICsgMSBdLnNldEZyb21NYXRyaXhQb3NpdGlvbiggYm9uZU1hdHJpeCApO1xuXG4gICAgXHRcdFx0aiArPSAyO1xuXG4gICAgXHRcdH1cblxuICAgIFx0fVxuXG4gICAgXHRnZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgPSB0cnVlO1xuXG4gICAgXHRnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcblxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICAgICAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBQb2ludExpZ2h0SGVscGVyKCBsaWdodCwgc3BoZXJlU2l6ZSApIHtcblxuICAgIFx0dGhpcy5saWdodCA9IGxpZ2h0O1xuICAgIFx0dGhpcy5saWdodC51cGRhdGVNYXRyaXhXb3JsZCgpO1xuXG4gICAgXHR2YXIgZ2VvbWV0cnkgPSBuZXcgU3BoZXJlQnVmZmVyR2VvbWV0cnkoIHNwaGVyZVNpemUsIDQsIDIgKTtcbiAgICBcdHZhciBtYXRlcmlhbCA9IG5ldyBNZXNoQmFzaWNNYXRlcmlhbCggeyB3aXJlZnJhbWU6IHRydWUsIGZvZzogZmFsc2UgfSApO1xuICAgIFx0bWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5saWdodC5jb2xvciApLm11bHRpcGx5U2NhbGFyKCB0aGlzLmxpZ2h0LmludGVuc2l0eSApO1xuXG4gICAgXHRNZXNoLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG4gICAgXHR0aGlzLm1hdHJpeCA9IHRoaXMubGlnaHQubWF0cml4V29ybGQ7XG4gICAgXHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblxuICAgIFx0LypcbiAgICBcdHZhciBkaXN0YW5jZUdlb21ldHJ5ID0gbmV3IFRIUkVFLkljb3NhaGVkcm9uR2VvbWV0cnkoIDEsIDIgKTtcbiAgICBcdHZhciBkaXN0YW5jZU1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBoZXhDb2xvciwgZm9nOiBmYWxzZSwgd2lyZWZyYW1lOiB0cnVlLCBvcGFjaXR5OiAwLjEsIHRyYW5zcGFyZW50OiB0cnVlIH0gKTtcblxuICAgIFx0dGhpcy5saWdodFNwaGVyZSA9IG5ldyBUSFJFRS5NZXNoKCBidWxiR2VvbWV0cnksIGJ1bGJNYXRlcmlhbCApO1xuICAgIFx0dGhpcy5saWdodERpc3RhbmNlID0gbmV3IFRIUkVFLk1lc2goIGRpc3RhbmNlR2VvbWV0cnksIGRpc3RhbmNlTWF0ZXJpYWwgKTtcblxuICAgIFx0dmFyIGQgPSBsaWdodC5kaXN0YW5jZTtcblxuICAgIFx0aWYgKCBkID09PSAwLjAgKSB7XG5cbiAgICBcdFx0dGhpcy5saWdodERpc3RhbmNlLnZpc2libGUgPSBmYWxzZTtcblxuICAgIFx0fSBlbHNlIHtcblxuICAgIFx0XHR0aGlzLmxpZ2h0RGlzdGFuY2Uuc2NhbGUuc2V0KCBkLCBkLCBkICk7XG5cbiAgICBcdH1cblxuICAgIFx0dGhpcy5hZGQoIHRoaXMubGlnaHREaXN0YW5jZSApO1xuICAgIFx0Ki9cblxuICAgIH1cblxuICAgIFBvaW50TGlnaHRIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTWVzaC5wcm90b3R5cGUgKTtcbiAgICBQb2ludExpZ2h0SGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBvaW50TGlnaHRIZWxwZXI7XG5cbiAgICBQb2ludExpZ2h0SGVscGVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXG4gICAgXHR0aGlzLmdlb21ldHJ5LmRpc3Bvc2UoKTtcbiAgICBcdHRoaXMubWF0ZXJpYWwuZGlzcG9zZSgpO1xuXG4gICAgfTtcblxuICAgIFBvaW50TGlnaHRIZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0dGhpcy5tYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmxpZ2h0LmNvbG9yICkubXVsdGlwbHlTY2FsYXIoIHRoaXMubGlnaHQuaW50ZW5zaXR5ICk7XG5cbiAgICBcdC8qXG4gICAgXHR2YXIgZCA9IHRoaXMubGlnaHQuZGlzdGFuY2U7XG5cbiAgICBcdGlmICggZCA9PT0gMC4wICkge1xuXG4gICAgXHRcdHRoaXMubGlnaHREaXN0YW5jZS52aXNpYmxlID0gZmFsc2U7XG5cbiAgICBcdH0gZWxzZSB7XG5cbiAgICBcdFx0dGhpcy5saWdodERpc3RhbmNlLnZpc2libGUgPSB0cnVlO1xuICAgIFx0XHR0aGlzLmxpZ2h0RGlzdGFuY2Uuc2NhbGUuc2V0KCBkLCBkLCBkICk7XG5cbiAgICBcdH1cbiAgICBcdCovXG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAgICAgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gSGVtaXNwaGVyZUxpZ2h0SGVscGVyKCBsaWdodCwgc3BoZXJlU2l6ZSApIHtcblxuICAgIFx0T2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG4gICAgXHR0aGlzLmxpZ2h0ID0gbGlnaHQ7XG4gICAgXHR0aGlzLmxpZ2h0LnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG5cbiAgICBcdHRoaXMubWF0cml4ID0gbGlnaHQubWF0cml4V29ybGQ7XG4gICAgXHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblxuICAgIFx0dGhpcy5jb2xvcnMgPSBbIG5ldyBDb2xvcigpLCBuZXcgQ29sb3IoKSBdO1xuXG4gICAgXHR2YXIgZ2VvbWV0cnkgPSBuZXcgU3BoZXJlR2VvbWV0cnkoIHNwaGVyZVNpemUsIDQsIDIgKTtcbiAgICBcdGdlb21ldHJ5LnJvdGF0ZVgoIC0gTWF0aC5QSSAvIDIgKTtcblxuICAgIFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IDg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgIFx0XHRnZW9tZXRyeS5mYWNlc1sgaSBdLmNvbG9yID0gdGhpcy5jb2xvcnNbIGkgPCA0ID8gMCA6IDEgXTtcblxuICAgIFx0fVxuXG4gICAgXHR2YXIgbWF0ZXJpYWwgPSBuZXcgTWVzaEJhc2ljTWF0ZXJpYWwoIHsgdmVydGV4Q29sb3JzOiBGYWNlQ29sb3JzLCB3aXJlZnJhbWU6IHRydWUgfSApO1xuXG4gICAgXHR0aGlzLmxpZ2h0U3BoZXJlID0gbmV3IE1lc2goIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuICAgIFx0dGhpcy5hZGQoIHRoaXMubGlnaHRTcGhlcmUgKTtcblxuICAgIFx0dGhpcy51cGRhdGUoKTtcblxuICAgIH1cblxuICAgIEhlbWlzcGhlcmVMaWdodEhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBPYmplY3QzRC5wcm90b3R5cGUgKTtcbiAgICBIZW1pc3BoZXJlTGlnaHRIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSGVtaXNwaGVyZUxpZ2h0SGVscGVyO1xuXG4gICAgSGVtaXNwaGVyZUxpZ2h0SGVscGVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXG4gICAgXHR0aGlzLmxpZ2h0U3BoZXJlLmdlb21ldHJ5LmRpc3Bvc2UoKTtcbiAgICBcdHRoaXMubGlnaHRTcGhlcmUubWF0ZXJpYWwuZGlzcG9zZSgpO1xuXG4gICAgfTtcblxuICAgIEhlbWlzcGhlcmVMaWdodEhlbHBlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuXG4gICAgXHR2YXIgdmVjdG9yID0gbmV3IFZlY3RvcjMoKTtcblxuICAgIFx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcblxuICAgIFx0XHR0aGlzLmNvbG9yc1sgMCBdLmNvcHkoIHRoaXMubGlnaHQuY29sb3IgKS5tdWx0aXBseVNjYWxhciggdGhpcy5saWdodC5pbnRlbnNpdHkgKTtcbiAgICBcdFx0dGhpcy5jb2xvcnNbIDEgXS5jb3B5KCB0aGlzLmxpZ2h0Lmdyb3VuZENvbG9yICkubXVsdGlwbHlTY2FsYXIoIHRoaXMubGlnaHQuaW50ZW5zaXR5ICk7XG5cbiAgICBcdFx0dGhpcy5saWdodFNwaGVyZS5sb29rQXQoIHZlY3Rvci5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubGlnaHQubWF0cml4V29ybGQgKS5uZWdhdGUoKSApO1xuICAgIFx0XHR0aGlzLmxpZ2h0U3BoZXJlLmdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGUgPSB0cnVlO1xuXG4gICAgXHR9O1xuXG4gICAgfSgpO1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIEdyaWRIZWxwZXIoIHNpemUsIGRpdmlzaW9ucywgY29sb3IxLCBjb2xvcjIgKSB7XG5cbiAgICBcdGRpdmlzaW9ucyA9IGRpdmlzaW9ucyB8fCAxO1xuICAgIFx0Y29sb3IxID0gbmV3IENvbG9yKCBjb2xvcjEgIT09IHVuZGVmaW5lZCA/IGNvbG9yMSA6IDB4NDQ0NDQ0ICk7XG4gICAgXHRjb2xvcjIgPSBuZXcgQ29sb3IoIGNvbG9yMiAhPT0gdW5kZWZpbmVkID8gY29sb3IyIDogMHg4ODg4ODggKTtcblxuICAgIFx0dmFyIGNlbnRlciA9IGRpdmlzaW9ucyAvIDI7XG4gICAgXHR2YXIgc3RlcCA9ICggc2l6ZSAqIDIgKSAvIGRpdmlzaW9ucztcbiAgICBcdHZhciB2ZXJ0aWNlcyA9IFtdLCBjb2xvcnMgPSBbXTtcblxuICAgIFx0Zm9yICggdmFyIGkgPSAwLCBqID0gMCwgayA9IC0gc2l6ZTsgaSA8PSBkaXZpc2lvbnM7IGkgKyssIGsgKz0gc3RlcCApIHtcblxuICAgIFx0XHR2ZXJ0aWNlcy5wdXNoKCAtIHNpemUsIDAsIGssIHNpemUsIDAsIGsgKTtcbiAgICBcdFx0dmVydGljZXMucHVzaCggaywgMCwgLSBzaXplLCBrLCAwLCBzaXplICk7XG5cbiAgICBcdFx0dmFyIGNvbG9yID0gaSA9PT0gY2VudGVyID8gY29sb3IxIDogY29sb3IyO1xuXG4gICAgXHRcdGNvbG9yLnRvQXJyYXkoIGNvbG9ycywgaiApOyBqICs9IDM7XG4gICAgXHRcdGNvbG9yLnRvQXJyYXkoIGNvbG9ycywgaiApOyBqICs9IDM7XG4gICAgXHRcdGNvbG9yLnRvQXJyYXkoIGNvbG9ycywgaiApOyBqICs9IDM7XG4gICAgXHRcdGNvbG9yLnRvQXJyYXkoIGNvbG9ycywgaiApOyBqICs9IDM7XG5cbiAgICBcdH1cblxuICAgIFx0dmFyIGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG4gICAgXHRnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XG4gICAgXHRnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdjb2xvcicsIG5ldyBGbG9hdDMyQXR0cmlidXRlKCBjb2xvcnMsIDMgKSApO1xuXG4gICAgXHR2YXIgbWF0ZXJpYWwgPSBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoIHsgdmVydGV4Q29sb3JzOiBWZXJ0ZXhDb2xvcnMgfSApO1xuXG4gICAgXHRMaW5lU2VnbWVudHMuY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cbiAgICB9XG5cbiAgICBHcmlkSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIExpbmVTZWdtZW50cy5wcm90b3R5cGUgKTtcbiAgICBHcmlkSGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdyaWRIZWxwZXI7XG5cbiAgICBHcmlkSGVscGVyLnByb3RvdHlwZS5zZXRDb2xvcnMgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5HcmlkSGVscGVyOiBzZXRDb2xvcnMoKSBoYXMgYmVlbiBkZXByZWNhdGVkLCBwYXNzIHRoZW0gaW4gdGhlIGNvbnN0cnVjdG9yIGluc3RlYWQuJyApO1xuXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gICAgICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4gICAgKi9cblxuICAgIGZ1bmN0aW9uIEZhY2VOb3JtYWxzSGVscGVyKCBvYmplY3QsIHNpemUsIGhleCwgbGluZXdpZHRoICkge1xuXG4gICAgXHQvLyBGYWNlTm9ybWFsc0hlbHBlciBvbmx5IHN1cHBvcnRzIFRIUkVFLkdlb21ldHJ5XG5cbiAgICBcdHRoaXMub2JqZWN0ID0gb2JqZWN0O1xuXG4gICAgXHR0aGlzLnNpemUgPSAoIHNpemUgIT09IHVuZGVmaW5lZCApID8gc2l6ZSA6IDE7XG5cbiAgICBcdHZhciBjb2xvciA9ICggaGV4ICE9PSB1bmRlZmluZWQgKSA/IGhleCA6IDB4ZmZmZjAwO1xuXG4gICAgXHR2YXIgd2lkdGggPSAoIGxpbmV3aWR0aCAhPT0gdW5kZWZpbmVkICkgPyBsaW5ld2lkdGggOiAxO1xuXG4gICAgXHQvL1xuXG4gICAgXHR2YXIgbk5vcm1hbHMgPSAwO1xuXG4gICAgXHR2YXIgb2JqR2VvbWV0cnkgPSB0aGlzLm9iamVjdC5nZW9tZXRyeTtcblxuICAgIFx0aWYgKCAob2JqR2VvbWV0cnkgJiYgb2JqR2VvbWV0cnkuaXNHZW9tZXRyeSkgKSB7XG5cbiAgICBcdFx0bk5vcm1hbHMgPSBvYmpHZW9tZXRyeS5mYWNlcy5sZW5ndGg7XG5cbiAgICBcdH0gZWxzZSB7XG5cbiAgICBcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuRmFjZU5vcm1hbHNIZWxwZXI6IG9ubHkgVEhSRUUuR2VvbWV0cnkgaXMgc3VwcG9ydGVkLiBVc2UgVEhSRUUuVmVydGV4Tm9ybWFsc0hlbHBlciwgaW5zdGVhZC4nICk7XG5cbiAgICBcdH1cblxuICAgIFx0Ly9cblxuICAgIFx0dmFyIGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cbiAgICBcdHZhciBwb3NpdGlvbnMgPSBuZXcgRmxvYXQzMkF0dHJpYnV0ZSggbk5vcm1hbHMgKiAyICogMywgMyApO1xuXG4gICAgXHRnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIHBvc2l0aW9ucyApO1xuXG4gICAgXHRMaW5lU2VnbWVudHMuY2FsbCggdGhpcywgZ2VvbWV0cnksIG5ldyBMaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogY29sb3IsIGxpbmV3aWR0aDogd2lkdGggfSApICk7XG5cbiAgICBcdC8vXG5cbiAgICBcdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuICAgIFx0dGhpcy51cGRhdGUoKTtcblxuICAgIH1cblxuICAgIEZhY2VOb3JtYWxzSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIExpbmVTZWdtZW50cy5wcm90b3R5cGUgKTtcbiAgICBGYWNlTm9ybWFsc0hlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBGYWNlTm9ybWFsc0hlbHBlcjtcblxuICAgIEZhY2VOb3JtYWxzSGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSAoIGZ1bmN0aW9uICgpIHtcblxuICAgIFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoKTtcbiAgICBcdHZhciB2MiA9IG5ldyBWZWN0b3IzKCk7XG4gICAgXHR2YXIgbm9ybWFsTWF0cml4ID0gbmV3IE1hdHJpeDMoKTtcblxuICAgIFx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcblxuICAgIFx0XHR0aGlzLm9iamVjdC51cGRhdGVNYXRyaXhXb3JsZCggdHJ1ZSApO1xuXG4gICAgXHRcdG5vcm1hbE1hdHJpeC5nZXROb3JtYWxNYXRyaXgoIHRoaXMub2JqZWN0Lm1hdHJpeFdvcmxkICk7XG5cbiAgICBcdFx0dmFyIG1hdHJpeFdvcmxkID0gdGhpcy5vYmplY3QubWF0cml4V29ybGQ7XG5cbiAgICBcdFx0dmFyIHBvc2l0aW9uID0gdGhpcy5nZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXG4gICAgXHRcdC8vXG5cbiAgICBcdFx0dmFyIG9iakdlb21ldHJ5ID0gdGhpcy5vYmplY3QuZ2VvbWV0cnk7XG5cbiAgICBcdFx0dmFyIHZlcnRpY2VzID0gb2JqR2VvbWV0cnkudmVydGljZXM7XG5cbiAgICBcdFx0dmFyIGZhY2VzID0gb2JqR2VvbWV0cnkuZmFjZXM7XG5cbiAgICBcdFx0dmFyIGlkeCA9IDA7XG5cbiAgICBcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gZmFjZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgIFx0XHRcdHZhciBmYWNlID0gZmFjZXNbIGkgXTtcblxuICAgIFx0XHRcdHZhciBub3JtYWwgPSBmYWNlLm5vcm1hbDtcblxuICAgIFx0XHRcdHYxLmNvcHkoIHZlcnRpY2VzWyBmYWNlLmEgXSApXG4gICAgXHRcdFx0XHQuYWRkKCB2ZXJ0aWNlc1sgZmFjZS5iIF0gKVxuICAgIFx0XHRcdFx0LmFkZCggdmVydGljZXNbIGZhY2UuYyBdIClcbiAgICBcdFx0XHRcdC5kaXZpZGVTY2FsYXIoIDMgKVxuICAgIFx0XHRcdFx0LmFwcGx5TWF0cml4NCggbWF0cml4V29ybGQgKTtcblxuICAgIFx0XHRcdHYyLmNvcHkoIG5vcm1hbCApLmFwcGx5TWF0cml4Myggbm9ybWFsTWF0cml4ICkubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIoIHRoaXMuc2l6ZSApLmFkZCggdjEgKTtcblxuICAgIFx0XHRcdHBvc2l0aW9uLnNldFhZWiggaWR4LCB2MS54LCB2MS55LCB2MS56ICk7XG5cbiAgICBcdFx0XHRpZHggPSBpZHggKyAxO1xuXG4gICAgXHRcdFx0cG9zaXRpb24uc2V0WFlaKCBpZHgsIHYyLngsIHYyLnksIHYyLnogKTtcblxuICAgIFx0XHRcdGlkeCA9IGlkeCArIDE7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHBvc2l0aW9uLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fTtcblxuICAgIH0oKSApO1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAgICAgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICAgICAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gRGlyZWN0aW9uYWxMaWdodEhlbHBlciggbGlnaHQsIHNpemUgKSB7XG5cbiAgICBcdE9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuICAgIFx0dGhpcy5saWdodCA9IGxpZ2h0O1xuICAgIFx0dGhpcy5saWdodC51cGRhdGVNYXRyaXhXb3JsZCgpO1xuXG4gICAgXHR0aGlzLm1hdHJpeCA9IGxpZ2h0Lm1hdHJpeFdvcmxkO1xuICAgIFx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cbiAgICBcdGlmICggc2l6ZSA9PT0gdW5kZWZpbmVkICkgc2l6ZSA9IDE7XG5cbiAgICBcdHZhciBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuICAgIFx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkF0dHJpYnV0ZSggW1xuICAgIFx0XHQtIHNpemUsICAgc2l6ZSwgMCxcbiAgICBcdFx0ICBzaXplLCAgIHNpemUsIDAsXG4gICAgXHRcdCAgc2l6ZSwgLSBzaXplLCAwLFxuICAgIFx0XHQtIHNpemUsIC0gc2l6ZSwgMCxcbiAgICBcdFx0LSBzaXplLCAgIHNpemUsIDBcbiAgICBcdF0sIDMgKSApO1xuXG4gICAgXHR2YXIgbWF0ZXJpYWwgPSBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoIHsgZm9nOiBmYWxzZSB9ICk7XG5cbiAgICBcdHRoaXMuYWRkKCBuZXcgTGluZSggZ2VvbWV0cnksIG1hdGVyaWFsICkgKTtcblxuICAgIFx0Z2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcbiAgICBcdGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJBdHRyaWJ1dGUoIFsgMCwgMCwgMCwgMCwgMCwgMSBdLCAzICkgKTtcblxuICAgIFx0dGhpcy5hZGQoIG5ldyBMaW5lKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKSk7XG5cbiAgICBcdHRoaXMudXBkYXRlKCk7XG5cbiAgICB9XG5cbiAgICBEaXJlY3Rpb25hbExpZ2h0SGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE9iamVjdDNELnByb3RvdHlwZSApO1xuICAgIERpcmVjdGlvbmFsTGlnaHRIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRGlyZWN0aW9uYWxMaWdodEhlbHBlcjtcblxuICAgIERpcmVjdGlvbmFsTGlnaHRIZWxwZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdHZhciBsaWdodFBsYW5lID0gdGhpcy5jaGlsZHJlblsgMCBdO1xuICAgIFx0dmFyIHRhcmdldExpbmUgPSB0aGlzLmNoaWxkcmVuWyAxIF07XG5cbiAgICBcdGxpZ2h0UGxhbmUuZ2VvbWV0cnkuZGlzcG9zZSgpO1xuICAgIFx0bGlnaHRQbGFuZS5tYXRlcmlhbC5kaXNwb3NlKCk7XG4gICAgXHR0YXJnZXRMaW5lLmdlb21ldHJ5LmRpc3Bvc2UoKTtcbiAgICBcdHRhcmdldExpbmUubWF0ZXJpYWwuZGlzcG9zZSgpO1xuXG4gICAgfTtcblxuICAgIERpcmVjdGlvbmFsTGlnaHRIZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoKTtcbiAgICBcdHZhciB2MiA9IG5ldyBWZWN0b3IzKCk7XG4gICAgXHR2YXIgdjMgPSBuZXcgVmVjdG9yMygpO1xuXG4gICAgXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlKCkge1xuXG4gICAgXHRcdHYxLnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5saWdodC5tYXRyaXhXb3JsZCApO1xuICAgIFx0XHR2Mi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubGlnaHQudGFyZ2V0Lm1hdHJpeFdvcmxkICk7XG4gICAgXHRcdHYzLnN1YlZlY3RvcnMoIHYyLCB2MSApO1xuXG4gICAgXHRcdHZhciBsaWdodFBsYW5lID0gdGhpcy5jaGlsZHJlblsgMCBdO1xuICAgIFx0XHR2YXIgdGFyZ2V0TGluZSA9IHRoaXMuY2hpbGRyZW5bIDEgXTtcblxuICAgIFx0XHRsaWdodFBsYW5lLmxvb2tBdCggdjMgKTtcbiAgICBcdFx0bGlnaHRQbGFuZS5tYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmxpZ2h0LmNvbG9yICkubXVsdGlwbHlTY2FsYXIoIHRoaXMubGlnaHQuaW50ZW5zaXR5ICk7XG5cbiAgICBcdFx0dGFyZ2V0TGluZS5sb29rQXQoIHYzICk7XG4gICAgXHRcdHRhcmdldExpbmUuc2NhbGUueiA9IHYzLmxlbmd0aCgpO1xuXG4gICAgXHR9O1xuXG4gICAgfSgpO1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAgICAgKlxuICAgICAqXHQtIHNob3dzIGZydXN0dW0sIGxpbmUgb2Ygc2lnaHQgYW5kIHVwIG9mIHRoZSBjYW1lcmFcbiAgICAgKlx0LSBzdWl0YWJsZSBmb3IgZmFzdCB1cGRhdGVzXG4gICAgICogXHQtIGJhc2VkIG9uIGZydXN0dW0gdmlzdWFsaXphdGlvbiBpbiBsaWdodGdsLmpzIHNoYWRvd21hcCBleGFtcGxlXG4gICAgICpcdFx0aHR0cDovL2V2YW53LmdpdGh1Yi5jb20vbGlnaHRnbC5qcy90ZXN0cy9zaGFkb3dtYXAuaHRtbFxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gQ2FtZXJhSGVscGVyKCBjYW1lcmEgKSB7XG5cbiAgICBcdHZhciBnZW9tZXRyeSA9IG5ldyBHZW9tZXRyeSgpO1xuICAgIFx0dmFyIG1hdGVyaWFsID0gbmV3IExpbmVCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiAweGZmZmZmZiwgdmVydGV4Q29sb3JzOiBGYWNlQ29sb3JzIH0gKTtcblxuICAgIFx0dmFyIHBvaW50TWFwID0ge307XG5cbiAgICBcdC8vIGNvbG9yc1xuXG4gICAgXHR2YXIgaGV4RnJ1c3R1bSA9IDB4ZmZhYTAwO1xuICAgIFx0dmFyIGhleENvbmUgPSAweGZmMDAwMDtcbiAgICBcdHZhciBoZXhVcCA9IDB4MDBhYWZmO1xuICAgIFx0dmFyIGhleFRhcmdldCA9IDB4ZmZmZmZmO1xuICAgIFx0dmFyIGhleENyb3NzID0gMHgzMzMzMzM7XG5cbiAgICBcdC8vIG5lYXJcblxuICAgIFx0YWRkTGluZSggXCJuMVwiLCBcIm4yXCIsIGhleEZydXN0dW0gKTtcbiAgICBcdGFkZExpbmUoIFwibjJcIiwgXCJuNFwiLCBoZXhGcnVzdHVtICk7XG4gICAgXHRhZGRMaW5lKCBcIm40XCIsIFwibjNcIiwgaGV4RnJ1c3R1bSApO1xuICAgIFx0YWRkTGluZSggXCJuM1wiLCBcIm4xXCIsIGhleEZydXN0dW0gKTtcblxuICAgIFx0Ly8gZmFyXG5cbiAgICBcdGFkZExpbmUoIFwiZjFcIiwgXCJmMlwiLCBoZXhGcnVzdHVtICk7XG4gICAgXHRhZGRMaW5lKCBcImYyXCIsIFwiZjRcIiwgaGV4RnJ1c3R1bSApO1xuICAgIFx0YWRkTGluZSggXCJmNFwiLCBcImYzXCIsIGhleEZydXN0dW0gKTtcbiAgICBcdGFkZExpbmUoIFwiZjNcIiwgXCJmMVwiLCBoZXhGcnVzdHVtICk7XG5cbiAgICBcdC8vIHNpZGVzXG5cbiAgICBcdGFkZExpbmUoIFwibjFcIiwgXCJmMVwiLCBoZXhGcnVzdHVtICk7XG4gICAgXHRhZGRMaW5lKCBcIm4yXCIsIFwiZjJcIiwgaGV4RnJ1c3R1bSApO1xuICAgIFx0YWRkTGluZSggXCJuM1wiLCBcImYzXCIsIGhleEZydXN0dW0gKTtcbiAgICBcdGFkZExpbmUoIFwibjRcIiwgXCJmNFwiLCBoZXhGcnVzdHVtICk7XG5cbiAgICBcdC8vIGNvbmVcblxuICAgIFx0YWRkTGluZSggXCJwXCIsIFwibjFcIiwgaGV4Q29uZSApO1xuICAgIFx0YWRkTGluZSggXCJwXCIsIFwibjJcIiwgaGV4Q29uZSApO1xuICAgIFx0YWRkTGluZSggXCJwXCIsIFwibjNcIiwgaGV4Q29uZSApO1xuICAgIFx0YWRkTGluZSggXCJwXCIsIFwibjRcIiwgaGV4Q29uZSApO1xuXG4gICAgXHQvLyB1cFxuXG4gICAgXHRhZGRMaW5lKCBcInUxXCIsIFwidTJcIiwgaGV4VXAgKTtcbiAgICBcdGFkZExpbmUoIFwidTJcIiwgXCJ1M1wiLCBoZXhVcCApO1xuICAgIFx0YWRkTGluZSggXCJ1M1wiLCBcInUxXCIsIGhleFVwICk7XG5cbiAgICBcdC8vIHRhcmdldFxuXG4gICAgXHRhZGRMaW5lKCBcImNcIiwgXCJ0XCIsIGhleFRhcmdldCApO1xuICAgIFx0YWRkTGluZSggXCJwXCIsIFwiY1wiLCBoZXhDcm9zcyApO1xuXG4gICAgXHQvLyBjcm9zc1xuXG4gICAgXHRhZGRMaW5lKCBcImNuMVwiLCBcImNuMlwiLCBoZXhDcm9zcyApO1xuICAgIFx0YWRkTGluZSggXCJjbjNcIiwgXCJjbjRcIiwgaGV4Q3Jvc3MgKTtcblxuICAgIFx0YWRkTGluZSggXCJjZjFcIiwgXCJjZjJcIiwgaGV4Q3Jvc3MgKTtcbiAgICBcdGFkZExpbmUoIFwiY2YzXCIsIFwiY2Y0XCIsIGhleENyb3NzICk7XG5cbiAgICBcdGZ1bmN0aW9uIGFkZExpbmUoIGEsIGIsIGhleCApIHtcblxuICAgIFx0XHRhZGRQb2ludCggYSwgaGV4ICk7XG4gICAgXHRcdGFkZFBvaW50KCBiLCBoZXggKTtcblxuICAgIFx0fVxuXG4gICAgXHRmdW5jdGlvbiBhZGRQb2ludCggaWQsIGhleCApIHtcblxuICAgIFx0XHRnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKCBuZXcgVmVjdG9yMygpICk7XG4gICAgXHRcdGdlb21ldHJ5LmNvbG9ycy5wdXNoKCBuZXcgQ29sb3IoIGhleCApICk7XG5cbiAgICBcdFx0aWYgKCBwb2ludE1hcFsgaWQgXSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0cG9pbnRNYXBbIGlkIF0gPSBbXTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cG9pbnRNYXBbIGlkIF0ucHVzaCggZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoIC0gMSApO1xuXG4gICAgXHR9XG5cbiAgICBcdExpbmVTZWdtZW50cy5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblxuICAgIFx0dGhpcy5jYW1lcmEgPSBjYW1lcmE7XG4gICAgXHRpZiggdGhpcy5jYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCApIHRoaXMuY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblxuICAgIFx0dGhpcy5tYXRyaXggPSBjYW1lcmEubWF0cml4V29ybGQ7XG4gICAgXHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblxuICAgIFx0dGhpcy5wb2ludE1hcCA9IHBvaW50TWFwO1xuXG4gICAgXHR0aGlzLnVwZGF0ZSgpO1xuXG4gICAgfVxuXG4gICAgQ2FtZXJhSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIExpbmVTZWdtZW50cy5wcm90b3R5cGUgKTtcbiAgICBDYW1lcmFIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2FtZXJhSGVscGVyO1xuXG4gICAgQ2FtZXJhSGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdHZhciBnZW9tZXRyeSwgcG9pbnRNYXA7XG5cbiAgICBcdHZhciB2ZWN0b3IgPSBuZXcgVmVjdG9yMygpO1xuICAgIFx0dmFyIGNhbWVyYSA9IG5ldyBDYW1lcmEoKTtcblxuICAgIFx0ZnVuY3Rpb24gc2V0UG9pbnQoIHBvaW50LCB4LCB5LCB6ICkge1xuXG4gICAgXHRcdHZlY3Rvci5zZXQoIHgsIHksIHogKS51bnByb2plY3QoIGNhbWVyYSApO1xuXG4gICAgXHRcdHZhciBwb2ludHMgPSBwb2ludE1hcFsgcG9pbnQgXTtcblxuICAgIFx0XHRpZiAoIHBvaW50cyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgIFx0XHRcdFx0Z2VvbWV0cnkudmVydGljZXNbIHBvaW50c1sgaSBdIF0uY29weSggdmVjdG9yICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9XG5cbiAgICBcdHJldHVybiBmdW5jdGlvbiB1cGRhdGUoKSB7XG5cbiAgICBcdFx0Z2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuICAgIFx0XHRwb2ludE1hcCA9IHRoaXMucG9pbnRNYXA7XG5cbiAgICBcdFx0dmFyIHcgPSAxLCBoID0gMTtcblxuICAgIFx0XHQvLyB3ZSBuZWVkIGp1c3QgY2FtZXJhIHByb2plY3Rpb24gbWF0cml4XG4gICAgXHRcdC8vIHdvcmxkIG1hdHJpeCBtdXN0IGJlIGlkZW50aXR5XG5cbiAgICBcdFx0Y2FtZXJhLnByb2plY3Rpb25NYXRyaXguY29weSggdGhpcy5jYW1lcmEucHJvamVjdGlvbk1hdHJpeCApO1xuXG4gICAgXHRcdC8vIGNlbnRlciAvIHRhcmdldFxuXG4gICAgXHRcdHNldFBvaW50KCBcImNcIiwgMCwgMCwgLSAxICk7XG4gICAgXHRcdHNldFBvaW50KCBcInRcIiwgMCwgMCwgIDEgKTtcblxuICAgIFx0XHQvLyBuZWFyXG5cbiAgICBcdFx0c2V0UG9pbnQoIFwibjFcIiwgLSB3LCAtIGgsIC0gMSApO1xuICAgIFx0XHRzZXRQb2ludCggXCJuMlwiLCAgIHcsIC0gaCwgLSAxICk7XG4gICAgXHRcdHNldFBvaW50KCBcIm4zXCIsIC0gdywgICBoLCAtIDEgKTtcbiAgICBcdFx0c2V0UG9pbnQoIFwibjRcIiwgICB3LCAgIGgsIC0gMSApO1xuXG4gICAgXHRcdC8vIGZhclxuXG4gICAgXHRcdHNldFBvaW50KCBcImYxXCIsIC0gdywgLSBoLCAxICk7XG4gICAgXHRcdHNldFBvaW50KCBcImYyXCIsICAgdywgLSBoLCAxICk7XG4gICAgXHRcdHNldFBvaW50KCBcImYzXCIsIC0gdywgICBoLCAxICk7XG4gICAgXHRcdHNldFBvaW50KCBcImY0XCIsICAgdywgICBoLCAxICk7XG5cbiAgICBcdFx0Ly8gdXBcblxuICAgIFx0XHRzZXRQb2ludCggXCJ1MVwiLCAgIHcgKiAwLjcsIGggKiAxLjEsIC0gMSApO1xuICAgIFx0XHRzZXRQb2ludCggXCJ1MlwiLCAtIHcgKiAwLjcsIGggKiAxLjEsIC0gMSApO1xuICAgIFx0XHRzZXRQb2ludCggXCJ1M1wiLCAgICAgICAgIDAsIGggKiAyLCAgIC0gMSApO1xuXG4gICAgXHRcdC8vIGNyb3NzXG5cbiAgICBcdFx0c2V0UG9pbnQoIFwiY2YxXCIsIC0gdywgICAwLCAxICk7XG4gICAgXHRcdHNldFBvaW50KCBcImNmMlwiLCAgIHcsICAgMCwgMSApO1xuICAgIFx0XHRzZXRQb2ludCggXCJjZjNcIiwgICAwLCAtIGgsIDEgKTtcbiAgICBcdFx0c2V0UG9pbnQoIFwiY2Y0XCIsICAgMCwgICBoLCAxICk7XG5cbiAgICBcdFx0c2V0UG9pbnQoIFwiY24xXCIsIC0gdywgICAwLCAtIDEgKTtcbiAgICBcdFx0c2V0UG9pbnQoIFwiY24yXCIsICAgdywgICAwLCAtIDEgKTtcbiAgICBcdFx0c2V0UG9pbnQoIFwiY24zXCIsICAgMCwgLSBoLCAtIDEgKTtcbiAgICBcdFx0c2V0UG9pbnQoIFwiY240XCIsICAgMCwgICBoLCAtIDEgKTtcblxuICAgIFx0XHRnZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgPSB0cnVlO1xuXG4gICAgXHR9O1xuXG4gICAgfSgpO1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4gICAgICovXG5cbiAgICAvLyBhIGhlbHBlciB0byBzaG93IHRoZSB3b3JsZC1heGlzLWFsaWduZWQgYm91bmRpbmcgYm94IGZvciBhbiBvYmplY3RcblxuICAgIGZ1bmN0aW9uIEJvdW5kaW5nQm94SGVscGVyKCBvYmplY3QsIGhleCApIHtcblxuICAgIFx0dmFyIGNvbG9yID0gKCBoZXggIT09IHVuZGVmaW5lZCApID8gaGV4IDogMHg4ODg4ODg7XG5cbiAgICBcdHRoaXMub2JqZWN0ID0gb2JqZWN0O1xuXG4gICAgXHR0aGlzLmJveCA9IG5ldyBCb3gzKCk7XG5cbiAgICBcdE1lc2guY2FsbCggdGhpcywgbmV3IEJveEdlb21ldHJ5KCAxLCAxLCAxICksIG5ldyBNZXNoQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogY29sb3IsIHdpcmVmcmFtZTogdHJ1ZSB9ICkgKTtcblxuICAgIH1cblxuICAgIEJvdW5kaW5nQm94SGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE1lc2gucHJvdG90eXBlICk7XG4gICAgQm91bmRpbmdCb3hIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQm91bmRpbmdCb3hIZWxwZXI7XG5cbiAgICBCb3VuZGluZ0JveEhlbHBlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuXG4gICAgXHR0aGlzLmJveC5zZXRGcm9tT2JqZWN0KCB0aGlzLm9iamVjdCApO1xuXG4gICAgXHR0aGlzLmJveC5zaXplKCB0aGlzLnNjYWxlICk7XG5cbiAgICBcdHRoaXMuYm94LmdldENlbnRlciggdGhpcy5wb3NpdGlvbiApO1xuXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBCb3hIZWxwZXIoIG9iamVjdCwgY29sb3IgKSB7XG5cbiAgICBcdGlmICggY29sb3IgPT09IHVuZGVmaW5lZCApIGNvbG9yID0gMHhmZmZmMDA7XG5cbiAgICBcdHZhciBpbmRpY2VzID0gbmV3IFVpbnQxNkFycmF5KCBbIDAsIDEsIDEsIDIsIDIsIDMsIDMsIDAsIDQsIDUsIDUsIDYsIDYsIDcsIDcsIDQsIDAsIDQsIDEsIDUsIDIsIDYsIDMsIDcgXSApO1xuICAgIFx0dmFyIHBvc2l0aW9ucyA9IG5ldyBGbG9hdDMyQXJyYXkoIDggKiAzICk7XG5cbiAgICBcdHZhciBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuICAgIFx0Z2VvbWV0cnkuc2V0SW5kZXgoIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIGluZGljZXMsIDEgKSApO1xuICAgIFx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbnMsIDMgKSApO1xuXG4gICAgXHRMaW5lU2VnbWVudHMuY2FsbCggdGhpcywgZ2VvbWV0cnksIG5ldyBMaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogY29sb3IgfSApICk7XG5cbiAgICBcdGlmICggb2JqZWN0ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0dGhpcy51cGRhdGUoIG9iamVjdCApO1xuXG4gICAgXHR9XG5cbiAgICB9XG5cbiAgICBCb3hIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTGluZVNlZ21lbnRzLnByb3RvdHlwZSApO1xuICAgIEJveEhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBCb3hIZWxwZXI7XG5cbiAgICBCb3hIZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9ICggZnVuY3Rpb24gKCkge1xuXG4gICAgXHR2YXIgYm94ID0gbmV3IEJveDMoKTtcblxuICAgIFx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSggb2JqZWN0ICkge1xuXG4gICAgXHRcdGlmICggKG9iamVjdCAmJiBvYmplY3QuaXNCb3gzKSApIHtcblxuICAgIFx0XHRcdGJveC5jb3B5KCBvYmplY3QgKTtcblxuICAgIFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0Ym94LnNldEZyb21PYmplY3QoIG9iamVjdCApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoIGJveC5pc0VtcHR5KCkgKSByZXR1cm47XG5cbiAgICBcdFx0dmFyIG1pbiA9IGJveC5taW47XG4gICAgXHRcdHZhciBtYXggPSBib3gubWF4O1xuXG4gICAgXHRcdC8qXG4gICAgXHRcdCAgNV9fX180XG4gICAgXHRcdDEvX19fMC98XG4gICAgXHRcdHwgNl9ffF83XG4gICAgXHRcdDIvX19fMy9cblxuICAgIFx0XHQwOiBtYXgueCwgbWF4LnksIG1heC56XG4gICAgXHRcdDE6IG1pbi54LCBtYXgueSwgbWF4LnpcbiAgICBcdFx0MjogbWluLngsIG1pbi55LCBtYXguelxuICAgIFx0XHQzOiBtYXgueCwgbWluLnksIG1heC56XG4gICAgXHRcdDQ6IG1heC54LCBtYXgueSwgbWluLnpcbiAgICBcdFx0NTogbWluLngsIG1heC55LCBtaW4uelxuICAgIFx0XHQ2OiBtaW4ueCwgbWluLnksIG1pbi56XG4gICAgXHRcdDc6IG1heC54LCBtaW4ueSwgbWluLnpcbiAgICBcdFx0Ki9cblxuICAgIFx0XHR2YXIgcG9zaXRpb24gPSB0aGlzLmdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG4gICAgXHRcdHZhciBhcnJheSA9IHBvc2l0aW9uLmFycmF5O1xuXG4gICAgXHRcdGFycmF5WyAgMCBdID0gbWF4Lng7IGFycmF5WyAgMSBdID0gbWF4Lnk7IGFycmF5WyAgMiBdID0gbWF4Lno7XG4gICAgXHRcdGFycmF5WyAgMyBdID0gbWluLng7IGFycmF5WyAgNCBdID0gbWF4Lnk7IGFycmF5WyAgNSBdID0gbWF4Lno7XG4gICAgXHRcdGFycmF5WyAgNiBdID0gbWluLng7IGFycmF5WyAgNyBdID0gbWluLnk7IGFycmF5WyAgOCBdID0gbWF4Lno7XG4gICAgXHRcdGFycmF5WyAgOSBdID0gbWF4Lng7IGFycmF5WyAxMCBdID0gbWluLnk7IGFycmF5WyAxMSBdID0gbWF4Lno7XG4gICAgXHRcdGFycmF5WyAxMiBdID0gbWF4Lng7IGFycmF5WyAxMyBdID0gbWF4Lnk7IGFycmF5WyAxNCBdID0gbWluLno7XG4gICAgXHRcdGFycmF5WyAxNSBdID0gbWluLng7IGFycmF5WyAxNiBdID0gbWF4Lnk7IGFycmF5WyAxNyBdID0gbWluLno7XG4gICAgXHRcdGFycmF5WyAxOCBdID0gbWluLng7IGFycmF5WyAxOSBdID0gbWluLnk7IGFycmF5WyAyMCBdID0gbWluLno7XG4gICAgXHRcdGFycmF5WyAyMSBdID0gbWF4Lng7IGFycmF5WyAyMiBdID0gbWluLnk7IGFycmF5WyAyMyBdID0gbWluLno7XG5cbiAgICBcdFx0cG9zaXRpb24ubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgXHRcdHRoaXMuZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cbiAgICBcdH07XG5cbiAgICB9ICkoKTtcblxuICAgIHZhciBsaW5lR2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcbiAgICBsaW5lR2VvbWV0cnkuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkF0dHJpYnV0ZSggWyAwLCAwLCAwLCAwLCAxLCAwIF0sIDMgKSApO1xuXG4gICAgdmFyIGNvbmVHZW9tZXRyeSA9IG5ldyBDeWxpbmRlckJ1ZmZlckdlb21ldHJ5KCAwLCAwLjUsIDEsIDUsIDEgKTtcbiAgICBjb25lR2VvbWV0cnkudHJhbnNsYXRlKCAwLCAtIDAuNSwgMCApO1xuXG4gICAgZnVuY3Rpb24gQXJyb3dIZWxwZXIoIGRpciwgb3JpZ2luLCBsZW5ndGgsIGNvbG9yLCBoZWFkTGVuZ3RoLCBoZWFkV2lkdGggKSB7XG5cbiAgICBcdC8vIGRpciBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWRcblxuICAgIFx0T2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG4gICAgXHRpZiAoIGNvbG9yID09PSB1bmRlZmluZWQgKSBjb2xvciA9IDB4ZmZmZjAwO1xuICAgIFx0aWYgKCBsZW5ndGggPT09IHVuZGVmaW5lZCApIGxlbmd0aCA9IDE7XG4gICAgXHRpZiAoIGhlYWRMZW5ndGggPT09IHVuZGVmaW5lZCApIGhlYWRMZW5ndGggPSAwLjIgKiBsZW5ndGg7XG4gICAgXHRpZiAoIGhlYWRXaWR0aCA9PT0gdW5kZWZpbmVkICkgaGVhZFdpZHRoID0gMC4yICogaGVhZExlbmd0aDtcblxuICAgIFx0dGhpcy5wb3NpdGlvbi5jb3B5KCBvcmlnaW4gKTtcblxuICAgIFx0dGhpcy5saW5lID0gbmV3IExpbmUoIGxpbmVHZW9tZXRyeSwgbmV3IExpbmVCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBjb2xvciB9ICkgKTtcbiAgICBcdHRoaXMubGluZS5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG4gICAgXHR0aGlzLmFkZCggdGhpcy5saW5lICk7XG5cbiAgICBcdHRoaXMuY29uZSA9IG5ldyBNZXNoKCBjb25lR2VvbWV0cnksIG5ldyBNZXNoQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogY29sb3IgfSApICk7XG4gICAgXHR0aGlzLmNvbmUubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuICAgIFx0dGhpcy5hZGQoIHRoaXMuY29uZSApO1xuXG4gICAgXHR0aGlzLnNldERpcmVjdGlvbiggZGlyICk7XG4gICAgXHR0aGlzLnNldExlbmd0aCggbGVuZ3RoLCBoZWFkTGVuZ3RoLCBoZWFkV2lkdGggKTtcblxuICAgIH1cblxuICAgIEFycm93SGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE9iamVjdDNELnByb3RvdHlwZSApO1xuICAgIEFycm93SGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEFycm93SGVscGVyO1xuXG4gICAgQXJyb3dIZWxwZXIucHJvdG90eXBlLnNldERpcmVjdGlvbiA9ICggZnVuY3Rpb24gKCkge1xuXG4gICAgXHR2YXIgYXhpcyA9IG5ldyBWZWN0b3IzKCk7XG4gICAgXHR2YXIgcmFkaWFucztcblxuICAgIFx0cmV0dXJuIGZ1bmN0aW9uIHNldERpcmVjdGlvbiggZGlyICkge1xuXG4gICAgXHRcdC8vIGRpciBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWRcblxuICAgIFx0XHRpZiAoIGRpci55ID4gMC45OTk5OSApIHtcblxuICAgIFx0XHRcdHRoaXMucXVhdGVybmlvbi5zZXQoIDAsIDAsIDAsIDEgKTtcblxuICAgIFx0XHR9IGVsc2UgaWYgKCBkaXIueSA8IC0gMC45OTk5OSApIHtcblxuICAgIFx0XHRcdHRoaXMucXVhdGVybmlvbi5zZXQoIDEsIDAsIDAsIDAgKTtcblxuICAgIFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0YXhpcy5zZXQoIGRpci56LCAwLCAtIGRpci54ICkubm9ybWFsaXplKCk7XG5cbiAgICBcdFx0XHRyYWRpYW5zID0gTWF0aC5hY29zKCBkaXIueSApO1xuXG4gICAgXHRcdFx0dGhpcy5xdWF0ZXJuaW9uLnNldEZyb21BeGlzQW5nbGUoIGF4aXMsIHJhZGlhbnMgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdH07XG5cbiAgICB9KCkgKTtcblxuICAgIEFycm93SGVscGVyLnByb3RvdHlwZS5zZXRMZW5ndGggPSBmdW5jdGlvbiAoIGxlbmd0aCwgaGVhZExlbmd0aCwgaGVhZFdpZHRoICkge1xuXG4gICAgXHRpZiAoIGhlYWRMZW5ndGggPT09IHVuZGVmaW5lZCApIGhlYWRMZW5ndGggPSAwLjIgKiBsZW5ndGg7XG4gICAgXHRpZiAoIGhlYWRXaWR0aCA9PT0gdW5kZWZpbmVkICkgaGVhZFdpZHRoID0gMC4yICogaGVhZExlbmd0aDtcblxuICAgIFx0dGhpcy5saW5lLnNjYWxlLnNldCggMSwgTWF0aC5tYXgoIDAsIGxlbmd0aCAtIGhlYWRMZW5ndGggKSwgMSApO1xuICAgIFx0dGhpcy5saW5lLnVwZGF0ZU1hdHJpeCgpO1xuXG4gICAgXHR0aGlzLmNvbmUuc2NhbGUuc2V0KCBoZWFkV2lkdGgsIGhlYWRMZW5ndGgsIGhlYWRXaWR0aCApO1xuICAgIFx0dGhpcy5jb25lLnBvc2l0aW9uLnkgPSBsZW5ndGg7XG4gICAgXHR0aGlzLmNvbmUudXBkYXRlTWF0cml4KCk7XG5cbiAgICB9O1xuXG4gICAgQXJyb3dIZWxwZXIucHJvdG90eXBlLnNldENvbG9yID0gZnVuY3Rpb24gKCBjb2xvciApIHtcblxuICAgIFx0dGhpcy5saW5lLm1hdGVyaWFsLmNvbG9yLmNvcHkoIGNvbG9yICk7XG4gICAgXHR0aGlzLmNvbmUubWF0ZXJpYWwuY29sb3IuY29weSggY29sb3IgKTtcblxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIHNyb3VjaGVyYXkgLyBodHRwOi8vc3JvdWNoZXJheS5vcmcvXG4gICAgICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIEF4aXNIZWxwZXIoIHNpemUgKSB7XG5cbiAgICBcdHNpemUgPSBzaXplIHx8IDE7XG5cbiAgICBcdHZhciB2ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIFtcbiAgICBcdFx0MCwgMCwgMCwgIHNpemUsIDAsIDAsXG4gICAgXHRcdDAsIDAsIDAsICAwLCBzaXplLCAwLFxuICAgIFx0XHQwLCAwLCAwLCAgMCwgMCwgc2l6ZVxuICAgIFx0XSApO1xuXG4gICAgXHR2YXIgY29sb3JzID0gbmV3IEZsb2F0MzJBcnJheSggW1xuICAgIFx0XHQxLCAwLCAwLCAgMSwgMC42LCAwLFxuICAgIFx0XHQwLCAxLCAwLCAgMC42LCAxLCAwLFxuICAgIFx0XHQwLCAwLCAxLCAgMCwgMC42LCAxXG4gICAgXHRdICk7XG5cbiAgICBcdHZhciBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuICAgIFx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XG4gICAgXHRnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdjb2xvcicsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIGNvbG9ycywgMyApICk7XG5cbiAgICBcdHZhciBtYXRlcmlhbCA9IG5ldyBMaW5lQmFzaWNNYXRlcmlhbCggeyB2ZXJ0ZXhDb2xvcnM6IFZlcnRleENvbG9ycyB9ICk7XG5cbiAgICBcdExpbmVTZWdtZW50cy5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblxuICAgIH1cblxuICAgIEF4aXNIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTGluZVNlZ21lbnRzLnByb3RvdHlwZSApO1xuICAgIEF4aXNIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQXhpc0hlbHBlcjtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3Igeno4NSBodHRwczovL2dpdGh1Yi5jb20veno4NVxuICAgICAqXG4gICAgICogQ2VudHJpcGV0YWwgQ2F0bXVsbFJvbSBDdXJ2ZSAtIHdoaWNoIGlzIHVzZWZ1bCBmb3IgYXZvaWRpbmdcbiAgICAgKiBjdXNwcyBhbmQgc2VsZi1pbnRlcnNlY3Rpb25zIGluIG5vbi11bmlmb3JtIGNhdG11bGwgcm9tIGN1cnZlcy5cbiAgICAgKiBodHRwOi8vd3d3LmNlbXl1a3NlbC5jb20vcmVzZWFyY2gvY2F0bXVsbHJvbV9wYXJhbS9jYXRtdWxscm9tLnBkZlxuICAgICAqXG4gICAgICogY3VydmUudHlwZSBhY2NlcHRzIGNlbnRyaXBldGFsKGRlZmF1bHQpLCBjaG9yZGFsIGFuZCBjYXRtdWxscm9tXG4gICAgICogY3VydmUudGVuc2lvbiBpcyB1c2VkIGZvciBjYXRtdWxscm9tIHdoaWNoIGRlZmF1bHRzIHRvIDAuNVxuICAgICAqL1xuXG4gICAgZXhwb3J0cy5DYXRtdWxsUm9tQ3VydmUzID0gKCBmdW5jdGlvbigpIHtcblxuICAgIFx0dmFyXG4gICAgXHRcdHRtcCA9IG5ldyBWZWN0b3IzKCksXG4gICAgXHRcdHB4ID0gbmV3IEN1YmljUG9seSgpLFxuICAgIFx0XHRweSA9IG5ldyBDdWJpY1BvbHkoKSxcbiAgICBcdFx0cHogPSBuZXcgQ3ViaWNQb2x5KCk7XG5cbiAgICBcdC8qXG4gICAgXHRCYXNlZCBvbiBhbiBvcHRpbWl6ZWQgYysrIHNvbHV0aW9uIGluXG4gICAgXHQgLSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzk0ODk3MzYvY2F0bXVsbC1yb20tY3VydmUtd2l0aC1uby1jdXNwcy1hbmQtbm8tc2VsZi1pbnRlcnNlY3Rpb25zL1xuICAgIFx0IC0gaHR0cDovL2lkZW9uZS5jb20vTm9FYlZNXG5cbiAgICBcdFRoaXMgQ3ViaWNQb2x5IGNsYXNzIGNvdWxkIGJlIHVzZWQgZm9yIHJldXNpbmcgc29tZSB2YXJpYWJsZXMgYW5kIGNhbGN1bGF0aW9ucyxcbiAgICBcdGJ1dCBmb3IgdGhyZWUuanMgY3VydmUgdXNlLCBpdCBjb3VsZCBiZSBwb3NzaWJsZSBpbmxpbmVkIGFuZCBmbGF0dGVuIGludG8gYSBzaW5nbGUgZnVuY3Rpb24gY2FsbFxuICAgIFx0d2hpY2ggY2FuIGJlIHBsYWNlZCBpbiBDdXJ2ZVV0aWxzLlxuICAgIFx0Ki9cblxuICAgIFx0ZnVuY3Rpb24gQ3ViaWNQb2x5KCkge1xuXG4gICAgXHR9XG5cbiAgICBcdC8qXG4gICAgXHQgKiBDb21wdXRlIGNvZWZmaWNpZW50cyBmb3IgYSBjdWJpYyBwb2x5bm9taWFsXG4gICAgXHQgKiAgIHAocykgPSBjMCArIGMxKnMgKyBjMipzXjIgKyBjMypzXjNcbiAgICBcdCAqIHN1Y2ggdGhhdFxuICAgIFx0ICogICBwKDApID0geDAsIHAoMSkgPSB4MVxuICAgIFx0ICogIGFuZFxuICAgIFx0ICogICBwJygwKSA9IHQwLCBwJygxKSA9IHQxLlxuICAgIFx0ICovXG4gICAgXHRDdWJpY1BvbHkucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiggeDAsIHgxLCB0MCwgdDEgKSB7XG5cbiAgICBcdFx0dGhpcy5jMCA9IHgwO1xuICAgIFx0XHR0aGlzLmMxID0gdDA7XG4gICAgXHRcdHRoaXMuYzIgPSAtIDMgKiB4MCArIDMgKiB4MSAtIDIgKiB0MCAtIHQxO1xuICAgIFx0XHR0aGlzLmMzID0gMiAqIHgwIC0gMiAqIHgxICsgdDAgKyB0MTtcblxuICAgIFx0fTtcblxuICAgIFx0Q3ViaWNQb2x5LnByb3RvdHlwZS5pbml0Tm9udW5pZm9ybUNhdG11bGxSb20gPSBmdW5jdGlvbiggeDAsIHgxLCB4MiwgeDMsIGR0MCwgZHQxLCBkdDIgKSB7XG5cbiAgICBcdFx0Ly8gY29tcHV0ZSB0YW5nZW50cyB3aGVuIHBhcmFtZXRlcml6ZWQgaW4gW3QxLHQyXVxuICAgIFx0XHR2YXIgdDEgPSAoIHgxIC0geDAgKSAvIGR0MCAtICggeDIgLSB4MCApIC8gKCBkdDAgKyBkdDEgKSArICggeDIgLSB4MSApIC8gZHQxO1xuICAgIFx0XHR2YXIgdDIgPSAoIHgyIC0geDEgKSAvIGR0MSAtICggeDMgLSB4MSApIC8gKCBkdDEgKyBkdDIgKSArICggeDMgLSB4MiApIC8gZHQyO1xuXG4gICAgXHRcdC8vIHJlc2NhbGUgdGFuZ2VudHMgZm9yIHBhcmFtZXRyaXphdGlvbiBpbiBbMCwxXVxuICAgIFx0XHR0MSAqPSBkdDE7XG4gICAgXHRcdHQyICo9IGR0MTtcblxuICAgIFx0XHQvLyBpbml0Q3ViaWNQb2x5XG4gICAgXHRcdHRoaXMuaW5pdCggeDEsIHgyLCB0MSwgdDIgKTtcblxuICAgIFx0fTtcblxuICAgIFx0Ly8gc3RhbmRhcmQgQ2F0bXVsbC1Sb20gc3BsaW5lOiBpbnRlcnBvbGF0ZSBiZXR3ZWVuIHgxIGFuZCB4MiB3aXRoIHByZXZpb3VzL2ZvbGxvd2luZyBwb2ludHMgeDEveDRcbiAgICBcdEN1YmljUG9seS5wcm90b3R5cGUuaW5pdENhdG11bGxSb20gPSBmdW5jdGlvbiggeDAsIHgxLCB4MiwgeDMsIHRlbnNpb24gKSB7XG5cbiAgICBcdFx0dGhpcy5pbml0KCB4MSwgeDIsIHRlbnNpb24gKiAoIHgyIC0geDAgKSwgdGVuc2lvbiAqICggeDMgLSB4MSApICk7XG5cbiAgICBcdH07XG5cbiAgICBcdEN1YmljUG9seS5wcm90b3R5cGUuY2FsYyA9IGZ1bmN0aW9uKCB0ICkge1xuXG4gICAgXHRcdHZhciB0MiA9IHQgKiB0O1xuICAgIFx0XHR2YXIgdDMgPSB0MiAqIHQ7XG4gICAgXHRcdHJldHVybiB0aGlzLmMwICsgdGhpcy5jMSAqIHQgKyB0aGlzLmMyICogdDIgKyB0aGlzLmMzICogdDM7XG5cbiAgICBcdH07XG5cbiAgICBcdC8vIFN1YmNsYXNzIFRocmVlLmpzIGN1cnZlXG4gICAgXHRyZXR1cm4gQ3VydmUuY3JlYXRlKFxuXG4gICAgXHRcdGZ1bmN0aW9uICggcCAvKiBhcnJheSBvZiBWZWN0b3IzICovICkge1xuXG4gICAgXHRcdFx0dGhpcy5wb2ludHMgPSBwIHx8IFtdO1xuICAgIFx0XHRcdHRoaXMuY2xvc2VkID0gZmFsc2U7XG5cbiAgICBcdFx0fSxcblxuICAgIFx0XHRmdW5jdGlvbiAoIHQgKSB7XG5cbiAgICBcdFx0XHR2YXIgcG9pbnRzID0gdGhpcy5wb2ludHMsXG4gICAgXHRcdFx0XHRwb2ludCwgaW50UG9pbnQsIHdlaWdodCwgbDtcblxuICAgIFx0XHRcdGwgPSBwb2ludHMubGVuZ3RoO1xuXG4gICAgXHRcdFx0aWYgKCBsIDwgMiApIGNvbnNvbGUubG9nKCAnZHVoLCB5b3UgbmVlZCBhdCBsZWFzdCAyIHBvaW50cycgKTtcblxuICAgIFx0XHRcdHBvaW50ID0gKCBsIC0gKCB0aGlzLmNsb3NlZCA/IDAgOiAxICkgKSAqIHQ7XG4gICAgXHRcdFx0aW50UG9pbnQgPSBNYXRoLmZsb29yKCBwb2ludCApO1xuICAgIFx0XHRcdHdlaWdodCA9IHBvaW50IC0gaW50UG9pbnQ7XG5cbiAgICBcdFx0XHRpZiAoIHRoaXMuY2xvc2VkICkge1xuXG4gICAgXHRcdFx0XHRpbnRQb2ludCArPSBpbnRQb2ludCA+IDAgPyAwIDogKCBNYXRoLmZsb29yKCBNYXRoLmFicyggaW50UG9pbnQgKSAvIHBvaW50cy5sZW5ndGggKSArIDEgKSAqIHBvaW50cy5sZW5ndGg7XG5cbiAgICBcdFx0XHR9IGVsc2UgaWYgKCB3ZWlnaHQgPT09IDAgJiYgaW50UG9pbnQgPT09IGwgLSAxICkge1xuXG4gICAgXHRcdFx0XHRpbnRQb2ludCA9IGwgLSAyO1xuICAgIFx0XHRcdFx0d2VpZ2h0ID0gMTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdHZhciBwMCwgcDEsIHAyLCBwMzsgLy8gNCBwb2ludHNcblxuICAgIFx0XHRcdGlmICggdGhpcy5jbG9zZWQgfHwgaW50UG9pbnQgPiAwICkge1xuXG4gICAgXHRcdFx0XHRwMCA9IHBvaW50c1sgKCBpbnRQb2ludCAtIDEgKSAlIGwgXTtcblxuICAgIFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdC8vIGV4dHJhcG9sYXRlIGZpcnN0IHBvaW50XG4gICAgXHRcdFx0XHR0bXAuc3ViVmVjdG9ycyggcG9pbnRzWyAwIF0sIHBvaW50c1sgMSBdICkuYWRkKCBwb2ludHNbIDAgXSApO1xuICAgIFx0XHRcdFx0cDAgPSB0bXA7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRwMSA9IHBvaW50c1sgaW50UG9pbnQgJSBsIF07XG4gICAgXHRcdFx0cDIgPSBwb2ludHNbICggaW50UG9pbnQgKyAxICkgJSBsIF07XG5cbiAgICBcdFx0XHRpZiAoIHRoaXMuY2xvc2VkIHx8IGludFBvaW50ICsgMiA8IGwgKSB7XG5cbiAgICBcdFx0XHRcdHAzID0gcG9pbnRzWyAoIGludFBvaW50ICsgMiApICUgbCBdO1xuXG4gICAgXHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0Ly8gZXh0cmFwb2xhdGUgbGFzdCBwb2ludFxuICAgIFx0XHRcdFx0dG1wLnN1YlZlY3RvcnMoIHBvaW50c1sgbCAtIDEgXSwgcG9pbnRzWyBsIC0gMiBdICkuYWRkKCBwb2ludHNbIGwgLSAxIF0gKTtcbiAgICBcdFx0XHRcdHAzID0gdG1wO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0aWYgKCB0aGlzLnR5cGUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLnR5cGUgPT09ICdjZW50cmlwZXRhbCcgfHwgdGhpcy50eXBlID09PSAnY2hvcmRhbCcgKSB7XG5cbiAgICBcdFx0XHRcdC8vIGluaXQgQ2VudHJpcGV0YWwgLyBDaG9yZGFsIENhdG11bGwtUm9tXG4gICAgXHRcdFx0XHR2YXIgcG93ID0gdGhpcy50eXBlID09PSAnY2hvcmRhbCcgPyAwLjUgOiAwLjI1O1xuICAgIFx0XHRcdFx0dmFyIGR0MCA9IE1hdGgucG93KCBwMC5kaXN0YW5jZVRvU3F1YXJlZCggcDEgKSwgcG93ICk7XG4gICAgXHRcdFx0XHR2YXIgZHQxID0gTWF0aC5wb3coIHAxLmRpc3RhbmNlVG9TcXVhcmVkKCBwMiApLCBwb3cgKTtcbiAgICBcdFx0XHRcdHZhciBkdDIgPSBNYXRoLnBvdyggcDIuZGlzdGFuY2VUb1NxdWFyZWQoIHAzICksIHBvdyApO1xuXG4gICAgXHRcdFx0XHQvLyBzYWZldHkgY2hlY2sgZm9yIHJlcGVhdGVkIHBvaW50c1xuICAgIFx0XHRcdFx0aWYgKCBkdDEgPCAxZS00ICkgZHQxID0gMS4wO1xuICAgIFx0XHRcdFx0aWYgKCBkdDAgPCAxZS00ICkgZHQwID0gZHQxO1xuICAgIFx0XHRcdFx0aWYgKCBkdDIgPCAxZS00ICkgZHQyID0gZHQxO1xuXG4gICAgXHRcdFx0XHRweC5pbml0Tm9udW5pZm9ybUNhdG11bGxSb20oIHAwLngsIHAxLngsIHAyLngsIHAzLngsIGR0MCwgZHQxLCBkdDIgKTtcbiAgICBcdFx0XHRcdHB5LmluaXROb251bmlmb3JtQ2F0bXVsbFJvbSggcDAueSwgcDEueSwgcDIueSwgcDMueSwgZHQwLCBkdDEsIGR0MiApO1xuICAgIFx0XHRcdFx0cHouaW5pdE5vbnVuaWZvcm1DYXRtdWxsUm9tKCBwMC56LCBwMS56LCBwMi56LCBwMy56LCBkdDAsIGR0MSwgZHQyICk7XG5cbiAgICBcdFx0XHR9IGVsc2UgaWYgKCB0aGlzLnR5cGUgPT09ICdjYXRtdWxscm9tJyApIHtcblxuICAgIFx0XHRcdFx0dmFyIHRlbnNpb24gPSB0aGlzLnRlbnNpb24gIT09IHVuZGVmaW5lZCA/IHRoaXMudGVuc2lvbiA6IDAuNTtcbiAgICBcdFx0XHRcdHB4LmluaXRDYXRtdWxsUm9tKCBwMC54LCBwMS54LCBwMi54LCBwMy54LCB0ZW5zaW9uICk7XG4gICAgXHRcdFx0XHRweS5pbml0Q2F0bXVsbFJvbSggcDAueSwgcDEueSwgcDIueSwgcDMueSwgdGVuc2lvbiApO1xuICAgIFx0XHRcdFx0cHouaW5pdENhdG11bGxSb20oIHAwLnosIHAxLnosIHAyLnosIHAzLnosIHRlbnNpb24gKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdHZhciB2ID0gbmV3IFZlY3RvcjMoXG4gICAgXHRcdFx0XHRweC5jYWxjKCB3ZWlnaHQgKSxcbiAgICBcdFx0XHRcdHB5LmNhbGMoIHdlaWdodCApLFxuICAgIFx0XHRcdFx0cHouY2FsYyggd2VpZ2h0IClcbiAgICBcdFx0XHQpO1xuXG4gICAgXHRcdFx0cmV0dXJuIHY7XG5cbiAgICBcdFx0fVxuXG4gICAgXHQpO1xuXG4gICAgfSApKCk7XG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgKlx0Q2xvc2VkIFNwbGluZSAzRCBjdXJ2ZVxuICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXG4gICAgZnVuY3Rpb24gQ2xvc2VkU3BsaW5lQ3VydmUzKCBwb2ludHMgKSB7XG5cbiAgICBcdGNvbnNvbGUud2FybiggJ1RIUkVFLkNsb3NlZFNwbGluZUN1cnZlMyBoYXMgYmVlbiBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIFRIUkVFLkNhdG11bGxSb21DdXJ2ZTMuJyApO1xuXG4gICAgXHRleHBvcnRzLkNhdG11bGxSb21DdXJ2ZTMuY2FsbCggdGhpcywgcG9pbnRzICk7XG4gICAgXHR0aGlzLnR5cGUgPSAnY2F0bXVsbHJvbSc7XG4gICAgXHR0aGlzLmNsb3NlZCA9IHRydWU7XG5cbiAgICB9XG5cbiAgICBDbG9zZWRTcGxpbmVDdXJ2ZTMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggZXhwb3J0cy5DYXRtdWxsUm9tQ3VydmUzLnByb3RvdHlwZSApO1xuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICpcdFNwbGluZSAzRCBjdXJ2ZVxuICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXG4gICAgdmFyIFNwbGluZUN1cnZlMyA9IEN1cnZlLmNyZWF0ZShcblxuICAgIFx0ZnVuY3Rpb24gKCBwb2ludHMgLyogYXJyYXkgb2YgVmVjdG9yMyAqLyApIHtcblxuICAgIFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5TcGxpbmVDdXJ2ZTMgd2lsbCBiZSBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIFRIUkVFLkNhdG11bGxSb21DdXJ2ZTMnICk7XG4gICAgXHRcdHRoaXMucG9pbnRzID0gKCBwb2ludHMgPT09IHVuZGVmaW5lZCApID8gW10gOiBwb2ludHM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGZ1bmN0aW9uICggdCApIHtcblxuICAgIFx0XHR2YXIgcG9pbnRzID0gdGhpcy5wb2ludHM7XG4gICAgXHRcdHZhciBwb2ludCA9ICggcG9pbnRzLmxlbmd0aCAtIDEgKSAqIHQ7XG5cbiAgICBcdFx0dmFyIGludFBvaW50ID0gTWF0aC5mbG9vciggcG9pbnQgKTtcbiAgICBcdFx0dmFyIHdlaWdodCA9IHBvaW50IC0gaW50UG9pbnQ7XG5cbiAgICBcdFx0dmFyIHBvaW50MCA9IHBvaW50c1sgaW50UG9pbnQgPT0gMCA/IGludFBvaW50IDogaW50UG9pbnQgLSAxIF07XG4gICAgXHRcdHZhciBwb2ludDEgPSBwb2ludHNbIGludFBvaW50IF07XG4gICAgXHRcdHZhciBwb2ludDIgPSBwb2ludHNbIGludFBvaW50ID4gcG9pbnRzLmxlbmd0aCAtIDIgPyBwb2ludHMubGVuZ3RoIC0gMSA6IGludFBvaW50ICsgMSBdO1xuICAgIFx0XHR2YXIgcG9pbnQzID0gcG9pbnRzWyBpbnRQb2ludCA+IHBvaW50cy5sZW5ndGggLSAzID8gcG9pbnRzLmxlbmd0aCAtIDEgOiBpbnRQb2ludCArIDIgXTtcblxuICAgIFx0XHR2YXIgaW50ZXJwb2xhdGUgPSBleHBvcnRzLkN1cnZlVXRpbHMuaW50ZXJwb2xhdGU7XG5cbiAgICBcdFx0cmV0dXJuIG5ldyBWZWN0b3IzKFxuICAgIFx0XHRcdGludGVycG9sYXRlKCBwb2ludDAueCwgcG9pbnQxLngsIHBvaW50Mi54LCBwb2ludDMueCwgd2VpZ2h0ICksXG4gICAgXHRcdFx0aW50ZXJwb2xhdGUoIHBvaW50MC55LCBwb2ludDEueSwgcG9pbnQyLnksIHBvaW50My55LCB3ZWlnaHQgKSxcbiAgICBcdFx0XHRpbnRlcnBvbGF0ZSggcG9pbnQwLnosIHBvaW50MS56LCBwb2ludDIueiwgcG9pbnQzLnosIHdlaWdodCApXG4gICAgXHRcdCk7XG5cbiAgICBcdH1cblxuICAgICk7XG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgKlx0Q3ViaWMgQmV6aWVyIDNEIGN1cnZlXG4gICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgZXhwb3J0cy5DdWJpY0JlemllckN1cnZlMyA9IEN1cnZlLmNyZWF0ZShcblxuICAgIFx0ZnVuY3Rpb24gKCB2MCwgdjEsIHYyLCB2MyApIHtcblxuICAgIFx0XHR0aGlzLnYwID0gdjA7XG4gICAgXHRcdHRoaXMudjEgPSB2MTtcbiAgICBcdFx0dGhpcy52MiA9IHYyO1xuICAgIFx0XHR0aGlzLnYzID0gdjM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGZ1bmN0aW9uICggdCApIHtcblxuICAgIFx0XHR2YXIgYjMgPSBleHBvcnRzLlNoYXBlVXRpbHMuYjM7XG5cbiAgICBcdFx0cmV0dXJuIG5ldyBWZWN0b3IzKFxuICAgIFx0XHRcdGIzKCB0LCB0aGlzLnYwLngsIHRoaXMudjEueCwgdGhpcy52Mi54LCB0aGlzLnYzLnggKSxcbiAgICBcdFx0XHRiMyggdCwgdGhpcy52MC55LCB0aGlzLnYxLnksIHRoaXMudjIueSwgdGhpcy52My55ICksXG4gICAgXHRcdFx0YjMoIHQsIHRoaXMudjAueiwgdGhpcy52MS56LCB0aGlzLnYyLnosIHRoaXMudjMueiApXG4gICAgXHRcdCk7XG5cbiAgICBcdH1cblxuICAgICk7XG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgKlx0UXVhZHJhdGljIEJlemllciAzRCBjdXJ2ZVxuICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgIGV4cG9ydHMuUXVhZHJhdGljQmV6aWVyQ3VydmUzID0gQ3VydmUuY3JlYXRlKFxuXG4gICAgXHRmdW5jdGlvbiAoIHYwLCB2MSwgdjIgKSB7XG5cbiAgICBcdFx0dGhpcy52MCA9IHYwO1xuICAgIFx0XHR0aGlzLnYxID0gdjE7XG4gICAgXHRcdHRoaXMudjIgPSB2MjtcblxuICAgIFx0fSxcblxuICAgIFx0ZnVuY3Rpb24gKCB0ICkge1xuXG4gICAgXHRcdHZhciBiMiA9IGV4cG9ydHMuU2hhcGVVdGlscy5iMjtcdFx0XG5cbiAgICBcdFx0cmV0dXJuIG5ldyBWZWN0b3IzKFxuICAgIFx0XHRcdGIyKCB0LCB0aGlzLnYwLngsIHRoaXMudjEueCwgdGhpcy52Mi54ICksXG4gICAgXHRcdFx0YjIoIHQsIHRoaXMudjAueSwgdGhpcy52MS55LCB0aGlzLnYyLnkgKSxcbiAgICBcdFx0XHRiMiggdCwgdGhpcy52MC56LCB0aGlzLnYxLnosIHRoaXMudjIueiApXG4gICAgXHRcdCk7XG5cbiAgICBcdH1cblxuICAgICk7XG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgKlx0TGluZTNEXG4gICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgZXhwb3J0cy5MaW5lQ3VydmUzID0gQ3VydmUuY3JlYXRlKFxuXG4gICAgXHRmdW5jdGlvbiAoIHYxLCB2MiApIHtcblxuICAgIFx0XHR0aGlzLnYxID0gdjE7XG4gICAgXHRcdHRoaXMudjIgPSB2MjtcblxuICAgIFx0fSxcblxuICAgIFx0ZnVuY3Rpb24gKCB0ICkge1xuXG4gICAgXHRcdGlmICggdCA9PT0gMSApIHtcblxuICAgIFx0XHRcdHJldHVybiB0aGlzLnYyLmNsb25lKCk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHZhciB2ZWN0b3IgPSBuZXcgVmVjdG9yMygpO1xuXG4gICAgXHRcdHZlY3Rvci5zdWJWZWN0b3JzKCB0aGlzLnYyLCB0aGlzLnYxICk7IC8vIGRpZmZcbiAgICBcdFx0dmVjdG9yLm11bHRpcGx5U2NhbGFyKCB0ICk7XG4gICAgXHRcdHZlY3Rvci5hZGQoIHRoaXMudjEgKTtcblxuICAgIFx0XHRyZXR1cm4gdmVjdG9yO1xuXG4gICAgXHR9XG5cbiAgICApO1xuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICpcdEFyYyBjdXJ2ZVxuICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgIGZ1bmN0aW9uIEFyY0N1cnZlKCBhWCwgYVksIGFSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKSB7XG5cbiAgICBcdEVsbGlwc2VDdXJ2ZS5jYWxsKCB0aGlzLCBhWCwgYVksIGFSYWRpdXMsIGFSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKTtcblxuICAgIH1cblxuICAgIEFyY0N1cnZlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEVsbGlwc2VDdXJ2ZS5wcm90b3R5cGUgKTtcbiAgICBBcmNDdXJ2ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBBcmNDdXJ2ZTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gICAgICovXG5cbiAgICBleHBvcnRzLlNjZW5lVXRpbHMgPSB7XG5cbiAgICBcdGNyZWF0ZU11bHRpTWF0ZXJpYWxPYmplY3Q6IGZ1bmN0aW9uICggZ2VvbWV0cnksIG1hdGVyaWFscyApIHtcblxuICAgIFx0XHR2YXIgZ3JvdXAgPSBuZXcgR3JvdXAoKTtcblxuICAgIFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBtYXRlcmlhbHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgIFx0XHRcdGdyb3VwLmFkZCggbmV3IE1lc2goIGdlb21ldHJ5LCBtYXRlcmlhbHNbIGkgXSApICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiBncm91cDtcblxuICAgIFx0fSxcblxuICAgIFx0ZGV0YWNoOiBmdW5jdGlvbiAoIGNoaWxkLCBwYXJlbnQsIHNjZW5lICkge1xuXG4gICAgXHRcdGNoaWxkLmFwcGx5TWF0cml4KCBwYXJlbnQubWF0cml4V29ybGQgKTtcbiAgICBcdFx0cGFyZW50LnJlbW92ZSggY2hpbGQgKTtcbiAgICBcdFx0c2NlbmUuYWRkKCBjaGlsZCApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRhdHRhY2g6IGZ1bmN0aW9uICggY2hpbGQsIHNjZW5lLCBwYXJlbnQgKSB7XG5cbiAgICBcdFx0dmFyIG1hdHJpeFdvcmxkSW52ZXJzZSA9IG5ldyBNYXRyaXg0KCk7XG4gICAgXHRcdG1hdHJpeFdvcmxkSW52ZXJzZS5nZXRJbnZlcnNlKCBwYXJlbnQubWF0cml4V29ybGQgKTtcbiAgICBcdFx0Y2hpbGQuYXBwbHlNYXRyaXgoIG1hdHJpeFdvcmxkSW52ZXJzZSApO1xuXG4gICAgXHRcdHNjZW5lLnJlbW92ZSggY2hpbGQgKTtcbiAgICBcdFx0cGFyZW50LmFkZCggY2hpbGQgKTtcblxuICAgIFx0fVxuXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIEZhY2U0ICggYSwgYiwgYywgZCwgbm9ybWFsLCBjb2xvciwgbWF0ZXJpYWxJbmRleCApIHtcbiAgICBcdGNvbnNvbGUud2FybiggJ1RIUkVFLkZhY2U0IGhhcyBiZWVuIHJlbW92ZWQuIEEgVEhSRUUuRmFjZTMgd2lsbCBiZSBjcmVhdGVkIGluc3RlYWQuJyApO1xuICAgIFx0cmV0dXJuIG5ldyBGYWNlMyggYSwgYiwgYywgbm9ybWFsLCBjb2xvciwgbWF0ZXJpYWxJbmRleCApO1xuICAgIH1cblxuICAgIHZhciBMaW5lU3RyaXAgPSAwO1xuXG4gICAgdmFyIExpbmVQaWVjZXMgPSAxO1xuXG4gICAgZnVuY3Rpb24gUG9pbnRDbG91ZCAoIGdlb21ldHJ5LCBtYXRlcmlhbCApIHtcbiAgICBcdGNvbnNvbGUud2FybiggJ1RIUkVFLlBvaW50Q2xvdWQgaGFzIGJlZW4gcmVuYW1lZCB0byBUSFJFRS5Qb2ludHMuJyApO1xuICAgIFx0cmV0dXJuIG5ldyBQb2ludHMoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFBhcnRpY2xlU3lzdGVtICggZ2VvbWV0cnksIG1hdGVyaWFsICkge1xuICAgIFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUGFydGljbGVTeXN0ZW0gaGFzIGJlZW4gcmVuYW1lZCB0byBUSFJFRS5Qb2ludHMuJyApO1xuICAgIFx0cmV0dXJuIG5ldyBQb2ludHMoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFBvaW50Q2xvdWRNYXRlcmlhbCAoIHBhcmFtZXRlcnMgKSB7XG4gICAgXHRjb25zb2xlLndhcm4oICdUSFJFRS5Qb2ludENsb3VkTWF0ZXJpYWwgaGFzIGJlZW4gcmVuYW1lZCB0byBUSFJFRS5Qb2ludHNNYXRlcmlhbC4nICk7XG4gICAgXHRyZXR1cm4gbmV3IFBvaW50c01hdGVyaWFsKCBwYXJhbWV0ZXJzICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gUGFydGljbGVCYXNpY01hdGVyaWFsICggcGFyYW1ldGVycyApIHtcbiAgICBcdGNvbnNvbGUud2FybiggJ1RIUkVFLlBhcnRpY2xlQmFzaWNNYXRlcmlhbCBoYXMgYmVlbiByZW5hbWVkIHRvIFRIUkVFLlBvaW50c01hdGVyaWFsLicgKTtcbiAgICBcdHJldHVybiBuZXcgUG9pbnRzTWF0ZXJpYWwoIHBhcmFtZXRlcnMgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBQYXJ0aWNsZVN5c3RlbU1hdGVyaWFsICggcGFyYW1ldGVycyApIHtcbiAgICBcdGNvbnNvbGUud2FybiggJ1RIUkVFLlBhcnRpY2xlU3lzdGVtTWF0ZXJpYWwgaGFzIGJlZW4gcmVuYW1lZCB0byBUSFJFRS5Qb2ludHNNYXRlcmlhbC4nICk7XG4gICAgXHRyZXR1cm4gbmV3IFBvaW50c01hdGVyaWFsKCBwYXJhbWV0ZXJzICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gVmVydGV4ICggeCwgeSwgeiApIHtcbiAgICBcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZlcnRleCBoYXMgYmVlbiByZW1vdmVkLiBVc2UgVEhSRUUuVmVjdG9yMyBpbnN0ZWFkLicgKTtcbiAgICBcdHJldHVybiBuZXcgVmVjdG9yMyggeCwgeSwgeiApO1xuICAgIH1cblxuICAgIC8vXG5cbiAgICBmdW5jdGlvbiBFZGdlc0hlbHBlciggb2JqZWN0LCBoZXggKSB7XG4gICAgXHRjb25zb2xlLndhcm4oICdUSFJFRS5FZGdlc0hlbHBlciBoYXMgYmVlbiByZW1vdmVkLiBVc2UgVEhSRUUuRWRnZXNHZW9tZXRyeSBpbnN0ZWFkLicgKTtcbiAgICBcdHJldHVybiBuZXcgTGluZVNlZ21lbnRzKCBuZXcgRWRnZXNHZW9tZXRyeSggb2JqZWN0Lmdlb21ldHJ5ICksIG5ldyBMaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogaGV4ICE9PSB1bmRlZmluZWQgPyBoZXggOiAweGZmZmZmZiB9ICkgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBXaXJlZnJhbWVIZWxwZXIoIG9iamVjdCwgaGV4ICkge1xuICAgIFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2lyZWZyYW1lSGVscGVyIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBUSFJFRS5XaXJlZnJhbWVHZW9tZXRyeSBpbnN0ZWFkLicgKTtcbiAgICBcdHJldHVybiBuZXcgTGluZVNlZ21lbnRzKCBuZXcgV2lyZWZyYW1lR2VvbWV0cnkoIG9iamVjdC5nZW9tZXRyeSApLCBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGhleCAhPT0gdW5kZWZpbmVkID8gaGV4IDogMHhmZmZmZmYgfSApICk7XG4gICAgfVxuXG4gICAgLy9cblxuICAgIE9iamVjdC5hc3NpZ24oIEJveDIucHJvdG90eXBlLCB7XG4gICAgXHRjZW50ZXI6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XG4gICAgXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJveDI6IC5jZW50ZXIoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5nZXRDZW50ZXIoKS4nICk7XG4gICAgXHRcdHJldHVybiB0aGlzLmdldENlbnRlciggb3B0aW9uYWxUYXJnZXQgKTtcbiAgICBcdH0sXG4gICAgXHRlbXB0eTogZnVuY3Rpb24gKCkge1xuICAgIFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Cb3gyOiAuZW1wdHkoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5pc0VtcHR5KCkuJyApO1xuICAgIFx0XHRyZXR1cm4gdGhpcy5pc0VtcHR5KCk7XG4gICAgXHR9LFxuICAgIFx0aXNJbnRlcnNlY3Rpb25Cb3g6IGZ1bmN0aW9uICggYm94ICkge1xuICAgIFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Cb3gyOiAuaXNJbnRlcnNlY3Rpb25Cb3goKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5pbnRlcnNlY3RzQm94KCkuJyApO1xuICAgIFx0XHRyZXR1cm4gdGhpcy5pbnRlcnNlY3RzQm94KCBib3ggKTtcbiAgICBcdH0sXG4gICAgXHRzaXplOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuICAgIFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Cb3gyOiAuc2l6ZSgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmdldFNpemUoKS4nICk7XG4gICAgXHRcdHJldHVybiB0aGlzLmdldFNpemUoIG9wdGlvbmFsVGFyZ2V0ICk7XG4gICAgXHR9XG4gICAgfSApO1xuXG4gICAgT2JqZWN0LmFzc2lnbiggQm94My5wcm90b3R5cGUsIHtcbiAgICBcdGNlbnRlcjogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcbiAgICBcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQm94MzogLmNlbnRlcigpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmdldENlbnRlcigpLicgKTtcbiAgICBcdFx0cmV0dXJuIHRoaXMuZ2V0Q2VudGVyKCBvcHRpb25hbFRhcmdldCApO1xuICAgIFx0fSxcbiAgICBcdGVtcHR5OiBmdW5jdGlvbiAoKSB7XG4gICAgXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJveDM6IC5lbXB0eSgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmlzRW1wdHkoKS4nICk7XG4gICAgXHRcdHJldHVybiB0aGlzLmlzRW1wdHkoKTtcbiAgICBcdH0sXG4gICAgXHRpc0ludGVyc2VjdGlvbkJveDogZnVuY3Rpb24gKCBib3ggKSB7XG4gICAgXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJveDM6IC5pc0ludGVyc2VjdGlvbkJveCgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmludGVyc2VjdHNCb3goKS4nICk7XG4gICAgXHRcdHJldHVybiB0aGlzLmludGVyc2VjdHNCb3goIGJveCApO1xuICAgIFx0fSxcbiAgICBcdGlzSW50ZXJzZWN0aW9uU3BoZXJlOiBmdW5jdGlvbiAoIHNwaGVyZSApIHtcbiAgICBcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQm94MzogLmlzSW50ZXJzZWN0aW9uU3BoZXJlKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuaW50ZXJzZWN0c1NwaGVyZSgpLicgKTtcbiAgICBcdFx0cmV0dXJuIHRoaXMuaW50ZXJzZWN0c1NwaGVyZSggc3BoZXJlICk7XG4gICAgXHR9LFxuICAgIFx0c2l6ZTogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcbiAgICBcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQm94MzogLnNpemUoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5nZXRTaXplKCkuJyApO1xuICAgIFx0XHRyZXR1cm4gdGhpcy5nZXRTaXplKCBvcHRpb25hbFRhcmdldCApO1xuICAgIFx0fVxuICAgIH0gKTtcblxuICAgIE9iamVjdC5hc3NpZ24oIExpbmUzLnByb3RvdHlwZSwge1xuICAgIFx0Y2VudGVyOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuICAgIFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5MaW5lMzogLmNlbnRlcigpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmdldENlbnRlcigpLicgKTtcbiAgICBcdFx0cmV0dXJuIHRoaXMuZ2V0Q2VudGVyKCBvcHRpb25hbFRhcmdldCApO1xuICAgIFx0fVxuICAgIH0gKTtcblxuICAgIE9iamVjdC5hc3NpZ24oIE1hdHJpeDMucHJvdG90eXBlLCB7XG4gICAgXHRtdWx0aXBseVZlY3RvcjM6IGZ1bmN0aW9uICggdmVjdG9yICkge1xuICAgIFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXgzOiAubXVsdGlwbHlWZWN0b3IzKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIHZlY3Rvci5hcHBseU1hdHJpeDMoIG1hdHJpeCApIGluc3RlYWQuJyApO1xuICAgIFx0XHRyZXR1cm4gdmVjdG9yLmFwcGx5TWF0cml4MyggdGhpcyApO1xuICAgIFx0fSxcbiAgICBcdG11bHRpcGx5VmVjdG9yM0FycmF5OiBmdW5jdGlvbiAoIGEgKSB7XG4gICAgXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDM6IC5tdWx0aXBseVZlY3RvcjNBcnJheSgpIGhhcyBiZWVuIHJlbmFtZWQuIFVzZSBtYXRyaXguYXBwbHlUb1ZlY3RvcjNBcnJheSggYXJyYXkgKSBpbnN0ZWFkLicgKTtcbiAgICBcdFx0cmV0dXJuIHRoaXMuYXBwbHlUb1ZlY3RvcjNBcnJheSggYSApO1xuICAgIFx0fVxuICAgIH0gKTtcblxuICAgIE9iamVjdC5hc3NpZ24oIE1hdHJpeDQucHJvdG90eXBlLCB7XG4gICAgXHRleHRyYWN0UG9zaXRpb246IGZ1bmN0aW9uICggbSApIHtcbiAgICBcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLmV4dHJhY3RQb3NpdGlvbigpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmNvcHlQb3NpdGlvbigpLicgKTtcbiAgICBcdFx0cmV0dXJuIHRoaXMuY29weVBvc2l0aW9uKCBtICk7XG4gICAgXHR9LFxuICAgIFx0c2V0Um90YXRpb25Gcm9tUXVhdGVybmlvbjogZnVuY3Rpb24gKCBxICkge1xuICAgIFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAuc2V0Um90YXRpb25Gcm9tUXVhdGVybmlvbigpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKCkuJyApO1xuICAgIFx0XHRyZXR1cm4gdGhpcy5tYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbiggcSApO1xuICAgIFx0fSxcbiAgICBcdG11bHRpcGx5VmVjdG9yMzogZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XG4gICAgXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5tdWx0aXBseVZlY3RvcjMoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgdmVjdG9yLmFwcGx5TWF0cml4NCggbWF0cml4ICkgb3IgdmVjdG9yLmFwcGx5UHJvamVjdGlvbiggbWF0cml4ICkgaW5zdGVhZC4nICk7XG4gICAgXHRcdHJldHVybiB2ZWN0b3IuYXBwbHlQcm9qZWN0aW9uKCB0aGlzICk7XG4gICAgXHR9LFxuICAgIFx0bXVsdGlwbHlWZWN0b3I0OiBmdW5jdGlvbiAoIHZlY3RvciApIHtcbiAgICBcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLm11bHRpcGx5VmVjdG9yNCgpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSB2ZWN0b3IuYXBwbHlNYXRyaXg0KCBtYXRyaXggKSBpbnN0ZWFkLicgKTtcbiAgICBcdFx0cmV0dXJuIHZlY3Rvci5hcHBseU1hdHJpeDQoIHRoaXMgKTtcbiAgICBcdH0sXG4gICAgXHRtdWx0aXBseVZlY3RvcjNBcnJheTogZnVuY3Rpb24gKCBhICkge1xuICAgIFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAubXVsdGlwbHlWZWN0b3IzQXJyYXkoKSBoYXMgYmVlbiByZW5hbWVkLiBVc2UgbWF0cml4LmFwcGx5VG9WZWN0b3IzQXJyYXkoIGFycmF5ICkgaW5zdGVhZC4nICk7XG4gICAgXHRcdHJldHVybiB0aGlzLmFwcGx5VG9WZWN0b3IzQXJyYXkoIGEgKTtcbiAgICBcdH0sXG4gICAgXHRyb3RhdGVBeGlzOiBmdW5jdGlvbiAoIHYgKSB7XG4gICAgXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5yb3RhdGVBeGlzKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFZlY3RvcjMudHJhbnNmb3JtRGlyZWN0aW9uKCBtYXRyaXggKSBpbnN0ZWFkLicgKTtcbiAgICBcdFx0di50cmFuc2Zvcm1EaXJlY3Rpb24oIHRoaXMgKTtcbiAgICBcdH0sXG4gICAgXHRjcm9zc1ZlY3RvcjogZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XG4gICAgXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5jcm9zc1ZlY3RvcigpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSB2ZWN0b3IuYXBwbHlNYXRyaXg0KCBtYXRyaXggKSBpbnN0ZWFkLicgKTtcbiAgICBcdFx0cmV0dXJuIHZlY3Rvci5hcHBseU1hdHJpeDQoIHRoaXMgKTtcbiAgICBcdH0sXG4gICAgXHR0cmFuc2xhdGU6IGZ1bmN0aW9uICggdiApIHtcbiAgICBcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLk1hdHJpeDQ6IC50cmFuc2xhdGUoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcbiAgICBcdH0sXG4gICAgXHRyb3RhdGVYOiBmdW5jdGlvbiAoIGFuZ2xlICkge1xuICAgIFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuTWF0cml4NDogLnJvdGF0ZVgoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcbiAgICBcdH0sXG4gICAgXHRyb3RhdGVZOiBmdW5jdGlvbiAoIGFuZ2xlICkge1xuICAgIFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuTWF0cml4NDogLnJvdGF0ZVkoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcbiAgICBcdH0sXG4gICAgXHRyb3RhdGVaOiBmdW5jdGlvbiAoIGFuZ2xlICkge1xuICAgIFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuTWF0cml4NDogLnJvdGF0ZVooKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcbiAgICBcdH0sXG4gICAgXHRyb3RhdGVCeUF4aXM6IGZ1bmN0aW9uICggYXhpcywgYW5nbGUgKSB7XG4gICAgXHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5NYXRyaXg0OiAucm90YXRlQnlBeGlzKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XG4gICAgXHR9XG4gICAgfSApO1xuXG4gICAgT2JqZWN0LmFzc2lnbiggUGxhbmUucHJvdG90eXBlLCB7XG4gICAgXHRpc0ludGVyc2VjdGlvbkxpbmU6IGZ1bmN0aW9uICggbGluZSApIHtcbiAgICBcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUGxhbmU6IC5pc0ludGVyc2VjdGlvbkxpbmUoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5pbnRlcnNlY3RzTGluZSgpLicgKTtcbiAgICBcdFx0cmV0dXJuIHRoaXMuaW50ZXJzZWN0c0xpbmUoIGxpbmUgKTtcbiAgICBcdH1cbiAgICB9ICk7XG5cbiAgICBPYmplY3QuYXNzaWduKCBRdWF0ZXJuaW9uLnByb3RvdHlwZSwge1xuICAgIFx0bXVsdGlwbHlWZWN0b3IzOiBmdW5jdGlvbiAoIHZlY3RvciApIHtcbiAgICBcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUXVhdGVybmlvbjogLm11bHRpcGx5VmVjdG9yMygpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBpcyBub3cgdmVjdG9yLmFwcGx5UXVhdGVybmlvbiggcXVhdGVybmlvbiApIGluc3RlYWQuJyApO1xuICAgIFx0XHRyZXR1cm4gdmVjdG9yLmFwcGx5UXVhdGVybmlvbiggdGhpcyApO1xuICAgIFx0fVxuICAgIH0gKTtcblxuICAgIE9iamVjdC5hc3NpZ24oIFJheS5wcm90b3R5cGUsIHtcbiAgICBcdGlzSW50ZXJzZWN0aW9uQm94OiBmdW5jdGlvbiAoIGJveCApIHtcbiAgICBcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUmF5OiAuaXNJbnRlcnNlY3Rpb25Cb3goKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5pbnRlcnNlY3RzQm94KCkuJyApO1xuICAgIFx0XHRyZXR1cm4gdGhpcy5pbnRlcnNlY3RzQm94KCBib3ggKTtcbiAgICBcdH0sXG4gICAgXHRpc0ludGVyc2VjdGlvblBsYW5lOiBmdW5jdGlvbiAoIHBsYW5lICkge1xuICAgIFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5SYXk6IC5pc0ludGVyc2VjdGlvblBsYW5lKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuaW50ZXJzZWN0c1BsYW5lKCkuJyApO1xuICAgIFx0XHRyZXR1cm4gdGhpcy5pbnRlcnNlY3RzUGxhbmUoIHBsYW5lICk7XG4gICAgXHR9LFxuICAgIFx0aXNJbnRlcnNlY3Rpb25TcGhlcmU6IGZ1bmN0aW9uICggc3BoZXJlICkge1xuICAgIFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5SYXk6IC5pc0ludGVyc2VjdGlvblNwaGVyZSgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmludGVyc2VjdHNTcGhlcmUoKS4nICk7XG4gICAgXHRcdHJldHVybiB0aGlzLmludGVyc2VjdHNTcGhlcmUoIHNwaGVyZSApO1xuICAgIFx0fVxuICAgIH0gKTtcblxuICAgIE9iamVjdC5hc3NpZ24oIFNoYXBlLnByb3RvdHlwZSwge1xuICAgIFx0ZXh0cnVkZTogZnVuY3Rpb24gKCBvcHRpb25zICkge1xuICAgIFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5TaGFwZTogLmV4dHJ1ZGUoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgRXh0cnVkZUdlb21ldHJ5KCkgaW5zdGVhZC4nICk7XG4gICAgXHRcdHJldHVybiBuZXcgRXh0cnVkZUdlb21ldHJ5KCB0aGlzLCBvcHRpb25zICk7XG4gICAgXHR9LFxuICAgIFx0bWFrZUdlb21ldHJ5OiBmdW5jdGlvbiAoIG9wdGlvbnMgKSB7XG4gICAgXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlNoYXBlOiAubWFrZUdlb21ldHJ5KCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFNoYXBlR2VvbWV0cnkoKSBpbnN0ZWFkLicgKTtcbiAgICBcdFx0cmV0dXJuIG5ldyBTaGFwZUdlb21ldHJ5KCB0aGlzLCBvcHRpb25zICk7XG4gICAgXHR9XG4gICAgfSApO1xuXG4gICAgT2JqZWN0LmFzc2lnbiggVmVjdG9yMy5wcm90b3R5cGUsIHtcbiAgICBcdHNldEV1bGVyRnJvbVJvdGF0aW9uTWF0cml4OiBmdW5jdGlvbiAoKSB7XG4gICAgXHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5WZWN0b3IzOiAuc2V0RXVsZXJGcm9tUm90YXRpb25NYXRyaXgoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgRXVsZXIuc2V0RnJvbVJvdGF0aW9uTWF0cml4KCkgaW5zdGVhZC4nICk7XG4gICAgXHR9LFxuICAgIFx0c2V0RXVsZXJGcm9tUXVhdGVybmlvbjogZnVuY3Rpb24gKCkge1xuICAgIFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuVmVjdG9yMzogLnNldEV1bGVyRnJvbVF1YXRlcm5pb24oKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgRXVsZXIuc2V0RnJvbVF1YXRlcm5pb24oKSBpbnN0ZWFkLicgKTtcbiAgICBcdH0sXG4gICAgXHRnZXRQb3NpdGlvbkZyb21NYXRyaXg6IGZ1bmN0aW9uICggbSApIHtcbiAgICBcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLmdldFBvc2l0aW9uRnJvbU1hdHJpeCgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLnNldEZyb21NYXRyaXhQb3NpdGlvbigpLicgKTtcbiAgICBcdFx0cmV0dXJuIHRoaXMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBtICk7XG4gICAgXHR9LFxuICAgIFx0Z2V0U2NhbGVGcm9tTWF0cml4OiBmdW5jdGlvbiAoIG0gKSB7XG4gICAgXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjM6IC5nZXRTY2FsZUZyb21NYXRyaXgoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5zZXRGcm9tTWF0cml4U2NhbGUoKS4nICk7XG4gICAgXHRcdHJldHVybiB0aGlzLnNldEZyb21NYXRyaXhTY2FsZSggbSApO1xuICAgIFx0fSxcbiAgICBcdGdldENvbHVtbkZyb21NYXRyaXg6IGZ1bmN0aW9uICggaW5kZXgsIG1hdHJpeCApIHtcbiAgICBcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLmdldENvbHVtbkZyb21NYXRyaXgoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5zZXRGcm9tTWF0cml4Q29sdW1uKCkuJyApO1xuICAgIFx0XHRyZXR1cm4gdGhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKCBtYXRyaXgsIGluZGV4ICk7XG4gICAgXHR9XG4gICAgfSApO1xuXG4gICAgLy9cblxuICAgIE9iamVjdC5hc3NpZ24oIE9iamVjdDNELnByb3RvdHlwZSwge1xuICAgIFx0Z2V0Q2hpbGRCeU5hbWU6IGZ1bmN0aW9uICggbmFtZSApIHtcbiAgICBcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0M0Q6IC5nZXRDaGlsZEJ5TmFtZSgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmdldE9iamVjdEJ5TmFtZSgpLicgKTtcbiAgICBcdFx0cmV0dXJuIHRoaXMuZ2V0T2JqZWN0QnlOYW1lKCBuYW1lICk7XG4gICAgXHR9LFxuICAgIFx0cmVuZGVyRGVwdGg6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG4gICAgXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdDNEOiAucmVuZGVyRGVwdGggaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIC5yZW5kZXJPcmRlciwgaW5zdGVhZC4nICk7XG4gICAgXHR9LFxuICAgIFx0dHJhbnNsYXRlOiBmdW5jdGlvbiAoIGRpc3RhbmNlLCBheGlzICkge1xuICAgIFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3QzRDogLnRyYW5zbGF0ZSgpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSAudHJhbnNsYXRlT25BeGlzKCBheGlzLCBkaXN0YW5jZSApIGluc3RlYWQuJyApO1xuICAgIFx0XHRyZXR1cm4gdGhpcy50cmFuc2xhdGVPbkF4aXMoIGF4aXMsIGRpc3RhbmNlICk7XG4gICAgXHR9XG4gICAgfSApO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIE9iamVjdDNELnByb3RvdHlwZSwge1xuICAgIFx0ZXVsZXJPcmRlcjoge1xuICAgIFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3QzRDogLmV1bGVyT3JkZXIgaXMgbm93IC5yb3RhdGlvbi5vcmRlci4nICk7XG4gICAgXHRcdFx0cmV0dXJuIHRoaXMucm90YXRpb24ub3JkZXI7XG4gICAgXHRcdH0sXG4gICAgXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcbiAgICBcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3QzRDogLmV1bGVyT3JkZXIgaXMgbm93IC5yb3RhdGlvbi5vcmRlci4nICk7XG4gICAgXHRcdFx0dGhpcy5yb3RhdGlvbi5vcmRlciA9IHZhbHVlO1xuICAgIFx0XHR9XG4gICAgXHR9LFxuICAgIFx0dXNlUXVhdGVybmlvbjoge1xuICAgIFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3QzRDogLnVzZVF1YXRlcm5pb24gaGFzIGJlZW4gcmVtb3ZlZC4gVGhlIGxpYnJhcnkgbm93IHVzZXMgcXVhdGVybmlvbnMgYnkgZGVmYXVsdC4nICk7XG4gICAgXHRcdH0sXG4gICAgXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcbiAgICBcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3QzRDogLnVzZVF1YXRlcm5pb24gaGFzIGJlZW4gcmVtb3ZlZC4gVGhlIGxpYnJhcnkgbm93IHVzZXMgcXVhdGVybmlvbnMgYnkgZGVmYXVsdC4nICk7XG4gICAgXHRcdH1cbiAgICBcdH1cbiAgICB9ICk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyggTE9ELnByb3RvdHlwZSwge1xuICAgIFx0b2JqZWN0czoge1xuICAgIFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5MT0Q6IC5vYmplY3RzIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmxldmVscy4nICk7XG4gICAgXHRcdFx0cmV0dXJuIHRoaXMubGV2ZWxzO1xuICAgIFx0XHR9XG4gICAgXHR9XG4gICAgfSApO1xuXG4gICAgLy9cblxuICAgIFBlcnNwZWN0aXZlQ2FtZXJhLnByb3RvdHlwZS5zZXRMZW5zID0gZnVuY3Rpb24gKCBmb2NhbExlbmd0aCwgZmlsbUdhdWdlICkge1xuXG4gICAgXHRjb25zb2xlLndhcm4oIFwiVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEuc2V0TGVucyBpcyBkZXByZWNhdGVkLiBcIiArXG4gICAgXHRcdFx0XCJVc2UgLnNldEZvY2FsTGVuZ3RoIGFuZCAuZmlsbUdhdWdlIGZvciBhIHBob3RvZ3JhcGhpYyBzZXR1cC5cIiApO1xuXG4gICAgXHRpZiAoIGZpbG1HYXVnZSAhPT0gdW5kZWZpbmVkICkgdGhpcy5maWxtR2F1Z2UgPSBmaWxtR2F1Z2U7XG4gICAgXHR0aGlzLnNldEZvY2FsTGVuZ3RoKCBmb2NhbExlbmd0aCApO1xuXG4gICAgfTtcblxuICAgIC8vXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyggTGlnaHQucHJvdG90eXBlLCB7XG4gICAgXHRvbmx5U2hhZG93OiB7XG4gICAgXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcbiAgICBcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5MaWdodDogLm9ubHlTaGFkb3cgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XG4gICAgXHRcdH1cbiAgICBcdH0sXG4gICAgXHRzaGFkb3dDYW1lcmFGb3Y6IHtcbiAgICBcdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuICAgIFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkxpZ2h0OiAuc2hhZG93Q2FtZXJhRm92IGlzIG5vdyAuc2hhZG93LmNhbWVyYS5mb3YuJyApO1xuICAgIFx0XHRcdHRoaXMuc2hhZG93LmNhbWVyYS5mb3YgPSB2YWx1ZTtcbiAgICBcdFx0fVxuICAgIFx0fSxcbiAgICBcdHNoYWRvd0NhbWVyYUxlZnQ6IHtcbiAgICBcdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuICAgIFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkxpZ2h0OiAuc2hhZG93Q2FtZXJhTGVmdCBpcyBub3cgLnNoYWRvdy5jYW1lcmEubGVmdC4nICk7XG4gICAgXHRcdFx0dGhpcy5zaGFkb3cuY2FtZXJhLmxlZnQgPSB2YWx1ZTtcbiAgICBcdFx0fVxuICAgIFx0fSxcbiAgICBcdHNoYWRvd0NhbWVyYVJpZ2h0OiB7XG4gICAgXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcbiAgICBcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5MaWdodDogLnNoYWRvd0NhbWVyYVJpZ2h0IGlzIG5vdyAuc2hhZG93LmNhbWVyYS5yaWdodC4nICk7XG4gICAgXHRcdFx0dGhpcy5zaGFkb3cuY2FtZXJhLnJpZ2h0ID0gdmFsdWU7XG4gICAgXHRcdH1cbiAgICBcdH0sXG4gICAgXHRzaGFkb3dDYW1lcmFUb3A6IHtcbiAgICBcdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuICAgIFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkxpZ2h0OiAuc2hhZG93Q2FtZXJhVG9wIGlzIG5vdyAuc2hhZG93LmNhbWVyYS50b3AuJyApO1xuICAgIFx0XHRcdHRoaXMuc2hhZG93LmNhbWVyYS50b3AgPSB2YWx1ZTtcbiAgICBcdFx0fVxuICAgIFx0fSxcbiAgICBcdHNoYWRvd0NhbWVyYUJvdHRvbToge1xuICAgIFx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG4gICAgXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTGlnaHQ6IC5zaGFkb3dDYW1lcmFCb3R0b20gaXMgbm93IC5zaGFkb3cuY2FtZXJhLmJvdHRvbS4nICk7XG4gICAgXHRcdFx0dGhpcy5zaGFkb3cuY2FtZXJhLmJvdHRvbSA9IHZhbHVlO1xuICAgIFx0XHR9XG4gICAgXHR9LFxuICAgIFx0c2hhZG93Q2FtZXJhTmVhcjoge1xuICAgIFx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG4gICAgXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTGlnaHQ6IC5zaGFkb3dDYW1lcmFOZWFyIGlzIG5vdyAuc2hhZG93LmNhbWVyYS5uZWFyLicgKTtcbiAgICBcdFx0XHR0aGlzLnNoYWRvdy5jYW1lcmEubmVhciA9IHZhbHVlO1xuICAgIFx0XHR9XG4gICAgXHR9LFxuICAgIFx0c2hhZG93Q2FtZXJhRmFyOiB7XG4gICAgXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcbiAgICBcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5MaWdodDogLnNoYWRvd0NhbWVyYUZhciBpcyBub3cgLnNoYWRvdy5jYW1lcmEuZmFyLicgKTtcbiAgICBcdFx0XHR0aGlzLnNoYWRvdy5jYW1lcmEuZmFyID0gdmFsdWU7XG4gICAgXHRcdH1cbiAgICBcdH0sXG4gICAgXHRzaGFkb3dDYW1lcmFWaXNpYmxlOiB7XG4gICAgXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcbiAgICBcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5MaWdodDogLnNoYWRvd0NhbWVyYVZpc2libGUgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIG5ldyBUSFJFRS5DYW1lcmFIZWxwZXIoIGxpZ2h0LnNoYWRvdy5jYW1lcmEgKSBpbnN0ZWFkLicgKTtcbiAgICBcdFx0fVxuICAgIFx0fSxcbiAgICBcdHNoYWRvd0JpYXM6IHtcbiAgICBcdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuICAgIFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkxpZ2h0OiAuc2hhZG93QmlhcyBpcyBub3cgLnNoYWRvdy5iaWFzLicgKTtcbiAgICBcdFx0XHR0aGlzLnNoYWRvdy5iaWFzID0gdmFsdWU7XG4gICAgXHRcdH1cbiAgICBcdH0sXG4gICAgXHRzaGFkb3dEYXJrbmVzczoge1xuICAgIFx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG4gICAgXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTGlnaHQ6IC5zaGFkb3dEYXJrbmVzcyBoYXMgYmVlbiByZW1vdmVkLicgKTtcbiAgICBcdFx0fVxuICAgIFx0fSxcbiAgICBcdHNoYWRvd01hcFdpZHRoOiB7XG4gICAgXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcbiAgICBcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5MaWdodDogLnNoYWRvd01hcFdpZHRoIGlzIG5vdyAuc2hhZG93Lm1hcFNpemUud2lkdGguJyApO1xuICAgIFx0XHRcdHRoaXMuc2hhZG93Lm1hcFNpemUud2lkdGggPSB2YWx1ZTtcbiAgICBcdFx0fVxuICAgIFx0fSxcbiAgICBcdHNoYWRvd01hcEhlaWdodDoge1xuICAgIFx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG4gICAgXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTGlnaHQ6IC5zaGFkb3dNYXBIZWlnaHQgaXMgbm93IC5zaGFkb3cubWFwU2l6ZS5oZWlnaHQuJyApO1xuICAgIFx0XHRcdHRoaXMuc2hhZG93Lm1hcFNpemUuaGVpZ2h0ID0gdmFsdWU7XG4gICAgXHRcdH1cbiAgICBcdH1cbiAgICB9ICk7XG5cbiAgICAvL1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUsIHtcbiAgICBcdGxlbmd0aDoge1xuICAgIFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJBdHRyaWJ1dGU6IC5sZW5ndGggaGFzIGJlZW4gZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSAuY291bnQuJyApO1xuICAgIFx0XHRcdHJldHVybiB0aGlzLmFycmF5Lmxlbmd0aDtcbiAgICBcdFx0fVxuICAgIFx0fVxuICAgIH0gKTtcblxuICAgIE9iamVjdC5hc3NpZ24oIEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSwge1xuICAgIFx0YWRkSW5kZXg6IGZ1bmN0aW9uICggaW5kZXggKSB7XG4gICAgXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5OiAuYWRkSW5kZXgoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5zZXRJbmRleCgpLicgKTtcbiAgICBcdFx0dGhpcy5zZXRJbmRleCggaW5kZXggKTtcbiAgICBcdH0sXG4gICAgXHRhZGREcmF3Q2FsbDogZnVuY3Rpb24gKCBzdGFydCwgY291bnQsIGluZGV4T2Zmc2V0ICkge1xuICAgIFx0XHRpZiAoIGluZGV4T2Zmc2V0ICE9PSB1bmRlZmluZWQgKSB7XG4gICAgXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5hZGREcmF3Q2FsbCgpIG5vIGxvbmdlciBzdXBwb3J0cyBpbmRleE9mZnNldC4nICk7XG4gICAgXHRcdH1cbiAgICBcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5hZGREcmF3Q2FsbCgpIGlzIG5vdyAuYWRkR3JvdXAoKS4nICk7XG4gICAgXHRcdHRoaXMuYWRkR3JvdXAoIHN0YXJ0LCBjb3VudCApO1xuICAgIFx0fSxcbiAgICBcdGNsZWFyRHJhd0NhbGxzOiBmdW5jdGlvbiAoKSB7XG4gICAgXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5OiAuY2xlYXJEcmF3Q2FsbHMoKSBpcyBub3cgLmNsZWFyR3JvdXBzKCkuJyApO1xuICAgIFx0XHR0aGlzLmNsZWFyR3JvdXBzKCk7XG4gICAgXHR9LFxuICAgIFx0Y29tcHV0ZVRhbmdlbnRzOiBmdW5jdGlvbiAoKSB7XG4gICAgXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5OiAuY29tcHV0ZVRhbmdlbnRzKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XG4gICAgXHR9LFxuICAgIFx0Y29tcHV0ZU9mZnNldHM6IGZ1bmN0aW9uICgpIHtcbiAgICBcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5jb21wdXRlT2Zmc2V0cygpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xuICAgIFx0fVxuICAgIH0gKTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUsIHtcbiAgICBcdGRyYXdjYWxsczoge1xuICAgIFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5kcmF3Y2FsbHMgaGFzIGJlZW4gcmVuYW1lZCB0byAuZ3JvdXBzLicgKTtcbiAgICBcdFx0XHRyZXR1cm4gdGhpcy5ncm91cHM7XG4gICAgXHRcdH1cbiAgICBcdH0sXG4gICAgXHRvZmZzZXRzOiB7XG4gICAgXHRcdGdldDogZnVuY3Rpb24gKCkge1xuICAgIFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5OiAub2Zmc2V0cyBoYXMgYmVlbiByZW5hbWVkIHRvIC5ncm91cHMuJyApO1xuICAgIFx0XHRcdHJldHVybiB0aGlzLmdyb3VwcztcbiAgICBcdFx0fVxuICAgIFx0fVxuICAgIH0gKTtcblxuICAgIC8vXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyggTWF0ZXJpYWwucHJvdG90eXBlLCB7XG4gICAgXHR3cmFwQXJvdW5kOiB7XG4gICAgXHRcdGdldDogZnVuY3Rpb24gKCkge1xuICAgIFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLicgKyB0aGlzLnR5cGUgKyAnOiAud3JhcEFyb3VuZCBoYXMgYmVlbiByZW1vdmVkLicgKTtcbiAgICBcdFx0fSxcbiAgICBcdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuICAgIFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLicgKyB0aGlzLnR5cGUgKyAnOiAud3JhcEFyb3VuZCBoYXMgYmVlbiByZW1vdmVkLicgKTtcbiAgICBcdFx0fVxuICAgIFx0fSxcbiAgICBcdHdyYXBSR0I6IHtcbiAgICBcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuJyArIHRoaXMudHlwZSArICc6IC53cmFwUkdCIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xuICAgIFx0XHRcdHJldHVybiBuZXcgQ29sb3IoKTtcbiAgICBcdFx0fVxuICAgIFx0fVxuICAgIH0gKTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBNZXNoUGhvbmdNYXRlcmlhbC5wcm90b3R5cGUsIHtcbiAgICBcdG1ldGFsOiB7XG4gICAgXHRcdGdldDogZnVuY3Rpb24gKCkge1xuICAgIFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1lc2hQaG9uZ01hdGVyaWFsOiAubWV0YWwgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFRIUkVFLk1lc2hTdGFuZGFyZE1hdGVyaWFsIGluc3RlYWQuJyApO1xuICAgIFx0XHRcdHJldHVybiBmYWxzZTtcbiAgICBcdFx0fSxcbiAgICBcdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuICAgIFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1lc2hQaG9uZ01hdGVyaWFsOiAubWV0YWwgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFRIUkVFLk1lc2hTdGFuZGFyZE1hdGVyaWFsIGluc3RlYWQnICk7XG4gICAgXHRcdH1cbiAgICBcdH1cbiAgICB9ICk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyggU2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlLCB7XG4gICAgXHRkZXJpdmF0aXZlczoge1xuICAgIFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5TaGFkZXJNYXRlcmlhbDogLmRlcml2YXRpdmVzIGhhcyBiZWVuIG1vdmVkIHRvIC5leHRlbnNpb25zLmRlcml2YXRpdmVzLicgKTtcbiAgICBcdFx0XHRyZXR1cm4gdGhpcy5leHRlbnNpb25zLmRlcml2YXRpdmVzO1xuICAgIFx0XHR9LFxuICAgIFx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG4gICAgXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuIFNoYWRlck1hdGVyaWFsOiAuZGVyaXZhdGl2ZXMgaGFzIGJlZW4gbW92ZWQgdG8gLmV4dGVuc2lvbnMuZGVyaXZhdGl2ZXMuJyApO1xuICAgIFx0XHRcdHRoaXMuZXh0ZW5zaW9ucy5kZXJpdmF0aXZlcyA9IHZhbHVlO1xuICAgIFx0XHR9XG4gICAgXHR9XG4gICAgfSApO1xuXG4gICAgLy9cblxuICAgIEV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCB7XG5cbiAgICBcdC8vIE5vdGU6IEV4dHJhIGJhc2UgZW5zdXJlcyB0aGVzZSBwcm9wZXJ0aWVzIGFyZSBub3QgJ2Fzc2lnbidlZC5cblxuICAgIFx0Y29uc3RydWN0b3I6IEV2ZW50RGlzcGF0Y2hlcixcblxuICAgIFx0YXBwbHk6IGZ1bmN0aW9uICggdGFyZ2V0ICkge1xuXG4gICAgXHRcdGNvbnNvbGUud2FybiggXCJUSFJFRS5FdmVudERpc3BhdGNoZXI6IC5hcHBseSBpcyBkZXByZWNhdGVkLCBcIiArXG4gICAgXHRcdFx0XHRcImp1c3QgaW5oZXJpdCBvciBPYmplY3QuYXNzaWduIHRoZSBwcm90b3R5cGUgdG8gbWl4LWluLlwiICk7XG5cbiAgICBcdFx0T2JqZWN0LmFzc2lnbiggdGFyZ2V0LCB0aGlzICk7XG5cbiAgICBcdH1cblxuICAgIH0gKSwgRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZSApO1xuXG4gICAgLy9cblxuICAgIE9iamVjdC5hc3NpZ24oIFdlYkdMUmVuZGVyZXIucHJvdG90eXBlLCB7XG4gICAgXHRzdXBwb3J0c0Zsb2F0VGV4dHVyZXM6IGZ1bmN0aW9uICgpIHtcbiAgICBcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnN1cHBvcnRzRmxvYXRUZXh0dXJlcygpIGlzIG5vdyAuZXh0ZW5zaW9ucy5nZXQoIFxcJ09FU190ZXh0dXJlX2Zsb2F0XFwnICkuJyApO1xuICAgIFx0XHRyZXR1cm4gdGhpcy5leHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2Zsb2F0JyApO1xuICAgIFx0fSxcbiAgICBcdHN1cHBvcnRzSGFsZkZsb2F0VGV4dHVyZXM6IGZ1bmN0aW9uICgpIHtcbiAgICBcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnN1cHBvcnRzSGFsZkZsb2F0VGV4dHVyZXMoKSBpcyBub3cgLmV4dGVuc2lvbnMuZ2V0KCBcXCdPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0XFwnICkuJyApO1xuICAgIFx0XHRyZXR1cm4gdGhpcy5leHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2hhbGZfZmxvYXQnICk7XG4gICAgXHR9LFxuICAgIFx0c3VwcG9ydHNTdGFuZGFyZERlcml2YXRpdmVzOiBmdW5jdGlvbiAoKSB7XG4gICAgXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zdXBwb3J0c1N0YW5kYXJkRGVyaXZhdGl2ZXMoKSBpcyBub3cgLmV4dGVuc2lvbnMuZ2V0KCBcXCdPRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXNcXCcgKS4nICk7XG4gICAgXHRcdHJldHVybiB0aGlzLmV4dGVuc2lvbnMuZ2V0KCAnT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzJyApO1xuICAgIFx0fSxcbiAgICBcdHN1cHBvcnRzQ29tcHJlc3NlZFRleHR1cmVTM1RDOiBmdW5jdGlvbiAoKSB7XG4gICAgXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zdXBwb3J0c0NvbXByZXNzZWRUZXh0dXJlUzNUQygpIGlzIG5vdyAuZXh0ZW5zaW9ucy5nZXQoIFxcJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjXFwnICkuJyApO1xuICAgIFx0XHRyZXR1cm4gdGhpcy5leHRlbnNpb25zLmdldCggJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJyApO1xuICAgIFx0fSxcbiAgICBcdHN1cHBvcnRzQ29tcHJlc3NlZFRleHR1cmVQVlJUQzogZnVuY3Rpb24gKCkge1xuICAgIFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc3VwcG9ydHNDb21wcmVzc2VkVGV4dHVyZVBWUlRDKCkgaXMgbm93IC5leHRlbnNpb25zLmdldCggXFwnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjXFwnICkuJyApO1xuICAgIFx0XHRyZXR1cm4gdGhpcy5leHRlbnNpb25zLmdldCggJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0YycgKTtcbiAgICBcdH0sXG4gICAgXHRzdXBwb3J0c0JsZW5kTWluTWF4OiBmdW5jdGlvbiAoKSB7XG4gICAgXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zdXBwb3J0c0JsZW5kTWluTWF4KCkgaXMgbm93IC5leHRlbnNpb25zLmdldCggXFwnRVhUX2JsZW5kX21pbm1heFxcJyApLicgKTtcbiAgICBcdFx0cmV0dXJuIHRoaXMuZXh0ZW5zaW9ucy5nZXQoICdFWFRfYmxlbmRfbWlubWF4JyApO1xuICAgIFx0fSxcbiAgICBcdHN1cHBvcnRzVmVydGV4VGV4dHVyZXM6IGZ1bmN0aW9uICgpIHtcbiAgICBcdFx0cmV0dXJuIHRoaXMuY2FwYWJpbGl0aWVzLnZlcnRleFRleHR1cmVzO1xuICAgIFx0fSxcbiAgICBcdHN1cHBvcnRzSW5zdGFuY2VkQXJyYXlzOiBmdW5jdGlvbiAoKSB7XG4gICAgXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zdXBwb3J0c0luc3RhbmNlZEFycmF5cygpIGlzIG5vdyAuZXh0ZW5zaW9ucy5nZXQoIFxcJ0FOR0xFX2luc3RhbmNlZF9hcnJheXNcXCcgKS4nICk7XG4gICAgXHRcdHJldHVybiB0aGlzLmV4dGVuc2lvbnMuZ2V0KCAnQU5HTEVfaW5zdGFuY2VkX2FycmF5cycgKTtcbiAgICBcdH0sXG4gICAgXHRlbmFibGVTY2lzc29yVGVzdDogZnVuY3Rpb24gKCBib29sZWFuICkge1xuICAgIFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuZW5hYmxlU2Npc3NvclRlc3QoKSBpcyBub3cgLnNldFNjaXNzb3JUZXN0KCkuJyApO1xuICAgIFx0XHR0aGlzLnNldFNjaXNzb3JUZXN0KCBib29sZWFuICk7XG4gICAgXHR9LFxuICAgIFx0aW5pdE1hdGVyaWFsOiBmdW5jdGlvbiAoKSB7XG4gICAgXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5pbml0TWF0ZXJpYWwoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcbiAgICBcdH0sXG4gICAgXHRhZGRQcmVQbHVnaW46IGZ1bmN0aW9uICgpIHtcbiAgICBcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLmFkZFByZVBsdWdpbigpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xuICAgIFx0fSxcbiAgICBcdGFkZFBvc3RQbHVnaW46IGZ1bmN0aW9uICgpIHtcbiAgICBcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLmFkZFBvc3RQbHVnaW4oKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcbiAgICBcdH0sXG4gICAgXHR1cGRhdGVTaGFkb3dNYXA6IGZ1bmN0aW9uICgpIHtcbiAgICBcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnVwZGF0ZVNoYWRvd01hcCgpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xuICAgIFx0fVxuICAgIH0gKTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBXZWJHTFJlbmRlcmVyLnByb3RvdHlwZSwge1xuICAgIFx0c2hhZG93TWFwRW5hYmxlZDoge1xuICAgIFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBcdFx0XHRyZXR1cm4gdGhpcy5zaGFkb3dNYXAuZW5hYmxlZDtcbiAgICBcdFx0fSxcbiAgICBcdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuICAgIFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zaGFkb3dNYXBFbmFibGVkIGlzIG5vdyAuc2hhZG93TWFwLmVuYWJsZWQuJyApO1xuICAgIFx0XHRcdHRoaXMuc2hhZG93TWFwLmVuYWJsZWQgPSB2YWx1ZTtcbiAgICBcdFx0fVxuICAgIFx0fSxcbiAgICBcdHNoYWRvd01hcFR5cGU6IHtcbiAgICBcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgXHRcdFx0cmV0dXJuIHRoaXMuc2hhZG93TWFwLnR5cGU7XG4gICAgXHRcdH0sXG4gICAgXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcbiAgICBcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc2hhZG93TWFwVHlwZSBpcyBub3cgLnNoYWRvd01hcC50eXBlLicgKTtcbiAgICBcdFx0XHR0aGlzLnNoYWRvd01hcC50eXBlID0gdmFsdWU7XG4gICAgXHRcdH1cbiAgICBcdH0sXG4gICAgXHRzaGFkb3dNYXBDdWxsRmFjZToge1xuICAgIFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBcdFx0XHRyZXR1cm4gdGhpcy5zaGFkb3dNYXAuY3VsbEZhY2U7XG4gICAgXHRcdH0sXG4gICAgXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcbiAgICBcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc2hhZG93TWFwQ3VsbEZhY2UgaXMgbm93IC5zaGFkb3dNYXAuY3VsbEZhY2UuJyApO1xuICAgIFx0XHRcdHRoaXMuc2hhZG93TWFwLmN1bGxGYWNlID0gdmFsdWU7XG4gICAgXHRcdH1cbiAgICBcdH1cbiAgICB9ICk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyggV2ViR0xTaGFkb3dNYXAucHJvdG90eXBlLCB7XG4gICAgXHRjdWxsRmFjZToge1xuICAgIFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBcdFx0XHRyZXR1cm4gdGhpcy5yZW5kZXJSZXZlcnNlU2lkZWQgPyBDdWxsRmFjZUZyb250IDogQ3VsbEZhY2VCYWNrO1xuICAgIFx0XHR9LFxuICAgIFx0XHRzZXQ6IGZ1bmN0aW9uICggY3VsbEZhY2UgKSB7XG4gICAgXHRcdFx0dmFyIHZhbHVlID0gKCBjdWxsRmFjZSAhPT0gQ3VsbEZhY2VCYWNrICk7XG4gICAgXHRcdFx0Y29uc29sZS53YXJuKCBcIldlYkdMUmVuZGVyZXI6IC5zaGFkb3dNYXAuY3VsbEZhY2UgaXMgZGVwcmVjYXRlZC4gU2V0IC5zaGFkb3dNYXAucmVuZGVyUmV2ZXJzZVNpZGVkIHRvIFwiICsgdmFsdWUgKyBcIi5cIiApO1xuICAgIFx0XHRcdHRoaXMucmVuZGVyUmV2ZXJzZVNpZGVkID0gdmFsdWU7XG4gICAgXHRcdH1cbiAgICBcdH1cbiAgICB9ICk7XG5cbiAgICAvL1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFdlYkdMUmVuZGVyVGFyZ2V0LnByb3RvdHlwZSwge1xuICAgIFx0d3JhcFM6IHtcbiAgICBcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC53cmFwUyBpcyBub3cgLnRleHR1cmUud3JhcFMuJyApO1xuICAgIFx0XHRcdHJldHVybiB0aGlzLnRleHR1cmUud3JhcFM7XG4gICAgXHRcdH0sXG4gICAgXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcbiAgICBcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLndyYXBTIGlzIG5vdyAudGV4dHVyZS53cmFwUy4nICk7XG4gICAgXHRcdFx0dGhpcy50ZXh0dXJlLndyYXBTID0gdmFsdWU7XG4gICAgXHRcdH1cbiAgICBcdH0sXG4gICAgXHR3cmFwVDoge1xuICAgIFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLndyYXBUIGlzIG5vdyAudGV4dHVyZS53cmFwVC4nICk7XG4gICAgXHRcdFx0cmV0dXJuIHRoaXMudGV4dHVyZS53cmFwVDtcbiAgICBcdFx0fSxcbiAgICBcdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuICAgIFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAud3JhcFQgaXMgbm93IC50ZXh0dXJlLndyYXBULicgKTtcbiAgICBcdFx0XHR0aGlzLnRleHR1cmUud3JhcFQgPSB2YWx1ZTtcbiAgICBcdFx0fVxuICAgIFx0fSxcbiAgICBcdG1hZ0ZpbHRlcjoge1xuICAgIFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLm1hZ0ZpbHRlciBpcyBub3cgLnRleHR1cmUubWFnRmlsdGVyLicgKTtcbiAgICBcdFx0XHRyZXR1cm4gdGhpcy50ZXh0dXJlLm1hZ0ZpbHRlcjtcbiAgICBcdFx0fSxcbiAgICBcdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuICAgIFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAubWFnRmlsdGVyIGlzIG5vdyAudGV4dHVyZS5tYWdGaWx0ZXIuJyApO1xuICAgIFx0XHRcdHRoaXMudGV4dHVyZS5tYWdGaWx0ZXIgPSB2YWx1ZTtcbiAgICBcdFx0fVxuICAgIFx0fSxcbiAgICBcdG1pbkZpbHRlcjoge1xuICAgIFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLm1pbkZpbHRlciBpcyBub3cgLnRleHR1cmUubWluRmlsdGVyLicgKTtcbiAgICBcdFx0XHRyZXR1cm4gdGhpcy50ZXh0dXJlLm1pbkZpbHRlcjtcbiAgICBcdFx0fSxcbiAgICBcdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuICAgIFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAubWluRmlsdGVyIGlzIG5vdyAudGV4dHVyZS5taW5GaWx0ZXIuJyApO1xuICAgIFx0XHRcdHRoaXMudGV4dHVyZS5taW5GaWx0ZXIgPSB2YWx1ZTtcbiAgICBcdFx0fVxuICAgIFx0fSxcbiAgICBcdGFuaXNvdHJvcHk6IHtcbiAgICBcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5hbmlzb3Ryb3B5IGlzIG5vdyAudGV4dHVyZS5hbmlzb3Ryb3B5LicgKTtcbiAgICBcdFx0XHRyZXR1cm4gdGhpcy50ZXh0dXJlLmFuaXNvdHJvcHk7XG4gICAgXHRcdH0sXG4gICAgXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcbiAgICBcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLmFuaXNvdHJvcHkgaXMgbm93IC50ZXh0dXJlLmFuaXNvdHJvcHkuJyApO1xuICAgIFx0XHRcdHRoaXMudGV4dHVyZS5hbmlzb3Ryb3B5ID0gdmFsdWU7XG4gICAgXHRcdH1cbiAgICBcdH0sXG4gICAgXHRvZmZzZXQ6IHtcbiAgICBcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5vZmZzZXQgaXMgbm93IC50ZXh0dXJlLm9mZnNldC4nICk7XG4gICAgXHRcdFx0cmV0dXJuIHRoaXMudGV4dHVyZS5vZmZzZXQ7XG4gICAgXHRcdH0sXG4gICAgXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcbiAgICBcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLm9mZnNldCBpcyBub3cgLnRleHR1cmUub2Zmc2V0LicgKTtcbiAgICBcdFx0XHR0aGlzLnRleHR1cmUub2Zmc2V0ID0gdmFsdWU7XG4gICAgXHRcdH1cbiAgICBcdH0sXG4gICAgXHRyZXBlYXQ6IHtcbiAgICBcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5yZXBlYXQgaXMgbm93IC50ZXh0dXJlLnJlcGVhdC4nICk7XG4gICAgXHRcdFx0cmV0dXJuIHRoaXMudGV4dHVyZS5yZXBlYXQ7XG4gICAgXHRcdH0sXG4gICAgXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcbiAgICBcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLnJlcGVhdCBpcyBub3cgLnRleHR1cmUucmVwZWF0LicgKTtcbiAgICBcdFx0XHR0aGlzLnRleHR1cmUucmVwZWF0ID0gdmFsdWU7XG4gICAgXHRcdH1cbiAgICBcdH0sXG4gICAgXHRmb3JtYXQ6IHtcbiAgICBcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5mb3JtYXQgaXMgbm93IC50ZXh0dXJlLmZvcm1hdC4nICk7XG4gICAgXHRcdFx0cmV0dXJuIHRoaXMudGV4dHVyZS5mb3JtYXQ7XG4gICAgXHRcdH0sXG4gICAgXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcbiAgICBcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLmZvcm1hdCBpcyBub3cgLnRleHR1cmUuZm9ybWF0LicgKTtcbiAgICBcdFx0XHR0aGlzLnRleHR1cmUuZm9ybWF0ID0gdmFsdWU7XG4gICAgXHRcdH1cbiAgICBcdH0sXG4gICAgXHR0eXBlOiB7XG4gICAgXHRcdGdldDogZnVuY3Rpb24gKCkge1xuICAgIFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAudHlwZSBpcyBub3cgLnRleHR1cmUudHlwZS4nICk7XG4gICAgXHRcdFx0cmV0dXJuIHRoaXMudGV4dHVyZS50eXBlO1xuICAgIFx0XHR9LFxuICAgIFx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG4gICAgXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC50eXBlIGlzIG5vdyAudGV4dHVyZS50eXBlLicgKTtcbiAgICBcdFx0XHR0aGlzLnRleHR1cmUudHlwZSA9IHZhbHVlO1xuICAgIFx0XHR9XG4gICAgXHR9LFxuICAgIFx0Z2VuZXJhdGVNaXBtYXBzOiB7XG4gICAgXHRcdGdldDogZnVuY3Rpb24gKCkge1xuICAgIFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAuZ2VuZXJhdGVNaXBtYXBzIGlzIG5vdyAudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMuJyApO1xuICAgIFx0XHRcdHJldHVybiB0aGlzLnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzO1xuICAgIFx0XHR9LFxuICAgIFx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG4gICAgXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5nZW5lcmF0ZU1pcG1hcHMgaXMgbm93IC50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcy4nICk7XG4gICAgXHRcdFx0dGhpcy50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IHZhbHVlO1xuICAgIFx0XHR9XG4gICAgXHR9XG4gICAgfSApO1xuXG4gICAgLy9cblxuICAgIE9iamVjdC5hc3NpZ24oIEF1ZGlvLnByb3RvdHlwZSwge1xuICAgIFx0bG9hZDogZnVuY3Rpb24gKCBmaWxlICkge1xuICAgIFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5BdWRpbzogLmxvYWQgaGFzIGJlZW4gZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBUSFJFRS5BdWRpb0xvYWRlci4nICk7XG4gICAgXHRcdHZhciBzY29wZSA9IHRoaXM7XG4gICAgXHRcdHZhciBhdWRpb0xvYWRlciA9IG5ldyBBdWRpb0xvYWRlcigpO1xuICAgIFx0XHRhdWRpb0xvYWRlci5sb2FkKCBmaWxlLCBmdW5jdGlvbiAoIGJ1ZmZlciApIHtcbiAgICBcdFx0XHRzY29wZS5zZXRCdWZmZXIoIGJ1ZmZlciApO1xuICAgIFx0XHR9ICk7XG4gICAgXHRcdHJldHVybiB0aGlzO1xuICAgIFx0fVxuICAgIH0gKTtcblxuICAgIE9iamVjdC5hc3NpZ24oIEF1ZGlvQW5hbHlzZXIucHJvdG90eXBlLCB7XG4gICAgXHRnZXREYXRhOiBmdW5jdGlvbiAoIGZpbGUgKSB7XG4gICAgXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkF1ZGlvQW5hbHlzZXI6IC5nZXREYXRhKCkgaXMgbm93IC5nZXRGcmVxdWVuY3lEYXRhKCkuJyApO1xuICAgIFx0XHRyZXR1cm4gdGhpcy5nZXRGcmVxdWVuY3lEYXRhKCk7XG4gICAgXHR9XG4gICAgfSApO1xuXG4gICAgLy9cblxuICAgIHZhciBHZW9tZXRyeVV0aWxzID0ge1xuXG4gICAgXHRtZXJnZTogZnVuY3Rpb24gKCBnZW9tZXRyeTEsIGdlb21ldHJ5MiwgbWF0ZXJpYWxJbmRleE9mZnNldCApIHtcblxuICAgIFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5HZW9tZXRyeVV0aWxzOiAubWVyZ2UoKSBoYXMgYmVlbiBtb3ZlZCB0byBHZW9tZXRyeS4gVXNlIGdlb21ldHJ5Lm1lcmdlKCBnZW9tZXRyeTIsIG1hdHJpeCwgbWF0ZXJpYWxJbmRleE9mZnNldCApIGluc3RlYWQuJyApO1xuXG4gICAgXHRcdHZhciBtYXRyaXg7XG5cbiAgICBcdFx0aWYgKCBnZW9tZXRyeTIuaXNNZXNoICkge1xuXG4gICAgXHRcdFx0Z2VvbWV0cnkyLm1hdHJpeEF1dG9VcGRhdGUgJiYgZ2VvbWV0cnkyLnVwZGF0ZU1hdHJpeCgpO1xuXG4gICAgXHRcdFx0bWF0cml4ID0gZ2VvbWV0cnkyLm1hdHJpeDtcbiAgICBcdFx0XHRnZW9tZXRyeTIgPSBnZW9tZXRyeTIuZ2VvbWV0cnk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGdlb21ldHJ5MS5tZXJnZSggZ2VvbWV0cnkyLCBtYXRyaXgsIG1hdGVyaWFsSW5kZXhPZmZzZXQgKTtcblxuICAgIFx0fSxcblxuICAgIFx0Y2VudGVyOiBmdW5jdGlvbiAoIGdlb21ldHJ5ICkge1xuXG4gICAgXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkdlb21ldHJ5VXRpbHM6IC5jZW50ZXIoKSBoYXMgYmVlbiBtb3ZlZCB0byBHZW9tZXRyeS4gVXNlIGdlb21ldHJ5LmNlbnRlcigpIGluc3RlYWQuJyApO1xuICAgIFx0XHRyZXR1cm4gZ2VvbWV0cnkuY2VudGVyKCk7XG5cbiAgICBcdH1cblxuICAgIH07XG5cbiAgICB2YXIgSW1hZ2VVdGlscyA9IHtcblxuICAgIFx0Y3Jvc3NPcmlnaW46IHVuZGVmaW5lZCxcblxuICAgIFx0bG9hZFRleHR1cmU6IGZ1bmN0aW9uICggdXJsLCBtYXBwaW5nLCBvbkxvYWQsIG9uRXJyb3IgKSB7XG5cbiAgICBcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuSW1hZ2VVdGlscy5sb2FkVGV4dHVyZSBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgVEhSRUUuVGV4dHVyZUxvYWRlcigpIGluc3RlYWQuJyApO1xuXG4gICAgXHRcdHZhciBsb2FkZXIgPSBuZXcgVGV4dHVyZUxvYWRlcigpO1xuICAgIFx0XHRsb2FkZXIuc2V0Q3Jvc3NPcmlnaW4oIHRoaXMuY3Jvc3NPcmlnaW4gKTtcblxuICAgIFx0XHR2YXIgdGV4dHVyZSA9IGxvYWRlci5sb2FkKCB1cmwsIG9uTG9hZCwgdW5kZWZpbmVkLCBvbkVycm9yICk7XG5cbiAgICBcdFx0aWYgKCBtYXBwaW5nICkgdGV4dHVyZS5tYXBwaW5nID0gbWFwcGluZztcblxuICAgIFx0XHRyZXR1cm4gdGV4dHVyZTtcblxuICAgIFx0fSxcblxuICAgIFx0bG9hZFRleHR1cmVDdWJlOiBmdW5jdGlvbiAoIHVybHMsIG1hcHBpbmcsIG9uTG9hZCwgb25FcnJvciApIHtcblxuICAgIFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5JbWFnZVV0aWxzLmxvYWRUZXh0dXJlQ3ViZSBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgVEhSRUUuQ3ViZVRleHR1cmVMb2FkZXIoKSBpbnN0ZWFkLicgKTtcblxuICAgIFx0XHR2YXIgbG9hZGVyID0gbmV3IEN1YmVUZXh0dXJlTG9hZGVyKCk7XG4gICAgXHRcdGxvYWRlci5zZXRDcm9zc09yaWdpbiggdGhpcy5jcm9zc09yaWdpbiApO1xuXG4gICAgXHRcdHZhciB0ZXh0dXJlID0gbG9hZGVyLmxvYWQoIHVybHMsIG9uTG9hZCwgdW5kZWZpbmVkLCBvbkVycm9yICk7XG5cbiAgICBcdFx0aWYgKCBtYXBwaW5nICkgdGV4dHVyZS5tYXBwaW5nID0gbWFwcGluZztcblxuICAgIFx0XHRyZXR1cm4gdGV4dHVyZTtcblxuICAgIFx0fSxcblxuICAgIFx0bG9hZENvbXByZXNzZWRUZXh0dXJlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkltYWdlVXRpbHMubG9hZENvbXByZXNzZWRUZXh0dXJlIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBUSFJFRS5ERFNMb2FkZXIgaW5zdGVhZC4nICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGxvYWRDb21wcmVzc2VkVGV4dHVyZUN1YmU6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuSW1hZ2VVdGlscy5sb2FkQ29tcHJlc3NlZFRleHR1cmVDdWJlIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBUSFJFRS5ERFNMb2FkZXIgaW5zdGVhZC4nICk7XG5cbiAgICBcdH1cblxuICAgIH07XG5cbiAgICAvL1xuXG4gICAgZnVuY3Rpb24gUHJvamVjdG9yICgpIHtcblxuICAgIFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlByb2plY3RvciBoYXMgYmVlbiBtb3ZlZCB0byAvZXhhbXBsZXMvanMvcmVuZGVyZXJzL1Byb2plY3Rvci5qcy4nICk7XG5cbiAgICBcdHRoaXMucHJvamVjdFZlY3RvciA9IGZ1bmN0aW9uICggdmVjdG9yLCBjYW1lcmEgKSB7XG5cbiAgICBcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUHJvamVjdG9yOiAucHJvamVjdFZlY3RvcigpIGlzIG5vdyB2ZWN0b3IucHJvamVjdCgpLicgKTtcbiAgICBcdFx0dmVjdG9yLnByb2plY3QoIGNhbWVyYSApO1xuXG4gICAgXHR9O1xuXG4gICAgXHR0aGlzLnVucHJvamVjdFZlY3RvciA9IGZ1bmN0aW9uICggdmVjdG9yLCBjYW1lcmEgKSB7XG5cbiAgICBcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUHJvamVjdG9yOiAudW5wcm9qZWN0VmVjdG9yKCkgaXMgbm93IHZlY3Rvci51bnByb2plY3QoKS4nICk7XG4gICAgXHRcdHZlY3Rvci51bnByb2plY3QoIGNhbWVyYSApO1xuXG4gICAgXHR9O1xuXG4gICAgXHR0aGlzLnBpY2tpbmdSYXkgPSBmdW5jdGlvbiAoIHZlY3RvciwgY2FtZXJhICkge1xuXG4gICAgXHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5Qcm9qZWN0b3I6IC5waWNraW5nUmF5KCkgaXMgbm93IHJheWNhc3Rlci5zZXRGcm9tQ2FtZXJhKCkuJyApO1xuXG4gICAgXHR9O1xuXG4gICAgfVxuXG4gICAgLy9cblxuICAgIGZ1bmN0aW9uIENhbnZhc1JlbmRlcmVyICgpIHtcblxuICAgIFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkNhbnZhc1JlbmRlcmVyIGhhcyBiZWVuIG1vdmVkIHRvIC9leGFtcGxlcy9qcy9yZW5kZXJlcnMvQ2FudmFzUmVuZGVyZXIuanMnICk7XG5cbiAgICBcdHRoaXMuZG9tRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyggJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnLCAnY2FudmFzJyApO1xuICAgIFx0dGhpcy5jbGVhciA9IGZ1bmN0aW9uICgpIHt9O1xuICAgIFx0dGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICBcdHRoaXMuc2V0Q2xlYXJDb2xvciA9IGZ1bmN0aW9uICgpIHt9O1xuICAgIFx0dGhpcy5zZXRTaXplID0gZnVuY3Rpb24gKCkge307XG5cbiAgICB9XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIGV4cG9ydHMsICdBdWRpb0NvbnRleHQnLCB7XG4gICAgXHRnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBcdFx0cmV0dXJuIGV4cG9ydHMuZ2V0QXVkaW9Db250ZXh0KCk7XG4gICAgXHR9XG4gICAgfSk7XG5cbiAgICBleHBvcnRzLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZSA9IFdlYkdMUmVuZGVyVGFyZ2V0Q3ViZTtcbiAgICBleHBvcnRzLldlYkdMUmVuZGVyVGFyZ2V0ID0gV2ViR0xSZW5kZXJUYXJnZXQ7XG4gICAgZXhwb3J0cy5XZWJHTFJlbmRlcmVyID0gV2ViR0xSZW5kZXJlcjtcbiAgICBleHBvcnRzLlNoYWRlckxpYiA9IFNoYWRlckxpYjtcbiAgICBleHBvcnRzLlVuaWZvcm1zTGliID0gVW5pZm9ybXNMaWI7XG4gICAgZXhwb3J0cy5TaGFkZXJDaHVuayA9IFNoYWRlckNodW5rO1xuICAgIGV4cG9ydHMuRm9nRXhwMiA9IEZvZ0V4cDI7XG4gICAgZXhwb3J0cy5Gb2cgPSBGb2c7XG4gICAgZXhwb3J0cy5TY2VuZSA9IFNjZW5lO1xuICAgIGV4cG9ydHMuTGVuc0ZsYXJlID0gTGVuc0ZsYXJlO1xuICAgIGV4cG9ydHMuU3ByaXRlID0gU3ByaXRlO1xuICAgIGV4cG9ydHMuTE9EID0gTE9EO1xuICAgIGV4cG9ydHMuU2tpbm5lZE1lc2ggPSBTa2lubmVkTWVzaDtcbiAgICBleHBvcnRzLlNrZWxldG9uID0gU2tlbGV0b247XG4gICAgZXhwb3J0cy5Cb25lID0gQm9uZTtcbiAgICBleHBvcnRzLk1lc2ggPSBNZXNoO1xuICAgIGV4cG9ydHMuTGluZVNlZ21lbnRzID0gTGluZVNlZ21lbnRzO1xuICAgIGV4cG9ydHMuTGluZSA9IExpbmU7XG4gICAgZXhwb3J0cy5Qb2ludHMgPSBQb2ludHM7XG4gICAgZXhwb3J0cy5Hcm91cCA9IEdyb3VwO1xuICAgIGV4cG9ydHMuVmlkZW9UZXh0dXJlID0gVmlkZW9UZXh0dXJlO1xuICAgIGV4cG9ydHMuRGF0YVRleHR1cmUgPSBEYXRhVGV4dHVyZTtcbiAgICBleHBvcnRzLkNvbXByZXNzZWRUZXh0dXJlID0gQ29tcHJlc3NlZFRleHR1cmU7XG4gICAgZXhwb3J0cy5DdWJlVGV4dHVyZSA9IEN1YmVUZXh0dXJlO1xuICAgIGV4cG9ydHMuQ2FudmFzVGV4dHVyZSA9IENhbnZhc1RleHR1cmU7XG4gICAgZXhwb3J0cy5EZXB0aFRleHR1cmUgPSBEZXB0aFRleHR1cmU7XG4gICAgZXhwb3J0cy5UZXh0dXJlSWRDb3VudCA9IFRleHR1cmVJZENvdW50O1xuICAgIGV4cG9ydHMuVGV4dHVyZSA9IFRleHR1cmU7XG4gICAgZXhwb3J0cy5NYXRlcmlhbElkQ291bnQgPSBNYXRlcmlhbElkQ291bnQ7XG4gICAgZXhwb3J0cy5Db21wcmVzc2VkVGV4dHVyZUxvYWRlciA9IENvbXByZXNzZWRUZXh0dXJlTG9hZGVyO1xuICAgIGV4cG9ydHMuQmluYXJ5VGV4dHVyZUxvYWRlciA9IEJpbmFyeVRleHR1cmVMb2FkZXI7XG4gICAgZXhwb3J0cy5EYXRhVGV4dHVyZUxvYWRlciA9IERhdGFUZXh0dXJlTG9hZGVyO1xuICAgIGV4cG9ydHMuQ3ViZVRleHR1cmVMb2FkZXIgPSBDdWJlVGV4dHVyZUxvYWRlcjtcbiAgICBleHBvcnRzLlRleHR1cmVMb2FkZXIgPSBUZXh0dXJlTG9hZGVyO1xuICAgIGV4cG9ydHMuT2JqZWN0TG9hZGVyID0gT2JqZWN0TG9hZGVyO1xuICAgIGV4cG9ydHMuTWF0ZXJpYWxMb2FkZXIgPSBNYXRlcmlhbExvYWRlcjtcbiAgICBleHBvcnRzLkJ1ZmZlckdlb21ldHJ5TG9hZGVyID0gQnVmZmVyR2VvbWV0cnlMb2FkZXI7XG4gICAgZXhwb3J0cy5Mb2FkaW5nTWFuYWdlciA9IExvYWRpbmdNYW5hZ2VyO1xuICAgIGV4cG9ydHMuSlNPTkxvYWRlciA9IEpTT05Mb2FkZXI7XG4gICAgZXhwb3J0cy5JbWFnZUxvYWRlciA9IEltYWdlTG9hZGVyO1xuICAgIGV4cG9ydHMuRm9udExvYWRlciA9IEZvbnRMb2FkZXI7XG4gICAgZXhwb3J0cy5YSFJMb2FkZXIgPSBYSFJMb2FkZXI7XG4gICAgZXhwb3J0cy5Mb2FkZXIgPSBMb2FkZXI7XG4gICAgZXhwb3J0cy5BdWRpb0xvYWRlciA9IEF1ZGlvTG9hZGVyO1xuICAgIGV4cG9ydHMuU3BvdExpZ2h0U2hhZG93ID0gU3BvdExpZ2h0U2hhZG93O1xuICAgIGV4cG9ydHMuU3BvdExpZ2h0ID0gU3BvdExpZ2h0O1xuICAgIGV4cG9ydHMuUG9pbnRMaWdodCA9IFBvaW50TGlnaHQ7XG4gICAgZXhwb3J0cy5IZW1pc3BoZXJlTGlnaHQgPSBIZW1pc3BoZXJlTGlnaHQ7XG4gICAgZXhwb3J0cy5EaXJlY3Rpb25hbExpZ2h0U2hhZG93ID0gRGlyZWN0aW9uYWxMaWdodFNoYWRvdztcbiAgICBleHBvcnRzLkRpcmVjdGlvbmFsTGlnaHQgPSBEaXJlY3Rpb25hbExpZ2h0O1xuICAgIGV4cG9ydHMuQW1iaWVudExpZ2h0ID0gQW1iaWVudExpZ2h0O1xuICAgIGV4cG9ydHMuTGlnaHRTaGFkb3cgPSBMaWdodFNoYWRvdztcbiAgICBleHBvcnRzLkxpZ2h0ID0gTGlnaHQ7XG4gICAgZXhwb3J0cy5TdGVyZW9DYW1lcmEgPSBTdGVyZW9DYW1lcmE7XG4gICAgZXhwb3J0cy5QZXJzcGVjdGl2ZUNhbWVyYSA9IFBlcnNwZWN0aXZlQ2FtZXJhO1xuICAgIGV4cG9ydHMuT3J0aG9ncmFwaGljQ2FtZXJhID0gT3J0aG9ncmFwaGljQ2FtZXJhO1xuICAgIGV4cG9ydHMuQ3ViZUNhbWVyYSA9IEN1YmVDYW1lcmE7XG4gICAgZXhwb3J0cy5DYW1lcmEgPSBDYW1lcmE7XG4gICAgZXhwb3J0cy5BdWRpb0xpc3RlbmVyID0gQXVkaW9MaXN0ZW5lcjtcbiAgICBleHBvcnRzLlBvc2l0aW9uYWxBdWRpbyA9IFBvc2l0aW9uYWxBdWRpbztcbiAgICBleHBvcnRzLmdldEF1ZGlvQ29udGV4dCA9IGdldEF1ZGlvQ29udGV4dDtcbiAgICBleHBvcnRzLkF1ZGlvQW5hbHlzZXIgPSBBdWRpb0FuYWx5c2VyO1xuICAgIGV4cG9ydHMuQXVkaW8gPSBBdWRpbztcbiAgICBleHBvcnRzLlZlY3RvcktleWZyYW1lVHJhY2sgPSBWZWN0b3JLZXlmcmFtZVRyYWNrO1xuICAgIGV4cG9ydHMuU3RyaW5nS2V5ZnJhbWVUcmFjayA9IFN0cmluZ0tleWZyYW1lVHJhY2s7XG4gICAgZXhwb3J0cy5RdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjayA9IFF1YXRlcm5pb25LZXlmcmFtZVRyYWNrO1xuICAgIGV4cG9ydHMuTnVtYmVyS2V5ZnJhbWVUcmFjayA9IE51bWJlcktleWZyYW1lVHJhY2s7XG4gICAgZXhwb3J0cy5Db2xvcktleWZyYW1lVHJhY2sgPSBDb2xvcktleWZyYW1lVHJhY2s7XG4gICAgZXhwb3J0cy5Cb29sZWFuS2V5ZnJhbWVUcmFjayA9IEJvb2xlYW5LZXlmcmFtZVRyYWNrO1xuICAgIGV4cG9ydHMuUHJvcGVydHlNaXhlciA9IFByb3BlcnR5TWl4ZXI7XG4gICAgZXhwb3J0cy5Qcm9wZXJ0eUJpbmRpbmcgPSBQcm9wZXJ0eUJpbmRpbmc7XG4gICAgZXhwb3J0cy5LZXlmcmFtZVRyYWNrID0gS2V5ZnJhbWVUcmFjaztcbiAgICBleHBvcnRzLkFuaW1hdGlvbk9iamVjdEdyb3VwID0gQW5pbWF0aW9uT2JqZWN0R3JvdXA7XG4gICAgZXhwb3J0cy5BbmltYXRpb25NaXhlciA9IEFuaW1hdGlvbk1peGVyO1xuICAgIGV4cG9ydHMuQW5pbWF0aW9uQ2xpcCA9IEFuaW1hdGlvbkNsaXA7XG4gICAgZXhwb3J0cy5Vbmlmb3JtID0gVW5pZm9ybTtcbiAgICBleHBvcnRzLkluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5ID0gSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnk7XG4gICAgZXhwb3J0cy5CdWZmZXJHZW9tZXRyeSA9IEJ1ZmZlckdlb21ldHJ5O1xuICAgIGV4cG9ydHMuR2VvbWV0cnlJZENvdW50ID0gR2VvbWV0cnlJZENvdW50O1xuICAgIGV4cG9ydHMuR2VvbWV0cnkgPSBHZW9tZXRyeTtcbiAgICBleHBvcnRzLkludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlID0gSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGU7XG4gICAgZXhwb3J0cy5JbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlciA9IEluc3RhbmNlZEludGVybGVhdmVkQnVmZmVyO1xuICAgIGV4cG9ydHMuSW50ZXJsZWF2ZWRCdWZmZXIgPSBJbnRlcmxlYXZlZEJ1ZmZlcjtcbiAgICBleHBvcnRzLkluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSA9IEluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZTtcbiAgICBleHBvcnRzLkR5bmFtaWNCdWZmZXJBdHRyaWJ1dGUgPSBEeW5hbWljQnVmZmVyQXR0cmlidXRlO1xuICAgIGV4cG9ydHMuRmxvYXQ2NEF0dHJpYnV0ZSA9IEZsb2F0NjRBdHRyaWJ1dGU7XG4gICAgZXhwb3J0cy5GbG9hdDMyQXR0cmlidXRlID0gRmxvYXQzMkF0dHJpYnV0ZTtcbiAgICBleHBvcnRzLlVpbnQzMkF0dHJpYnV0ZSA9IFVpbnQzMkF0dHJpYnV0ZTtcbiAgICBleHBvcnRzLkludDMyQXR0cmlidXRlID0gSW50MzJBdHRyaWJ1dGU7XG4gICAgZXhwb3J0cy5VaW50MTZBdHRyaWJ1dGUgPSBVaW50MTZBdHRyaWJ1dGU7XG4gICAgZXhwb3J0cy5JbnQxNkF0dHJpYnV0ZSA9IEludDE2QXR0cmlidXRlO1xuICAgIGV4cG9ydHMuVWludDhDbGFtcGVkQXR0cmlidXRlID0gVWludDhDbGFtcGVkQXR0cmlidXRlO1xuICAgIGV4cG9ydHMuVWludDhBdHRyaWJ1dGUgPSBVaW50OEF0dHJpYnV0ZTtcbiAgICBleHBvcnRzLkludDhBdHRyaWJ1dGUgPSBJbnQ4QXR0cmlidXRlO1xuICAgIGV4cG9ydHMuQnVmZmVyQXR0cmlidXRlID0gQnVmZmVyQXR0cmlidXRlO1xuICAgIGV4cG9ydHMuRmFjZTMgPSBGYWNlMztcbiAgICBleHBvcnRzLk9iamVjdDNESWRDb3VudCA9IE9iamVjdDNESWRDb3VudDtcbiAgICBleHBvcnRzLk9iamVjdDNEID0gT2JqZWN0M0Q7XG4gICAgZXhwb3J0cy5SYXljYXN0ZXIgPSBSYXljYXN0ZXI7XG4gICAgZXhwb3J0cy5MYXllcnMgPSBMYXllcnM7XG4gICAgZXhwb3J0cy5FdmVudERpc3BhdGNoZXIgPSBFdmVudERpc3BhdGNoZXI7XG4gICAgZXhwb3J0cy5DbG9jayA9IENsb2NrO1xuICAgIGV4cG9ydHMuUXVhdGVybmlvbkxpbmVhckludGVycG9sYW50ID0gUXVhdGVybmlvbkxpbmVhckludGVycG9sYW50O1xuICAgIGV4cG9ydHMuTGluZWFySW50ZXJwb2xhbnQgPSBMaW5lYXJJbnRlcnBvbGFudDtcbiAgICBleHBvcnRzLkRpc2NyZXRlSW50ZXJwb2xhbnQgPSBEaXNjcmV0ZUludGVycG9sYW50O1xuICAgIGV4cG9ydHMuQ3ViaWNJbnRlcnBvbGFudCA9IEN1YmljSW50ZXJwb2xhbnQ7XG4gICAgZXhwb3J0cy5JbnRlcnBvbGFudCA9IEludGVycG9sYW50O1xuICAgIGV4cG9ydHMuVHJpYW5nbGUgPSBUcmlhbmdsZTtcbiAgICBleHBvcnRzLlNwbGluZSA9IFNwbGluZTtcbiAgICBleHBvcnRzLlNwaGVyaWNhbCA9IFNwaGVyaWNhbDtcbiAgICBleHBvcnRzLlBsYW5lID0gUGxhbmU7XG4gICAgZXhwb3J0cy5GcnVzdHVtID0gRnJ1c3R1bTtcbiAgICBleHBvcnRzLlNwaGVyZSA9IFNwaGVyZTtcbiAgICBleHBvcnRzLlJheSA9IFJheTtcbiAgICBleHBvcnRzLk1hdHJpeDQgPSBNYXRyaXg0O1xuICAgIGV4cG9ydHMuTWF0cml4MyA9IE1hdHJpeDM7XG4gICAgZXhwb3J0cy5Cb3gzID0gQm94MztcbiAgICBleHBvcnRzLkJveDIgPSBCb3gyO1xuICAgIGV4cG9ydHMuTGluZTMgPSBMaW5lMztcbiAgICBleHBvcnRzLkV1bGVyID0gRXVsZXI7XG4gICAgZXhwb3J0cy5WZWN0b3I0ID0gVmVjdG9yNDtcbiAgICBleHBvcnRzLlZlY3RvcjMgPSBWZWN0b3IzO1xuICAgIGV4cG9ydHMuVmVjdG9yMiA9IFZlY3RvcjI7XG4gICAgZXhwb3J0cy5RdWF0ZXJuaW9uID0gUXVhdGVybmlvbjtcbiAgICBleHBvcnRzLkNvbG9yID0gQ29sb3I7XG4gICAgZXhwb3J0cy5Nb3JwaEJsZW5kTWVzaCA9IE1vcnBoQmxlbmRNZXNoO1xuICAgIGV4cG9ydHMuSW1tZWRpYXRlUmVuZGVyT2JqZWN0ID0gSW1tZWRpYXRlUmVuZGVyT2JqZWN0O1xuICAgIGV4cG9ydHMuVmVydGV4Tm9ybWFsc0hlbHBlciA9IFZlcnRleE5vcm1hbHNIZWxwZXI7XG4gICAgZXhwb3J0cy5TcG90TGlnaHRIZWxwZXIgPSBTcG90TGlnaHRIZWxwZXI7XG4gICAgZXhwb3J0cy5Ta2VsZXRvbkhlbHBlciA9IFNrZWxldG9uSGVscGVyO1xuICAgIGV4cG9ydHMuUG9pbnRMaWdodEhlbHBlciA9IFBvaW50TGlnaHRIZWxwZXI7XG4gICAgZXhwb3J0cy5IZW1pc3BoZXJlTGlnaHRIZWxwZXIgPSBIZW1pc3BoZXJlTGlnaHRIZWxwZXI7XG4gICAgZXhwb3J0cy5HcmlkSGVscGVyID0gR3JpZEhlbHBlcjtcbiAgICBleHBvcnRzLkZhY2VOb3JtYWxzSGVscGVyID0gRmFjZU5vcm1hbHNIZWxwZXI7XG4gICAgZXhwb3J0cy5EaXJlY3Rpb25hbExpZ2h0SGVscGVyID0gRGlyZWN0aW9uYWxMaWdodEhlbHBlcjtcbiAgICBleHBvcnRzLkNhbWVyYUhlbHBlciA9IENhbWVyYUhlbHBlcjtcbiAgICBleHBvcnRzLkJvdW5kaW5nQm94SGVscGVyID0gQm91bmRpbmdCb3hIZWxwZXI7XG4gICAgZXhwb3J0cy5Cb3hIZWxwZXIgPSBCb3hIZWxwZXI7XG4gICAgZXhwb3J0cy5BcnJvd0hlbHBlciA9IEFycm93SGVscGVyO1xuICAgIGV4cG9ydHMuQXhpc0hlbHBlciA9IEF4aXNIZWxwZXI7XG4gICAgZXhwb3J0cy5DbG9zZWRTcGxpbmVDdXJ2ZTMgPSBDbG9zZWRTcGxpbmVDdXJ2ZTM7XG4gICAgZXhwb3J0cy5TcGxpbmVDdXJ2ZTMgPSBTcGxpbmVDdXJ2ZTM7XG4gICAgZXhwb3J0cy5BcmNDdXJ2ZSA9IEFyY0N1cnZlO1xuICAgIGV4cG9ydHMuRWxsaXBzZUN1cnZlID0gRWxsaXBzZUN1cnZlO1xuICAgIGV4cG9ydHMuU3BsaW5lQ3VydmUgPSBTcGxpbmVDdXJ2ZTtcbiAgICBleHBvcnRzLkN1YmljQmV6aWVyQ3VydmUgPSBDdWJpY0JlemllckN1cnZlO1xuICAgIGV4cG9ydHMuUXVhZHJhdGljQmV6aWVyQ3VydmUgPSBRdWFkcmF0aWNCZXppZXJDdXJ2ZTtcbiAgICBleHBvcnRzLkxpbmVDdXJ2ZSA9IExpbmVDdXJ2ZTtcbiAgICBleHBvcnRzLlNoYXBlID0gU2hhcGU7XG4gICAgZXhwb3J0cy5TaGFwZVBhdGggPSBTaGFwZVBhdGg7XG4gICAgZXhwb3J0cy5QYXRoID0gUGF0aDtcbiAgICBleHBvcnRzLkZvbnQgPSBGb250O1xuICAgIGV4cG9ydHMuQ3VydmVQYXRoID0gQ3VydmVQYXRoO1xuICAgIGV4cG9ydHMuQ3VydmUgPSBDdXJ2ZTtcbiAgICBleHBvcnRzLldpcmVmcmFtZUdlb21ldHJ5ID0gV2lyZWZyYW1lR2VvbWV0cnk7XG4gICAgZXhwb3J0cy5QYXJhbWV0cmljR2VvbWV0cnkgPSBQYXJhbWV0cmljR2VvbWV0cnk7XG4gICAgZXhwb3J0cy5UZXRyYWhlZHJvbkdlb21ldHJ5ID0gVGV0cmFoZWRyb25HZW9tZXRyeTtcbiAgICBleHBvcnRzLk9jdGFoZWRyb25HZW9tZXRyeSA9IE9jdGFoZWRyb25HZW9tZXRyeTtcbiAgICBleHBvcnRzLkljb3NhaGVkcm9uR2VvbWV0cnkgPSBJY29zYWhlZHJvbkdlb21ldHJ5O1xuICAgIGV4cG9ydHMuRG9kZWNhaGVkcm9uR2VvbWV0cnkgPSBEb2RlY2FoZWRyb25HZW9tZXRyeTtcbiAgICBleHBvcnRzLlBvbHloZWRyb25HZW9tZXRyeSA9IFBvbHloZWRyb25HZW9tZXRyeTtcbiAgICBleHBvcnRzLlR1YmVHZW9tZXRyeSA9IFR1YmVHZW9tZXRyeTtcbiAgICBleHBvcnRzLlRvcnVzS25vdEdlb21ldHJ5ID0gVG9ydXNLbm90R2VvbWV0cnk7XG4gICAgZXhwb3J0cy5Ub3J1c0tub3RCdWZmZXJHZW9tZXRyeSA9IFRvcnVzS25vdEJ1ZmZlckdlb21ldHJ5O1xuICAgIGV4cG9ydHMuVG9ydXNHZW9tZXRyeSA9IFRvcnVzR2VvbWV0cnk7XG4gICAgZXhwb3J0cy5Ub3J1c0J1ZmZlckdlb21ldHJ5ID0gVG9ydXNCdWZmZXJHZW9tZXRyeTtcbiAgICBleHBvcnRzLlRleHRHZW9tZXRyeSA9IFRleHRHZW9tZXRyeTtcbiAgICBleHBvcnRzLlNwaGVyZUJ1ZmZlckdlb21ldHJ5ID0gU3BoZXJlQnVmZmVyR2VvbWV0cnk7XG4gICAgZXhwb3J0cy5TcGhlcmVHZW9tZXRyeSA9IFNwaGVyZUdlb21ldHJ5O1xuICAgIGV4cG9ydHMuUmluZ0dlb21ldHJ5ID0gUmluZ0dlb21ldHJ5O1xuICAgIGV4cG9ydHMuUmluZ0J1ZmZlckdlb21ldHJ5ID0gUmluZ0J1ZmZlckdlb21ldHJ5O1xuICAgIGV4cG9ydHMuUGxhbmVCdWZmZXJHZW9tZXRyeSA9IFBsYW5lQnVmZmVyR2VvbWV0cnk7XG4gICAgZXhwb3J0cy5QbGFuZUdlb21ldHJ5ID0gUGxhbmVHZW9tZXRyeTtcbiAgICBleHBvcnRzLkxhdGhlR2VvbWV0cnkgPSBMYXRoZUdlb21ldHJ5O1xuICAgIGV4cG9ydHMuTGF0aGVCdWZmZXJHZW9tZXRyeSA9IExhdGhlQnVmZmVyR2VvbWV0cnk7XG4gICAgZXhwb3J0cy5TaGFwZUdlb21ldHJ5ID0gU2hhcGVHZW9tZXRyeTtcbiAgICBleHBvcnRzLkV4dHJ1ZGVHZW9tZXRyeSA9IEV4dHJ1ZGVHZW9tZXRyeTtcbiAgICBleHBvcnRzLkVkZ2VzR2VvbWV0cnkgPSBFZGdlc0dlb21ldHJ5O1xuICAgIGV4cG9ydHMuQ29uZUdlb21ldHJ5ID0gQ29uZUdlb21ldHJ5O1xuICAgIGV4cG9ydHMuQ29uZUJ1ZmZlckdlb21ldHJ5ID0gQ29uZUJ1ZmZlckdlb21ldHJ5O1xuICAgIGV4cG9ydHMuQ3lsaW5kZXJHZW9tZXRyeSA9IEN5bGluZGVyR2VvbWV0cnk7XG4gICAgZXhwb3J0cy5DeWxpbmRlckJ1ZmZlckdlb21ldHJ5ID0gQ3lsaW5kZXJCdWZmZXJHZW9tZXRyeTtcbiAgICBleHBvcnRzLkNpcmNsZUJ1ZmZlckdlb21ldHJ5ID0gQ2lyY2xlQnVmZmVyR2VvbWV0cnk7XG4gICAgZXhwb3J0cy5DaXJjbGVHZW9tZXRyeSA9IENpcmNsZUdlb21ldHJ5O1xuICAgIGV4cG9ydHMuQm94QnVmZmVyR2VvbWV0cnkgPSBCb3hCdWZmZXJHZW9tZXRyeTtcbiAgICBleHBvcnRzLkJveEdlb21ldHJ5ID0gQm94R2VvbWV0cnk7XG4gICAgZXhwb3J0cy5TaGFkb3dNYXRlcmlhbCA9IFNoYWRvd01hdGVyaWFsO1xuICAgIGV4cG9ydHMuU3ByaXRlTWF0ZXJpYWwgPSBTcHJpdGVNYXRlcmlhbDtcbiAgICBleHBvcnRzLlJhd1NoYWRlck1hdGVyaWFsID0gUmF3U2hhZGVyTWF0ZXJpYWw7XG4gICAgZXhwb3J0cy5TaGFkZXJNYXRlcmlhbCA9IFNoYWRlck1hdGVyaWFsO1xuICAgIGV4cG9ydHMuUG9pbnRzTWF0ZXJpYWwgPSBQb2ludHNNYXRlcmlhbDtcbiAgICBleHBvcnRzLk11bHRpTWF0ZXJpYWwgPSBNdWx0aU1hdGVyaWFsO1xuICAgIGV4cG9ydHMuTWVzaFBoeXNpY2FsTWF0ZXJpYWwgPSBNZXNoUGh5c2ljYWxNYXRlcmlhbDtcbiAgICBleHBvcnRzLk1lc2hTdGFuZGFyZE1hdGVyaWFsID0gTWVzaFN0YW5kYXJkTWF0ZXJpYWw7XG4gICAgZXhwb3J0cy5NZXNoUGhvbmdNYXRlcmlhbCA9IE1lc2hQaG9uZ01hdGVyaWFsO1xuICAgIGV4cG9ydHMuTWVzaE5vcm1hbE1hdGVyaWFsID0gTWVzaE5vcm1hbE1hdGVyaWFsO1xuICAgIGV4cG9ydHMuTWVzaExhbWJlcnRNYXRlcmlhbCA9IE1lc2hMYW1iZXJ0TWF0ZXJpYWw7XG4gICAgZXhwb3J0cy5NZXNoRGVwdGhNYXRlcmlhbCA9IE1lc2hEZXB0aE1hdGVyaWFsO1xuICAgIGV4cG9ydHMuTWVzaEJhc2ljTWF0ZXJpYWwgPSBNZXNoQmFzaWNNYXRlcmlhbDtcbiAgICBleHBvcnRzLkxpbmVEYXNoZWRNYXRlcmlhbCA9IExpbmVEYXNoZWRNYXRlcmlhbDtcbiAgICBleHBvcnRzLkxpbmVCYXNpY01hdGVyaWFsID0gTGluZUJhc2ljTWF0ZXJpYWw7XG4gICAgZXhwb3J0cy5NYXRlcmlhbCA9IE1hdGVyaWFsO1xuICAgIGV4cG9ydHMuUkVWSVNJT04gPSBSRVZJU0lPTjtcbiAgICBleHBvcnRzLk1PVVNFID0gTU9VU0U7XG4gICAgZXhwb3J0cy5DdWxsRmFjZU5vbmUgPSBDdWxsRmFjZU5vbmU7XG4gICAgZXhwb3J0cy5DdWxsRmFjZUJhY2sgPSBDdWxsRmFjZUJhY2s7XG4gICAgZXhwb3J0cy5DdWxsRmFjZUZyb250ID0gQ3VsbEZhY2VGcm9udDtcbiAgICBleHBvcnRzLkN1bGxGYWNlRnJvbnRCYWNrID0gQ3VsbEZhY2VGcm9udEJhY2s7XG4gICAgZXhwb3J0cy5Gcm9udEZhY2VEaXJlY3Rpb25DVyA9IEZyb250RmFjZURpcmVjdGlvbkNXO1xuICAgIGV4cG9ydHMuRnJvbnRGYWNlRGlyZWN0aW9uQ0NXID0gRnJvbnRGYWNlRGlyZWN0aW9uQ0NXO1xuICAgIGV4cG9ydHMuQmFzaWNTaGFkb3dNYXAgPSBCYXNpY1NoYWRvd01hcDtcbiAgICBleHBvcnRzLlBDRlNoYWRvd01hcCA9IFBDRlNoYWRvd01hcDtcbiAgICBleHBvcnRzLlBDRlNvZnRTaGFkb3dNYXAgPSBQQ0ZTb2Z0U2hhZG93TWFwO1xuICAgIGV4cG9ydHMuRnJvbnRTaWRlID0gRnJvbnRTaWRlO1xuICAgIGV4cG9ydHMuQmFja1NpZGUgPSBCYWNrU2lkZTtcbiAgICBleHBvcnRzLkRvdWJsZVNpZGUgPSBEb3VibGVTaWRlO1xuICAgIGV4cG9ydHMuRmxhdFNoYWRpbmcgPSBGbGF0U2hhZGluZztcbiAgICBleHBvcnRzLlNtb290aFNoYWRpbmcgPSBTbW9vdGhTaGFkaW5nO1xuICAgIGV4cG9ydHMuTm9Db2xvcnMgPSBOb0NvbG9ycztcbiAgICBleHBvcnRzLkZhY2VDb2xvcnMgPSBGYWNlQ29sb3JzO1xuICAgIGV4cG9ydHMuVmVydGV4Q29sb3JzID0gVmVydGV4Q29sb3JzO1xuICAgIGV4cG9ydHMuTm9CbGVuZGluZyA9IE5vQmxlbmRpbmc7XG4gICAgZXhwb3J0cy5Ob3JtYWxCbGVuZGluZyA9IE5vcm1hbEJsZW5kaW5nO1xuICAgIGV4cG9ydHMuQWRkaXRpdmVCbGVuZGluZyA9IEFkZGl0aXZlQmxlbmRpbmc7XG4gICAgZXhwb3J0cy5TdWJ0cmFjdGl2ZUJsZW5kaW5nID0gU3VidHJhY3RpdmVCbGVuZGluZztcbiAgICBleHBvcnRzLk11bHRpcGx5QmxlbmRpbmcgPSBNdWx0aXBseUJsZW5kaW5nO1xuICAgIGV4cG9ydHMuQ3VzdG9tQmxlbmRpbmcgPSBDdXN0b21CbGVuZGluZztcbiAgICBleHBvcnRzLkJsZW5kaW5nTW9kZSA9IEJsZW5kaW5nTW9kZTtcbiAgICBleHBvcnRzLkFkZEVxdWF0aW9uID0gQWRkRXF1YXRpb247XG4gICAgZXhwb3J0cy5TdWJ0cmFjdEVxdWF0aW9uID0gU3VidHJhY3RFcXVhdGlvbjtcbiAgICBleHBvcnRzLlJldmVyc2VTdWJ0cmFjdEVxdWF0aW9uID0gUmV2ZXJzZVN1YnRyYWN0RXF1YXRpb247XG4gICAgZXhwb3J0cy5NaW5FcXVhdGlvbiA9IE1pbkVxdWF0aW9uO1xuICAgIGV4cG9ydHMuTWF4RXF1YXRpb24gPSBNYXhFcXVhdGlvbjtcbiAgICBleHBvcnRzLlplcm9GYWN0b3IgPSBaZXJvRmFjdG9yO1xuICAgIGV4cG9ydHMuT25lRmFjdG9yID0gT25lRmFjdG9yO1xuICAgIGV4cG9ydHMuU3JjQ29sb3JGYWN0b3IgPSBTcmNDb2xvckZhY3RvcjtcbiAgICBleHBvcnRzLk9uZU1pbnVzU3JjQ29sb3JGYWN0b3IgPSBPbmVNaW51c1NyY0NvbG9yRmFjdG9yO1xuICAgIGV4cG9ydHMuU3JjQWxwaGFGYWN0b3IgPSBTcmNBbHBoYUZhY3RvcjtcbiAgICBleHBvcnRzLk9uZU1pbnVzU3JjQWxwaGFGYWN0b3IgPSBPbmVNaW51c1NyY0FscGhhRmFjdG9yO1xuICAgIGV4cG9ydHMuRHN0QWxwaGFGYWN0b3IgPSBEc3RBbHBoYUZhY3RvcjtcbiAgICBleHBvcnRzLk9uZU1pbnVzRHN0QWxwaGFGYWN0b3IgPSBPbmVNaW51c0RzdEFscGhhRmFjdG9yO1xuICAgIGV4cG9ydHMuRHN0Q29sb3JGYWN0b3IgPSBEc3RDb2xvckZhY3RvcjtcbiAgICBleHBvcnRzLk9uZU1pbnVzRHN0Q29sb3JGYWN0b3IgPSBPbmVNaW51c0RzdENvbG9yRmFjdG9yO1xuICAgIGV4cG9ydHMuU3JjQWxwaGFTYXR1cmF0ZUZhY3RvciA9IFNyY0FscGhhU2F0dXJhdGVGYWN0b3I7XG4gICAgZXhwb3J0cy5OZXZlckRlcHRoID0gTmV2ZXJEZXB0aDtcbiAgICBleHBvcnRzLkFsd2F5c0RlcHRoID0gQWx3YXlzRGVwdGg7XG4gICAgZXhwb3J0cy5MZXNzRGVwdGggPSBMZXNzRGVwdGg7XG4gICAgZXhwb3J0cy5MZXNzRXF1YWxEZXB0aCA9IExlc3NFcXVhbERlcHRoO1xuICAgIGV4cG9ydHMuRXF1YWxEZXB0aCA9IEVxdWFsRGVwdGg7XG4gICAgZXhwb3J0cy5HcmVhdGVyRXF1YWxEZXB0aCA9IEdyZWF0ZXJFcXVhbERlcHRoO1xuICAgIGV4cG9ydHMuR3JlYXRlckRlcHRoID0gR3JlYXRlckRlcHRoO1xuICAgIGV4cG9ydHMuTm90RXF1YWxEZXB0aCA9IE5vdEVxdWFsRGVwdGg7XG4gICAgZXhwb3J0cy5NdWx0aXBseU9wZXJhdGlvbiA9IE11bHRpcGx5T3BlcmF0aW9uO1xuICAgIGV4cG9ydHMuTWl4T3BlcmF0aW9uID0gTWl4T3BlcmF0aW9uO1xuICAgIGV4cG9ydHMuQWRkT3BlcmF0aW9uID0gQWRkT3BlcmF0aW9uO1xuICAgIGV4cG9ydHMuTm9Ub25lTWFwcGluZyA9IE5vVG9uZU1hcHBpbmc7XG4gICAgZXhwb3J0cy5MaW5lYXJUb25lTWFwcGluZyA9IExpbmVhclRvbmVNYXBwaW5nO1xuICAgIGV4cG9ydHMuUmVpbmhhcmRUb25lTWFwcGluZyA9IFJlaW5oYXJkVG9uZU1hcHBpbmc7XG4gICAgZXhwb3J0cy5VbmNoYXJ0ZWQyVG9uZU1hcHBpbmcgPSBVbmNoYXJ0ZWQyVG9uZU1hcHBpbmc7XG4gICAgZXhwb3J0cy5DaW5lb25Ub25lTWFwcGluZyA9IENpbmVvblRvbmVNYXBwaW5nO1xuICAgIGV4cG9ydHMuVVZNYXBwaW5nID0gVVZNYXBwaW5nO1xuICAgIGV4cG9ydHMuQ3ViZVJlZmxlY3Rpb25NYXBwaW5nID0gQ3ViZVJlZmxlY3Rpb25NYXBwaW5nO1xuICAgIGV4cG9ydHMuQ3ViZVJlZnJhY3Rpb25NYXBwaW5nID0gQ3ViZVJlZnJhY3Rpb25NYXBwaW5nO1xuICAgIGV4cG9ydHMuRXF1aXJlY3Rhbmd1bGFyUmVmbGVjdGlvbk1hcHBpbmcgPSBFcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZztcbiAgICBleHBvcnRzLkVxdWlyZWN0YW5ndWxhclJlZnJhY3Rpb25NYXBwaW5nID0gRXF1aXJlY3Rhbmd1bGFyUmVmcmFjdGlvbk1hcHBpbmc7XG4gICAgZXhwb3J0cy5TcGhlcmljYWxSZWZsZWN0aW9uTWFwcGluZyA9IFNwaGVyaWNhbFJlZmxlY3Rpb25NYXBwaW5nO1xuICAgIGV4cG9ydHMuQ3ViZVVWUmVmbGVjdGlvbk1hcHBpbmcgPSBDdWJlVVZSZWZsZWN0aW9uTWFwcGluZztcbiAgICBleHBvcnRzLkN1YmVVVlJlZnJhY3Rpb25NYXBwaW5nID0gQ3ViZVVWUmVmcmFjdGlvbk1hcHBpbmc7XG4gICAgZXhwb3J0cy5UZXh0dXJlTWFwcGluZyA9IFRleHR1cmVNYXBwaW5nO1xuICAgIGV4cG9ydHMuUmVwZWF0V3JhcHBpbmcgPSBSZXBlYXRXcmFwcGluZztcbiAgICBleHBvcnRzLkNsYW1wVG9FZGdlV3JhcHBpbmcgPSBDbGFtcFRvRWRnZVdyYXBwaW5nO1xuICAgIGV4cG9ydHMuTWlycm9yZWRSZXBlYXRXcmFwcGluZyA9IE1pcnJvcmVkUmVwZWF0V3JhcHBpbmc7XG4gICAgZXhwb3J0cy5UZXh0dXJlV3JhcHBpbmcgPSBUZXh0dXJlV3JhcHBpbmc7XG4gICAgZXhwb3J0cy5OZWFyZXN0RmlsdGVyID0gTmVhcmVzdEZpbHRlcjtcbiAgICBleHBvcnRzLk5lYXJlc3RNaXBNYXBOZWFyZXN0RmlsdGVyID0gTmVhcmVzdE1pcE1hcE5lYXJlc3RGaWx0ZXI7XG4gICAgZXhwb3J0cy5OZWFyZXN0TWlwTWFwTGluZWFyRmlsdGVyID0gTmVhcmVzdE1pcE1hcExpbmVhckZpbHRlcjtcbiAgICBleHBvcnRzLkxpbmVhckZpbHRlciA9IExpbmVhckZpbHRlcjtcbiAgICBleHBvcnRzLkxpbmVhck1pcE1hcE5lYXJlc3RGaWx0ZXIgPSBMaW5lYXJNaXBNYXBOZWFyZXN0RmlsdGVyO1xuICAgIGV4cG9ydHMuTGluZWFyTWlwTWFwTGluZWFyRmlsdGVyID0gTGluZWFyTWlwTWFwTGluZWFyRmlsdGVyO1xuICAgIGV4cG9ydHMuVGV4dHVyZUZpbHRlciA9IFRleHR1cmVGaWx0ZXI7XG4gICAgZXhwb3J0cy5VbnNpZ25lZEJ5dGVUeXBlID0gVW5zaWduZWRCeXRlVHlwZTtcbiAgICBleHBvcnRzLkJ5dGVUeXBlID0gQnl0ZVR5cGU7XG4gICAgZXhwb3J0cy5TaG9ydFR5cGUgPSBTaG9ydFR5cGU7XG4gICAgZXhwb3J0cy5VbnNpZ25lZFNob3J0VHlwZSA9IFVuc2lnbmVkU2hvcnRUeXBlO1xuICAgIGV4cG9ydHMuSW50VHlwZSA9IEludFR5cGU7XG4gICAgZXhwb3J0cy5VbnNpZ25lZEludFR5cGUgPSBVbnNpZ25lZEludFR5cGU7XG4gICAgZXhwb3J0cy5GbG9hdFR5cGUgPSBGbG9hdFR5cGU7XG4gICAgZXhwb3J0cy5IYWxmRmxvYXRUeXBlID0gSGFsZkZsb2F0VHlwZTtcbiAgICBleHBvcnRzLlVuc2lnbmVkU2hvcnQ0NDQ0VHlwZSA9IFVuc2lnbmVkU2hvcnQ0NDQ0VHlwZTtcbiAgICBleHBvcnRzLlVuc2lnbmVkU2hvcnQ1NTUxVHlwZSA9IFVuc2lnbmVkU2hvcnQ1NTUxVHlwZTtcbiAgICBleHBvcnRzLlVuc2lnbmVkU2hvcnQ1NjVUeXBlID0gVW5zaWduZWRTaG9ydDU2NVR5cGU7XG4gICAgZXhwb3J0cy5VbnNpZ25lZEludDI0OFR5cGUgPSBVbnNpZ25lZEludDI0OFR5cGU7XG4gICAgZXhwb3J0cy5BbHBoYUZvcm1hdCA9IEFscGhhRm9ybWF0O1xuICAgIGV4cG9ydHMuUkdCRm9ybWF0ID0gUkdCRm9ybWF0O1xuICAgIGV4cG9ydHMuUkdCQUZvcm1hdCA9IFJHQkFGb3JtYXQ7XG4gICAgZXhwb3J0cy5MdW1pbmFuY2VGb3JtYXQgPSBMdW1pbmFuY2VGb3JtYXQ7XG4gICAgZXhwb3J0cy5MdW1pbmFuY2VBbHBoYUZvcm1hdCA9IEx1bWluYW5jZUFscGhhRm9ybWF0O1xuICAgIGV4cG9ydHMuUkdCRUZvcm1hdCA9IFJHQkVGb3JtYXQ7XG4gICAgZXhwb3J0cy5EZXB0aEZvcm1hdCA9IERlcHRoRm9ybWF0O1xuICAgIGV4cG9ydHMuRGVwdGhTdGVuY2lsRm9ybWF0ID0gRGVwdGhTdGVuY2lsRm9ybWF0O1xuICAgIGV4cG9ydHMuUkdCX1MzVENfRFhUMV9Gb3JtYXQgPSBSR0JfUzNUQ19EWFQxX0Zvcm1hdDtcbiAgICBleHBvcnRzLlJHQkFfUzNUQ19EWFQxX0Zvcm1hdCA9IFJHQkFfUzNUQ19EWFQxX0Zvcm1hdDtcbiAgICBleHBvcnRzLlJHQkFfUzNUQ19EWFQzX0Zvcm1hdCA9IFJHQkFfUzNUQ19EWFQzX0Zvcm1hdDtcbiAgICBleHBvcnRzLlJHQkFfUzNUQ19EWFQ1X0Zvcm1hdCA9IFJHQkFfUzNUQ19EWFQ1X0Zvcm1hdDtcbiAgICBleHBvcnRzLlJHQl9QVlJUQ180QlBQVjFfRm9ybWF0ID0gUkdCX1BWUlRDXzRCUFBWMV9Gb3JtYXQ7XG4gICAgZXhwb3J0cy5SR0JfUFZSVENfMkJQUFYxX0Zvcm1hdCA9IFJHQl9QVlJUQ18yQlBQVjFfRm9ybWF0O1xuICAgIGV4cG9ydHMuUkdCQV9QVlJUQ180QlBQVjFfRm9ybWF0ID0gUkdCQV9QVlJUQ180QlBQVjFfRm9ybWF0O1xuICAgIGV4cG9ydHMuUkdCQV9QVlJUQ18yQlBQVjFfRm9ybWF0ID0gUkdCQV9QVlJUQ18yQlBQVjFfRm9ybWF0O1xuICAgIGV4cG9ydHMuUkdCX0VUQzFfRm9ybWF0ID0gUkdCX0VUQzFfRm9ybWF0O1xuICAgIGV4cG9ydHMuTG9vcE9uY2UgPSBMb29wT25jZTtcbiAgICBleHBvcnRzLkxvb3BSZXBlYXQgPSBMb29wUmVwZWF0O1xuICAgIGV4cG9ydHMuTG9vcFBpbmdQb25nID0gTG9vcFBpbmdQb25nO1xuICAgIGV4cG9ydHMuSW50ZXJwb2xhdGVEaXNjcmV0ZSA9IEludGVycG9sYXRlRGlzY3JldGU7XG4gICAgZXhwb3J0cy5JbnRlcnBvbGF0ZUxpbmVhciA9IEludGVycG9sYXRlTGluZWFyO1xuICAgIGV4cG9ydHMuSW50ZXJwb2xhdGVTbW9vdGggPSBJbnRlcnBvbGF0ZVNtb290aDtcbiAgICBleHBvcnRzLlplcm9DdXJ2YXR1cmVFbmRpbmcgPSBaZXJvQ3VydmF0dXJlRW5kaW5nO1xuICAgIGV4cG9ydHMuWmVyb1Nsb3BlRW5kaW5nID0gWmVyb1Nsb3BlRW5kaW5nO1xuICAgIGV4cG9ydHMuV3JhcEFyb3VuZEVuZGluZyA9IFdyYXBBcm91bmRFbmRpbmc7XG4gICAgZXhwb3J0cy5UcmlhbmdsZXNEcmF3TW9kZSA9IFRyaWFuZ2xlc0RyYXdNb2RlO1xuICAgIGV4cG9ydHMuVHJpYW5nbGVTdHJpcERyYXdNb2RlID0gVHJpYW5nbGVTdHJpcERyYXdNb2RlO1xuICAgIGV4cG9ydHMuVHJpYW5nbGVGYW5EcmF3TW9kZSA9IFRyaWFuZ2xlRmFuRHJhd01vZGU7XG4gICAgZXhwb3J0cy5MaW5lYXJFbmNvZGluZyA9IExpbmVhckVuY29kaW5nO1xuICAgIGV4cG9ydHMuc1JHQkVuY29kaW5nID0gc1JHQkVuY29kaW5nO1xuICAgIGV4cG9ydHMuR2FtbWFFbmNvZGluZyA9IEdhbW1hRW5jb2Rpbmc7XG4gICAgZXhwb3J0cy5SR0JFRW5jb2RpbmcgPSBSR0JFRW5jb2Rpbmc7XG4gICAgZXhwb3J0cy5Mb2dMdXZFbmNvZGluZyA9IExvZ0x1dkVuY29kaW5nO1xuICAgIGV4cG9ydHMuUkdCTTdFbmNvZGluZyA9IFJHQk03RW5jb2Rpbmc7XG4gICAgZXhwb3J0cy5SR0JNMTZFbmNvZGluZyA9IFJHQk0xNkVuY29kaW5nO1xuICAgIGV4cG9ydHMuUkdCREVuY29kaW5nID0gUkdCREVuY29kaW5nO1xuICAgIGV4cG9ydHMuQmFzaWNEZXB0aFBhY2tpbmcgPSBCYXNpY0RlcHRoUGFja2luZztcbiAgICBleHBvcnRzLlJHQkFEZXB0aFBhY2tpbmcgPSBSR0JBRGVwdGhQYWNraW5nO1xuICAgIGV4cG9ydHMuQ3ViZUdlb21ldHJ5ID0gQm94R2VvbWV0cnk7XG4gICAgZXhwb3J0cy5GYWNlNCA9IEZhY2U0O1xuICAgIGV4cG9ydHMuTGluZVN0cmlwID0gTGluZVN0cmlwO1xuICAgIGV4cG9ydHMuTGluZVBpZWNlcyA9IExpbmVQaWVjZXM7XG4gICAgZXhwb3J0cy5NZXNoRmFjZU1hdGVyaWFsID0gTXVsdGlNYXRlcmlhbDtcbiAgICBleHBvcnRzLlBvaW50Q2xvdWQgPSBQb2ludENsb3VkO1xuICAgIGV4cG9ydHMuUGFydGljbGUgPSBTcHJpdGU7XG4gICAgZXhwb3J0cy5QYXJ0aWNsZVN5c3RlbSA9IFBhcnRpY2xlU3lzdGVtO1xuICAgIGV4cG9ydHMuUG9pbnRDbG91ZE1hdGVyaWFsID0gUG9pbnRDbG91ZE1hdGVyaWFsO1xuICAgIGV4cG9ydHMuUGFydGljbGVCYXNpY01hdGVyaWFsID0gUGFydGljbGVCYXNpY01hdGVyaWFsO1xuICAgIGV4cG9ydHMuUGFydGljbGVTeXN0ZW1NYXRlcmlhbCA9IFBhcnRpY2xlU3lzdGVtTWF0ZXJpYWw7XG4gICAgZXhwb3J0cy5WZXJ0ZXggPSBWZXJ0ZXg7XG4gICAgZXhwb3J0cy5FZGdlc0hlbHBlciA9IEVkZ2VzSGVscGVyO1xuICAgIGV4cG9ydHMuV2lyZWZyYW1lSGVscGVyID0gV2lyZWZyYW1lSGVscGVyO1xuICAgIGV4cG9ydHMuR2VvbWV0cnlVdGlscyA9IEdlb21ldHJ5VXRpbHM7XG4gICAgZXhwb3J0cy5JbWFnZVV0aWxzID0gSW1hZ2VVdGlscztcbiAgICBleHBvcnRzLlByb2plY3RvciA9IFByb2plY3RvcjtcbiAgICBleHBvcnRzLkNhbnZhc1JlbmRlcmVyID0gQ2FudmFzUmVuZGVyZXI7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpOyIsIi8qKlxuICogQGF1dGhvciBKYW1lcyBCYWljb2lhbnUgLyBodHRwOi8vd3d3LmJhaWNvaWFudS5jb20vXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gKFRIUkVFKSA9Pntcblx0VEhSRUUuRmx5Q29udHJvbHMgPSBmdW5jdGlvbiAoIG9iamVjdCwgZG9tRWxlbWVudCApIHtcblxuXHRcdHRoaXMub2JqZWN0ID0gb2JqZWN0O1xuXG5cdFx0dGhpcy5kb21FbGVtZW50ID0gKCBkb21FbGVtZW50ICE9PSB1bmRlZmluZWQgKSA/IGRvbUVsZW1lbnQgOiBkb2N1bWVudDtcblx0XHRpZiAoIGRvbUVsZW1lbnQgKSB0aGlzLmRvbUVsZW1lbnQuc2V0QXR0cmlidXRlKCAndGFiaW5kZXgnLCAtIDEgKTtcblxuXHRcdC8vIEFQSVxuXG5cdFx0dGhpcy5tb3ZlbWVudFNwZWVkID0gMS4wO1xuXHRcdHRoaXMucm9sbFNwZWVkID0gMC4wMDU7XG5cblx0XHR0aGlzLmRyYWdUb0xvb2sgPSBmYWxzZTtcblx0XHR0aGlzLmF1dG9Gb3J3YXJkID0gZmFsc2U7XG5cblx0XHQvLyBkaXNhYmxlIGRlZmF1bHQgdGFyZ2V0IG9iamVjdCBiZWhhdmlvclxuXG5cdFx0Ly8gaW50ZXJuYWxzXG5cblx0XHR0aGlzLnRtcFF1YXRlcm5pb24gPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xuXG5cdFx0dGhpcy5tb3VzZVN0YXR1cyA9IDA7XG5cblx0XHR0aGlzLm1vdmVTdGF0ZSA9IHsgdXA6IDAsIGRvd246IDAsIGxlZnQ6IDAsIHJpZ2h0OiAwLCBmb3J3YXJkOiAwLCBiYWNrOiAwLCBwaXRjaFVwOiAwLCBwaXRjaERvd246IDAsIHlhd0xlZnQ6IDAsIHlhd1JpZ2h0OiAwLCByb2xsTGVmdDogMCwgcm9sbFJpZ2h0OiAwIH07XG5cdFx0dGhpcy5tb3ZlVmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDAsIDAgKTtcblx0XHR0aGlzLnJvdGF0aW9uVmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDAsIDAgKTtcblxuXHRcdHRoaXMuaGFuZGxlRXZlbnQgPSBmdW5jdGlvbiAoIGV2ZW50ICkge1xuXG5cdFx0XHRpZiAoIHR5cGVvZiB0aGlzWyBldmVudC50eXBlIF0gPT0gJ2Z1bmN0aW9uJyApIHtcblxuXHRcdFx0XHR0aGlzWyBldmVudC50eXBlIF0oIGV2ZW50ICk7XG5cblx0XHRcdH1cblxuXHRcdH07XG5cblx0XHR0aGlzLmtleWRvd24gPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHRcdGlmICggZXZlbnQuYWx0S2V5ICkge1xuXG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0fVxuXG5cdFx0XHQvL2V2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHRcdHN3aXRjaCAoIGV2ZW50LmtleUNvZGUgKSB7XG5cblx0XHRcdFx0Y2FzZSAxNjogLyogc2hpZnQgKi8gdGhpcy5tb3ZlbWVudFNwZWVkTXVsdGlwbGllciA9IC4xOyBicmVhaztcblxuXHRcdFx0XHRjYXNlIDg3OiAvKlcqLyB0aGlzLm1vdmVTdGF0ZS5mb3J3YXJkID0gMTsgYnJlYWs7XG5cdFx0XHRcdGNhc2UgODM6IC8qUyovIHRoaXMubW92ZVN0YXRlLmJhY2sgPSAxOyBicmVhaztcblxuXHRcdFx0XHRjYXNlIDY1OiAvKkEqLyB0aGlzLm1vdmVTdGF0ZS5sZWZ0ID0gMTsgYnJlYWs7XG5cdFx0XHRcdGNhc2UgNjg6IC8qRCovIHRoaXMubW92ZVN0YXRlLnJpZ2h0ID0gMTsgYnJlYWs7XG5cblx0XHRcdFx0Y2FzZSA4MjogLypSKi8gdGhpcy5tb3ZlU3RhdGUudXAgPSAxOyBicmVhaztcblx0XHRcdFx0Y2FzZSA3MDogLypGKi8gdGhpcy5tb3ZlU3RhdGUuZG93biA9IDE7IGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgMzg6IC8qdXAqLyB0aGlzLm1vdmVTdGF0ZS5waXRjaFVwID0gMTsgYnJlYWs7XG5cdFx0XHRcdGNhc2UgNDA6IC8qZG93biovIHRoaXMubW92ZVN0YXRlLnBpdGNoRG93biA9IDE7IGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgMzc6IC8qbGVmdCovIHRoaXMubW92ZVN0YXRlLnlhd0xlZnQgPSAxOyBicmVhaztcblx0XHRcdFx0Y2FzZSAzOTogLypyaWdodCovIHRoaXMubW92ZVN0YXRlLnlhd1JpZ2h0ID0gMTsgYnJlYWs7XG5cblx0XHRcdFx0Y2FzZSA4MTogLypRKi8gdGhpcy5tb3ZlU3RhdGUucm9sbExlZnQgPSAxOyBicmVhaztcblx0XHRcdFx0Y2FzZSA2OTogLypFKi8gdGhpcy5tb3ZlU3RhdGUucm9sbFJpZ2h0ID0gMTsgYnJlYWs7XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy51cGRhdGVNb3ZlbWVudFZlY3RvcigpO1xuXHRcdFx0dGhpcy51cGRhdGVSb3RhdGlvblZlY3RvcigpO1xuXG5cdFx0fTtcblxuXHRcdHRoaXMua2V5dXAgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHRcdHN3aXRjaCAoIGV2ZW50LmtleUNvZGUgKSB7XG5cblx0XHRcdFx0Y2FzZSAxNjogLyogc2hpZnQgKi8gdGhpcy5tb3ZlbWVudFNwZWVkTXVsdGlwbGllciA9IDE7IGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgODc6IC8qVyovIHRoaXMubW92ZVN0YXRlLmZvcndhcmQgPSAwOyBicmVhaztcblx0XHRcdFx0Y2FzZSA4MzogLypTKi8gdGhpcy5tb3ZlU3RhdGUuYmFjayA9IDA7IGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgNjU6IC8qQSovIHRoaXMubW92ZVN0YXRlLmxlZnQgPSAwOyBicmVhaztcblx0XHRcdFx0Y2FzZSA2ODogLypEKi8gdGhpcy5tb3ZlU3RhdGUucmlnaHQgPSAwOyBicmVhaztcblxuXHRcdFx0XHRjYXNlIDgyOiAvKlIqLyB0aGlzLm1vdmVTdGF0ZS51cCA9IDA7IGJyZWFrO1xuXHRcdFx0XHRjYXNlIDcwOiAvKkYqLyB0aGlzLm1vdmVTdGF0ZS5kb3duID0gMDsgYnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAzODogLyp1cCovIHRoaXMubW92ZVN0YXRlLnBpdGNoVXAgPSAwOyBicmVhaztcblx0XHRcdFx0Y2FzZSA0MDogLypkb3duKi8gdGhpcy5tb3ZlU3RhdGUucGl0Y2hEb3duID0gMDsgYnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAzNzogLypsZWZ0Ki8gdGhpcy5tb3ZlU3RhdGUueWF3TGVmdCA9IDA7IGJyZWFrO1xuXHRcdFx0XHRjYXNlIDM5OiAvKnJpZ2h0Ki8gdGhpcy5tb3ZlU3RhdGUueWF3UmlnaHQgPSAwOyBicmVhaztcblxuXHRcdFx0XHRjYXNlIDgxOiAvKlEqLyB0aGlzLm1vdmVTdGF0ZS5yb2xsTGVmdCA9IDA7IGJyZWFrO1xuXHRcdFx0XHRjYXNlIDY5OiAvKkUqLyB0aGlzLm1vdmVTdGF0ZS5yb2xsUmlnaHQgPSAwOyBicmVhaztcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnVwZGF0ZU1vdmVtZW50VmVjdG9yKCk7XG5cdFx0XHR0aGlzLnVwZGF0ZVJvdGF0aW9uVmVjdG9yKCk7XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5tb3VzZWRvd24gPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHRcdGlmICggdGhpcy5kb21FbGVtZW50ICE9PSBkb2N1bWVudCApIHtcblxuXHRcdFx0XHR0aGlzLmRvbUVsZW1lbnQuZm9jdXMoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cblx0XHRcdGlmICggdGhpcy5kcmFnVG9Mb29rICkge1xuXG5cdFx0XHRcdHRoaXMubW91c2VTdGF0dXMgKys7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0c3dpdGNoICggZXZlbnQuYnV0dG9uICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAwOiB0aGlzLm1vdmVTdGF0ZS5mb3J3YXJkID0gMTsgYnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAyOiB0aGlzLm1vdmVTdGF0ZS5iYWNrID0gMTsgYnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMudXBkYXRlTW92ZW1lbnRWZWN0b3IoKTtcblxuXHRcdFx0fVxuXG5cdFx0fTtcblxuXHRcdHRoaXMubW91c2Vtb3ZlID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0XHRpZiAoICEgdGhpcy5kcmFnVG9Mb29rIHx8IHRoaXMubW91c2VTdGF0dXMgPiAwICkge1xuXG5cdFx0XHRcdHZhciBjb250YWluZXIgPSB0aGlzLmdldENvbnRhaW5lckRpbWVuc2lvbnMoKTtcblx0XHRcdFx0dmFyIGhhbGZXaWR0aCAgPSBjb250YWluZXIuc2l6ZVsgMCBdIC8gMjtcblx0XHRcdFx0dmFyIGhhbGZIZWlnaHQgPSBjb250YWluZXIuc2l6ZVsgMSBdIC8gMjtcblxuXHRcdFx0XHR0aGlzLm1vdmVTdGF0ZS55YXdMZWZ0ICAgPSAtICggKCBldmVudC5wYWdlWCAtIGNvbnRhaW5lci5vZmZzZXRbIDAgXSApIC0gaGFsZldpZHRoICApIC8gaGFsZldpZHRoO1xuXHRcdFx0XHR0aGlzLm1vdmVTdGF0ZS5waXRjaERvd24gPSAgICggKCBldmVudC5wYWdlWSAtIGNvbnRhaW5lci5vZmZzZXRbIDEgXSApIC0gaGFsZkhlaWdodCApIC8gaGFsZkhlaWdodDtcblxuXHRcdFx0XHR0aGlzLnVwZGF0ZVJvdGF0aW9uVmVjdG9yKCk7XG5cblx0XHRcdH1cblxuXHRcdH07XG5cblx0XHR0aGlzLm1vdXNldXAgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuXHRcdFx0aWYgKCB0aGlzLmRyYWdUb0xvb2sgKSB7XG5cblx0XHRcdFx0dGhpcy5tb3VzZVN0YXR1cyAtLTtcblxuXHRcdFx0XHR0aGlzLm1vdmVTdGF0ZS55YXdMZWZ0ID0gdGhpcy5tb3ZlU3RhdGUucGl0Y2hEb3duID0gMDtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRzd2l0Y2ggKCBldmVudC5idXR0b24gKSB7XG5cblx0XHRcdFx0XHRjYXNlIDA6IHRoaXMubW92ZVN0YXRlLmZvcndhcmQgPSAwOyBicmVhaztcblx0XHRcdFx0XHRjYXNlIDI6IHRoaXMubW92ZVN0YXRlLmJhY2sgPSAwOyBicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy51cGRhdGVNb3ZlbWVudFZlY3RvcigpO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMudXBkYXRlUm90YXRpb25WZWN0b3IoKTtcblxuXHRcdH07XG5cblx0XHR0aGlzLnVwZGF0ZSA9IGZ1bmN0aW9uKCBkZWx0YSApIHtcblxuXHRcdFx0dmFyIG1vdmVNdWx0ID0gZGVsdGEgKiB0aGlzLm1vdmVtZW50U3BlZWQ7XG5cdFx0XHR2YXIgcm90TXVsdCA9IGRlbHRhICogdGhpcy5yb2xsU3BlZWQ7XG5cblx0XHRcdHRoaXMub2JqZWN0LnRyYW5zbGF0ZVgoIHRoaXMubW92ZVZlY3Rvci54ICogbW92ZU11bHQgKTtcblx0XHRcdHRoaXMub2JqZWN0LnRyYW5zbGF0ZVkoIHRoaXMubW92ZVZlY3Rvci55ICogbW92ZU11bHQgKTtcblx0XHRcdHRoaXMub2JqZWN0LnRyYW5zbGF0ZVooIHRoaXMubW92ZVZlY3Rvci56ICogbW92ZU11bHQgKTtcblxuXHRcdFx0dGhpcy50bXBRdWF0ZXJuaW9uLnNldCggdGhpcy5yb3RhdGlvblZlY3Rvci54ICogcm90TXVsdCwgdGhpcy5yb3RhdGlvblZlY3Rvci55ICogcm90TXVsdCwgdGhpcy5yb3RhdGlvblZlY3Rvci56ICogcm90TXVsdCwgMSApLm5vcm1hbGl6ZSgpO1xuXHRcdFx0dGhpcy5vYmplY3QucXVhdGVybmlvbi5tdWx0aXBseSggdGhpcy50bXBRdWF0ZXJuaW9uICk7XG5cblx0XHRcdC8vIGV4cG9zZSB0aGUgcm90YXRpb24gdmVjdG9yIGZvciBjb252ZW5pZW5jZVxuXHRcdFx0dGhpcy5vYmplY3Qucm90YXRpb24uc2V0RnJvbVF1YXRlcm5pb24oIHRoaXMub2JqZWN0LnF1YXRlcm5pb24sIHRoaXMub2JqZWN0LnJvdGF0aW9uLm9yZGVyICk7XG5cblxuXHRcdH07XG5cblx0XHR0aGlzLnVwZGF0ZU1vdmVtZW50VmVjdG9yID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdHZhciBmb3J3YXJkID0gKCB0aGlzLm1vdmVTdGF0ZS5mb3J3YXJkIHx8ICggdGhpcy5hdXRvRm9yd2FyZCAmJiAhIHRoaXMubW92ZVN0YXRlLmJhY2sgKSApID8gMSA6IDA7XG5cblx0XHRcdHRoaXMubW92ZVZlY3Rvci54ID0gKCAtIHRoaXMubW92ZVN0YXRlLmxlZnQgICAgKyB0aGlzLm1vdmVTdGF0ZS5yaWdodCApO1xuXHRcdFx0dGhpcy5tb3ZlVmVjdG9yLnkgPSAoIC0gdGhpcy5tb3ZlU3RhdGUuZG93biAgICArIHRoaXMubW92ZVN0YXRlLnVwICk7XG5cdFx0XHR0aGlzLm1vdmVWZWN0b3IueiA9ICggLSBmb3J3YXJkICsgdGhpcy5tb3ZlU3RhdGUuYmFjayApO1xuXG5cdFx0XHQvL2NvbnNvbGUubG9nKCAnbW92ZTonLCBbIHRoaXMubW92ZVZlY3Rvci54LCB0aGlzLm1vdmVWZWN0b3IueSwgdGhpcy5tb3ZlVmVjdG9yLnogXSApO1xuXG5cdFx0fTtcblxuXHRcdHRoaXMudXBkYXRlUm90YXRpb25WZWN0b3IgPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0dGhpcy5yb3RhdGlvblZlY3Rvci54ID0gKCAtIHRoaXMubW92ZVN0YXRlLnBpdGNoRG93biArIHRoaXMubW92ZVN0YXRlLnBpdGNoVXAgKTtcblx0XHRcdHRoaXMucm90YXRpb25WZWN0b3IueSA9ICggLSB0aGlzLm1vdmVTdGF0ZS55YXdSaWdodCAgKyB0aGlzLm1vdmVTdGF0ZS55YXdMZWZ0ICk7XG5cdFx0XHR0aGlzLnJvdGF0aW9uVmVjdG9yLnogPSAoIC0gdGhpcy5tb3ZlU3RhdGUucm9sbFJpZ2h0ICsgdGhpcy5tb3ZlU3RhdGUucm9sbExlZnQgKTtcblxuXHRcdFx0Ly9jb25zb2xlLmxvZyggJ3JvdGF0ZTonLCBbIHRoaXMucm90YXRpb25WZWN0b3IueCwgdGhpcy5yb3RhdGlvblZlY3Rvci55LCB0aGlzLnJvdGF0aW9uVmVjdG9yLnogXSApO1xuXG5cdFx0fTtcblxuXHRcdHRoaXMuZ2V0Q29udGFpbmVyRGltZW5zaW9ucyA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRpZiAoIHRoaXMuZG9tRWxlbWVudCAhPSBkb2N1bWVudCApIHtcblxuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdHNpemVcdDogWyB0aGlzLmRvbUVsZW1lbnQub2Zmc2V0V2lkdGgsIHRoaXMuZG9tRWxlbWVudC5vZmZzZXRIZWlnaHQgXSxcblx0XHRcdFx0XHRvZmZzZXRcdDogWyB0aGlzLmRvbUVsZW1lbnQub2Zmc2V0TGVmdCwgIHRoaXMuZG9tRWxlbWVudC5vZmZzZXRUb3AgXVxuXHRcdFx0XHR9O1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0c2l6ZVx0OiBbIHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQgXSxcblx0XHRcdFx0XHRvZmZzZXRcdDogWyAwLCAwIF1cblx0XHRcdFx0fTtcblxuXHRcdFx0fVxuXG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGJpbmQoIHNjb3BlLCBmbiApIHtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRmbi5hcHBseSggc2NvcGUsIGFyZ3VtZW50cyApO1xuXG5cdFx0XHR9O1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gY29udGV4dG1lbnUoIGV2ZW50ICkge1xuXG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5kaXNwb3NlID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdHRoaXMuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCAnY29udGV4dG1lbnUnLCBjb250ZXh0bWVudSwgZmFsc2UgKTtcblx0XHRcdHRoaXMuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCAnbW91c2Vkb3duJywgX21vdXNlZG93biwgZmFsc2UgKTtcblx0XHRcdHRoaXMuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCAnbW91c2Vtb3ZlJywgX21vdXNlbW92ZSwgZmFsc2UgKTtcblx0XHRcdHRoaXMuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCAnbW91c2V1cCcsIF9tb3VzZXVwLCBmYWxzZSApO1xuXG5cdFx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2tleWRvd24nLCBfa2V5ZG93biwgZmFsc2UgKTtcblx0XHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCAna2V5dXAnLCBfa2V5dXAsIGZhbHNlICk7XG5cblx0XHR9O1xuXG5cdFx0dmFyIF9tb3VzZW1vdmUgPSBiaW5kKCB0aGlzLCB0aGlzLm1vdXNlbW92ZSApO1xuXHRcdHZhciBfbW91c2Vkb3duID0gYmluZCggdGhpcywgdGhpcy5tb3VzZWRvd24gKTtcblx0XHR2YXIgX21vdXNldXAgPSBiaW5kKCB0aGlzLCB0aGlzLm1vdXNldXAgKTtcblx0XHR2YXIgX2tleWRvd24gPSBiaW5kKCB0aGlzLCB0aGlzLmtleWRvd24gKTtcblx0XHR2YXIgX2tleXVwID0gYmluZCggdGhpcywgdGhpcy5rZXl1cCApO1xuXG5cdFx0dGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdjb250ZXh0bWVudScsIGNvbnRleHRtZW51LCBmYWxzZSApO1xuXG5cdFx0dGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdtb3VzZW1vdmUnLCBfbW91c2Vtb3ZlLCBmYWxzZSApO1xuXHRcdHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCAnbW91c2Vkb3duJywgX21vdXNlZG93biwgZmFsc2UgKTtcblx0XHR0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ21vdXNldXAnLCAgIF9tb3VzZXVwLCBmYWxzZSApO1xuXG5cdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoICdrZXlkb3duJywgX2tleWRvd24sIGZhbHNlICk7XG5cdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoICdrZXl1cCcsICAgX2tleXVwLCBmYWxzZSApO1xuXG5cdFx0dGhpcy51cGRhdGVNb3ZlbWVudFZlY3RvcigpO1xuXHRcdHRoaXMudXBkYXRlUm90YXRpb25WZWN0b3IoKTtcblxuXHR9O1xufTtcbiIsImltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJ1xuaW1wb3J0IENvbG9ycyBmcm9tICcuL2NvbG9ycydcblxuY2xhc3MgQWlyUGxhbmUge1xuICBjb25zdHJ1Y3RvciAoY29sb3IpIHtcbiAgICB0aGlzLm1lc2ggPSBuZXcgVEhSRUUuT2JqZWN0M0QoKVxuXG4gICAgLy8gQ3JlYXRlIHRoZSBjYWJpblxuICAgIHZhciBnZW9tQ29ja3BpdFRhaWwgPSBuZXcgVEhSRUUuQm94R2VvbWV0cnkoMTMwLCA0MCwgNDAsIDEsIDEsIDEpXG4gICAgdmFyIG1hdENvY2twaXRUYWlsID0gbmV3IFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsKHtjb2xvcjogY29sb3IsIGZsYXRTaGFkaW5nOiBUSFJFRS5GbGF0U2hhZGluZ30pXG5cbiAgICAvLyB3ZSBjYW4gYWNjZXNzIGEgc3BlY2lmaWMgdmVydGV4IG9mIGEgc2hhcGUgdGhyb3VnaFxuICAgIC8vIHRoZSB2ZXJ0aWNlcyBhcnJheSwgYW5kIHRoZW4gbW92ZSBpdHMgeCwgeSBhbmQgeiBwcm9wZXJ0eTpcbiAgICBnZW9tQ29ja3BpdFRhaWwudmVydGljZXNbNF0ueSAtPSAxMFxuICAgIGdlb21Db2NrcGl0VGFpbC52ZXJ0aWNlc1s0XS56ICs9IDIwXG4gICAgZ2VvbUNvY2twaXRUYWlsLnZlcnRpY2VzWzVdLnkgLT0gMTBcbiAgICBnZW9tQ29ja3BpdFRhaWwudmVydGljZXNbNV0ueiAtPSAyMFxuICAgIGdlb21Db2NrcGl0VGFpbC52ZXJ0aWNlc1s2XS55ICs9IDMwXG4gICAgZ2VvbUNvY2twaXRUYWlsLnZlcnRpY2VzWzZdLnogKz0gMjBcbiAgICBnZW9tQ29ja3BpdFRhaWwudmVydGljZXNbN10ueSArPSAzMFxuICAgIGdlb21Db2NrcGl0VGFpbC52ZXJ0aWNlc1s3XS56IC09IDIwXG5cbiAgICB2YXIgY29ja3BpdFRhaWwgPSBuZXcgVEhSRUUuTWVzaChnZW9tQ29ja3BpdFRhaWwsIG1hdENvY2twaXRUYWlsKVxuICAgIGNvY2twaXRUYWlsLmNhc3RTaGFkb3cgPSB0cnVlXG4gICAgY29ja3BpdFRhaWwucmVjZWl2ZVNoYWRvdyA9IHRydWVcbiAgICBjb2NrcGl0VGFpbC5wb3NpdGlvbi5zZXQoLTc1LCAwLCAwKVxuICAgIHRoaXMubWVzaC5hZGQoY29ja3BpdFRhaWwpXG5cbiAgICB2YXIgZ2VvbUNvY2twaXQgPSBuZXcgVEhSRUUuQm94R2VvbWV0cnkoNDAsIDQwLCA0MCwgMSwgMSwgMSlcbiAgICB2YXIgbWF0Q29ja3BpdCA9IG5ldyBUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbCh7Y29sb3I6IGNvbG9yLCBmbGF0U2hhZGluZzogVEhSRUUuRmxhdFNoYWRpbmd9KVxuICAgIHZhciBjb2NrcGl0ID0gbmV3IFRIUkVFLk1lc2goZ2VvbUNvY2twaXQsIG1hdENvY2twaXQpXG4gICAgY29ja3BpdC5jYXN0U2hhZG93ID0gdHJ1ZVxuICAgIGNvY2twaXQucmVjZWl2ZVNoYWRvdyA9IHRydWVcbiAgICBjb2NrcGl0LnBvc2l0aW9uLnNldCgxMCwgMCwgMClcbiAgICB0aGlzLm1lc2guYWRkKGNvY2twaXQpXG5cbiAgICAvLyBDcmVhdGUgdGhlIGVuZ2luZVxuICAgIHZhciBnZW9tRW5naW5lID0gbmV3IFRIUkVFLkJveEdlb21ldHJ5KDIwLCA0MCwgNDAsIDEsIDEsIDEpXG4gICAgdmFyIG1hdEVuZ2luZSA9IG5ldyBUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbCh7Y29sb3I6IENvbG9ycy53aGl0ZSwgZmxhdFNoYWRpbmc6IFRIUkVFLkZsYXRTaGFkaW5nfSlcbiAgICB2YXIgZW5naW5lID0gbmV3IFRIUkVFLk1lc2goZ2VvbUVuZ2luZSwgbWF0RW5naW5lKVxuICAgIGVuZ2luZS5wb3NpdGlvbi54ID0gNDBcbiAgICBlbmdpbmUuY2FzdFNoYWRvdyA9IHRydWVcbiAgICBlbmdpbmUucmVjZWl2ZVNoYWRvdyA9IHRydWVcbiAgICB0aGlzLm1lc2guYWRkKGVuZ2luZSlcblxuICAgIC8vIENyZWF0ZSB0b3Agd2luZ1xuICAgIC8vIHZhciBnZW9tVG9wV2luZyA9IG5ldyBUSFJFRS5Cb3hHZW9tZXRyeSg0MCwgMiwgMjAwLCAxLCAxLCAxKVxuICAgIC8vIHZhciBtYXRUb3BXaW5nID0gbmV3IFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsKHtjb2xvcjogY29sb3IsIHNoYWRpbmc6IFRIUkVFLkZsYXRTaGFkaW5nfSlcbiAgICAvLyB2YXIgdG9wV2luZyA9IG5ldyBUSFJFRS5NZXNoKGdlb21Ub3BXaW5nLCBtYXRUb3BXaW5nKVxuICAgIC8vIHRvcFdpbmcuY2FzdFNoYWRvdyA9IHRydWVcbiAgICAvLyB0b3BXaW5nLnJlY2VpdmVTaGFkb3cgPSB0cnVlXG4gICAgLy8gdG9wV2luZy5wb3NpdGlvbi5zZXQoMjAsIDUwLCAwKVxuICAgIC8vIHRoaXMubWVzaC5hZGQodG9wV2luZylcblxuICAgIC8vIENyZWF0ZSBib3R0b20gd2luZ1xuICAgIHZhciBnZW9tQm90dG9tV2luZyA9IG5ldyBUSFJFRS5Cb3hHZW9tZXRyeSg0MCwgMiwgMjAwLCAxLCAxLCAxKVxuICAgIHZhciBtYXRCb3R0b21XaW5nID0gbmV3IFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsKHtjb2xvcjogY29sb3IsIGZsYXRTaGFkaW5nOiBUSFJFRS5GbGF0U2hhZGluZ30pXG4gICAgdmFyIGJvdHRvbVdpbmcgPSBuZXcgVEhSRUUuTWVzaChnZW9tQm90dG9tV2luZywgbWF0Qm90dG9tV2luZylcbiAgICBib3R0b21XaW5nLmNhc3RTaGFkb3cgPSB0cnVlXG4gICAgYm90dG9tV2luZy5yZWNlaXZlU2hhZG93ID0gdHJ1ZVxuICAgIGJvdHRvbVdpbmcucG9zaXRpb24uc2V0KDEwLCAtMTAsIDApXG4gICAgdGhpcy5tZXNoLmFkZChib3R0b21XaW5nKVxuXG4gICAgLy8gV2luZyBzdXBwb3J0XG4gICAgLy8gdmFyIGdlb21XaW5nU3VwcG9ydCA9IG5ldyBUSFJFRS5Cb3hHZW9tZXRyeSgyLCA2MCwgMiwgMSwgMSwgMSlcbiAgICAvLyB2YXIgbWF0V2luZ1N1cHBvcnQgPSBuZXcgVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwoe2NvbG9yOiBjb2xvciwgc2hhZGluZzogVEhSRUUuRmxhdFNoYWRpbmd9KVxuICAgIC8vIHZhciB3aW5nU3VwcG9ydExlZnQgPSBuZXcgVEhSRUUuTWVzaChnZW9tV2luZ1N1cHBvcnQsIG1hdFdpbmdTdXBwb3J0KVxuICAgIC8vIHdpbmdTdXBwb3J0TGVmdC5jYXN0U2hhZG93ID0gdHJ1ZVxuICAgIC8vIHdpbmdTdXBwb3J0TGVmdC5yZWNlaXZlU2hhZG93ID0gdHJ1ZVxuICAgIC8vIHdpbmdTdXBwb3J0TGVmdC5wb3NpdGlvbi5zZXQoMTUsIDIwLCAtODApXG4gICAgLy8gdGhpcy5tZXNoLmFkZCh3aW5nU3VwcG9ydExlZnQpXG4gICAgLy8gdmFyIHdpbmdTdXBwb3J0UmlnaHQgPSBuZXcgVEhSRUUuTWVzaChnZW9tV2luZ1N1cHBvcnQsIG1hdFdpbmdTdXBwb3J0KVxuICAgIC8vIHdpbmdTdXBwb3J0UmlnaHQuY2FzdFNoYWRvdyA9IHRydWVcbiAgICAvLyB3aW5nU3VwcG9ydFJpZ2h0LnJlY2VpdmVTaGFkb3cgPSB0cnVlXG4gICAgLy8gd2luZ1N1cHBvcnRSaWdodC5wb3NpdGlvbi5zZXQoMTUsIDIwLCA4MClcbiAgICAvLyB0aGlzLm1lc2guYWRkKHdpbmdTdXBwb3J0UmlnaHQpXG5cbiAgICAvLyBDcmVhdGUgdGhlIHRhaWxcbiAgICB2YXIgZ2VvbVRhaWxQbGFuZSA9IG5ldyBUSFJFRS5Cb3hHZW9tZXRyeSgzMCwgMjUsIDIsIDEsIDEsIDEpXG4gICAgdmFyIG1hdFRhaWxQbGFuZSA9IG5ldyBUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbCh7Y29sb3I6IGNvbG9yLCBmbGF0U2hhZGluZzogVEhSRUUuRmxhdFNoYWRpbmd9KVxuICAgIHZhciB0YWlsUGxhbmUgPSBuZXcgVEhSRUUuTWVzaChnZW9tVGFpbFBsYW5lLCBtYXRUYWlsUGxhbmUpXG4gICAgdGFpbFBsYW5lLnBvc2l0aW9uLnNldCgtMTE1LCAyMCwgMClcbiAgICB0YWlsUGxhbmUuY2FzdFNoYWRvdyA9IHRydWVcbiAgICB0YWlsUGxhbmUucmVjZWl2ZVNoYWRvdyA9IHRydWVcbiAgICB0aGlzLm1lc2guYWRkKHRhaWxQbGFuZSlcblxuICAgIC8vIENyZWF0ZSB0aGUgdGFpbCB3aW5nXG4gICAgdmFyIGdlb21UYWlsV2luZyA9IG5ldyBUSFJFRS5Cb3hHZW9tZXRyeSgyMCwgMiwgNjAsIDEsIDEsIDEpXG4gICAgdmFyIG1hdFRhaWxXaW5nID0gbmV3IFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsKHtjb2xvcjogY29sb3IsIGZsYXRTaGFkaW5nOiBUSFJFRS5GbGF0U2hhZGluZ30pXG4gICAgdmFyIHRhaWxXaW5nID0gbmV3IFRIUkVFLk1lc2goZ2VvbVRhaWxXaW5nLCBtYXRUYWlsV2luZylcbiAgICB0YWlsV2luZy5jYXN0U2hhZG93ID0gdHJ1ZVxuICAgIHRhaWxXaW5nLnJlY2VpdmVTaGFkb3cgPSB0cnVlXG4gICAgdGFpbFdpbmcucG9zaXRpb24uc2V0KC0xMTAsIDExLCAwKVxuICAgIHRoaXMubWVzaC5hZGQodGFpbFdpbmcpXG5cbiAgICAvLyBwcm9wZWxsZXJcbiAgICB2YXIgZ2VvbVByb3BlbGxlciA9IG5ldyBUSFJFRS5Cb3hHZW9tZXRyeSgyMCwgMTAsIDEwLCAxLCAxLCAxKVxuICAgIGdlb21Qcm9wZWxsZXIudmVydGljZXNbNF0ueSAtPSA1XG4gICAgZ2VvbVByb3BlbGxlci52ZXJ0aWNlc1s0XS56ICs9IDVcbiAgICBnZW9tUHJvcGVsbGVyLnZlcnRpY2VzWzVdLnkgLT0gNVxuICAgIGdlb21Qcm9wZWxsZXIudmVydGljZXNbNV0ueiAtPSA1XG4gICAgZ2VvbVByb3BlbGxlci52ZXJ0aWNlc1s2XS55ICs9IDVcbiAgICBnZW9tUHJvcGVsbGVyLnZlcnRpY2VzWzZdLnogKz0gNVxuICAgIGdlb21Qcm9wZWxsZXIudmVydGljZXNbN10ueSArPSA1XG4gICAgZ2VvbVByb3BlbGxlci52ZXJ0aWNlc1s3XS56IC09IDVcbiAgICB2YXIgbWF0UHJvcGVsbGVyID0gbmV3IFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsKHtjb2xvcjogQ29sb3JzLmJyb3duLCBmbGF0U2hhZGluZzogVEhSRUUuRmxhdFNoYWRpbmd9KVxuICAgIHRoaXMucHJvcGVsbGVyID0gbmV3IFRIUkVFLk1lc2goZ2VvbVByb3BlbGxlciwgbWF0UHJvcGVsbGVyKVxuXG4gICAgdGhpcy5wcm9wZWxsZXIuY2FzdFNoYWRvdyA9IHRydWVcbiAgICB0aGlzLnByb3BlbGxlci5yZWNlaXZlU2hhZG93ID0gdHJ1ZVxuXG4gICAgdmFyIGdlb21CbGFkZSA9IG5ldyBUSFJFRS5Cb3hHZW9tZXRyeSgxLCA4MCwgMTAsIDEsIDEsIDEpXG4gICAgdmFyIG1hdEJsYWRlID0gbmV3IFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsKHtjb2xvcjogQ29sb3JzLmJyb3duRGFyaywgZmxhdFNoYWRpbmc6IFRIUkVFLkZsYXRTaGFkaW5nfSlcbiAgICB2YXIgYmxhZGUxID0gbmV3IFRIUkVFLk1lc2goZ2VvbUJsYWRlLCBtYXRCbGFkZSlcbiAgICBibGFkZTEucG9zaXRpb24uc2V0KDgsIDAsIDApXG5cbiAgICBibGFkZTEuY2FzdFNoYWRvdyA9IHRydWVcbiAgICBibGFkZTEucmVjZWl2ZVNoYWRvdyA9IHRydWVcblxuICAgIHZhciBibGFkZTIgPSBibGFkZTEuY2xvbmUoKVxuICAgIGJsYWRlMi5yb3RhdGlvbi54ID0gTWF0aC5QSSAvIDJcblxuICAgIGJsYWRlMi5jYXN0U2hhZG93ID0gdHJ1ZVxuICAgIGJsYWRlMi5yZWNlaXZlU2hhZG93ID0gdHJ1ZVxuXG4gICAgdGhpcy5wcm9wZWxsZXIuYWRkKGJsYWRlMSlcbiAgICB0aGlzLnByb3BlbGxlci5hZGQoYmxhZGUyKVxuICAgIHRoaXMucHJvcGVsbGVyLnBvc2l0aW9uLnNldCg1MCwgMCwgMClcbiAgICB0aGlzLm1lc2guYWRkKHRoaXMucHJvcGVsbGVyKVxuXG4gICAgLy8gcm90YXRlIHRoZSBnZW9tZXRyeSBvbiB0aGUgWSBheGlzIGF3YXkgZnJvbSB0aGUgY2FtZXJhXG4gICAgLy90aGlzLm1lc2guYXBwbHlNYXRyaXgobmV3IFRIUkVFLk1hdHJpeDQoKS5tYWtlUm90YXRpb25ZKE1hdGguUEkgLyAyKSlcblxuICAgIC8vIGNoYW5nZSByb3RhdGlvbiBvcmRlciB0byBhdm9pZCBnaW1iYWwgbG9ja1xuICAgIC8vIHRoaXMubWVzaC5yb3RhdGlvbi5vcmRlciA9ICdaWFknXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQWlyUGxhbmVcbiIsImxldCByYW5kb21Db2xvciA9ICcweCcrKDB4MTAwMDAwMCsoTWF0aC5yYW5kb20oKSkqMHhmZmZmZmYpLnRvU3RyaW5nKDE2KS5zdWJzdHIoMSw2KTtcblxuY29uc3QgQ29sb3JzID0ge1xuICBhaXJwbGFuZTogcmFuZG9tQ29sb3IsXG4gIHdoaXRlOiAweGU4ZTBlMSxcbiAgYnJvd246IDB4NTkzMzJlLFxuICBicm93bkRhcms6IDB4MjMxOTBmLFxuICB3YXRlcjogMHgwMDY0NTdcbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29sb3JzXG4iLCJpbXBvcnQgU2NlbmUgZnJvbSAnLi9zY2VuZSc7XG5pbXBvcnQgQWlycGxhbmUgZnJvbSAnLi9haXJwbGFuZSc7XG5pbXBvcnQgQ29sb3JzIGZyb20gJy4vY29sb3JzJ1xuXG5pbXBvcnQgKiBhcyBUSFJFRSBmcm9tICd0aHJlZSc7XG5cbmNvbnN0IHJhbmRvbUNvbG9yID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gJyMnKygweDEwMDAwMDArKE1hdGgucmFuZG9tKCkpKjB4ZmZmZmZmKS50b1N0cmluZygxNikuc3Vic3RyKDEsNik7XG59XG5cbi8vQSBzb2NrZXQuaW8gaW5zdGFuY2VcbmNvbnN0IHNvY2tldCA9IGlvKCk7XG5cbi8vT25lIFdlYkdMIGNvbnRleHQgdG8gcnVsZSB0aGVtIGFsbCAhXG5sZXQgZ2xTY2VuZSA9IG5ldyBTY2VuZSgpO1xubGV0IGlkO1xubGV0IGluc3RhbmNlcyA9IFtdO1xubGV0IGNsaWVudHMgPSBuZXcgT2JqZWN0KCk7XG5cbmdsU2NlbmUub24oJ3VzZXJNb3ZlZCcsICgpID0+IHtcbiAgY29uc3QgbmV3UG9zaXRpb24gPSBbXG4gICAgZ2xTY2VuZS5jYW1lcmEucG9zaXRpb24ueCxcbiAgICBnbFNjZW5lLmNhbWVyYS5wb3NpdGlvbi55LFxuICAgIGdsU2NlbmUuY2FtZXJhLnBvc2l0aW9uLnpcbiAgXTtcbiAgY29uc3QgbmV3Um90YXRpb24gPSBbXG4gICAgZ2xTY2VuZS5jYW1lcmEucm90YXRpb24ueCxcbiAgICBnbFNjZW5lLmNhbWVyYS5yb3RhdGlvbi55LFxuICAgIGdsU2NlbmUuY2FtZXJhLnJvdGF0aW9uLnosXG4gIF07XG4gIGNvbnNvbGUubG9nKG5ld1JvdGF0aW9uKTtcbiAgc29ja2V0LmVtaXQoJ21vdmUnLCBuZXdQb3NpdGlvbiwgbmV3Um90YXRpb24pO1xufSk7XG5cbi8vT24gY29ubmVjdGlvbiBzZXJ2ZXIgc2VuZHMgdGhlIGNsaWVudCBoaXMgSURcbnNvY2tldC5vbignaW50cm9kdWN0aW9uJywgKF9pZCwgX2NsaWVudE51bSwgX2lkcykgPT4ge1xuICAvLyBDcmVhdGUgYWlycGxhbmVzIGZvciBvdGhlciBjb25uZWN0ZWQgY2xpZW50c1xuICBmb3IobGV0IGkgPSAwOyBpIDwgX2lkcy5sZW5ndGg7IGkrKykge1xuICAgIC8vIGlmKF9pZHNbaV0gIT0gX2lkKSB7XG4gICAgICAvLyBjb25zdCBwbGFuZVN0YXJ0WSA9IDIwMFxuICAgICAgLy8gY29uc3QgcGxhbmVTdGFydFogPSAwXG4gICAgICBsZXQgYWlycGxhbmUgPSBuZXcgQWlycGxhbmUocmFuZG9tQ29sb3IoKSk7XG4gICAgICBhaXJwbGFuZS5tZXNoLnNjYWxlLnNldCgwLjAxLCAwLjAxLCAwLjAxKTtcblxuICAgICAgYWlycGxhbmUubWVzaC5yb3RhdGlvbi55ID0gMS41O1xuXG5cbiAgICAgIGNsaWVudHNbX2lkc1tpXV0gPSB7XG4gICAgICAgIGFpcnBsYW5lOiBhaXJwbGFuZS5tZXNoXG4gICAgICB9XG5cbiAgICAgIC8vQWRkIGluaXRpYWwgdXNlcnMgdG8gdGhlIHNjZW5lXG4gICAgICBnbFNjZW5lLnNjZW5lLmFkZChjbGllbnRzW19pZHNbaV1dLmFpcnBsYW5lKTtcbiAgICAgIGNvbnNvbGUubG9nKGBhcCBYOiAke2FpcnBsYW5lLm1lc2gucm90YXRpb24ueH0gYXAgWTogJHthaXJwbGFuZS5tZXNoLnJvdGF0aW9uLnl9IGFwIFo6ICR7YWlycGxhbmUubWVzaC5yb3RhdGlvbi56fWApO1xuICAgIC8vIH1cbiAgfVxuXG4gIGNvbnNvbGUubG9nKGNsaWVudHMpO1xuXG4gIGlkID0gX2lkO1xuICBjb25zb2xlLmxvZygnTXkgSUQgaXM6ICcgKyBpZCk7XG4gIC8vYWlycGxhbmUucHJvcGVsbGVyLnJvdGF0aW9uLnggKz0gMC4zO1xufSk7XG5cbnNvY2tldC5vbignbmV3VXNlckNvbm5lY3RlZCcsIChjbGllbnRDb3VudCwgX2lkLCBfaWRzKSA9PiB7XG4gIGNvbnNvbGUubG9nKGNsaWVudENvdW50ICsgJyBjbGllbnRzIGNvbm5lY3RlZCcpO1xuICBsZXQgYWxyZWFkeUhhc1VzZXIgPSBmYWxzZTtcbiAgZm9yKGxldCBpID0gMDsgaSA8IE9iamVjdC5rZXlzKGNsaWVudHMpLmxlbmd0aDsgaSsrKXtcbiAgICBpZihPYmplY3Qua2V5cyhjbGllbnRzKVtpXSA9PSBfaWQpe1xuICAgICAgYWxyZWFkeUhhc1VzZXIgPSB0cnVlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmKF9pZCAhPSBpZCAmJiAhYWxyZWFkeUhhc1VzZXIpIHtcbiAgICBjb25zb2xlLmxvZygnQSBuZXcgdXNlciBjb25uZWN0ZWQgd2l0aCB0aGUgaWQ6ICcgKyBfaWQpO1xuICAgIC8vIGNvbnN0IHBsYW5lU3RhcnRZID0gMjAwXG4gICAgLy8gY29uc3QgcGxhbmVTdGFydFogPSAwXG4gICAgbGV0IGFpcnBsYW5lID0gbmV3IEFpcnBsYW5lKHJhbmRvbUNvbG9yKCkpO1xuICAgIGFpcnBsYW5lLm1lc2guc2NhbGUuc2V0KDAuMDEsIDAuMDEsIDAuMDEpO1xuICAgIC8vIGFpcnBsYW5lLm1lc2gucG9zaXRpb24ueSA9IDIwMDAgKyBwbGFuZVN0YXJ0WVxuICAgIGNsaWVudHNbX2lkXSA9IHtcbiAgICAgIGFpcnBsYW5lOiBhaXJwbGFuZS5tZXNoXG4gICAgfVxuXG4gICAgLy9BZGQgaW5pdGlhbCB1c2VycyB0byB0aGUgc2NlbmVcbiAgICBnbFNjZW5lLnNjZW5lLmFkZChjbGllbnRzW19pZF0uYWlycGxhbmUpO1xuICAgIGNvbnNvbGUubG9nKGBhcCBYOiAke2FpcnBsYW5lLm1lc2gucm90YXRpb24ueH0gYXAgWTogJHthaXJwbGFuZS5tZXNoLnJvdGF0aW9uLnl9IGFwIFo6ICR7YWlycGxhbmUubWVzaC5yb3RhdGlvbi56fWApO1xuICB9XG4gIC8vYWlycGxhbmUucHJvcGVsbGVyLnJvdGF0aW9uLnggKz0gMC4zXG59KTtcblxuc29ja2V0Lm9uKCd1c2VyRGlzY29ubmVjdGVkJywgKGNsaWVudENvdW50LCBfaWQsIF9pZHMpID0+IHtcbiAgLy9VcGRhdGUgdGhlIGRhdGEgZnJvbSB0aGUgc2VydmVyXG4gIC8vIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdudW1Vc2VycycpLnRleHRDb250ZW50ID0gY2xpZW50Q291bnQ7XG5cbiAgaWYoX2lkICE9IGlkKSB7XG4gICAgY29uc29sZS5sb2coJ0EgdXNlciBkaXNjb25uZWN0ZWQgd2l0aCB0aGUgaWQ6ICcgKyBfaWQpO1xuICAgIGdsU2NlbmUuc2NlbmUucmVtb3ZlKGNsaWVudHNbX2lkXS5haXJwbGFuZSk7XG4gICAgZGVsZXRlIGNsaWVudHNbX2lkXTtcbiAgfVxufSk7XG5cbnNvY2tldC5vbignY29ubmVjdCcsICgpPT57fSk7XG5cbi8vVXBkYXRlIHdoZW4gb25lIG9mIHRoZSB1c2VycyBtb3ZlcyBpbiBzcGFjZVxuLy8gcHJvcHMgc2VudCBjb250YWluIHBvc2l0aW9uIGFuZCByb3RhdGlvbiBvZiB0aGUgb3RoZXIgdXNlcnMnIGNhbWVyYVxuc29ja2V0Lm9uKCd1c2VyUG9zaXRpb25zJywgX2NsaWVudFByb3BzID0+IHtcbiAgZm9yKGxldCBpID0gMDsgaSA8IE9iamVjdC5rZXlzKF9jbGllbnRQcm9wcykubGVuZ3RoOyBpKyspIHtcbiAgICBpZihPYmplY3Qua2V5cyhfY2xpZW50UHJvcHMpW2ldICE9IGlkKSB7XG5cbiAgICAgIGNvbnN0IGN1cnJlbnRQcm9wcyA9IE9iamVjdC5rZXlzKF9jbGllbnRQcm9wcylbaV07XG5cbiAgICAgIC8vU3RvcmUgdGhlIHZhbHVlc1xuICAgICAgbGV0IG9sZFBvcyA9IGNsaWVudHNbY3VycmVudFByb3BzXS5haXJwbGFuZS5wb3NpdGlvbjtcbiAgICAgIGxldCBvbGRSb3QgPSBjbGllbnRzW2N1cnJlbnRQcm9wc10uYWlycGxhbmUucm90YXRpb247XG4gICAgICBsZXQgbmV3UG9zID0gX2NsaWVudFByb3BzW2N1cnJlbnRQcm9wc10ucG9zaXRpb247XG4gICAgICBsZXQgbmV3Um90ID0gX2NsaWVudFByb3BzW2N1cnJlbnRQcm9wc10ucm90YXRpb247XG5cbiAgICAgIC8vQ3JlYXRlIGEgdmVjdG9yIDMgYW5kIGxlcnAgdGhlIG5ldyB2YWx1ZXMgd2l0aCB0aGUgb2xkIHZhbHVlc1xuICAgICAgbGV0IGxlcnBlZFBvcyA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICBsZXJwZWRQb3MueCA9IFRIUkVFLk1hdGgubGVycChvbGRQb3MueCwgbmV3UG9zWzBdLCAwLjMpO1xuICAgICAgbGVycGVkUG9zLnkgPSBUSFJFRS5NYXRoLmxlcnAob2xkUG9zLnksIG5ld1Bvc1sxXSwgMC4zKTtcbiAgICAgIGxlcnBlZFBvcy56ID0gVEhSRUUuTWF0aC5sZXJwKG9sZFBvcy56LCBuZXdQb3NbMl0sIDAuMyk7XG5cbiAgICAgIGxldCBsZXJwZWRSb3QgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgbGVycGVkUm90LnggPSBUSFJFRS5NYXRoLmxlcnAob2xkUm90LngsIG5ld1JvdFswXSwgMC4zKTtcbiAgICAgIGxlcnBlZFJvdC55ID0gVEhSRUUuTWF0aC5sZXJwKG9sZFJvdC55LCBuZXdSb3RbMV0sIDAuMyk7XG4gICAgICBsZXJwZWRSb3QueiA9IFRIUkVFLk1hdGgubGVycChvbGRSb3QueiwgbmV3Um90WzJdLCAwLjMpO1xuXG4gICAgICAvL1NldCB0aGUgcG9zaXRpb24gYW5kIHJvdGF0aW9uXG4gICAgICBjbGllbnRzW2N1cnJlbnRQcm9wc10uYWlycGxhbmUucG9zaXRpb24uc2V0KGxlcnBlZFBvcy54LCBsZXJwZWRQb3MueSwgbGVycGVkUG9zLnopO1xuICAgICAgY2xpZW50c1tjdXJyZW50UHJvcHNdLmFpcnBsYW5lLnJvdGF0aW9uLnNldChsZXJwZWRSb3QueCwgbGVycGVkUm90LnksIGxlcnBlZFJvdC56KVxuICAgIH1cbiAgfVxufSk7XG4iLCIvL1RocmVlLmpzXG5pbXBvcnQgKiBhcyBUSFJFRSBmcm9tICd0aHJlZSc7XG4vL2ltcG9ydCBBaXJwbGFuZSBmcm9tICcuL2FpcnBsYW5lJztcbi8vIGltcG9ydCBQcm9jZWR1cmFsQ2l0eSBmcm9tICcuL3Byb2NlZHVyYWxjaXR5Jztcbi8vaW1wb3J0IEZpcnN0UGVyc29uQ29udHJvbHMgZnJvbSAnLi9mcHNjb250cm9scyc7XG5pbXBvcnQgRmx5Q29udHJvbHMgZnJvbSAnLi9GbHlDb250cm9scyc7XG4vL0ZpcnN0UGVyc29uQ29udHJvbHMoVEhSRUUpO1xuRmx5Q29udHJvbHMoVEhSRUUpO1xuLy8gUHJvY2VkdXJhbENpdHkoVEhSRUUpO1xuXG4vLyBFdmVudCBlbWl0dGVyIGltcGxlbWVudGF0aW9uIGZvciBFUzZcbmltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnZXZlbnQtZW1pdHRlci1lczYnO1xuXG5jbGFzcyBTY2VuZSBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKGRvbUVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZ2xfY29udGV4dCcpLFxuICAgICAgICAgICAgICBfd2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aCxcbiAgICAgICAgICAgICAgX2hlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodCxcbiAgICAgICAgICAgICAgaGFzQ29udHJvbHMgPSB0cnVlLFxuICAgICAgICAgICAgICBjbGVhckNvbG9yID0gJ2JsYWNrJyl7XG5cbiAgICAvL1NpbmNlIHdlIGV4dGVuZCBFdmVudEVtaXR0ZXIgd2UgbmVlZCB0byBpbnN0YW5jZSBpdCBmcm9tIGhlcmVcbiAgICBzdXBlcigpO1xuXG4gICAgLy9USFJFRSBzY2VuZVxuICAgIHRoaXMuc2NlbmUgPSBuZXcgVEhSRUUuU2NlbmUoKTtcblxuICAgIC8vVXRpbGl0eVxuICAgIHRoaXMud2lkdGggPSBfd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBfaGVpZ2h0O1xuXG4gICAgLy9USFJFRSBDYW1lcmFcbiAgICB0aGlzLmNhbWVyYSA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSg1MCwgdGhpcy53aWR0aCAvIHRoaXMuaGVpZ2h0LCAwLjEsIDEwMDApO1xuXG4gICAgLy9USFJFRSBXZWJHTCByZW5kZXJlclxuICAgIHRoaXMucmVuZGVyZXIgPSBuZXcgVEhSRUUuV2ViR0xSZW5kZXJlcih7XG4gICAgICBhbnRpYWxpYXNpbmc6IHRydWVcbiAgICB9KTtcblxuICAgIHRoaXMucmVuZGVyZXIuc2V0Q2xlYXJDb2xvcihuZXcgVEhSRUUuQ29sb3IoY2xlYXJDb2xvcikpO1xuXG4gICAgdGhpcy5yZW5kZXJlci5zZXRTaXplKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcblxuICAgIC8vUHVzaCB0aGUgY2FudmFzIHRvIHRoZSBET01cbiAgICBkb21FbGVtZW50LmFwcGVuZCh0aGlzLnJlbmRlcmVyLmRvbUVsZW1lbnQpO1xuXG4gICAgaWYoaGFzQ29udHJvbHMpe1xuICAgICAgLy8gdGhpcy5jb250cm9scyA9IG5ldyBUSFJFRS5GaXJzdFBlcnNvbkNvbnRyb2xzKHRoaXMuY2FtZXJhLCB0aGlzLnJlbmRlcmVyLmRvbUVsZW1lbnQpO1xuICAgICAgdGhpcy5jb250cm9scyA9IG5ldyBUSFJFRS5GbHlDb250cm9scyh0aGlzLmNhbWVyYSwgdGhpcy5yZW5kZXJlci5kb21FbGVtZW50KTtcbiAgICAgIC8vdGhpcy5jb250cm9scy5sb29rU3BlZWQgPSAwLjE1O1xuICAgICAgdGhpcy5jb250cm9scy5kcmFnVG9Mb29rID0gdHJ1ZTtcbiAgICAgIHRoaXMuY29udHJvbHMubW92ZW1lbnRTcGVlZCA9IDU7XG4gICAgICB0aGlzLmNvbnRyb2xzLnJvbGxTcGVlZCA9IDAuNTtcbiAgICAgIHRoaXMuYXV0b0ZvcndhcmQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvL1NldHVwIGV2ZW50IGxpc3RlbmVycyBmb3IgZXZlbnRzIGFuZCBoYW5kbGUgdGhlIHN0YXRlc1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBlID0+IHRoaXMub25XaW5kb3dSZXNpemUoZSksIGZhbHNlKTtcbiAgICBkb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCBlID0+IHRoaXMub25FbnRlckNhbnZhcyhlKSwgZmFsc2UpO1xuICAgIGRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIGUgPT4gdGhpcy5vbkxlYXZlQ2FudmFzKGUpLCBmYWxzZSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBlID0+IHRoaXMub25LZXlEb3duKGUpLCBmYWxzZSk7XG5cbiAgICB0aGlzLmhlbHBlckdyaWQgPSBuZXcgVEhSRUUuR3JpZEhlbHBlciggNTAsIDUwICk7XG4gICAgdGhpcy5oZWxwZXJHcmlkLnBvc2l0aW9uLnkgPSAtMC41O1xuICAgIHRoaXMuc2NlbmUuYWRkKHRoaXMuaGVscGVyR3JpZCk7XG4gICAgdGhpcy5jbG9jayA9IG5ldyBUSFJFRS5DbG9jaygpO1xuXG4gICAgLy8gdmFyIGxpZ2h0ID0gbmV3IFRIUkVFLkFtYmllbnRMaWdodCggMHhGRkZGRkYgKTsgLy8gc29mdCB3aGl0ZSBsaWdodFxuICAgIC8vIHRoaXMuc2NlbmUuYWRkKCBsaWdodCApO1xuICAgIC8vIGNvbnN0IHNwb3RsaWdodCA9IG5ldyBUSFJFRS5TcG90TGlnaHQoIDB4RkZGRkZGICk7XG4gICAgLy8gc3BvdGxpZ2h0LnBvc2l0aW9uLnNldCggLTEwLCA2MCwgMTAgKTtcbiAgICAvLyB0aGlzLnNjZW5lLmFkZChzcG90bGlnaHQpO1xuICAgIC8vIExJR0hUU1xuICAgICAgdGhpcy5zY2VuZS5iYWNrZ3JvdW5kID0gbmV3IFRIUkVFLkNvbG9yKCkuc2V0SFNMKCAwLjYsIDAsIDEgKTtcblx0XHRcdHRoaXMuc2NlbmUuZm9nID0gbmV3IFRIUkVFLkZvZyggdGhpcy5zY2VuZS5iYWNrZ3JvdW5kLCAxLCA1MDAwICk7XG5cblx0XHRcdHZhciBoZW1pTGlnaHQgPSBuZXcgVEhSRUUuSGVtaXNwaGVyZUxpZ2h0KCAweGZmZmZmZiwgMHhmZmZmZmYsIDAuNiApO1xuXHRcdFx0XHRoZW1pTGlnaHQuY29sb3Iuc2V0SFNMKCAwLjYsIDEsIDAuNiApO1xuXHRcdFx0XHRoZW1pTGlnaHQuZ3JvdW5kQ29sb3Iuc2V0SFNMKCAwLjA5NSwgMSwgMC43NSApO1xuXHRcdFx0XHRoZW1pTGlnaHQucG9zaXRpb24uc2V0KCAwLCA1MCwgMCApO1xuXHRcdFx0XHR0aGlzLnNjZW5lLmFkZCggaGVtaUxpZ2h0ICk7XG5cdFx0XHRcdHZhciBoZW1pTGlnaHRIZWxwZXIgPSBuZXcgVEhSRUUuSGVtaXNwaGVyZUxpZ2h0SGVscGVyKCBoZW1pTGlnaHQsIDEwICk7XG5cdFx0XHRcdHRoaXMuc2NlbmUuYWRkKCBoZW1pTGlnaHRIZWxwZXIgKTtcblx0XHRcdFx0Ly9cblx0XHRcdFx0dmFyIGRpckxpZ2h0ID0gbmV3IFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQoIDB4ZmZmZmZmLCAxICk7XG5cdFx0XHRcdGRpckxpZ2h0LmNvbG9yLnNldEhTTCggMC4xLCAxLCAwLjk1ICk7XG5cdFx0XHRcdGRpckxpZ2h0LnBvc2l0aW9uLnNldCggLTEsIDEuNzUsIDEgKTtcblx0XHRcdFx0ZGlyTGlnaHQucG9zaXRpb24ubXVsdGlwbHlTY2FsYXIoIDMwICk7XG5cdFx0XHRcdHRoaXMuc2NlbmUuYWRkKCBkaXJMaWdodCApO1xuXHRcdFx0XHRkaXJMaWdodC5jYXN0U2hhZG93ID0gdHJ1ZTtcblx0XHRcdFx0ZGlyTGlnaHQuc2hhZG93Lm1hcFNpemUud2lkdGggPSAyMDQ4O1xuXHRcdFx0XHRkaXJMaWdodC5zaGFkb3cubWFwU2l6ZS5oZWlnaHQgPSAyMDQ4O1xuXHRcdFx0XHR2YXIgZCA9IDUwO1xuXHRcdFx0XHRkaXJMaWdodC5zaGFkb3cuY2FtZXJhLmxlZnQgPSAtZDtcblx0XHRcdFx0ZGlyTGlnaHQuc2hhZG93LmNhbWVyYS5yaWdodCA9IGQ7XG5cdFx0XHRcdGRpckxpZ2h0LnNoYWRvdy5jYW1lcmEudG9wID0gZDtcblx0XHRcdFx0ZGlyTGlnaHQuc2hhZG93LmNhbWVyYS5ib3R0b20gPSAtZDtcblx0XHRcdFx0ZGlyTGlnaHQuc2hhZG93LmNhbWVyYS5mYXIgPSAzNTAwO1xuXHRcdFx0XHRkaXJMaWdodC5zaGFkb3cuYmlhcyA9IC0wLjAwMDE7XG5cdFx0XHRcdHZhciBkaXJMaWdodEhlcGVyID0gbmV3IFRIUkVFLkRpcmVjdGlvbmFsTGlnaHRIZWxwZXIoIGRpckxpZ2h0LCAxMCApXG5cdFx0XHRcdHRoaXMuc2NlbmUuYWRkKCBkaXJMaWdodEhlcGVyICk7XG5cdFx0XHRcdC8vIEdST1VORFxuXHRcdFx0XHR2YXIgZ3JvdW5kR2VvID0gbmV3IFRIUkVFLlBsYW5lQnVmZmVyR2VvbWV0cnkoIDEwMDAwLCAxMDAwMCApO1xuXHRcdFx0XHR2YXIgZ3JvdW5kTWF0ID0gbmV3IFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsKCB7IGNvbG9yOiAweGZmZmZmZiwgc3BlY3VsYXI6IDB4MDUwNTA1IH0gKTtcblx0XHRcdFx0Z3JvdW5kTWF0LmNvbG9yLnNldEhTTCggMC4wOTUsIDEsIDAuNzUgKTtcblx0XHRcdFx0dmFyIGdyb3VuZCA9IG5ldyBUSFJFRS5NZXNoKCBncm91bmRHZW8sIGdyb3VuZE1hdCApO1xuXHRcdFx0XHRncm91bmQucm90YXRpb24ueCA9IC1NYXRoLlBJLzI7XG5cdFx0XHRcdGdyb3VuZC5wb3NpdGlvbi55ID0gLTMzO1xuXHRcdFx0XHR0aGlzLnNjZW5lLmFkZCggZ3JvdW5kICk7XG5cdFx0XHRcdGdyb3VuZC5yZWNlaXZlU2hhZG93ID0gdHJ1ZTtcblx0XHRcdFx0Ly8gU0tZRE9NRVxuXHRcdFx0XHR2YXIgdmVydGV4U2hhZGVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoICd2ZXJ0ZXhTaGFkZXInICkudGV4dENvbnRlbnQ7XG5cdFx0XHRcdHZhciBmcmFnbWVudFNoYWRlciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCAnZnJhZ21lbnRTaGFkZXInICkudGV4dENvbnRlbnQ7XG5cdFx0XHRcdHZhciB1bmlmb3JtcyA9IHtcblx0XHRcdFx0XHR0b3BDb2xvcjogICAgeyB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKCAweDAwNzdmZiApIH0sXG5cdFx0XHRcdFx0Ym90dG9tQ29sb3I6IHsgdmFsdWU6IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKSB9LFxuXHRcdFx0XHRcdG9mZnNldDogICAgICB7IHZhbHVlOiAzMyB9LFxuXHRcdFx0XHRcdGV4cG9uZW50OiAgICB7IHZhbHVlOiAwLjYgfVxuXHRcdFx0XHR9O1xuXHRcdFx0XHR1bmlmb3Jtcy50b3BDb2xvci52YWx1ZS5jb3B5KCBoZW1pTGlnaHQuY29sb3IgKTtcblx0XHRcdFx0dGhpcy5zY2VuZS5mb2cuY29sb3IuY29weSggdW5pZm9ybXMuYm90dG9tQ29sb3IudmFsdWUgKTtcblx0XHRcdFx0dmFyIHNreUdlbyA9IG5ldyBUSFJFRS5TcGhlcmVHZW9tZXRyeSggNDAwMCwgMzIsIDE1ICk7XG5cdFx0XHRcdHZhciBza3lNYXQgPSBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoIHsgdmVydGV4U2hhZGVyOiB2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyOiBmcmFnbWVudFNoYWRlciwgdW5pZm9ybXM6IHVuaWZvcm1zLCBzaWRlOiBUSFJFRS5CYWNrU2lkZSB9ICk7XG5cdFx0XHRcdHZhciBza3kgPSBuZXcgVEhSRUUuTWVzaCggc2t5R2VvLCBza3lNYXQgKTtcblx0XHRcdFx0dGhpcy5zY2VuZS5hZGQoIHNreSApO1xuXG4gICAgICAgIC8vIHZhciBjaXR5ICA9IFByb2NlZHVyYWxDaXR5KCk7XG4gICAgICAgIC8vIHRoaXMuc2NlbmUuYWRkKGNpdHkpO1xuXG4gICAgdGhpcy51cGRhdGUoKTtcblxuICB9XG5cbiAgZHJhd1VzZXJzKHBvc2l0aW9ucywgaWQpe1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBPYmplY3Qua2V5cyhwb3NpdGlvbnMpLmxlbmd0aDsgaSsrKXtcbiAgICAgIGlmKE9iamVjdC5rZXlzKHBvc2l0aW9ucylbaV0gIT0gaWQpe1xuICAgICAgICB0aGlzLnVzZXJzW2ldLnBvc2l0aW9uLnNldChwb3NpdGlvbnNbT2JqZWN0LmtleXMocG9zaXRpb25zKVtpXV0ucG9zaXRpb25bMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uc1tPYmplY3Qua2V5cyhwb3NpdGlvbnMpW2ldXS5wb3NpdGlvblsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25zW09iamVjdC5rZXlzKHBvc2l0aW9ucylbaV1dLnBvc2l0aW9uWzJdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB1cGRhdGUoKXtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gdGhpcy51cGRhdGUoKSk7XG5cblxuICAgIHRoaXMuY29udHJvbHMudXBkYXRlKHRoaXMuY2xvY2suZ2V0RGVsdGEoKSk7XG4gICAgdGhpcy5jb250cm9scy50YXJnZXQgPSBuZXcgVEhSRUUuVmVjdG9yMygwLDAsMCk7XG4gICAgdGhpcy5yZW5kZXIoKTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLnJlbmRlcmVyLnJlbmRlcih0aGlzLnNjZW5lLCB0aGlzLmNhbWVyYSk7XG4gIH1cblxuICBvbldpbmRvd1Jlc2l6ZShlKSB7XG4gICAgdGhpcy53aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gTWF0aC5mbG9vcih3aW5kb3cuaW5uZXJIZWlnaHQgLSAod2luZG93LmlubmVySGVpZ2h0ICogMC4zKSk7XG4gICAgdGhpcy5jYW1lcmEuYXNwZWN0ID0gdGhpcy53aWR0aCAvIHRoaXMuaGVpZ2h0O1xuICAgIHRoaXMuY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgICB0aGlzLnJlbmRlcmVyLnNldFNpemUodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICB9XG5cbiAgb25MZWF2ZUNhbnZhcyhlKXtcbiAgICB0aGlzLmNvbnRyb2xzLmVuYWJsZWQgPSBmYWxzZTtcbiAgfVxuICBvbkVudGVyQ2FudmFzKGUpe1xuICAgIHRoaXMuY29udHJvbHMuZW5hYmxlZCA9IHRydWU7XG4gIH1cbiAgb25LZXlEb3duKGUpe1xuICAgIHRoaXMuZW1pdCgndXNlck1vdmVkJyk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgU2NlbmU7XG4iXX0=
